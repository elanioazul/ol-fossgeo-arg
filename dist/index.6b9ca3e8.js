// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function(modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function(id, exports) {
    modules[id] = [
      function(require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function() {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function() {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"5J2cI":[function(require,module,exports) {
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "69f74e7f31319ffd";
module.bundle.HMR_BUNDLE_ID = "b00901706b9ca3e8";
"use strict";
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F1() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('ðŸš¨ [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                } // Render the fancy html overlay
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
            document.body.appendChild(overlay);
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] ðŸš¨ Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] âœ¨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>\n          ").concat(stack, "\n        </pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>' + hint + '</div>';
            }).join(''), "\n        </div>\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') {
        reloadCSS();
        return;
    }
    var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
    if (deps) {
        var fn = new Function('require', 'module', 'exports', asset.output);
        modules[asset.id] = [
            fn,
            deps
        ];
    } else if (bundle.parent) hmrApply(bundle.parent, asset);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) return true;
    return getParents(module.bundle.root, id).some(function(v) {
        return hmrAcceptCheck(v[0], v[1], null);
    });
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"hTXjU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _geoTIFFJs = require("ol/source/GeoTIFF.js");
var _geoTIFFJsDefault = parcelHelpers.interopDefault(_geoTIFFJs);
var _mapJs = require("ol/Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _webGLTileJs = require("ol/layer/WebGLTile.js");
var _webGLTileJsDefault = parcelHelpers.interopDefault(_webGLTileJs);
var _colormap = require("colormap");
var _colormapDefault = parcelHelpers.interopDefault(_colormap);
const map = new _mapJsDefault.default({
    target: 'map-container'
});
const visualizations = [
    {
        name: 'True Color',
        sources: [
            'TCI'
        ]
    },
    {
        name: 'False Color',
        sources: [
            'B08',
            'B04',
            'B03'
        ],
        max: 5000
    },
    {
        name: 'NDVI',
        sources: [
            'B04',
            'B08'
        ],
        max: 10000,
        style: {
            color: [
                'interpolate',
                [
                    'linear'
                ],
                [
                    '/',
                    [
                        '-',
                        [
                            'band',
                            2
                        ],
                        [
                            'band',
                            1
                        ]
                    ],
                    [
                        '+',
                        [
                            'band',
                            2
                        ],
                        [
                            'band',
                            1
                        ]
                    ]
                ],
                ...getColorStops('earth', -0.5, 1, 10, true), 
            ]
        }
    },
    {
        name: 'NDWI',
        sources: [
            'B03',
            'B08'
        ],
        max: 10000,
        style: {
            color: [
                'interpolate',
                [
                    'linear'
                ],
                [
                    '/',
                    [
                        '-',
                        [
                            'band',
                            1
                        ],
                        [
                            'band',
                            2
                        ]
                    ],
                    [
                        '+',
                        [
                            'band',
                            1
                        ],
                        [
                            'band',
                            2
                        ]
                    ]
                ],
                ...getColorStops('viridis', -1, 1, 10, true), 
            ]
        }
    }, 
];
function getColorStops(name, min, max, steps, reverse) {
    const delta = (max - min) / (steps - 1);
    const stops = new Array(steps * 2);
    const colors = _colormapDefault.default({
        colormap: name,
        nshades: steps,
        format: 'rgba'
    });
    if (reverse) colors.reverse();
    for(let i = 0; i < steps; i++){
        stops[i * 2] = min + i * delta;
        stops[i * 2 + 1] = colors[i];
    }
    return stops;
}
const visualizationSelector = document.getElementById('visualization');
visualizations.forEach((visualization)=>{
    const option = document.createElement('option');
    option.textContent = visualization.name;
    visualizationSelector.appendChild(option);
});
function updateVisualization() {
    const visualization = visualizations[visualizationSelector.selectedIndex];
    const base = 'https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/21/H/UB/2021/9/S2B_21HUB_20210915_0_L2A';
    const layer = createLayer(base, visualization);
    map.setLayers([
        layer
    ]);
    map.setView(layer.getSource().getView());
}
visualizationSelector.addEventListener('change', updateVisualization);
updateVisualization();
function createLayer(base, visualization) {
    const source = new _geoTIFFJsDefault.default({
        sources: visualization.sources.map((id)=>({
                url: `${base}/${id}.tif`,
                max: visualization.max
            })
        )
    });
    return new _webGLTileJsDefault.default({
        source: source,
        style: visualization.style
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc","ol/source/GeoTIFF.js":"aZuLW","ol/Map.js":"76DwP","ol/layer/WebGLTile.js":"3h2AK","colormap":"8Epul"}],"JacNc":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule') return;
        // Skip duplicate re-exports when they have the same value.
        if (key in dest && dest[key] === source[key]) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"aZuLW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/source/GeoTIFF
 */ var _dataTileJs = require("./DataTile.js");
var _dataTileJsDefault = parcelHelpers.interopDefault(_dataTileJs);
var _stateJs = require("./State.js");
var _stateJsDefault = parcelHelpers.interopDefault(_stateJs);
var _tileGridJs = require("../tilegrid/TileGrid.js");
var _tileGridJsDefault = parcelHelpers.interopDefault(_tileGridJs);
var _geotiff = require("geotiff");
var _projJs = require("../proj.js");
var _mathJs = require("../math.js");
var _geotiffDecoderJs = require("../worker/geotiff-decoder.js");
var _extentJs = require("../extent.js");
var _sizeJs = require("../size.js");
var _unitsJs = require("../proj/Units.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} SourceInfo
 * @property {string} url URL for the source GeoTIFF.
 * @property {Array<string>} [overviews] List of any overview URLs.
 * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on
 * the configured min and max.
 * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on
 * the configured min and max.
 * @property {number} [nodata] Values to discard. When provided, an additional band (alpha) will be added
 * to the data.
 * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will
 * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the
 * near-infrared band, configure `bands: [4]`.
 */ /**
 * @typedef {Object} GeoKeys
 * @property {number} GTModelTypeGeoKey Model type.
 * @property {number} GTRasterTypeGeoKey Raster type.
 * @property {number} GeogAngularUnitsGeoKey Angular units.
 * @property {number} GeogInvFlatteningGeoKey Inverse flattening.
 * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.
 * @property {number} GeographicTypeGeoKey Geographic coordinate system code.
 * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.
 * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.
 */ /**
 * @typedef {Object} GeoTIFFImage
 * @property {Object} fileDirectory The file directory.
 * @property {GeoKeys} geoKeys The parsed geo-keys.
 * @property {boolean} littleEndian Uses little endian byte order.
 * @property {Object} tiles The tile cache.
 * @property {boolean} isTiled The image is tiled.
 * @property {function():Array<number>} getBoundingBox Get the image bounding box.
 * @property {function():Array<number>} getOrigin Get the image origin.
 * @property {function(GeoTIFFImage):Array<number>} getResolution Get the image resolution.
 */ var workerPool;
function getWorkerPool() {
    if (!workerPool) workerPool = new _geotiff.Pool(undefined, _geotiffDecoderJs.create());
    return workerPool;
}
/**
 * Get the bounding box of an image.  If the image does not have an affine transform,
 * the pixel bounds are returned.
 * @param {GeoTIFFImage} image The image.
 * @return {Array<number>} The image bounding box.
 */ function getBoundingBox(image) {
    try {
        return image.getBoundingBox();
    } catch (_) {
        var fileDirectory = image.fileDirectory;
        return [
            0,
            0,
            fileDirectory.ImageWidth,
            fileDirectory.ImageLength
        ];
    }
}
/**
 * Get the origin of an image.  If the image does not have an affine transform,
 * the top-left corner of the pixel bounds is returned.
 * @param {GeoTIFFImage} image The image.
 * @return {Array<number>} The image origin.
 */ function getOrigin(image) {
    try {
        return image.getOrigin().slice(0, 2);
    } catch (_) {
        return [
            0,
            image.fileDirectory.ImageLength
        ];
    }
}
/**
 * Get the resolution of an image.  If the image does not have an affine transform,
 * the width of the image is compared with the reference image.
 * @param {GeoTIFFImage} image The image.
 * @param {GeoTIFFImage} referenceImage The reference image.
 * @return {number} The image resolution.
 */ function getResolution(image, referenceImage) {
    try {
        return image.getResolution(referenceImage)[0];
    } catch (_) {
        return referenceImage.fileDirectory.ImageWidth / image.fileDirectory.ImageWidth;
    }
}
/**
 * @param {GeoTIFFImage} image A GeoTIFF.
 * @return {import("../proj/Projection.js").default} The image projection.
 */ function getProjection(image) {
    var geoKeys = image.geoKeys;
    if (!geoKeys) return null;
    if (geoKeys.ProjectedCSTypeGeoKey) {
        var code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;
        var projection = _projJs.get(code);
        if (!projection) {
            var units = _unitsJs.fromCode(geoKeys.ProjLinearUnitsGeoKey);
            if (units) projection = new _projJs.Projection({
                code: code,
                units: units
            });
        }
        return projection;
    }
    if (geoKeys.GeographicTypeGeoKey) {
        var code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;
        var projection = _projJs.get(code);
        if (!projection) {
            var units = _unitsJs.fromCode(geoKeys.GeogAngularUnitsGeoKey);
            if (units) projection = new _projJs.Projection({
                code: code,
                units: units
            });
        }
        return projection;
    }
    return null;
}
/**
 * @param {import("geotiff/src/geotiff.js").GeoTIFF|import("geotiff/src/geotiff.js").MultiGeoTIFF} tiff A GeoTIFF.
 * @return {Promise<Array<import("geotiff/src/geotiffimage.js").GeoTIFFImage>>} Resolves to a list of images.
 */ function getImagesForTIFF(tiff) {
    return tiff.getImageCount().then(function(count) {
        var requests = new Array(count);
        for(var i = 0; i < count; ++i)requests[i] = tiff.getImage(i);
        return Promise.all(requests);
    });
}
/**
 * @param {SourceInfo} source The GeoTIFF source.
 * @return {Promise<Array<import("geotiff/src/geotiffimage.js").GeoTIFFImage>>} Resolves to a list of images.
 */ function getImagesForSource(source) {
    var request;
    if (source.overviews) request = _geotiff.fromUrls(source.url, source.overviews);
    else request = _geotiff.fromUrl(source.url);
    return request.then(getImagesForTIFF);
}
/**
 * @param {number|Array<number>|Array<Array<number>>} expected Expected value.
 * @param {number|Array<number>|Array<Array<number>>} got Actual value.
 * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.
 * @param {string} message The error message.
 * @param {function(Error):void} rejector A function to be called with any error.
 */ function assertEqual(expected, got, tolerance, message, rejector) {
    if (Array.isArray(expected)) {
        var length_1 = expected.length;
        if (!Array.isArray(got) || length_1 != got.length) {
            var error = new Error(message);
            rejector(error);
            throw error;
        }
        for(var i = 0; i < length_1; ++i)assertEqual(expected[i], got[i], tolerance, message, rejector);
        return;
    }
    if (Math.abs(expected - got) > tolerance * expected) throw new Error(message);
}
/**
 * @param {Array} array The data array.
 * @return {number} The minimum value.
 */ function getMinForDataType(array) {
    if (array instanceof Int8Array) return -128;
    if (array instanceof Int16Array) return -32768;
    if (array instanceof Int32Array) return -2147483648;
    if (array instanceof Float32Array) return 0.000000000000000000000000000000000000012;
    return 0;
}
/**
 * @param {Array} array The data array.
 * @return {number} The maximum value.
 */ function getMaxForDataType(array) {
    if (array instanceof Int8Array) return 127;
    if (array instanceof Uint8Array) return 255;
    if (array instanceof Uint8ClampedArray) return 255;
    if (array instanceof Int16Array) return 32767;
    if (array instanceof Uint16Array) return 65535;
    if (array instanceof Int32Array) return 2147483647;
    if (array instanceof Uint32Array) return 4294967295;
    if (array instanceof Float32Array) return 340000000000000000000000000000000000000;
    return 255;
}
/**
 * @typedef {Object} Options
 * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.
 * Multiple sources can be combined when their resolution sets are equal after applying a scale.
 * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and
 * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,
 * use the {@link import("./GeoTIFF.js").SourceInfo bands} property. If, for example, you specify two
 * sources, one with 3 bands and {@link import("./GeoTIFF.js").SourceInfo nodata} configured, and
 * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha
 * band from the first source, and 1 band from the second source.
 * @property {boolean} [convertToRGB = false] By default, bands from the sources are read as-is. When
 * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will
 * convert other color spaces (YCbCr, CMYK) to RGB.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */ /**
 * @classdesc
 * A source for working with GeoTIFF data.
 * @api
 */ var GeoTIFFSource1 = function(_super) {
    __extends(GeoTIFFSource2, _super);
    /**
     * @param {Options} options Data tile options.
     */ function GeoTIFFSource2(options) {
        var _this = _super.call(this, {
            state: _stateJsDefault.default.LOADING,
            tileGrid: null,
            projection: null,
            opaque: options.opaque,
            transition: options.transition
        }) || this;
        /**
         * @type {Array<SourceInfo>}
         * @private
         */ _this.sourceInfo_ = options.sources;
        var numSources = _this.sourceInfo_.length;
        /**
         * @type {Array<Array<import("geotiff/src/geotiffimage.js").GeoTIFFImage>>}
         * @private
         */ _this.sourceImagery_ = new Array(numSources);
        /**
         * @type {Array<number>}
         * @private
         */ _this.resolutionFactors_ = new Array(numSources);
        /**
         * @type {Array<number>}
         * @private
         */ _this.samplesPerPixel_;
        /**
         * @type {Array<Array<number>>}
         * @private
         */ _this.nodataValues_;
        /**
         * @type {boolean}
         * @private
         */ _this.addAlpha_ = false;
        /**
         * @type {Error}
         * @private
         */ _this.error_ = null;
        /**
         * @type {'readRasters' | 'readRGB'}
         */ _this.readMethod_ = options.convertToRGB ? 'readRGB' : 'readRasters';
        _this.setKey(_this.sourceInfo_.map(function(source) {
            return source.url;
        }).join(','));
        var self = _this;
        var requests = new Array(numSources);
        for(var i = 0; i < numSources; ++i)requests[i] = getImagesForSource(_this.sourceInfo_[i]);
        Promise.all(requests).then(function(sources) {
            self.configure_(sources);
        }).catch(function(error) {
            console.error(error); // eslint-disable-line no-console
            self.error_ = error;
            self.setState(_stateJsDefault.default.ERROR);
        });
        return _this;
    }
    /**
     * @return {Error} A source loading error. When the source state is `error`, use this function
     * to get more information about the error. To debug a faulty configuration, you may want to use
     * a listener like
     * ```js
     * geotiffSource.on('change', () => {
     *   if (geotiffSource.getState() === 'error') {
     *     console.error(geotiffSource.getError());
     *   }
     * });
     * ```
     */ GeoTIFFSource2.prototype.getError = function() {
        return this.error_;
    };
    /**
     * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF
     * must have the same internal tiled structure.
     * @param {Array<Array<import("geotiff/src/geotiffimage.js").GeoTIFFImage>>} sources Each source is a list of images
     * from a single GeoTIFF.
     * @private
     */ GeoTIFFSource2.prototype.configure_ = function(sources) {
        var extent;
        var origin;
        var tileSizes;
        var resolutions;
        var samplesPerPixel = new Array(sources.length);
        var nodataValues = new Array(sources.length);
        var minZoom = 0;
        var sourceCount = sources.length;
        var _loop_1 = function(sourceIndex) {
            var images = sources[sourceIndex];
            var imageCount = images.length;
            var sourceExtent = void 0;
            var sourceOrigin = void 0;
            var sourceTileSizes = new Array(imageCount);
            var sourceResolutions = new Array(imageCount);
            nodataValues[sourceIndex] = new Array(imageCount);
            for(var imageIndex = 0; imageIndex < imageCount; ++imageIndex){
                var image = images[imageIndex];
                var nodataValue = image.getGDALNoData();
                nodataValues[sourceIndex][imageIndex] = nodataValue === null ? NaN : nodataValue;
                var wantedSamples = this_1.sourceInfo_[sourceIndex].bands;
                samplesPerPixel[sourceIndex] = wantedSamples ? wantedSamples.length : image.getSamplesPerPixel();
                var level = imageCount - (imageIndex + 1);
                if (!sourceExtent) sourceExtent = getBoundingBox(image);
                if (!sourceOrigin) sourceOrigin = getOrigin(image);
                sourceResolutions[level] = getResolution(image, images[0]);
                sourceTileSizes[level] = [
                    image.getTileWidth(),
                    image.getTileHeight()
                ];
            }
            if (!extent) extent = sourceExtent;
            else _extentJs.getIntersection(extent, sourceExtent, extent);
            if (!origin) origin = sourceOrigin;
            else {
                var message = "Origin mismatch for source " + sourceIndex + ", got [" + sourceOrigin + "] but expected [" + origin + "]";
                assertEqual(origin, sourceOrigin, 0, message, this_1.viewRejector);
            }
            if (!resolutions) {
                resolutions = sourceResolutions;
                this_1.resolutionFactors_[sourceIndex] = 1;
            } else {
                if (resolutions.length - minZoom > sourceResolutions.length) minZoom = resolutions.length - sourceResolutions.length;
                var resolutionFactor_1 = resolutions[resolutions.length - 1] / sourceResolutions[sourceResolutions.length - 1];
                this_1.resolutionFactors_[sourceIndex] = resolutionFactor_1;
                var scaledSourceResolutions = sourceResolutions.map(function(resolution) {
                    return resolution *= resolutionFactor_1;
                });
                var message = "Resolution mismatch for source " + sourceIndex + ", got [" + scaledSourceResolutions + "] but expected [" + resolutions + "]";
                assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 0.005, message, this_1.viewRejector);
            }
            if (!tileSizes) tileSizes = sourceTileSizes;
            else assertEqual(tileSizes.slice(minZoom, tileSizes.length), sourceTileSizes, 0, "Tile size mismatch for source " + sourceIndex, this_1.viewRejector);
            this_1.sourceImagery_[sourceIndex] = images.reverse();
        };
        var this_1 = this;
        for(var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex)_loop_1(sourceIndex);
        for(var i = 0, ii = this.sourceImagery_.length; i < ii; ++i){
            var sourceImagery = this.sourceImagery_[i];
            while(sourceImagery.length < resolutions.length)sourceImagery.unshift(undefined);
        }
        if (!this.getProjection()) {
            var firstSource = sources[0];
            for(var i = firstSource.length - 1; i >= 0; --i){
                var image = firstSource[i];
                var projection = getProjection(image);
                if (projection) {
                    this.projection = projection;
                    break;
                }
            }
        }
        this.samplesPerPixel_ = samplesPerPixel;
        this.nodataValues_ = nodataValues;
        // decide if we need to add an alpha band to handle nodata
        outer: for(var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex){
            // option 1: source is configured with a nodata value
            if (this.sourceInfo_[sourceIndex].nodata !== undefined) {
                this.addAlpha_ = true;
                break;
            }
            var values = nodataValues[sourceIndex];
            // option 2: check image metadata for limited bands
            var bands = this.sourceInfo_[sourceIndex].bands;
            if (bands) {
                for(var i = 0; i < bands.length; ++i)if (!isNaN(values[bands[i] - 1])) {
                    this.addAlpha_ = true;
                    break outer;
                }
                continue;
            }
            // option 3: check image metadata for all bands
            for(var imageIndex = 0; imageIndex < values.length; ++imageIndex)if (!isNaN(values[imageIndex])) {
                this.addAlpha_ = true;
                break outer;
            }
        }
        var additionalBands = this.addAlpha_ ? 1 : 0;
        this.bandCount = samplesPerPixel.reduce(function(accumulator, value) {
            accumulator += value;
            return accumulator;
        }, 0) + additionalBands;
        var tileGrid = new _tileGridJsDefault.default({
            extent: extent,
            minZoom: minZoom,
            origin: origin,
            resolutions: resolutions,
            tileSizes: tileSizes
        });
        this.tileGrid = tileGrid;
        this.setLoader(this.loadTile_.bind(this));
        this.setState(_stateJsDefault.default.READY);
        this.viewResolver({
            projection: this.projection,
            resolutions: resolutions,
            center: _projJs.toUserCoordinate(_extentJs.getCenter(extent), this.projection),
            extent: _projJs.toUserExtent(extent, this.projection),
            zoom: 0
        });
    };
    GeoTIFFSource2.prototype.loadTile_ = function(z, x, y) {
        var size = _sizeJs.toSize(this.tileGrid.getTileSize(z));
        var sourceCount = this.sourceImagery_.length;
        var requests = new Array(sourceCount);
        var addAlpha = this.addAlpha_;
        var bandCount = this.bandCount;
        var samplesPerPixel = this.samplesPerPixel_;
        var sourceInfo = this.sourceInfo_;
        for(var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex){
            var source = sourceInfo[sourceIndex];
            var resolutionFactor = this.resolutionFactors_[sourceIndex];
            var pixelBounds = [
                Math.round(x * (size[0] * resolutionFactor)),
                Math.round(y * (size[1] * resolutionFactor)),
                Math.round((x + 1) * (size[0] * resolutionFactor)),
                Math.round((y + 1) * (size[1] * resolutionFactor)), 
            ];
            var image = this.sourceImagery_[sourceIndex][z];
            var samples = void 0;
            if (source.bands) samples = source.bands.map(function(bandNumber) {
                return bandNumber - 1;
            });
            requests[sourceIndex] = image[this.readMethod_]({
                window: pixelBounds,
                width: size[0],
                height: size[1],
                samples: samples,
                fillValue: source.nodata,
                pool: getWorkerPool(),
                interleave: false
            });
        }
        var pixelCount = size[0] * size[1];
        var dataLength = pixelCount * bandCount;
        var nodataValues = this.nodataValues_;
        return Promise.all(requests).then(function(sourceSamples) {
            var data = new Uint8Array(dataLength);
            var dataIndex = 0;
            for(var pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex){
                var transparent = addAlpha;
                for(var sourceIndex1 = 0; sourceIndex1 < sourceCount; ++sourceIndex1){
                    var source = sourceInfo[sourceIndex1];
                    var min = source.min;
                    if (min === undefined) min = getMinForDataType(sourceSamples[sourceIndex1][0]);
                    var max = source.max;
                    if (max === undefined) max = getMaxForDataType(sourceSamples[sourceIndex1][0]);
                    var gain = 255 / (max - min);
                    var bias = -min * gain;
                    for(var sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex1]; ++sampleIndex){
                        var sourceValue = sourceSamples[sourceIndex1][sampleIndex][pixelIndex];
                        var value = _mathJs.clamp(gain * sourceValue + bias, 0, 255);
                        if (!addAlpha) data[dataIndex] = value;
                        else {
                            var nodata = source.nodata;
                            if (nodata === undefined) {
                                var bandIndex = void 0;
                                if (source.bands) bandIndex = source.bands[sampleIndex] - 1;
                                else bandIndex = sampleIndex;
                                nodata = nodataValues[sourceIndex1][bandIndex];
                            }
                            if (sourceValue !== nodata) {
                                transparent = false;
                                data[dataIndex] = value;
                            }
                        }
                        dataIndex++;
                    }
                }
                if (addAlpha) {
                    if (!transparent) data[dataIndex] = 255;
                    dataIndex++;
                }
            }
            return data;
        });
    };
    return GeoTIFFSource2;
}(_dataTileJsDefault.default);
/**
 * Get a promise for view properties based on the source.  Use the result of this function
 * as the `view` option in a map constructor.
 *
 *     const source = new GeoTIFF(options);
 *
 *     const map = new Map({
 *       target: 'map',
 *       layers: [
 *         new TileLayer({
 *           source: source,
 *         }),
 *       ],
 *       view: source.getView(),
 *     });
 *
 * @function
 * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
 * @api
 *
 */ GeoTIFFSource1.prototype.getView;
exports.default = GeoTIFFSource1;

},{"./DataTile.js":"aCD0b","./State.js":"hpoq1","../tilegrid/TileGrid.js":"7vmIN","geotiff":"1tgV5","../proj.js":"hmdWM","../math.js":"kI4rE","../worker/geotiff-decoder.js":"4LmLV","../extent.js":"jgUz2","../size.js":"5PZ8p","../proj/Units.js":"g2gaW","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aCD0b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/source/DataTile
 */ var _dataTileJs = require("../DataTile.js");
var _dataTileJsDefault = parcelHelpers.interopDefault(_dataTileJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _tileEventTypeJs = require("./TileEventType.js");
var _tileEventTypeJsDefault = parcelHelpers.interopDefault(_tileEventTypeJs);
var _tileJs = require("./Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileStateJs = require("../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _objJs = require("../obj.js");
var _tilegridJs = require("../tilegrid.js");
var _tilecoordJs = require("../tilecoord.js");
var _utilJs = require("../util.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {function(number, number, number) : Promise<import("../DataTile.js").Data>} [loader] Data loader.  Called with z, x, and y tile coordinates.
 * Returns a promise that resolves to a {@link import("../DataTile.js").Data}.
 * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The pixel width and height of the tiles.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Tile projection.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("./State.js").default} [state] The source state.
 * @property {number} [tilePixelRatio] Tile pixel ratio.
 * @property {boolean} [wrapX=true] Render tiles beyond the antimeridian.
 * @property {number} [transition] Transition time when fading in new tiles (in miliseconds).
 * @property {number} [bandCount=4] Number of bands represented in the data.
 */ /**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */ var DataTileSource1 = function(_super) {
    __extends(DataTileSource2, _super);
    /**
     * @param {Options} options Image tile options.
     */ function DataTileSource2(options) {
        var _this = this;
        var projection = options.projection === undefined ? 'EPSG:3857' : options.projection;
        var tileGrid = options.tileGrid;
        if (tileGrid === undefined && projection) tileGrid = _tilegridJs.createXYZ({
            extent: _tilegridJs.extentFromProjection(projection),
            maxResolution: options.maxResolution,
            maxZoom: options.maxZoom,
            minZoom: options.minZoom,
            tileSize: options.tileSize
        });
        _this = _super.call(this, {
            cacheSize: 0.1,
            projection: projection,
            tileGrid: tileGrid,
            opaque: options.opaque,
            state: options.state,
            tilePixelRatio: options.tilePixelRatio,
            wrapX: options.wrapX,
            transition: options.transition
        }) || this;
        /**
         * @private
         * @type {!Object<string, boolean>}
         */ _this.tileLoadingKeys_ = {
        };
        /**
         * @private
         */ _this.loader_ = options.loader;
        _this.handleTileChange_ = _this.handleTileChange_.bind(_this);
        /**
         * @type {number}
         */ _this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined
        return _this;
    }
    /**
     * @param {function(number, number, number) : Promise<import("../DataTile.js").Data>} loader The data loader.
     * @protected
     */ DataTileSource2.prototype.setLoader = function(loader) {
        this.loader_ = loader;
    };
    /**
     * @abstract
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!DataTile} Tile.
     */ DataTileSource2.prototype.getTile = function(z, x, y, pixelRatio, projection) {
        var tileCoordKey = _tilecoordJs.getKeyZXY(z, x, y);
        if (this.tileCache.containsKey(tileCoordKey)) return this.tileCache.get(tileCoordKey);
        var sourceLoader = this.loader_;
        function loader() {
            return sourceLoader(z, x, y);
        }
        var tile = new _dataTileJsDefault.default(_objJs.assign({
            tileCoord: [
                z,
                x,
                y
            ],
            loader: loader
        }, this.tileOptions));
        tile.key = this.getKey();
        tile.addEventListener(_eventTypeJsDefault.default.CHANGE, this.handleTileChange_);
        this.tileCache.set(tileCoordKey, tile);
        return tile;
    };
    /**
     * Handle tile change events.
     * @param {import("../events/Event.js").default} event Event.
     */ DataTileSource2.prototype.handleTileChange_ = function(event) {
        var tile = event.target;
        var uid = _utilJs.getUid(tile);
        var tileState = tile.getState();
        var type;
        if (tileState == _tileStateJsDefault.default.LOADING) {
            this.tileLoadingKeys_[uid] = true;
            type = _tileEventTypeJsDefault.default.TILELOADSTART;
        } else if (uid in this.tileLoadingKeys_) {
            delete this.tileLoadingKeys_[uid];
            type = tileState == _tileStateJsDefault.default.ERROR ? _tileEventTypeJsDefault.default.TILELOADERROR : tileState == _tileStateJsDefault.default.LOADED ? _tileEventTypeJsDefault.default.TILELOADEND : undefined;
        }
        if (type) this.dispatchEvent(new _tileJs.TileSourceEvent(type, tile));
    };
    return DataTileSource2;
}(_tileJsDefault.default);
exports.default = DataTileSource1;

},{"../DataTile.js":"gnR7h","../events/EventType.js":"83vee","./TileEventType.js":"ekKYy","./Tile.js":"hcBBe","../TileState.js":"eIJIE","../obj.js":"g3fPg","../tilegrid.js":"llps6","../tilecoord.js":"gDmuU","../util.js":"9zOhk","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"gnR7h":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/DataTile
 */ var _tileJs = require("./Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileStateJs = require("./TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * Data that can be used with a DataTile.  For increased browser compatibility, use
 * Uint8Array instead of Uint8ClampedArray where possible.
 * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} Data
 */ /**
 * @typedef {Object} Options
 * @property {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @property {function() : Promise<Data>} loader Data loader.
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @api
 */ var DataTile1 = function(_super) {
    __extends(DataTile2, _super);
    /**
     * @param {Options} options Tile options.
     */ function DataTile2(options) {
        var _this = this;
        var state = _tileStateJsDefault.default.IDLE;
        _this = _super.call(this, options.tileCoord, state, {
            transition: options.transition
        }) || this;
        _this.loader_ = options.loader;
        _this.data_ = null;
        _this.error_ = null;
        return _this;
    }
    /**
     * Get the data for the tile.
     * @return {Data} Tile data.
     * @api
     */ DataTile2.prototype.getData = function() {
        return this.data_;
    };
    /**
     * Get any loading error.
     * @return {Error} Loading error.
     * @api
     */ DataTile2.prototype.getError = function() {
        return this.error_;
    };
    /**
     * Load not yet loaded URI.
     * @api
     */ DataTile2.prototype.load = function() {
        this.state = _tileStateJsDefault.default.LOADING;
        this.changed();
        var self = this;
        this.loader_().then(function(data) {
            self.data_ = data;
            self.state = _tileStateJsDefault.default.LOADED;
            self.changed();
        }).catch(function(error) {
            self.error_ = error;
            self.state = _tileStateJsDefault.default.ERROR;
            self.changed();
        });
    };
    return DataTile2;
}(_tileJsDefault.default);
exports.default = DataTile1;

},{"./Tile.js":"5dc8H","./TileState.js":"eIJIE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5dc8H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/Tile
 */ var _targetJs = require("./events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _tileStateJs = require("./TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _utilJs = require("./util.js");
var _easingJs = require("./easing.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * A function that takes an {@link module:ol/Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   var xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     var data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string): void} LoadFunction
 * @api
 */ /**
 * {@link module:ol/source/Tile~Tile} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */ /**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @api
 */ /**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */ var Tile1 = function(_super) {
    __extends(Tile2, _super);
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {Options} [opt_options] Tile options.
     */ function Tile2(tileCoord, state, opt_options) {
        var _this = _super.call(this) || this;
        var options = opt_options ? opt_options : {
        };
        /**
         * @type {import("./tilecoord.js").TileCoord}
         */ _this.tileCoord = tileCoord;
        /**
         * @protected
         * @type {import("./TileState.js").default}
         */ _this.state = state;
        /**
         * An "interim" tile for this tile. The interim tile may be used while this
         * one is loading, for "smooth" transitions when changing params/dimensions
         * on the source.
         * @type {Tile}
         */ _this.interimTile = null;
        /**
         * A key assigned to the tile. This is used by the tile source to determine
         * if this tile can effectively be used, or if a new tile should be created
         * and this one be used as an interim tile for this new tile.
         * @type {string}
         */ _this.key = '';
        /**
         * The duration for the opacity transition.
         * @type {number}
         */ _this.transition_ = options.transition === undefined ? 250 : options.transition;
        /**
         * Lookup of start times for rendering transitions.  If the start time is
         * equal to -1, the transition is complete.
         * @type {Object<string, number>}
         */ _this.transitionStarts_ = {
        };
        return _this;
    }
    /**
     * @protected
     */ Tile2.prototype.changed = function() {
        this.dispatchEvent(_eventTypeJsDefault.default.CHANGE);
    };
    /**
     * Called by the tile cache when the tile is removed from the cache due to expiry
     */ Tile2.prototype.release = function() {
    };
    /**
     * @return {string} Key.
     */ Tile2.prototype.getKey = function() {
        return this.key + '/' + this.tileCoord;
    };
    /**
     * Get the interim tile most suitable for rendering using the chain of interim
     * tiles. This corresponds to the  most recent tile that has been loaded, if no
     * such tile exists, the original tile is returned.
     * @return {!Tile} Best tile for rendering.
     */ Tile2.prototype.getInterimTile = function() {
        if (!this.interimTile) //empty chain
        return this;
        var tile = this.interimTile;
        // find the first loaded tile and return it. Since the chain is sorted in
        // decreasing order of creation time, there is no need to search the remainder
        // of the list (all those tiles correspond to older requests and will be
        // cleaned up by refreshInterimChain)
        do {
            if (tile.getState() == _tileStateJsDefault.default.LOADED) {
                // Show tile immediately instead of fading it in after loading, because
                // the interim tile is in place already
                this.transition_ = 0;
                return tile;
            }
            tile = tile.interimTile;
        }while (tile)
        // we can not find a better tile
        return this;
    };
    /**
     * Goes through the chain of interim tiles and discards sections of the chain
     * that are no longer relevant.
     */ Tile2.prototype.refreshInterimChain = function() {
        if (!this.interimTile) return;
        var tile = this.interimTile;
        var prev = this;
        do {
            if (tile.getState() == _tileStateJsDefault.default.LOADED) {
                //we have a loaded tile, we can discard the rest of the list
                //we would could abort any LOADING tile request
                //older than this tile (i.e. any LOADING tile following this entry in the chain)
                tile.interimTile = null;
                break;
            } else if (tile.getState() == _tileStateJsDefault.default.LOADING) //keep this LOADING tile any loaded tiles later in the chain are
            //older than this tile, so we're still interested in the request
            prev = tile;
            else if (tile.getState() == _tileStateJsDefault.default.IDLE) //the head of the list is the most current tile, we don't need
            //to start any other requests for this chain
            prev.interimTile = tile.interimTile;
            else prev = tile;
            tile = prev.interimTile;
        }while (tile)
    };
    /**
     * Get the tile coordinate for this tile.
     * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
     * @api
     */ Tile2.prototype.getTileCoord = function() {
        return this.tileCoord;
    };
    /**
     * @return {import("./TileState.js").default} State.
     */ Tile2.prototype.getState = function() {
        return this.state;
    };
    /**
     * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
     * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
     * when the tile cannot be loaded. Otherwise the tile cannot be removed from
     * the tile queue and will block other requests.
     * @param {import("./TileState.js").default} state State.
     * @api
     */ Tile2.prototype.setState = function(state) {
        if (this.state !== _tileStateJsDefault.default.ERROR && this.state > state) throw new Error('Tile load sequence violation');
        this.state = state;
        this.changed();
    };
    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     * @abstract
     * @api
     */ Tile2.prototype.load = function() {
        _utilJs.abstract();
    };
    /**
     * Get the alpha value for rendering.
     * @param {string} id An id for the renderer.
     * @param {number} time The render frame time.
     * @return {number} A number between 0 and 1.
     */ Tile2.prototype.getAlpha = function(id, time) {
        if (!this.transition_) return 1;
        var start = this.transitionStarts_[id];
        if (!start) {
            start = time;
            this.transitionStarts_[id] = start;
        } else if (start === -1) return 1;
        var delta = time - start + 1000 / 60; // avoid rendering at 0
        if (delta >= this.transition_) return 1;
        return _easingJs.easeIn(delta / this.transition_);
    };
    /**
     * Determine if a tile is in an alpha transition.  A tile is considered in
     * transition if tile.getAlpha() has not yet been called or has been called
     * and returned 1.
     * @param {string} id An id for the renderer.
     * @return {boolean} The tile is in transition.
     */ Tile2.prototype.inTransition = function(id) {
        if (!this.transition_) return false;
        return this.transitionStarts_[id] !== -1;
    };
    /**
     * Mark a transition as complete.
     * @param {string} id An id for the renderer.
     */ Tile2.prototype.endTransition = function(id) {
        if (this.transition_) this.transitionStarts_[id] = -1;
    };
    return Tile2;
}(_targetJsDefault.default);
exports.default = Tile1;

},{"./events/Target.js":"dj5zz","./events/EventType.js":"83vee","./TileState.js":"eIJIE","./util.js":"9zOhk","./easing.js":"BpZIl","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"dj5zz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/events/Target
 */ var _disposableJs = require("../Disposable.js");
var _disposableJsDefault = parcelHelpers.interopDefault(_disposableJs);
var _eventJs = require("./Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _functionsJs = require("../functions.js");
var _objJs = require("../obj.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {EventTarget|Target} EventTargetLike
 */ /**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */ var Target1 = function(_super) {
    __extends(Target2, _super);
    /**
     * @param {*} [opt_target] Default event target for dispatched events.
     */ function Target2(opt_target) {
        var _this = _super.call(this) || this;
        /**
         * @private
         * @type {*}
         */ _this.eventTarget_ = opt_target;
        /**
         * @private
         * @type {Object<string, number>}
         */ _this.pendingRemovals_ = null;
        /**
         * @private
         * @type {Object<string, number>}
         */ _this.dispatching_ = null;
        /**
         * @private
         * @type {Object<string, Array<import("../events.js").Listener>>}
         */ _this.listeners_ = null;
        return _this;
    }
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */ Target2.prototype.addEventListener = function(type, listener) {
        if (!type || !listener) return;
        var listeners = this.listeners_ || (this.listeners_ = {
        });
        var listenersForType = listeners[type] || (listeners[type] = []);
        if (listenersForType.indexOf(listener) === -1) listenersForType.push(listener);
    };
    /**
     * Dispatches an event and calls all listeners listening for events
     * of this type. The event parameter can either be a string or an
     * Object with a `type` property.
     *
     * @param {import("./Event.js").default|string} event Event object.
     * @return {boolean|undefined} `false` if anyone called preventDefault on the
     *     event object or if any of the listeners returned false.
     * @api
     */ Target2.prototype.dispatchEvent = function(event) {
        /** @type {import("./Event.js").default|Event} */ var evt = typeof event === 'string' ? new _eventJsDefault.default(event) : event;
        var type = evt.type;
        if (!evt.target) evt.target = this.eventTarget_ || this;
        var listeners = this.listeners_ && this.listeners_[type];
        var propagate;
        if (listeners) {
            var dispatching = this.dispatching_ || (this.dispatching_ = {
            });
            var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {
            });
            if (!(type in dispatching)) {
                dispatching[type] = 0;
                pendingRemovals[type] = 0;
            }
            ++dispatching[type];
            for(var i = 0, ii = listeners.length; i < ii; ++i){
                if ('handleEvent' in listeners[i]) propagate = /** @type {import("../events.js").ListenerObject} */ listeners[i].handleEvent(evt);
                else propagate = /** @type {import("../events.js").ListenerFunction} */ listeners[i].call(this, evt);
                if (propagate === false || evt.propagationStopped) {
                    propagate = false;
                    break;
                }
            }
            --dispatching[type];
            if (dispatching[type] === 0) {
                var pr = pendingRemovals[type];
                delete pendingRemovals[type];
                while(pr--)this.removeEventListener(type, _functionsJs.VOID);
                delete dispatching[type];
            }
            return propagate;
        }
    };
    /**
     * Clean up.
     */ Target2.prototype.disposeInternal = function() {
        this.listeners_ && _objJs.clear(this.listeners_);
    };
    /**
     * Get the listeners for a specified event type. Listeners are returned in the
     * order that they will be called in.
     *
     * @param {string} type Type.
     * @return {Array<import("../events.js").Listener>|undefined} Listeners.
     */ Target2.prototype.getListeners = function(type) {
        return this.listeners_ && this.listeners_[type] || undefined;
    };
    /**
     * @param {string} [opt_type] Type. If not provided,
     *     `true` will be returned if this event target has any listeners.
     * @return {boolean} Has listeners.
     */ Target2.prototype.hasListener = function(opt_type) {
        if (!this.listeners_) return false;
        return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
    };
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */ Target2.prototype.removeEventListener = function(type, listener) {
        var listeners = this.listeners_ && this.listeners_[type];
        if (listeners) {
            var index = listeners.indexOf(listener);
            if (index !== -1) {
                if (this.pendingRemovals_ && type in this.pendingRemovals_) {
                    // make listener a no-op, and remove later in #dispatchEvent()
                    listeners[index] = _functionsJs.VOID;
                    ++this.pendingRemovals_[type];
                } else {
                    listeners.splice(index, 1);
                    if (listeners.length === 0) delete this.listeners_[type];
                }
            }
        }
    };
    return Target2;
}(_disposableJsDefault.default);
exports.default = Target1;

},{"../Disposable.js":"b72Yc","./Event.js":"7AR9n","../functions.js":"d72zA","../obj.js":"g3fPg","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"b72Yc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/Disposable
 */ /**
 * @classdesc
 * Objects that need to clean up after themselves.
 */ var Disposable = function() {
    function Disposable1() {
        /**
         * The object has already been disposed.
         * @type {boolean}
         * @protected
         */ this.disposed = false;
    }
    /**
     * Clean up.
     */ Disposable1.prototype.dispose = function() {
        if (!this.disposed) {
            this.disposed = true;
            this.disposeInternal();
        }
    };
    /**
     * Extension point for disposable objects.
     * @protected
     */ Disposable1.prototype.disposeInternal = function() {
    };
    return Disposable1;
}();
exports.default = Disposable;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7AR9n":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Event|import("./Event.js").default} evt Event
 */ parcelHelpers.export(exports, "stopPropagation", ()=>stopPropagation
);
/**
 * @param {Event|import("./Event.js").default} evt Event
 */ parcelHelpers.export(exports, "preventDefault", ()=>preventDefault
);
/**
 * @module ol/events/Event
 */ /**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */ var BaseEvent = function() {
    /**
     * @param {string} type Type.
     */ function BaseEvent1(type) {
        /**
         * @type {boolean}
         */ this.propagationStopped;
        /**
         * @type {boolean}
         */ this.defaultPrevented;
        /**
         * The event type.
         * @type {string}
         * @api
         */ this.type = type;
        /**
         * The event target.
         * @type {Object}
         * @api
         */ this.target = null;
    }
    /**
     * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
     * will be fired.
     * @api
     */ BaseEvent1.prototype.preventDefault = function() {
        this.defaultPrevented = true;
    };
    /**
     * Stop event propagation.
     * @api
     */ BaseEvent1.prototype.stopPropagation = function() {
        this.propagationStopped = true;
    };
    return BaseEvent1;
}();
function stopPropagation(evt) {
    evt.stopPropagation();
}
function preventDefault(evt) {
    evt.preventDefault();
}
exports.default = BaseEvent;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"d72zA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Always returns true.
 * @return {boolean} true.
 */ parcelHelpers.export(exports, "TRUE", ()=>TRUE
);
/**
 * Always returns false.
 * @return {boolean} false.
 */ parcelHelpers.export(exports, "FALSE", ()=>FALSE
);
/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */ parcelHelpers.export(exports, "VOID", ()=>VOID
);
/**
 * Wrap a function in another function that remembers the last return.  If the
 * returned function is called twice in a row with the same arguments and the same
 * this object, it will return the value from the first call in the second call.
 *
 * @param {function(...any): ReturnType} fn The function to memoize.
 * @return {function(...any): ReturnType} The memoized function.
 * @template ReturnType
 */ parcelHelpers.export(exports, "memoizeOne", ()=>memoizeOne
);
/**
 * @module ol/functions
 */ var _arrayJs = require("./array.js");
function TRUE() {
    return true;
}
function FALSE() {
    return false;
}
function VOID() {
}
function memoizeOne(fn) {
    var called = false;
    /** @type {ReturnType} */ var lastResult;
    /** @type {Array<any>} */ var lastArgs;
    var lastThis;
    return function() {
        var nextArgs = Array.prototype.slice.call(arguments);
        if (!called || this !== lastThis || !_arrayJs.equals(nextArgs, lastArgs)) {
            called = true;
            lastThis = this;
            lastArgs = nextArgs;
            lastResult = fn.apply(this, arguments);
        }
        return lastResult;
    };
}

},{"./array.js":"jKNP0","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jKNP0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/array
 */ /**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function} [opt_comparator] Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */ parcelHelpers.export(exports, "binarySearch", ()=>binarySearch
);
/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */ parcelHelpers.export(exports, "numberSafeCompareFunction", ()=>numberSafeCompareFunction
);
/**
 * Whether the array contains the given object.
 * @param {Array<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */ parcelHelpers.export(exports, "includes", ()=>includes
);
/**
 * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function
 * of this type to determine which nearest resolution to use.
 *
 * This function takes a `{number}` representing a value between two array entries,
 * a `{number}` representing the value of the nearest higher entry and
 * a `{number}` representing the value of the nearest lower entry
 * as arguments and returns a `{number}`. If a negative number or zero is returned
 * the lower value will be used, if a positive number is returned the higher value
 * will be used.
 * @typedef {function(number, number, number): number} NearestDirectionFunction
 * @api
 */ /**
 * @param {Array<number>} arr Array in descending order.
 * @param {number} target Target.
 * @param {number|NearestDirectionFunction} direction
 *    0 means return the nearest,
 *    > 0 means return the largest nearest,
 *    < 0 means return the smallest nearest.
 * @return {number} Index.
 */ parcelHelpers.export(exports, "linearFindNearest", ()=>linearFindNearest
);
/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */ parcelHelpers.export(exports, "reverseSubArray", ()=>reverseSubArray
);
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */ parcelHelpers.export(exports, "extend", ()=>extend
);
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */ parcelHelpers.export(exports, "remove", ()=>remove
);
/**
 * @param {Array<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE|null} The element found or null.
 */ parcelHelpers.export(exports, "find", ()=>find
);
/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
/**
 * Sort the passed array such that the relative order of equal elements is preserved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */ parcelHelpers.export(exports, "stableSort", ()=>stableSort
);
/**
 * @param {Array<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */ parcelHelpers.export(exports, "findIndex", ()=>findIndex
);
/**
 * @param {Array<*>} arr The array to test.
 * @param {Function} [opt_func] Comparison function.
 * @param {boolean} [opt_strict] Strictly sorted (default false).
 * @return {boolean} Return index.
 */ parcelHelpers.export(exports, "isSorted", ()=>isSorted
);
function binarySearch(haystack, needle, opt_comparator) {
    var mid, cmp;
    var comparator = opt_comparator || numberSafeCompareFunction;
    var low = 0;
    var high = haystack.length;
    var found = false;
    while(low < high){
        /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
         * to double (which gives the wrong results). */ mid = low + (high - low >> 1);
        cmp = +comparator(haystack[mid], needle);
        if (cmp < 0) /* Too low. */ low = mid + 1;
        else {
            /* Key found or too high */ high = mid;
            found = !cmp;
        }
    }
    /* Key not found. */ return found ? low : ~low;
}
function numberSafeCompareFunction(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
}
function includes(arr, obj) {
    return arr.indexOf(obj) >= 0;
}
function linearFindNearest(arr, target, direction) {
    var n = arr.length;
    if (arr[0] <= target) return 0;
    else if (target <= arr[n - 1]) return n - 1;
    else {
        var i = void 0;
        if (direction > 0) for(i = 1; i < n; ++i){
            if (arr[i] < target) return i - 1;
        }
        else if (direction < 0) for(i = 1; i < n; ++i){
            if (arr[i] <= target) return i;
        }
        else for(i = 1; i < n; ++i){
            if (arr[i] == target) return i;
            else if (arr[i] < target) {
                if (typeof direction === 'function') {
                    if (direction(target, arr[i - 1], arr[i]) > 0) return i - 1;
                    else return i;
                } else if (arr[i - 1] - target < target - arr[i]) return i - 1;
                else return i;
            }
        }
        return n - 1;
    }
}
function reverseSubArray(arr, begin, end) {
    while(begin < end){
        var tmp = arr[begin];
        arr[begin] = arr[end];
        arr[end] = tmp;
        ++begin;
        --end;
    }
}
function extend(arr, data) {
    var extension = Array.isArray(data) ? data : [
        data
    ];
    var length = extension.length;
    for(var i = 0; i < length; i++)arr[arr.length] = extension[i];
}
function remove(arr, obj) {
    var i = arr.indexOf(obj);
    var found = i > -1;
    if (found) arr.splice(i, 1);
    return found;
}
function find(arr, func) {
    var length = arr.length >>> 0;
    var value;
    for(var i = 0; i < length; i++){
        value = arr[i];
        if (func(value, i, arr)) return value;
    }
    return null;
}
function equals(arr1, arr2) {
    var len1 = arr1.length;
    if (len1 !== arr2.length) return false;
    for(var i = 0; i < len1; i++){
        if (arr1[i] !== arr2[i]) return false;
    }
    return true;
}
function stableSort(arr, compareFnc) {
    var length = arr.length;
    var tmp = Array(arr.length);
    var i;
    for(i = 0; i < length; i++)tmp[i] = {
        index: i,
        value: arr[i]
    };
    tmp.sort(function(a, b) {
        return compareFnc(a.value, b.value) || a.index - b.index;
    });
    for(i = 0; i < arr.length; i++)arr[i] = tmp[i].value;
}
function findIndex(arr, func) {
    var index;
    var found = !arr.every(function(el, idx) {
        index = idx;
        return !func(el, idx, arr);
    });
    return found ? index : -1;
}
function isSorted(arr, opt_func, opt_strict) {
    var compare = opt_func || numberSafeCompareFunction;
    return arr.every(function(currentVal, index) {
        if (index === 0) return true;
        var res = compare(arr[index - 1], currentVal);
        return !(res > 0 || opt_strict && res === 0);
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"g3fPg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "assign", ()=>assign
);
/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */ parcelHelpers.export(exports, "clear", ()=>clear
);
parcelHelpers.export(exports, "getValues", ()=>getValues
);
/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */ parcelHelpers.export(exports, "isEmpty", ()=>isEmpty
);
var assign = typeof Object.assign === 'function' ? Object.assign : function(target, var_sources) {
    if (target === undefined || target === null) throw new TypeError('Cannot convert undefined or null to object');
    var output = Object(target);
    for(var i = 1, ii = arguments.length; i < ii; ++i){
        var source = arguments[i];
        if (source !== undefined && source !== null) {
            for(var key in source)if (source.hasOwnProperty(key)) output[key] = source[key];
        }
    }
    return output;
};
function clear(object) {
    for(var property in object)delete object[property];
}
var getValues = typeof Object.values === 'function' ? Object.values : function(object) {
    var values = [];
    for(var property in object)values.push(object[property]);
    return values;
};
function isEmpty(object) {
    var property;
    for(property in object)return false;
    return !property;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"83vee":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
     * Generic change event. Triggered when the revision counter is increased.
     * @event module:ol/events/Event~BaseEvent#change
     * @api
     */ CHANGE: 'change',
    /**
     * Generic error event. Triggered when an error occurs.
     * @event module:ol/events/Event~BaseEvent#error
     * @api
     */ ERROR: 'error',
    BLUR: 'blur',
    CLEAR: 'clear',
    CONTEXTMENU: 'contextmenu',
    CLICK: 'click',
    DBLCLICK: 'dblclick',
    DRAGENTER: 'dragenter',
    DRAGOVER: 'dragover',
    DROP: 'drop',
    FOCUS: 'focus',
    KEYDOWN: 'keydown',
    KEYPRESS: 'keypress',
    LOAD: 'load',
    RESIZE: 'resize',
    TOUCHMOVE: 'touchmove',
    WHEEL: 'wheel'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eIJIE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    /**
     * Indicates that tile loading failed
     * @type {number}
     */ ERROR: 3,
    EMPTY: 4
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9zOhk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/util
 */ /**
 * @return {?} Any return.
 */ parcelHelpers.export(exports, "abstract", ()=>abstract
);
/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @api
 */ parcelHelpers.export(exports, "getUid", ()=>getUid
);
parcelHelpers.export(exports, "VERSION", ()=>VERSION
);
function abstract() {
    return (function() {
        throw new Error('Unimplemented abstract method.');
    })();
}
/**
 * Counter for getUid.
 * @type {number}
 * @private
 */ var uidCounter_ = 0;
function getUid(obj) {
    return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
var VERSION = '6.8.1';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"BpZIl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/easing
 */ /**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "easeIn", ()=>easeIn
);
/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "easeOut", ()=>easeOut
);
/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "inAndOut", ()=>inAndOut
);
/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "linear", ()=>linear
);
/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing.inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */ parcelHelpers.export(exports, "upAndDown", ()=>upAndDown
);
function easeIn(t) {
    return Math.pow(t, 3);
}
function easeOut(t) {
    return 1 - easeIn(1 - t);
}
function inAndOut(t) {
    return 3 * t * t - 2 * t * t * t;
}
function linear(t) {
    return t;
}
function upAndDown(t) {
    if (t < 0.5) return inAndOut(2 * t);
    else return 1 - inAndOut(2 * (t - 0.5));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"ekKYy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
     * Triggered when a tile starts loading.
     * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
     * @api
     */ TILELOADSTART: 'tileloadstart',
    /**
     * Triggered when a tile finishes loading, either when its data is loaded,
     * or when loading was aborted because the tile is no longer needed.
     * @event module:ol/source/Tile.TileSourceEvent#tileloadend
     * @api
     */ TILELOADEND: 'tileloadend',
    /**
     * Triggered if tile loading results in an error.
     * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
     * @api
     */ TILELOADERROR: 'tileloaderror'
}; /**
 * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hcBBe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TileSourceEvent", ()=>TileSourceEvent1
);
/**
 * @module ol/source/Tile
 */ var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _sourceJs = require("./Source.js");
var _sourceJsDefault = parcelHelpers.interopDefault(_sourceJs);
var _tileCacheJs = require("../TileCache.js");
var _tileCacheJsDefault = parcelHelpers.interopDefault(_tileCacheJs);
var _tileStateJs = require("../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _utilJs = require("../util.js");
var _assertsJs = require("../asserts.js");
var _projJs = require("../proj.js");
var _tilecoordJs = require("../tilecoord.js");
var _tilegridJs = require("../tilegrid.js");
var _sizeJs = require("../size.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./TileEventType").TileSourceEventTypes, TileSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./TileEventType").TileSourceEventTypes, Return>} TileSourceOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] CacheSize.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {number} [tilePixelRatio] TilePixelRatio.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {import("./State.js").default} [state] State.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
 * @property {boolean} [wrapX=true] WrapX.
 * @property {number} [transition] Transition.
 * @property {string} [key] Key.
 * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * @abstract
 * @api
 */ var TileSource1 = function(_super) {
    __extends(TileSource2, _super);
    /**
     * @param {Options} options SourceTile source options.
     */ function TileSource2(options) {
        var _this = _super.call(this, {
            attributions: options.attributions,
            attributionsCollapsible: options.attributionsCollapsible,
            projection: options.projection,
            state: options.state,
            wrapX: options.wrapX
        }) || this;
        /***
         * @type {TileSourceOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {TileSourceOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {TileSourceOnSignature<void>}
         */ _this.un;
        /**
         * @private
         * @type {boolean}
         */ _this.opaque_ = options.opaque !== undefined ? options.opaque : false;
        /**
         * @private
         * @type {number}
         */ _this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;
        /**
         * @protected
         * @type {import("../tilegrid/TileGrid.js").default}
         */ _this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;
        var tileSize = [
            256,
            256
        ];
        var tileGrid = options.tileGrid;
        if (tileGrid) _sizeJs.toSize(tileGrid.getTileSize(tileGrid.getMinZoom()), tileSize);
        /**
         * @protected
         * @type {import("../TileCache.js").default}
         */ _this.tileCache = new _tileCacheJsDefault.default(options.cacheSize || 0);
        /**
         * @protected
         * @type {import("../size.js").Size}
         */ _this.tmpSize = [
            0,
            0
        ];
        /**
         * @private
         * @type {string}
         */ _this.key_ = options.key || '';
        /**
         * @protected
         * @type {import("../Tile.js").Options}
         */ _this.tileOptions = {
            transition: options.transition
        };
        /**
         * zDirection hint, read by the renderer. Indicates which resolution should be used
         * by a renderer if the views resolution does not match any resolution of the tile source.
         * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
         * will be used. If -1, the nearest higher resolution will be used.
         * @type {number|import("../array.js").NearestDirectionFunction}
         */ _this.zDirection = options.zDirection ? options.zDirection : 0;
        return _this;
    }
    /**
     * @return {boolean} Can expire cache.
     */ TileSource2.prototype.canExpireCache = function() {
        return this.tileCache.canExpireCache();
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {!Object<string, boolean>} usedTiles Used tiles.
     */ TileSource2.prototype.expireCache = function(projection, usedTiles) {
        var tileCache = this.getTileCacheForProjection(projection);
        if (tileCache) tileCache.expireCache(usedTiles);
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @param {number} z Zoom level.
     * @param {import("../TileRange.js").default} tileRange Tile range.
     * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
     *     loaded tile.  If the callback returns `false`, the tile will not be
     *     considered loaded.
     * @return {boolean} The tile range is fully covered with loaded tiles.
     */ TileSource2.prototype.forEachLoadedTile = function(projection, z, tileRange, callback) {
        var tileCache = this.getTileCacheForProjection(projection);
        if (!tileCache) return false;
        var covered = true;
        var tile, tileCoordKey, loaded;
        for(var x = tileRange.minX; x <= tileRange.maxX; ++x)for(var y = tileRange.minY; y <= tileRange.maxY; ++y){
            tileCoordKey = _tilecoordJs.getKeyZXY(z, x, y);
            loaded = false;
            if (tileCache.containsKey(tileCoordKey)) {
                tile = tileCache.get(tileCoordKey);
                loaded = tile.getState() === _tileStateJsDefault.default.LOADED;
                if (loaded) loaded = callback(tile) !== false;
            }
            if (!loaded) covered = false;
        }
        return covered;
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {number} Gutter.
     */ TileSource2.prototype.getGutterForProjection = function(projection) {
        return 0;
    };
    /**
     * Return the key to be used for all tiles in the source.
     * @return {string} The key for all tiles.
     * @protected
     */ TileSource2.prototype.getKey = function() {
        return this.key_;
    };
    /**
     * Set the value to be used as the key for all tiles in the source.
     * @param {string} key The key for tiles.
     * @protected
     */ TileSource2.prototype.setKey = function(key) {
        if (this.key_ !== key) {
            this.key_ = key;
            this.changed();
        }
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {boolean} Opaque.
     */ TileSource2.prototype.getOpaque = function(projection) {
        return this.opaque_;
    };
    /**
     * @return {Array<number>} Resolutions.
     */ TileSource2.prototype.getResolutions = function() {
        return this.tileGrid.getResolutions();
    };
    /**
     * @abstract
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../Tile.js").default} Tile.
     */ TileSource2.prototype.getTile = function(z, x, y, pixelRatio, projection) {
        return _utilJs.abstract();
    };
    /**
     * Return the tile grid of the tile source.
     * @return {import("../tilegrid/TileGrid.js").default} Tile grid.
     * @api
     */ TileSource2.prototype.getTileGrid = function() {
        return this.tileGrid;
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
     */ TileSource2.prototype.getTileGridForProjection = function(projection) {
        if (!this.tileGrid) return _tilegridJs.getForProjection(projection);
        else return this.tileGrid;
    };
    /**
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../TileCache.js").default} Tile cache.
     * @protected
     */ TileSource2.prototype.getTileCacheForProjection = function(projection) {
        _assertsJs.assert(_projJs.equivalent(this.getProjection(), projection), 68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.
        );
        return this.tileCache;
    };
    /**
     * Get the tile pixel ratio for this source. Subclasses may override this
     * method, which is meant to return a supported pixel ratio that matches the
     * provided `pixelRatio` as close as possible.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Tile pixel ratio.
     */ TileSource2.prototype.getTilePixelRatio = function(pixelRatio) {
        return this.tilePixelRatio_;
    };
    /**
     * @param {number} z Z.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../proj/Projection.js").default} projection Projection.
     * @return {import("../size.js").Size} Tile size.
     */ TileSource2.prototype.getTilePixelSize = function(z, pixelRatio, projection) {
        var tileGrid = this.getTileGridForProjection(projection);
        var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
        var tileSize = _sizeJs.toSize(tileGrid.getTileSize(z), this.tmpSize);
        if (tilePixelRatio == 1) return tileSize;
        else return _sizeJs.scale(tileSize, tilePixelRatio, this.tmpSize);
    };
    /**
     * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
     * is outside the resolution and extent range of the tile grid, `null` will be
     * returned.
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../proj/Projection.js").default} [opt_projection] Projection.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
     *     null if no tile URL should be created for the passed `tileCoord`.
     */ TileSource2.prototype.getTileCoordForTileUrlFunction = function(tileCoord, opt_projection) {
        var projection = opt_projection !== undefined ? opt_projection : this.getProjection();
        var tileGrid = this.getTileGridForProjection(projection);
        if (this.getWrapX() && projection.isGlobal()) tileCoord = _tilegridJs.wrapX(tileGrid, tileCoord, projection);
        return _tilecoordJs.withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
    };
    /**
     * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
     * @api
     */ TileSource2.prototype.clear = function() {
        this.tileCache.clear();
    };
    TileSource2.prototype.refresh = function() {
        this.clear();
        _super.prototype.refresh.call(this);
    };
    /**
     * Increases the cache size if needed
     * @param {number} tileCount Minimum number of tiles needed.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */ TileSource2.prototype.updateCacheSize = function(tileCount, projection) {
        var tileCache = this.getTileCacheForProjection(projection);
        if (tileCount > tileCache.highWaterMark) tileCache.highWaterMark = tileCount;
    };
    /**
     * Marks a tile coord as being used, without triggering a load.
     * @abstract
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */ TileSource2.prototype.useTile = function(z, x, y, projection) {
    };
    return TileSource2;
}(_sourceJsDefault.default);
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */ var TileSourceEvent1 = function(_super) {
    __extends(TileSourceEvent2, _super);
    /**
     * @param {string} type Type.
     * @param {import("../Tile.js").default} tile The tile.
     */ function TileSourceEvent2(type, tile) {
        var _this = _super.call(this, type) || this;
        /**
         * The tile related to the event.
         * @type {import("../Tile.js").default}
         * @api
         */ _this.tile = tile;
        return _this;
    }
    return TileSourceEvent2;
}(_eventJsDefault.default);
exports.default = TileSource1;

},{"../events/Event.js":"7AR9n","./Source.js":"2JiFe","../TileCache.js":"1wm9c","../TileState.js":"eIJIE","../util.js":"9zOhk","../asserts.js":"cnrP4","../proj.js":"hmdWM","../tilecoord.js":"gDmuU","../tilegrid.js":"llps6","../size.js":"5PZ8p","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"2JiFe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/source/Source
 */ var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _stateJs = require("./State.js");
var _stateJsDefault = parcelHelpers.interopDefault(_stateJs);
var _utilJs = require("../util.js");
var _projJs = require("../proj.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * A function that takes a {@link module:ol/PluggableMap~FrameState} and returns a string or
 * an array of strings representing source attributions.
 *
 * @typedef {function(import("../PluggableMap.js").FrameState): (string|Array<string>)} Attribution
 */ /**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `'Â© Acme Inc.'`)
 * * an array of simple strings (e.g. `['Â© Acme Inc.', 'Â© Bacme Inc.']`)
 * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */ /**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("./State.js").default} [state='ready'] State.
 * @property {boolean} [wrapX=false] WrapX.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */ var Source1 = function(_super) {
    __extends(Source2, _super);
    /**
     * @param {Options} options Source options.
     */ function Source2(options) {
        var _this = _super.call(this) || this;
        /**
         * @protected
         * @type {import("../proj/Projection.js").default}
         */ _this.projection = _projJs.get(options.projection);
        /**
         * @private
         * @type {?Attribution}
         */ _this.attributions_ = adaptAttributions(options.attributions);
        /**
         * @private
         * @type {boolean}
         */ _this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ? options.attributionsCollapsible : true;
        /**
         * This source is currently loading data. Sources that defer loading to the
         * map's tile queue never set this to `true`.
         * @type {boolean}
         */ _this.loading = false;
        /**
         * @private
         * @type {import("./State.js").default}
         */ _this.state_ = options.state !== undefined ? options.state : _stateJsDefault.default.READY;
        /**
         * @private
         * @type {boolean}
         */ _this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
        /**
         * @protected
         * @type {function(import("../View.js").ViewOptions):void}
         */ _this.viewResolver = null;
        /**
         * @protected
         * @type {function(Error):void}
         */ _this.viewRejector = null;
        var self = _this;
        /**
         * @private
         * @type {Promise<import("../View.js").ViewOptions>}
         */ _this.viewPromise_ = new Promise(function(resolve, reject) {
            self.viewResolver = resolve;
            self.viewRejector = reject;
        });
        return _this;
    }
    /**
     * Get the attribution function for the source.
     * @return {?Attribution} Attribution function.
     * @api
     */ Source2.prototype.getAttributions = function() {
        return this.attributions_;
    };
    /**
     * @return {boolean} Attributions are collapsible.
     * @api
     */ Source2.prototype.getAttributionsCollapsible = function() {
        return this.attributionsCollapsible_;
    };
    /**
     * Get the projection of the source.
     * @return {import("../proj/Projection.js").default} Projection.
     * @api
     */ Source2.prototype.getProjection = function() {
        return this.projection;
    };
    /**
     * @abstract
     * @return {Array<number>|undefined} Resolutions.
     */ Source2.prototype.getResolutions = function() {
        return _utilJs.abstract();
    };
    /**
     * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
     */ Source2.prototype.getView = function() {
        return this.viewPromise_;
    };
    /**
     * Get the state of the source, see {@link module:ol/source/State~State} for possible states.
     * @return {import("./State.js").default} State.
     * @api
     */ Source2.prototype.getState = function() {
        return this.state_;
    };
    /**
     * @return {boolean|undefined} Wrap X.
     */ Source2.prototype.getWrapX = function() {
        return this.wrapX_;
    };
    /**
     * @return {Object|undefined} Context options.
     */ Source2.prototype.getContextOptions = function() {
        return undefined;
    };
    /**
     * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
     * @api
     */ Source2.prototype.refresh = function() {
        this.changed();
    };
    /**
     * Set the attributions of the source.
     * @param {AttributionLike|undefined} attributions Attributions.
     *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
     *     or `undefined`.
     * @api
     */ Source2.prototype.setAttributions = function(attributions) {
        this.attributions_ = adaptAttributions(attributions);
        this.changed();
    };
    /**
     * Set the state of the source.
     * @param {import("./State.js").default} state State.
     */ Source2.prototype.setState = function(state) {
        this.state_ = state;
        this.changed();
    };
    return Source2;
}(_objectJsDefault.default);
/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {?Attribution} An attribution function (or null).
 */ function adaptAttributions(attributionLike) {
    if (!attributionLike) return null;
    if (Array.isArray(attributionLike)) return function(frameState) {
        return attributionLike;
    };
    if (typeof attributionLike === 'function') return attributionLike;
    return function(frameState) {
        return [
            attributionLike
        ];
    };
}
exports.default = Source1;

},{"../Object.js":"3roCV","./State.js":"hpoq1","../util.js":"9zOhk","../proj.js":"hmdWM","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3roCV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ObjectEvent", ()=>ObjectEvent1
);
/**
 * @module ol/Object
 */ var _eventJs = require("./events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _objectEventTypeJs = require("./ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _observableJs = require("./Observable.js");
var _observableJsDefault = parcelHelpers.interopDefault(_observableJs);
var _objJs = require("./obj.js");
var _utilJs = require("./util.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */ var ObjectEvent1 = function(_super) {
    __extends(ObjectEvent2, _super);
    /**
     * @param {string} type The event type.
     * @param {string} key The property name.
     * @param {*} oldValue The old value for `key`.
     */ function ObjectEvent2(type, key, oldValue) {
        var _this = _super.call(this, type) || this;
        /**
         * The name of the property whose value is changing.
         * @type {string}
         * @api
         */ _this.key = key;
        /**
         * The old value. To get the new value use `e.target.get(e.key)` where
         * `e` is the event object.
         * @type {*}
         * @api
         */ _this.oldValue = oldValue;
        return _this;
    }
    return ObjectEvent2;
}(_eventJsDefault.default);
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<import("./ObjectEventType").Types, ObjectEvent, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types, Return>} ObjectOnSignature
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */ var BaseObject1 = function(_super) {
    __extends(BaseObject2, _super);
    /**
     * @param {Object<string, *>} [opt_values] An object with key-value pairs.
     */ function BaseObject2(opt_values) {
        var _this = _super.call(this) || this;
        /***
         * @type {ObjectOnSignature<import("./events").EventsKey>}
         */ _this.on;
        /***
         * @type {ObjectOnSignature<import("./events").EventsKey>}
         */ _this.once;
        /***
         * @type {ObjectOnSignature<void>}
         */ _this.un;
        // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is
        // the same as the order in which they were created.  This also helps to
        // ensure that object properties are always added in the same order, which
        // helps many JavaScript engines generate faster code.
        _utilJs.getUid(_this);
        /**
         * @private
         * @type {Object<string, *>}
         */ _this.values_ = null;
        if (opt_values !== undefined) _this.setProperties(opt_values);
        return _this;
    }
    /**
     * Gets a value.
     * @param {string} key Key name.
     * @return {*} Value.
     * @api
     */ BaseObject2.prototype.get = function(key) {
        var value;
        if (this.values_ && this.values_.hasOwnProperty(key)) value = this.values_[key];
        return value;
    };
    /**
     * Get a list of object property names.
     * @return {Array<string>} List of property names.
     * @api
     */ BaseObject2.prototype.getKeys = function() {
        return this.values_ && Object.keys(this.values_) || [];
    };
    /**
     * Get an object of all property names and values.
     * @return {Object<string, *>} Object.
     * @api
     */ BaseObject2.prototype.getProperties = function() {
        return this.values_ && _objJs.assign({
        }, this.values_) || {
        };
    };
    /**
     * @return {boolean} The object has properties.
     */ BaseObject2.prototype.hasProperties = function() {
        return !!this.values_;
    };
    /**
     * @param {string} key Key name.
     * @param {*} oldValue Old value.
     */ BaseObject2.prototype.notify = function(key, oldValue) {
        var eventType;
        eventType = "change:" + key;
        this.dispatchEvent(new ObjectEvent1(eventType, key, oldValue));
        eventType = _objectEventTypeJsDefault.default.PROPERTYCHANGE;
        this.dispatchEvent(new ObjectEvent1(eventType, key, oldValue));
    };
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */ BaseObject2.prototype.addChangeListener = function(key, listener) {
        this.addEventListener("change:" + key, listener);
    };
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */ BaseObject2.prototype.removeChangeListener = function(key, listener) {
        this.removeEventListener("change:" + key, listener);
    };
    /**
     * Sets a value.
     * @param {string} key Key name.
     * @param {*} value Value.
     * @param {boolean} [opt_silent] Update without triggering an event.
     * @api
     */ BaseObject2.prototype.set = function(key, value, opt_silent) {
        var values = this.values_ || (this.values_ = {
        });
        if (opt_silent) values[key] = value;
        else {
            var oldValue = values[key];
            values[key] = value;
            if (oldValue !== value) this.notify(key, oldValue);
        }
    };
    /**
     * Sets a collection of key-value pairs.  Note that this changes any existing
     * properties and adds new ones (it does not remove any existing properties).
     * @param {Object<string, *>} values Values.
     * @param {boolean} [opt_silent] Update without triggering an event.
     * @api
     */ BaseObject2.prototype.setProperties = function(values, opt_silent) {
        for(var key in values)this.set(key, values[key], opt_silent);
    };
    /**
     * Apply any properties from another object without triggering events.
     * @param {BaseObject} source The source object.
     * @protected
     */ BaseObject2.prototype.applyProperties = function(source) {
        if (!source.values_) return;
        _objJs.assign(this.values_ || (this.values_ = {
        }), source.values_);
    };
    /**
     * Unsets a property.
     * @param {string} key Key name.
     * @param {boolean} [opt_silent] Unset without triggering an event.
     * @api
     */ BaseObject2.prototype.unset = function(key, opt_silent) {
        if (this.values_ && key in this.values_) {
            var oldValue = this.values_[key];
            delete this.values_[key];
            if (_objJs.isEmpty(this.values_)) this.values_ = null;
            if (!opt_silent) this.notify(key, oldValue);
        }
    };
    return BaseObject2;
}(_observableJsDefault.default);
exports.default = BaseObject1;

},{"./events/Event.js":"7AR9n","./ObjectEventType.js":"j6hH6","./Observable.js":"j1IoA","./obj.js":"g3fPg","./util.js":"9zOhk","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"j6hH6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
     * Triggered when a property is changed.
     * @event module:ol/Object.ObjectEvent#propertychange
     * @api
     */ PROPERTYCHANGE: 'propertychange'
}; /**
 * @typedef {'propertychange'} Types
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"j1IoA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */ parcelHelpers.export(exports, "unByKey", ()=>unByKey
);
/**
 * @module ol/Observable
 */ var _targetJs = require("./events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _eventsJs = require("./events.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/***
 * @template {string} Type
 * @template {Event|import("./events/Event.js").default} EventClass
 * @template Return
 * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature
 */ /***
 * @template {string} Type
 * @template Return
 * @typedef {(type: Type[], listener: (event: Event|import("./events/Event").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature
 */ /**
 * @typedef {'change'|'error'} EventTypes
 */ /***
 * @template Return
 * @typedef {OnSignature<EventTypes, import("./events/Event.js").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").default
 * @api
 */ var Observable1 = function(_super) {
    __extends(Observable2, _super);
    function Observable2() {
        var _this = _super.call(this) || this;
        _this.on = _this.onInternal;
        _this.once = _this.onceInternal;
        _this.un = _this.unInternal;
        /**
         * @private
         * @type {number}
         */ _this.revision_ = 0;
        return _this;
    }
    /**
     * Increases the revision counter and dispatches a 'change' event.
     * @api
     */ Observable2.prototype.changed = function() {
        ++this.revision_;
        this.dispatchEvent(_eventTypeJsDefault.default.CHANGE);
    };
    /**
     * Get the version number for this object.  Each time the object is modified,
     * its version number will be incremented.
     * @return {number} Revision.
     * @api
     */ Observable2.prototype.getRevision = function() {
        return this.revision_;
    };
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */ Observable2.prototype.onInternal = function(type, listener) {
        if (Array.isArray(type)) {
            var len = type.length;
            var keys = new Array(len);
            for(var i = 0; i < len; ++i)keys[i] = _eventsJs.listen(this, type[i], listener);
            return keys;
        } else return _eventsJs.listen(this, type, listener);
    };
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */ Observable2.prototype.onceInternal = function(type, listener) {
        var key;
        if (Array.isArray(type)) {
            var len = type.length;
            key = new Array(len);
            for(var i = 0; i < len; ++i)key[i] = _eventsJs.listenOnce(this, type[i], listener);
        } else key = _eventsJs.listenOnce(this, type, listener);
        /** @type {Object} */ (listener).ol_key = key;
        return key;
    };
    /**
     * Unlisten for a certain type of event.
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @protected
     */ Observable2.prototype.unInternal = function(type, listener) {
        var key = /** @type {Object} */ listener.ol_key;
        if (key) unByKey(key);
        else if (Array.isArray(type)) for(var i = 0, ii = type.length; i < ii; ++i)this.removeEventListener(type[i], listener);
        else this.removeEventListener(type, listener);
    };
    return Observable2;
}(_targetJsDefault.default);
/**
 * Listen for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */ Observable1.prototype.on;
/**
 * Listen once for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */ Observable1.prototype.once;
/**
 * Unlisten for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @api
 */ Observable1.prototype.un;
function unByKey(key) {
    if (Array.isArray(key)) for(var i = 0, ii = key.length; i < ii; ++i)_eventsJs.unlistenByKey(key[i]);
    else _eventsJs.unlistenByKey(key);
}
exports.default = Observable1;

},{"./events/Target.js":"dj5zz","./events/EventType.js":"83vee","./events.js":"e9Qqr","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"e9Qqr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Key to use with {@link module:ol/Observable~Observable#unByKey}.
 * @typedef {Object} EventsKey
 * @property {ListenerFunction} listener Listener.
 * @property {import("./events/Target.js").EventTargetLike} target Target.
 * @property {string} type Type.
 * @api
 */ /**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */ /**
 * @typedef {Object} ListenerObject
 * @property {ListenerFunction} handleEvent HandleEvent listener function.
 */ /**
 * @typedef {ListenerFunction|ListenerObject} Listener
 */ /**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events.unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [opt_this] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean} [opt_once] If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */ parcelHelpers.export(exports, "listen", ()=>listen
);
/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events.unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [opt_this] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */ parcelHelpers.export(exports, "listenOnce", ()=>listenOnce
);
/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.
 *
 * @param {EventsKey} key The key.
 */ parcelHelpers.export(exports, "unlistenByKey", ()=>unlistenByKey
);
/**
 * @module ol/events
 */ var _objJs = require("./obj.js");
function listen(target, type, listener, opt_this, opt_once) {
    if (opt_this && opt_this !== target) listener = listener.bind(opt_this);
    if (opt_once) {
        var originalListener_1 = listener;
        listener = function() {
            target.removeEventListener(type, listener);
            originalListener_1.apply(this, arguments);
        };
    }
    var eventsKey = {
        target: target,
        type: type,
        listener: listener
    };
    target.addEventListener(type, listener);
    return eventsKey;
}
function listenOnce(target, type, listener, opt_this) {
    return listen(target, type, listener, opt_this, true);
}
function unlistenByKey(key) {
    if (key && key.target) {
        key.target.removeEventListener(key.type, key.listener);
        _objJs.clear(key);
    }
}

},{"./obj.js":"g3fPg","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hpoq1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    UNDEFINED: 'undefined',
    LOADING: 'loading',
    READY: 'ready',
    ERROR: 'error'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hmdWM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A projection as {@link module:ol/proj/Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */ /**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */ parcelHelpers.export(exports, "METERS_PER_UNIT", ()=>_unitsJs.METERS_PER_UNIT
);
parcelHelpers.export(exports, "Projection", ()=>_projectionJsDefault.default
);
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */ parcelHelpers.export(exports, "cloneTransform", ()=>cloneTransform
);
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension.
 * @return {Array<number>} Input coordinate array (same array as input).
 */ parcelHelpers.export(exports, "identityTransform", ()=>identityTransform
);
/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */ parcelHelpers.export(exports, "addProjection", ()=>addProjection
);
/**
 * @param {Array<Projection>} projections Projections.
 */ parcelHelpers.export(exports, "addProjections", ()=>addProjections
);
/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection} Projection object, or null if not in list.
 * @api
 */ parcelHelpers.export(exports, "get", ()=>get
);
/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {import("./proj/Units.js").default} [opt_units] Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */ parcelHelpers.export(exports, "getPointResolution", ()=>getPointResolution
);
/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */ parcelHelpers.export(exports, "addEquivalentProjections", ()=>addEquivalentProjections
);
/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */ parcelHelpers.export(exports, "addEquivalentTransforms", ()=>addEquivalentTransforms
);
/**
 * Clear all cached projections and transforms.
 */ parcelHelpers.export(exports, "clearAllProjections", ()=>clearAllProjections
);
/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */ parcelHelpers.export(exports, "createProjection", ()=>createProjection
);
/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */ parcelHelpers.export(exports, "createTransformFromCoordinateTransform", ()=>createTransformFromCoordinateTransform
);
/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @api
 */ parcelHelpers.export(exports, "addCoordinateTransforms", ()=>addCoordinateTransforms
);
/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike} [opt_projection] Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */ parcelHelpers.export(exports, "fromLonLat", ()=>fromLonLat
);
/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike} [opt_projection] Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */ parcelHelpers.export(exports, "toLonLat", ()=>toLonLat
);
/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */ parcelHelpers.export(exports, "equivalent", ()=>equivalent
);
/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */ parcelHelpers.export(exports, "getTransformFromProjections", ()=>getTransformFromProjections
);
/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */ parcelHelpers.export(exports, "getTransform", ()=>getTransform
);
/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj.transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */ parcelHelpers.export(exports, "transform", ()=>transform
);
/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @param {number} [opt_stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */ parcelHelpers.export(exports, "transformExtent", ()=>transformExtent
);
/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */ parcelHelpers.export(exports, "transformWithProjections", ()=>transformWithProjections
);
/**
 * Set the projection for coordinates supplied from and returned by API methods.
 * Note that this method is not yet a part of the stable API.  Support for user
 * projections is not yet complete and should be considered experimental.
 * @param {ProjectionLike} projection The user projection.
 */ parcelHelpers.export(exports, "setUserProjection", ()=>setUserProjection
);
/**
 * Clear the user projection if set.  Note that this method is not yet a part of
 * the stable API.  Support for user projections is not yet complete and should
 * be considered experimental.
 */ parcelHelpers.export(exports, "clearUserProjection", ()=>clearUserProjection
);
/**
 * Get the projection for coordinates supplied from and returned by API methods.
 * Note that this method is not yet a part of the stable API.  Support for user
 * projections is not yet complete and should be considered experimental.
 * @return {?Projection} The user projection (or null if not set).
 */ parcelHelpers.export(exports, "getUserProjection", ()=>getUserProjection
);
/**
 * Use geographic coordinates (WGS-84 datum) in API methods.  Note that this
 * method is not yet a part of the stable API.  Support for user projections is
 * not yet complete and should be considered experimental.
 */ parcelHelpers.export(exports, "useGeographic", ()=>useGeographic
);
/**
 * Return a coordinate transformed into the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} sourceProjection The input coordinate projection.
 * @return {Array<number>} The input coordinate in the user projection.
 */ parcelHelpers.export(exports, "toUserCoordinate", ()=>toUserCoordinate
);
/**
 * Return a coordinate transformed from the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {Array<number>} The input coordinate transformed.
 */ parcelHelpers.export(exports, "fromUserCoordinate", ()=>fromUserCoordinate
);
/**
 * Return an extent transformed into the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} sourceProjection The input extent projection.
 * @return {import("./extent.js").Extent} The input extent in the user projection.
 */ parcelHelpers.export(exports, "toUserExtent", ()=>toUserExtent
);
/**
 * Return an extent transformed from the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {import("./extent.js").Extent} The input extent transformed.
 */ parcelHelpers.export(exports, "fromUserExtent", ()=>fromUserExtent
);
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in input projection units per pixel.
 * @param {ProjectionLike} sourceProjection The input projection.
 * @return {number} Resolution in user projection units per pixel.
 */ parcelHelpers.export(exports, "toUserResolution", ()=>toUserResolution
);
/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in user projection units per pixel.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {number} Resolution in destination projection units per pixel.
 */ parcelHelpers.export(exports, "fromUserResolution", ()=>fromUserResolution
);
/**
 * Creates a safe coordinate transform function from a coordinate transform function.
 * "Safe" means that it can handle wrapping of x-coordinates for global projections,
 * and that coordinates exceeding the source projection validity extent's range will be
 * clamped to the validity range.
 * @param {Projection} sourceProj Source projection.
 * @param {Projection} destProj Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destiation).
 * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destiation).
 */ parcelHelpers.export(exports, "createSafeCoordinateTransform", ()=>createSafeCoordinateTransform
);
/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */ parcelHelpers.export(exports, "addCommon", ()=>addCommon
);
/**
 * @module ol/proj
 */ /**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection} object for the new projection and add it with
 * {@link module:ol/proj.addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj.addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection} with
 * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of
 * this.
 */ var _projectionJs = require("./proj/Projection.js");
var _projectionJsDefault = parcelHelpers.interopDefault(_projectionJs);
var _unitsJs = require("./proj/Units.js");
var _unitsJsDefault = parcelHelpers.interopDefault(_unitsJs);
var _epsg3857Js = require("./proj/epsg3857.js");
var _epsg4326Js = require("./proj/epsg4326.js");
var _projectionsJs = require("./proj/projections.js");
var _transformsJs = require("./proj/transforms.js");
var _extentJs = require("./extent.js");
var _mathJs = require("./math.js");
var _sphereJs = require("./sphere.js");
var _coordinateJs = require("./coordinate.js");
function cloneTransform(input, opt_output, opt_dimension) {
    var output;
    if (opt_output !== undefined) {
        for(var i = 0, ii = input.length; i < ii; ++i)opt_output[i] = input[i];
        output = opt_output;
    } else output = input.slice();
    return output;
}
function identityTransform(input, opt_output, opt_dimension) {
    if (opt_output !== undefined && input !== opt_output) {
        for(var i = 0, ii = input.length; i < ii; ++i)opt_output[i] = input[i];
        input = opt_output;
    }
    return input;
}
function addProjection(projection) {
    _projectionsJs.add(projection.getCode(), projection);
    _transformsJs.add(projection, projection, cloneTransform);
}
function addProjections(projections) {
    projections.forEach(addProjection);
}
function get(projectionLike) {
    return typeof projectionLike === 'string' ? _projectionsJs.get(projectionLike) : /** @type {Projection} */ projectionLike || null;
}
function getPointResolution(projection, resolution, point, opt_units) {
    projection = get(projection);
    var pointResolution;
    var getter = projection.getPointResolutionFunc();
    if (getter) {
        pointResolution = getter(resolution, point);
        if (opt_units && opt_units !== projection.getUnits()) {
            var metersPerUnit = projection.getMetersPerUnit();
            if (metersPerUnit) pointResolution = pointResolution * metersPerUnit / _unitsJs.METERS_PER_UNIT[opt_units];
        }
    } else {
        var units = projection.getUnits();
        if (units == _unitsJsDefault.default.DEGREES && !opt_units || opt_units == _unitsJsDefault.default.DEGREES) pointResolution = resolution;
        else {
            // Estimate point resolution by transforming the center pixel to EPSG:4326,
            // measuring its width and height on the normal sphere, and taking the
            // average of the width and height.
            var toEPSG4326_1 = getTransformFromProjections(projection, get('EPSG:4326'));
            if (toEPSG4326_1 === identityTransform && units !== _unitsJsDefault.default.DEGREES) // no transform is available
            pointResolution = resolution * projection.getMetersPerUnit();
            else {
                var vertices = [
                    point[0] - resolution / 2,
                    point[1],
                    point[0] + resolution / 2,
                    point[1],
                    point[0],
                    point[1] - resolution / 2,
                    point[0],
                    point[1] + resolution / 2, 
                ];
                vertices = toEPSG4326_1(vertices, vertices, 2);
                var width = _sphereJs.getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
                var height = _sphereJs.getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
                pointResolution = (width + height) / 2;
            }
            var metersPerUnit = opt_units ? _unitsJs.METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();
            if (metersPerUnit !== undefined) pointResolution /= metersPerUnit;
        }
    }
    return pointResolution;
}
function addEquivalentProjections(projections) {
    addProjections(projections);
    projections.forEach(function(source) {
        projections.forEach(function(destination) {
            if (source !== destination) _transformsJs.add(source, destination, cloneTransform);
        });
    });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
    projections1.forEach(function(projection1) {
        projections2.forEach(function(projection2) {
            _transformsJs.add(projection1, projection2, forwardTransform);
            _transformsJs.add(projection2, projection1, inverseTransform);
        });
    });
}
function clearAllProjections() {
    _projectionsJs.clear();
    _transformsJs.clear();
}
function createProjection(projection, defaultCode) {
    if (!projection) return get(defaultCode);
    else if (typeof projection === 'string') return get(projection);
    else return projection;
}
function createTransformFromCoordinateTransform(coordTransform) {
    return(/**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [opt_output] Output.
     * @param {number} [opt_dimension] Dimension.
     * @return {Array<number>} Output.
     */ function(input, opt_output, opt_dimension) {
        var length = input.length;
        var dimension = opt_dimension !== undefined ? opt_dimension : 2;
        var output = opt_output !== undefined ? opt_output : new Array(length);
        for(var i = 0; i < length; i += dimension){
            var point = coordTransform([
                input[i],
                input[i + 1]
            ]);
            output[i] = point[0];
            output[i + 1] = point[1];
            for(var j = dimension - 1; j >= 2; --j)output[i + j] = input[i + j];
        }
        return output;
    });
}
function addCoordinateTransforms(source, destination, forward, inverse) {
    var sourceProj = get(source);
    var destProj = get(destination);
    _transformsJs.add(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
    _transformsJs.add(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}
function fromLonLat(coordinate, opt_projection) {
    return transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');
}
function toLonLat(coordinate, opt_projection) {
    var lonLat = transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
    var lon = lonLat[0];
    if (lon < -180 || lon > 180) lonLat[0] = _mathJs.modulo(lon + 180, 360) - 180;
    return lonLat;
}
function equivalent(projection1, projection2) {
    if (projection1 === projection2) return true;
    var equalUnits = projection1.getUnits() === projection2.getUnits();
    if (projection1.getCode() === projection2.getCode()) return equalUnits;
    else {
        var transformFunc = getTransformFromProjections(projection1, projection2);
        return transformFunc === cloneTransform && equalUnits;
    }
}
function getTransformFromProjections(sourceProjection, destinationProjection) {
    var sourceCode = sourceProjection.getCode();
    var destinationCode = destinationProjection.getCode();
    var transformFunc = _transformsJs.get(sourceCode, destinationCode);
    if (!transformFunc) transformFunc = identityTransform;
    return transformFunc;
}
function getTransform(source, destination) {
    var sourceProjection = get(source);
    var destinationProjection = get(destination);
    return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source, destination) {
    var transformFunc = getTransform(source, destination);
    return transformFunc(coordinate, undefined, coordinate.length);
}
function transformExtent(extent, source, destination, opt_stops) {
    var transformFunc = getTransform(source, destination);
    return _extentJs.applyTransform(extent, transformFunc, undefined, opt_stops);
}
function transformWithProjections(point, sourceProjection, destinationProjection) {
    var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
    return transformFunc(point);
}
/**
 * @type {?Projection}
 */ var userProjection = null;
function setUserProjection(projection) {
    userProjection = get(projection);
}
function clearUserProjection() {
    userProjection = null;
}
function getUserProjection() {
    return userProjection;
}
function useGeographic() {
    setUserProjection('EPSG:4326');
}
function toUserCoordinate(coordinate, sourceProjection) {
    if (!userProjection) return coordinate;
    return transform(coordinate, sourceProjection, userProjection);
}
function fromUserCoordinate(coordinate, destProjection) {
    if (!userProjection) return coordinate;
    return transform(coordinate, userProjection, destProjection);
}
function toUserExtent(extent, sourceProjection) {
    if (!userProjection) return extent;
    return transformExtent(extent, sourceProjection, userProjection);
}
function fromUserExtent(extent, destProjection) {
    if (!userProjection) return extent;
    return transformExtent(extent, userProjection, destProjection);
}
function toUserResolution(resolution, sourceProjection) {
    if (!userProjection) return resolution;
    var sourceUnits = get(sourceProjection).getUnits();
    var userUnits = userProjection.getUnits();
    return sourceUnits && userUnits ? resolution * _unitsJs.METERS_PER_UNIT[sourceUnits] / _unitsJs.METERS_PER_UNIT[userUnits] : resolution;
}
function fromUserResolution(resolution, destProjection) {
    if (!userProjection) return resolution;
    var sourceUnits = get(destProjection).getUnits();
    var userUnits = userProjection.getUnits();
    return sourceUnits && userUnits ? resolution * _unitsJs.METERS_PER_UNIT[userUnits] / _unitsJs.METERS_PER_UNIT[sourceUnits] : resolution;
}
function createSafeCoordinateTransform(sourceProj, destProj, transform1) {
    return function(coord) {
        var sourceX = coord[0];
        var sourceY = coord[1];
        var transformed, worldsAway;
        if (sourceProj.canWrapX()) {
            var sourceExtent = sourceProj.getExtent();
            var sourceExtentWidth = _extentJs.getWidth(sourceExtent);
            worldsAway = _coordinateJs.getWorldsAway(coord, sourceProj, sourceExtentWidth);
            if (worldsAway) // Move x to the real world
            sourceX = sourceX - worldsAway * sourceExtentWidth;
            sourceX = _mathJs.clamp(sourceX, sourceExtent[0], sourceExtent[2]);
            sourceY = _mathJs.clamp(sourceY, sourceExtent[1], sourceExtent[3]);
            transformed = transform1([
                sourceX,
                sourceY
            ]);
        } else transformed = transform1(coord);
        if (worldsAway && destProj.canWrapX()) // Move transformed coordinate back to the offset world
        transformed[0] += worldsAway * _extentJs.getWidth(destProj.getExtent());
        return transformed;
    };
}
function addCommon() {
    // Add transformations that don't alter coordinates to convert within set of
    // projections with equal meaning.
    addEquivalentProjections(_epsg3857Js.PROJECTIONS);
    addEquivalentProjections(_epsg4326Js.PROJECTIONS);
    // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
    // coordinates and back.
    addEquivalentTransforms(_epsg4326Js.PROJECTIONS, _epsg3857Js.PROJECTIONS, _epsg3857Js.fromEPSG4326, _epsg3857Js.toEPSG4326);
}
addCommon();

},{"./proj/Projection.js":"5zsPV","./proj/Units.js":"g2gaW","./proj/epsg3857.js":"a5Gu6","./proj/epsg4326.js":"2UwXv","./proj/projections.js":"vDmCg","./proj/transforms.js":"fagQi","./extent.js":"jgUz2","./math.js":"kI4rE","./sphere.js":"d26nZ","./coordinate.js":"cmApa","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5zsPV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/proj/Projection
 */ var _unitsJs = require("./Units.js");
/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").default|string} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `number` view resolution and a {@link module:ol/coordinate~Coordinate Coordinate} as arguments, and returns
 * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj.getPointResolution getPointResolution()} function will be used.
 */ /**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4.register} function.
 *
 * @api
 */ var Projection = function() {
    /**
     * @param {Options} options Projection options.
     */ function Projection1(options) {
        /**
         * @private
         * @type {string}
         */ this.code_ = options.code;
        /**
         * Units of projected coordinates. When set to `TILE_PIXELS`, a
         * `this.extent_` and `this.worldExtent_` must be configured properly for each
         * tile.
         * @private
         * @type {import("./Units.js").default}
         */ this.units_ = options.units;
        /**
         * Validity extent of the projection in projected coordinates. For projections
         * with `TILE_PIXELS` units, this is the extent of the tile in
         * tile pixel space.
         * @private
         * @type {import("../extent.js").Extent}
         */ this.extent_ = options.extent !== undefined ? options.extent : null;
        /**
         * Extent of the world in EPSG:4326. For projections with
         * `TILE_PIXELS` units, this is the extent of the tile in
         * projected coordinate space.
         * @private
         * @type {import("../extent.js").Extent}
         */ this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;
        /**
         * @private
         * @type {string}
         */ this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
        /**
         * @private
         * @type {boolean}
         */ this.global_ = options.global !== undefined ? options.global : false;
        /**
         * @private
         * @type {boolean}
         */ this.canWrapX_ = !!(this.global_ && this.extent_);
        /**
         * @private
         * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
         */ this.getPointResolutionFunc_ = options.getPointResolution;
        /**
         * @private
         * @type {import("../tilegrid/TileGrid.js").default}
         */ this.defaultTileGrid_ = null;
        /**
         * @private
         * @type {number|undefined}
         */ this.metersPerUnit_ = options.metersPerUnit;
    }
    /**
     * @return {boolean} The projection is suitable for wrapping the x-axis
     */ Projection1.prototype.canWrapX = function() {
        return this.canWrapX_;
    };
    /**
     * Get the code for this projection, e.g. 'EPSG:4326'.
     * @return {string} Code.
     * @api
     */ Projection1.prototype.getCode = function() {
        return this.code_;
    };
    /**
     * Get the validity extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */ Projection1.prototype.getExtent = function() {
        return this.extent_;
    };
    /**
     * Get the units of this projection.
     * @return {import("./Units.js").default} Units.
     * @api
     */ Projection1.prototype.getUnits = function() {
        return this.units_;
    };
    /**
     * Get the amount of meters per unit of this projection.  If the projection is
     * not configured with `metersPerUnit` or a units identifier, the return is
     * `undefined`.
     * @return {number|undefined} Meters.
     * @api
     */ Projection1.prototype.getMetersPerUnit = function() {
        return this.metersPerUnit_ || _unitsJs.METERS_PER_UNIT[this.units_];
    };
    /**
     * Get the world extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */ Projection1.prototype.getWorldExtent = function() {
        return this.worldExtent_;
    };
    /**
     * Get the axis orientation of this projection.
     * Example values are:
     * enu - the default easting, northing, elevation.
     * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
     *     or south orientated transverse mercator.
     * wnu - westing, northing, up - some planetary coordinate systems have
     *     "west positive" coordinate systems
     * @return {string} Axis orientation.
     * @api
     */ Projection1.prototype.getAxisOrientation = function() {
        return this.axisOrientation_;
    };
    /**
     * Is this projection a global projection which spans the whole world?
     * @return {boolean} Whether the projection is global.
     * @api
     */ Projection1.prototype.isGlobal = function() {
        return this.global_;
    };
    /**
     * Set if the projection is a global projection which spans the whole world
     * @param {boolean} global Whether the projection is global.
     * @api
     */ Projection1.prototype.setGlobal = function(global) {
        this.global_ = global;
        this.canWrapX_ = !!(global && this.extent_);
    };
    /**
     * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
     */ Projection1.prototype.getDefaultTileGrid = function() {
        return this.defaultTileGrid_;
    };
    /**
     * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
     */ Projection1.prototype.setDefaultTileGrid = function(tileGrid) {
        this.defaultTileGrid_ = tileGrid;
    };
    /**
     * Set the validity extent for this projection.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */ Projection1.prototype.setExtent = function(extent) {
        this.extent_ = extent;
        this.canWrapX_ = !!(this.global_ && extent);
    };
    /**
     * Set the world extent for this projection.
     * @param {import("../extent.js").Extent} worldExtent World extent
     *     [minlon, minlat, maxlon, maxlat].
     * @api
     */ Projection1.prototype.setWorldExtent = function(worldExtent) {
        this.worldExtent_ = worldExtent;
    };
    /**
     * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
     * for this projection.
     * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
     * @api
     */ Projection1.prototype.setGetPointResolution = function(func) {
        this.getPointResolutionFunc_ = func;
    };
    /**
     * Get the custom point resolution function for this projection (if set).
     * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
     * resolution function (if set).
     */ Projection1.prototype.getPointResolutionFunc = function() {
        return this.getPointResolutionFunc_;
    };
    return Projection1;
}();
exports.default = Projection;

},{"./Units.js":"g2gaW","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"g2gaW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {number} code Unit code.
 * @return {Units} Units.
 */ parcelHelpers.export(exports, "fromCode", ()=>fromCode
);
parcelHelpers.export(exports, "METERS_PER_UNIT", ()=>METERS_PER_UNIT
);
/**
 * @module ol/proj/Units
 */ /**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */ var Units = {
    /**
     * Radians
     * @api
     */ RADIANS: 'radians',
    /**
     * Degrees
     * @api
     */ DEGREES: 'degrees',
    /**
     * Feet
     * @api
     */ FEET: 'ft',
    /**
     * Meters
     * @api
     */ METERS: 'm',
    /**
     * Pixels
     * @api
     */ PIXELS: 'pixels',
    /**
     * Tile Pixels
     * @api
     */ TILE_PIXELS: 'tile-pixels',
    /**
     * US Feet
     * @api
     */ USFEET: 'us-ft'
};
/**
 * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt
 * @type {Object<number, Units>}
 */ var unitByCode = {
    '9001': Units.METERS,
    '9002': Units.FEET,
    '9003': Units.USFEET,
    '9101': Units.RADIANS,
    '9102': Units.DEGREES
};
function fromCode(code) {
    return unitByCode[code];
}
var METERS_PER_UNIT = {
};
// use the radius of the Normal sphere
METERS_PER_UNIT[Units.RADIANS] = 6370997 / (2 * Math.PI);
METERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
METERS_PER_UNIT[Units.FEET] = 0.3048;
METERS_PER_UNIT[Units.METERS] = 1;
METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;
exports.default = Units;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"a5Gu6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RADIUS", ()=>RADIUS
);
parcelHelpers.export(exports, "HALF_SIZE", ()=>HALF_SIZE
);
parcelHelpers.export(exports, "EXTENT", ()=>EXTENT
);
parcelHelpers.export(exports, "WORLD_EXTENT", ()=>WORLD_EXTENT
);
parcelHelpers.export(exports, "MAX_SAFE_Y", ()=>MAX_SAFE_Y
);
parcelHelpers.export(exports, "PROJECTIONS", ()=>PROJECTIONS
);
/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */ parcelHelpers.export(exports, "fromEPSG4326", ()=>fromEPSG4326
);
/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [opt_output] Output array of coordinate values.
 * @param {number} [opt_dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */ parcelHelpers.export(exports, "toEPSG4326", ()=>toEPSG4326
);
/**
 * @module ol/proj/epsg3857
 */ var _projectionJs = require("./Projection.js");
var _projectionJsDefault = parcelHelpers.interopDefault(_projectionJs);
var _unitsJs = require("./Units.js");
var _unitsJsDefault = parcelHelpers.interopDefault(_unitsJs);
var _mathJs = require("../math.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var RADIUS = 6378137;
var HALF_SIZE = Math.PI * RADIUS;
var EXTENT = [
    -HALF_SIZE,
    -HALF_SIZE,
    HALF_SIZE,
    HALF_SIZE
];
var WORLD_EXTENT = [
    -180,
    -85,
    180,
    85
];
var MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */ var EPSG3857Projection1 = function(_super) {
    __extends(EPSG3857Projection2, _super);
    /**
     * @param {string} code Code.
     */ function EPSG3857Projection2(code) {
        return _super.call(this, {
            code: code,
            units: _unitsJsDefault.default.METERS,
            extent: EXTENT,
            global: true,
            worldExtent: WORLD_EXTENT,
            getPointResolution: function(resolution, point) {
                return resolution / _mathJs.cosh(point[1] / RADIUS);
            }
        }) || this;
    }
    return EPSG3857Projection2;
}(_projectionJsDefault.default);
var PROJECTIONS = [
    new EPSG3857Projection1('EPSG:3857'),
    new EPSG3857Projection1('EPSG:102100'),
    new EPSG3857Projection1('EPSG:102113'),
    new EPSG3857Projection1('EPSG:900913'),
    new EPSG3857Projection1('http://www.opengis.net/def/crs/EPSG/0/3857'),
    new EPSG3857Projection1('http://www.opengis.net/gml/srs/epsg.xml#3857'), 
];
function fromEPSG4326(input, opt_output, opt_dimension) {
    var length = input.length;
    var dimension = opt_dimension > 1 ? opt_dimension : 2;
    var output = opt_output;
    if (output === undefined) {
        if (dimension > 2) // preserve values beyond second dimension
        output = input.slice();
        else output = new Array(length);
    }
    for(var i = 0; i < length; i += dimension){
        output[i] = HALF_SIZE * input[i] / 180;
        var y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
        if (y > MAX_SAFE_Y) y = MAX_SAFE_Y;
        else if (y < -MAX_SAFE_Y) y = -MAX_SAFE_Y;
        output[i + 1] = y;
    }
    return output;
}
function toEPSG4326(input, opt_output, opt_dimension) {
    var length = input.length;
    var dimension = opt_dimension > 1 ? opt_dimension : 2;
    var output = opt_output;
    if (output === undefined) {
        if (dimension > 2) // preserve values beyond second dimension
        output = input.slice();
        else output = new Array(length);
    }
    for(var i = 0; i < length; i += dimension){
        output[i] = 180 * input[i] / HALF_SIZE;
        output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
    }
    return output;
}

},{"./Projection.js":"5zsPV","./Units.js":"g2gaW","../math.js":"kI4rE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kI4rE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/math
 */ /**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */ parcelHelpers.export(exports, "clamp", ()=>clamp
);
parcelHelpers.export(exports, "cosh", ()=>cosh
);
parcelHelpers.export(exports, "log2", ()=>log2
);
/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */ parcelHelpers.export(exports, "squaredSegmentDistance", ()=>squaredSegmentDistance
);
/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance
);
/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>} The resulting vector.
 */ parcelHelpers.export(exports, "solveLinearSystem", ()=>solveLinearSystem
);
/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */ parcelHelpers.export(exports, "toDegrees", ()=>toDegrees
);
/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */ parcelHelpers.export(exports, "toRadians", ()=>toRadians
);
/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */ parcelHelpers.export(exports, "modulo", ()=>modulo
);
/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */ parcelHelpers.export(exports, "lerp", ()=>lerp
);
function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
}
var cosh = function() {
    // Wrapped in a iife, to save the overhead of checking for the native
    // implementation on every invocation.
    var cosh1;
    if ('cosh' in Math) // The environment supports the native Math.cosh function, use itâ€¦
    cosh1 = Math.cosh;
    else // â€¦ else, use the reference implementation of MDN:
    cosh1 = function(x) {
        var y = /** @type {Math} */ Math.exp(x);
        return (y + 1 / y) / 2;
    };
    return cosh1;
}();
var log2 = function() {
    // Wrapped in a iife, to save the overhead of checking for the native
    // implementation on every invocation.
    var log21;
    if ('log2' in Math) // The environment supports the native Math.log2 function, use itâ€¦
    log21 = Math.log2;
    else // â€¦ else, use the reference implementation of MDN:
    log21 = function(x) {
        return Math.log(x) * Math.LOG2E;
    };
    return log21;
}();
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    if (dx !== 0 || dy !== 0) {
        var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
            x1 = x2;
            y1 = y2;
        } else if (t > 0) {
            x1 += dx * t;
            y1 += dy * t;
        }
    }
    return squaredDistance(x, y, x1, y1);
}
function squaredDistance(x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
    var n = mat.length;
    for(var i = 0; i < n; i++){
        // Find max in the i-th column (ignoring i - 1 first rows)
        var maxRow = i;
        var maxEl = Math.abs(mat[i][i]);
        for(var r = i + 1; r < n; r++){
            var absValue = Math.abs(mat[r][i]);
            if (absValue > maxEl) {
                maxEl = absValue;
                maxRow = r;
            }
        }
        if (maxEl === 0) return null; // matrix is singular
        // Swap max row with i-th (current) row
        var tmp = mat[maxRow];
        mat[maxRow] = mat[i];
        mat[i] = tmp;
        // Subtract the i-th row to make all the remaining rows 0 in the i-th column
        for(var j = i + 1; j < n; j++){
            var coef = -mat[j][i] / mat[i][i];
            for(var k = i; k < n + 1; k++)if (i == k) mat[j][k] = 0;
            else mat[j][k] += coef * mat[i][k];
        }
    }
    // Solve Ax=b for upper triangular matrix A (mat)
    var x = new Array(n);
    for(var l = n - 1; l >= 0; l--){
        x[l] = mat[l][n] / mat[l][l];
        for(var m = l - 1; m >= 0; m--)mat[m][n] -= mat[m][l] * x[l];
    }
    return x;
}
function toDegrees(angleInRadians) {
    return angleInRadians * 180 / Math.PI;
}
function toRadians(angleInDegrees) {
    return angleInDegrees * Math.PI / 180;
}
function modulo(a, b) {
    var r = a % b;
    return r * b < 0 ? r + b : r;
}
function lerp(a, b, x) {
    return a + x * (b - a);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"2UwXv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RADIUS", ()=>RADIUS
);
parcelHelpers.export(exports, "EXTENT", ()=>EXTENT
);
parcelHelpers.export(exports, "METERS_PER_UNIT", ()=>METERS_PER_UNIT
);
parcelHelpers.export(exports, "PROJECTIONS", ()=>PROJECTIONS
);
/**
 * @module ol/proj/epsg4326
 */ var _projectionJs = require("./Projection.js");
var _projectionJsDefault = parcelHelpers.interopDefault(_projectionJs);
var _unitsJs = require("./Units.js");
var _unitsJsDefault = parcelHelpers.interopDefault(_unitsJs);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var RADIUS = 6378137;
var EXTENT = [
    -180,
    -90,
    180,
    90
];
var METERS_PER_UNIT = Math.PI * RADIUS / 180;
/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */ var EPSG4326Projection1 = function(_super) {
    __extends(EPSG4326Projection2, _super);
    /**
     * @param {string} code Code.
     * @param {string} [opt_axisOrientation] Axis orientation.
     */ function EPSG4326Projection2(code, opt_axisOrientation) {
        return _super.call(this, {
            code: code,
            units: _unitsJsDefault.default.DEGREES,
            extent: EXTENT,
            axisOrientation: opt_axisOrientation,
            global: true,
            metersPerUnit: METERS_PER_UNIT,
            worldExtent: EXTENT
        }) || this;
    }
    return EPSG4326Projection2;
}(_projectionJsDefault.default);
var PROJECTIONS = [
    new EPSG4326Projection1('CRS:84'),
    new EPSG4326Projection1('EPSG:4326', 'neu'),
    new EPSG4326Projection1('urn:ogc:def:crs:OGC:1.3:CRS84'),
    new EPSG4326Projection1('urn:ogc:def:crs:OGC:2:84'),
    new EPSG4326Projection1('http://www.opengis.net/def/crs/OGC/1.3/CRS84', 'neu'),
    new EPSG4326Projection1('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
    new EPSG4326Projection1('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'), 
];

},{"./Projection.js":"5zsPV","./Units.js":"g2gaW","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"vDmCg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Clear the projections cache.
 */ parcelHelpers.export(exports, "clear", ()=>clear
);
/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */ parcelHelpers.export(exports, "get", ()=>get
);
/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * @module ol/proj/projections
 */ /**
 * @type {Object<string, import("./Projection.js").default>}
 */ var cache = {
};
function clear() {
    cache = {
    };
}
function get(code) {
    return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] || null;
}
function add(code, projection) {
    cache[code] = projection;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"fagQi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Clear the transform cache.
 */ parcelHelpers.export(exports, "clear", ()=>clear
);
/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */ parcelHelpers.export(exports, "remove", ()=>remove
);
/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */ parcelHelpers.export(exports, "get", ()=>get
);
/**
 * @module ol/proj/transforms
 */ var _objJs = require("../obj.js");
/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */ var transforms = {
};
function clear() {
    transforms = {
    };
}
function add(source, destination, transformFn) {
    var sourceCode = source.getCode();
    var destinationCode = destination.getCode();
    if (!(sourceCode in transforms)) transforms[sourceCode] = {
    };
    transforms[sourceCode][destinationCode] = transformFn;
}
function remove(source, destination) {
    var sourceCode = source.getCode();
    var destinationCode = destination.getCode();
    var transform = transforms[sourceCode][destinationCode];
    delete transforms[sourceCode][destinationCode];
    if (_objJs.isEmpty(transforms[sourceCode])) delete transforms[sourceCode];
    return transform;
}
function get(sourceCode, destinationCode) {
    var transform;
    if (sourceCode in transforms && destinationCode in transforms[sourceCode]) transform = transforms[sourceCode][destinationCode];
    return transform;
}

},{"../obj.js":"g3fPg","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jgUz2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */ /**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */ parcelHelpers.export(exports, "boundingExtent", ()=>boundingExtent
);
/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 * @api
 */ parcelHelpers.export(exports, "buffer", ()=>buffer
);
/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} The clone.
 */ parcelHelpers.export(exports, "clone", ()=>clone
);
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */ parcelHelpers.export(exports, "closestSquaredDistanceXY", ()=>closestSquaredDistanceXY
);
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */ parcelHelpers.export(exports, "containsCoordinate", ()=>containsCoordinate
);
/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */ parcelHelpers.export(exports, "containsExtent", ()=>containsExtent
);
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */ parcelHelpers.export(exports, "containsXY", ()=>containsXY
);
/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */ parcelHelpers.export(exports, "coordinateRelationship", ()=>coordinateRelationship
);
/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */ parcelHelpers.export(exports, "createEmpty", ()=>createEmpty
);
/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent} [opt_extent] Destination extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdate", ()=>createOrUpdate
);
/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateEmpty", ()=>createOrUpdateEmpty
);
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromCoordinate", ()=>createOrUpdateFromCoordinate
);
/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromCoordinates", ()=>createOrUpdateFromCoordinates
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromFlatCoordinates", ()=>createOrUpdateFromFlatCoordinates
);
/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "createOrUpdateFromRings", ()=>createOrUpdateFromRings
);
/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
/**
 * Determine if two extents are approximately equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {number} tolerance Tolerance in extent coordinate units.
 * @return {boolean} The two extents differ by less than the tolerance.
 */ parcelHelpers.export(exports, "approximatelyEquals", ()=>approximatelyEquals
);
/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */ parcelHelpers.export(exports, "extend", ()=>extend
);
/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */ parcelHelpers.export(exports, "extendCoordinate", ()=>extendCoordinate
);
/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "extendCoordinates", ()=>extendCoordinates
);
/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "extendFlatCoordinates", ()=>extendFlatCoordinates
);
/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "extendRings", ()=>extendRings
);
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */ parcelHelpers.export(exports, "extendXY", ()=>extendXY
);
/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
 * @return {S|boolean} Value.
 * @template S
 */ parcelHelpers.export(exports, "forEachCorner", ()=>forEachCorner
);
/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */ parcelHelpers.export(exports, "getArea", ()=>getArea
);
/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */ parcelHelpers.export(exports, "getBottomLeft", ()=>getBottomLeft
);
/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */ parcelHelpers.export(exports, "getBottomRight", ()=>getBottomRight
);
/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */ parcelHelpers.export(exports, "getCenter", ()=>getCenter
);
/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {import("./extent/Corner.js").default} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */ parcelHelpers.export(exports, "getCorner", ()=>getCorner
);
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */ parcelHelpers.export(exports, "getEnlargedArea", ()=>getEnlargedArea
);
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent} [opt_extent] Destination extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "getForViewAndSize", ()=>getForViewAndSize
);
/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */ parcelHelpers.export(exports, "getHeight", ()=>getHeight
);
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */ parcelHelpers.export(exports, "getIntersectionArea", ()=>getIntersectionArea
);
/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent} [opt_extent] Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */ parcelHelpers.export(exports, "getIntersection", ()=>getIntersection
);
/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */ parcelHelpers.export(exports, "getMargin", ()=>getMargin
);
/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */ parcelHelpers.export(exports, "getSize", ()=>getSize
);
/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */ parcelHelpers.export(exports, "getTopLeft", ()=>getTopLeft
);
/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */ parcelHelpers.export(exports, "getTopRight", ()=>getTopRight
);
/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */ parcelHelpers.export(exports, "getWidth", ()=>getWidth
);
/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */ parcelHelpers.export(exports, "intersects", ()=>intersects
);
/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */ parcelHelpers.export(exports, "isEmpty", ()=>isEmpty
);
/**
 * @param {Extent} extent Extent.
 * @param {Extent} [opt_extent] Extent.
 * @return {Extent} Extent.
 */ parcelHelpers.export(exports, "returnOrUpdate", ()=>returnOrUpdate
);
/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */ parcelHelpers.export(exports, "scaleFromCenter", ()=>scaleFromCenter
);
/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */ parcelHelpers.export(exports, "intersectsSegment", ()=>intersectsSegment
);
/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent} [opt_extent] Destination extent.
 * @param {number} [opt_stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {Extent} Extent.
 * @api
 */ parcelHelpers.export(exports, "applyTransform", ()=>applyTransform
);
/**
 * Modifies the provided extent in-place to be within the real world
 * extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Extent} The extent within the real world extent.
 */ parcelHelpers.export(exports, "wrapX", ()=>wrapX
);
/**
 * @module ol/extent
 */ var _cornerJs = require("./extent/Corner.js");
var _cornerJsDefault = parcelHelpers.interopDefault(_cornerJs);
var _relationshipJs = require("./extent/Relationship.js");
var _relationshipJsDefault = parcelHelpers.interopDefault(_relationshipJs);
var _assertsJs = require("./asserts.js");
function boundingExtent(coordinates) {
    var extent = createEmpty();
    for(var i = 0, ii = coordinates.length; i < ii; ++i)extendCoordinate(extent, coordinates[i]);
    return extent;
}
/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent} [opt_extent] Destination extent.
 * @private
 * @return {Extent} Extent.
 */ function _boundingExtentXYs(xs, ys, opt_extent) {
    var minX = Math.min.apply(null, xs);
    var minY = Math.min.apply(null, ys);
    var maxX = Math.max.apply(null, xs);
    var maxY = Math.max.apply(null, ys);
    return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
}
function buffer(extent, value, opt_extent) {
    if (opt_extent) {
        opt_extent[0] = extent[0] - value;
        opt_extent[1] = extent[1] - value;
        opt_extent[2] = extent[2] + value;
        opt_extent[3] = extent[3] + value;
        return opt_extent;
    } else return [
        extent[0] - value,
        extent[1] - value,
        extent[2] + value,
        extent[3] + value, 
    ];
}
function clone(extent, opt_extent) {
    if (opt_extent) {
        opt_extent[0] = extent[0];
        opt_extent[1] = extent[1];
        opt_extent[2] = extent[2];
        opt_extent[3] = extent[3];
        return opt_extent;
    } else return extent.slice();
}
function closestSquaredDistanceXY(extent, x, y) {
    var dx, dy;
    if (x < extent[0]) dx = extent[0] - x;
    else if (extent[2] < x) dx = x - extent[2];
    else dx = 0;
    if (y < extent[1]) dy = extent[1] - y;
    else if (extent[3] < y) dy = y - extent[3];
    else dy = 0;
    return dx * dx + dy * dy;
}
function containsCoordinate(extent, coordinate) {
    return containsXY(extent, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
    return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent, x, y) {
    return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var x = coordinate[0];
    var y = coordinate[1];
    var relationship = _relationshipJsDefault.default.UNKNOWN;
    if (x < minX) relationship = relationship | _relationshipJsDefault.default.LEFT;
    else if (x > maxX) relationship = relationship | _relationshipJsDefault.default.RIGHT;
    if (y < minY) relationship = relationship | _relationshipJsDefault.default.BELOW;
    else if (y > maxY) relationship = relationship | _relationshipJsDefault.default.ABOVE;
    if (relationship === _relationshipJsDefault.default.UNKNOWN) relationship = _relationshipJsDefault.default.INTERSECTING;
    return relationship;
}
function createEmpty() {
    return [
        Infinity,
        Infinity, -Infinity, -Infinity];
}
function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
    if (opt_extent) {
        opt_extent[0] = minX;
        opt_extent[1] = minY;
        opt_extent[2] = maxX;
        opt_extent[3] = maxY;
        return opt_extent;
    } else return [
        minX,
        minY,
        maxX,
        maxY
    ];
}
function createOrUpdateEmpty(opt_extent) {
    return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
}
function createOrUpdateFromCoordinate(coordinate, opt_extent) {
    var x = coordinate[0];
    var y = coordinate[1];
    return createOrUpdate(x, y, x, y, opt_extent);
}
function createOrUpdateFromCoordinates(coordinates, opt_extent) {
    var extent = createOrUpdateEmpty(opt_extent);
    return extendCoordinates(extent, coordinates);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
    var extent = createOrUpdateEmpty(opt_extent);
    return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
function createOrUpdateFromRings(rings, opt_extent) {
    var extent = createOrUpdateEmpty(opt_extent);
    return extendRings(extent, rings);
}
function equals(extent1, extent2) {
    return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function approximatelyEquals(extent1, extent2, tolerance) {
    return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
}
function extend(extent1, extent2) {
    if (extent2[0] < extent1[0]) extent1[0] = extent2[0];
    if (extent2[2] > extent1[2]) extent1[2] = extent2[2];
    if (extent2[1] < extent1[1]) extent1[1] = extent2[1];
    if (extent2[3] > extent1[3]) extent1[3] = extent2[3];
    return extent1;
}
function extendCoordinate(extent, coordinate) {
    if (coordinate[0] < extent[0]) extent[0] = coordinate[0];
    if (coordinate[0] > extent[2]) extent[2] = coordinate[0];
    if (coordinate[1] < extent[1]) extent[1] = coordinate[1];
    if (coordinate[1] > extent[3]) extent[3] = coordinate[1];
}
function extendCoordinates(extent, coordinates) {
    for(var i = 0, ii = coordinates.length; i < ii; ++i)extendCoordinate(extent, coordinates[i]);
    return extent;
}
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
    for(; offset < end; offset += stride)extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
    return extent;
}
function extendRings(extent, rings) {
    for(var i = 0, ii = rings.length; i < ii; ++i)extendCoordinates(extent, rings[i]);
    return extent;
}
function extendXY(extent, x, y) {
    extent[0] = Math.min(extent[0], x);
    extent[1] = Math.min(extent[1], y);
    extent[2] = Math.max(extent[2], x);
    extent[3] = Math.max(extent[3], y);
}
function forEachCorner(extent, callback) {
    var val;
    val = callback(getBottomLeft(extent));
    if (val) return val;
    val = callback(getBottomRight(extent));
    if (val) return val;
    val = callback(getTopRight(extent));
    if (val) return val;
    val = callback(getTopLeft(extent));
    if (val) return val;
    return false;
}
function getArea(extent) {
    var area = 0;
    if (!isEmpty(extent)) area = getWidth(extent) * getHeight(extent);
    return area;
}
function getBottomLeft(extent) {
    return [
        extent[0],
        extent[1]
    ];
}
function getBottomRight(extent) {
    return [
        extent[2],
        extent[1]
    ];
}
function getCenter(extent) {
    return [
        (extent[0] + extent[2]) / 2,
        (extent[1] + extent[3]) / 2
    ];
}
function getCorner(extent, corner) {
    var coordinate;
    if (corner === _cornerJsDefault.default.BOTTOM_LEFT) coordinate = getBottomLeft(extent);
    else if (corner === _cornerJsDefault.default.BOTTOM_RIGHT) coordinate = getBottomRight(extent);
    else if (corner === _cornerJsDefault.default.TOP_LEFT) coordinate = getTopLeft(extent);
    else if (corner === _cornerJsDefault.default.TOP_RIGHT) coordinate = getTopRight(extent);
    else _assertsJs.assert(false, 13); // Invalid corner
    return coordinate;
}
function getEnlargedArea(extent1, extent2) {
    var minX = Math.min(extent1[0], extent2[0]);
    var minY = Math.min(extent1[1], extent2[1]);
    var maxX = Math.max(extent1[2], extent2[2]);
    var maxY = Math.max(extent1[3], extent2[3]);
    return (maxX - minX) * (maxY - minY);
}
function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
    var dx = resolution * size[0] / 2;
    var dy = resolution * size[1] / 2;
    var cosRotation = Math.cos(rotation);
    var sinRotation = Math.sin(rotation);
    var xCos = dx * cosRotation;
    var xSin = dx * sinRotation;
    var yCos = dy * cosRotation;
    var ySin = dy * sinRotation;
    var x = center[0];
    var y = center[1];
    var x0 = x - xCos + ySin;
    var x1 = x - xCos - ySin;
    var x2 = x + xCos - ySin;
    var x3 = x + xCos + ySin;
    var y0 = y - xSin - yCos;
    var y1 = y - xSin + yCos;
    var y2 = y + xSin + yCos;
    var y3 = y + xSin - yCos;
    return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
}
function getHeight(extent) {
    return extent[3] - extent[1];
}
function getIntersectionArea(extent1, extent2) {
    var intersection = getIntersection(extent1, extent2);
    return getArea(intersection);
}
function getIntersection(extent1, extent2, opt_extent) {
    var intersection = opt_extent ? opt_extent : createEmpty();
    if (intersects(extent1, extent2)) {
        if (extent1[0] > extent2[0]) intersection[0] = extent1[0];
        else intersection[0] = extent2[0];
        if (extent1[1] > extent2[1]) intersection[1] = extent1[1];
        else intersection[1] = extent2[1];
        if (extent1[2] < extent2[2]) intersection[2] = extent1[2];
        else intersection[2] = extent2[2];
        if (extent1[3] < extent2[3]) intersection[3] = extent1[3];
        else intersection[3] = extent2[3];
    } else createOrUpdateEmpty(intersection);
    return intersection;
}
function getMargin(extent) {
    return getWidth(extent) + getHeight(extent);
}
function getSize(extent) {
    return [
        extent[2] - extent[0],
        extent[3] - extent[1]
    ];
}
function getTopLeft(extent) {
    return [
        extent[0],
        extent[3]
    ];
}
function getTopRight(extent) {
    return [
        extent[2],
        extent[3]
    ];
}
function getWidth(extent) {
    return extent[2] - extent[0];
}
function intersects(extent1, extent2) {
    return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty(extent) {
    return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, opt_extent) {
    if (opt_extent) {
        opt_extent[0] = extent[0];
        opt_extent[1] = extent[1];
        opt_extent[2] = extent[2];
        opt_extent[3] = extent[3];
        return opt_extent;
    } else return extent;
}
function scaleFromCenter(extent, value) {
    var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
    var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
    extent[0] -= deltaX;
    extent[2] += deltaX;
    extent[1] -= deltaY;
    extent[3] += deltaY;
}
function intersectsSegment(extent, start, end) {
    var intersects1 = false;
    var startRel = coordinateRelationship(extent, start);
    var endRel = coordinateRelationship(extent, end);
    if (startRel === _relationshipJsDefault.default.INTERSECTING || endRel === _relationshipJsDefault.default.INTERSECTING) intersects1 = true;
    else {
        var minX = extent[0];
        var minY = extent[1];
        var maxX = extent[2];
        var maxY = extent[3];
        var startX = start[0];
        var startY = start[1];
        var endX = end[0];
        var endY = end[1];
        var slope = (endY - startY) / (endX - startX);
        var x = void 0, y = void 0;
        if (!!(endRel & _relationshipJsDefault.default.ABOVE) && !(startRel & _relationshipJsDefault.default.ABOVE)) {
            // potentially intersects top
            x = endX - (endY - maxY) / slope;
            intersects1 = x >= minX && x <= maxX;
        }
        if (!intersects1 && !!(endRel & _relationshipJsDefault.default.RIGHT) && !(startRel & _relationshipJsDefault.default.RIGHT)) {
            // potentially intersects right
            y = endY - (endX - maxX) * slope;
            intersects1 = y >= minY && y <= maxY;
        }
        if (!intersects1 && !!(endRel & _relationshipJsDefault.default.BELOW) && !(startRel & _relationshipJsDefault.default.BELOW)) {
            // potentially intersects bottom
            x = endX - (endY - minY) / slope;
            intersects1 = x >= minX && x <= maxX;
        }
        if (!intersects1 && !!(endRel & _relationshipJsDefault.default.LEFT) && !(startRel & _relationshipJsDefault.default.LEFT)) {
            // potentially intersects left
            y = endY - (endX - minX) * slope;
            intersects1 = y >= minY && y <= maxY;
        }
    }
    return intersects1;
}
function applyTransform(extent, transformFn, opt_extent, opt_stops) {
    var coordinates = [];
    if (opt_stops > 1) {
        var width = extent[2] - extent[0];
        var height = extent[3] - extent[1];
        for(var i = 0; i < opt_stops; ++i)coordinates.push(extent[0] + width * i / opt_stops, extent[1], extent[2], extent[1] + height * i / opt_stops, extent[2] - width * i / opt_stops, extent[3], extent[0], extent[3] - height * i / opt_stops);
    } else coordinates = [
        extent[0],
        extent[1],
        extent[2],
        extent[1],
        extent[2],
        extent[3],
        extent[0],
        extent[3], 
    ];
    transformFn(coordinates, coordinates, 2);
    var xs = [];
    var ys = [];
    for(var i = 0, l = coordinates.length; i < l; i += 2){
        xs.push(coordinates[i]);
        ys.push(coordinates[i + 1]);
    }
    return _boundingExtentXYs(xs, ys, opt_extent);
}
function wrapX(extent, projection) {
    var projectionExtent = projection.getExtent();
    var center = getCenter(extent);
    if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
        var worldWidth = getWidth(projectionExtent);
        var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
        var offset = worldsAway * worldWidth;
        extent[0] -= offset;
        extent[2] -= offset;
    }
    return extent;
}

},{"./extent/Corner.js":"j9uRQ","./extent/Relationship.js":"6qC6Y","./asserts.js":"cnrP4","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"j9uRQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    BOTTOM_LEFT: 'bottom-left',
    BOTTOM_RIGHT: 'bottom-right',
    TOP_LEFT: 'top-left',
    TOP_RIGHT: 'top-right'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6qC6Y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    UNKNOWN: 0,
    INTERSECTING: 1,
    ABOVE: 2,
    RIGHT: 4,
    BELOW: 8,
    LEFT: 16
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cnrP4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */ parcelHelpers.export(exports, "assert", ()=>assert
);
/**
 * @module ol/asserts
 */ var _assertionErrorJs = require("./AssertionError.js");
var _assertionErrorJsDefault = parcelHelpers.interopDefault(_assertionErrorJs);
function assert(assertion, errorCode) {
    if (!assertion) throw new _assertionErrorJsDefault.default(errorCode);
}

},{"./AssertionError.js":"6D6Dt","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6D6Dt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/AssertionError
 */ var _utilJs = require("./util.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
 */ var AssertionError1 = function(_super) {
    __extends(AssertionError2, _super);
    /**
     * @param {number} code Error code.
     */ function AssertionError2(code) {
        var _this = this;
        var path = _utilJs.VERSION === 'latest' ? _utilJs.VERSION : 'v' + _utilJs.VERSION.split('-')[0];
        var message = 'Assertion failed. See https://openlayers.org/en/' + path + '/doc/errors/#' + code + ' for details.';
        _this = _super.call(this, message) || this;
        /**
         * Error code. The meaning of the code can be found on
         * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
         * the version found in the OpenLayers script's header comment if a version
         * other than the latest is used).
         * @type {number}
         * @api
         */ _this.code = code;
        /**
         * @type {string}
         */ _this.name = 'AssertionError';
        // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40
        _this.message = message;
        return _this;
    }
    return AssertionError2;
}(Error);
exports.default = AssertionError1;

},{"./util.js":"9zOhk","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"d26nZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_RADIUS", ()=>DEFAULT_RADIUS
);
/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} [opt_radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */ parcelHelpers.export(exports, "getDistance", ()=>getDistance
);
/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [opt_options] Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */ parcelHelpers.export(exports, "getLength", ()=>getLength
);
/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [opt_options] Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */ parcelHelpers.export(exports, "getArea", ()=>getArea
);
/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number} [opt_radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */ parcelHelpers.export(exports, "offset", ()=>offset
);
/**
 * @module ol/sphere
 */ var _geometryTypeJs = require("./geom/GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _mathJs = require("./math.js");
var DEFAULT_RADIUS = 6371008.8;
function getDistance(c1, c2, opt_radius) {
    var radius = opt_radius || DEFAULT_RADIUS;
    var lat1 = _mathJs.toRadians(c1[1]);
    var lat2 = _mathJs.toRadians(c2[1]);
    var deltaLatBy2 = (lat2 - lat1) / 2;
    var deltaLonBy2 = _mathJs.toRadians(c2[0] - c1[0]) / 2;
    var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
    return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */ function getLengthInternal(coordinates, radius) {
    var length = 0;
    for(var i = 0, ii = coordinates.length; i < ii - 1; ++i)length += getDistance(coordinates[i], coordinates[i + 1], radius);
    return length;
}
function getLength(geometry, opt_options) {
    var options = opt_options || {
    };
    var radius = options.radius || DEFAULT_RADIUS;
    var projection = options.projection || 'EPSG:3857';
    var type = geometry.getType();
    if (type !== _geometryTypeJsDefault.default.GEOMETRY_COLLECTION) geometry = geometry.clone().transform(projection, 'EPSG:4326');
    var length = 0;
    var coordinates, coords, i, ii, j, jj;
    switch(type){
        case _geometryTypeJsDefault.default.POINT:
        case _geometryTypeJsDefault.default.MULTI_POINT:
            break;
        case _geometryTypeJsDefault.default.LINE_STRING:
        case _geometryTypeJsDefault.default.LINEAR_RING:
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            length = getLengthInternal(coordinates, radius);
            break;
        case _geometryTypeJsDefault.default.MULTI_LINE_STRING:
        case _geometryTypeJsDefault.default.POLYGON:
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            for(i = 0, ii = coordinates.length; i < ii; ++i)length += getLengthInternal(coordinates[i], radius);
            break;
        case _geometryTypeJsDefault.default.MULTI_POLYGON:
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            for(i = 0, ii = coordinates.length; i < ii; ++i){
                coords = coordinates[i];
                for(j = 0, jj = coords.length; j < jj; ++j)length += getLengthInternal(coords[j], radius);
            }
            break;
        case _geometryTypeJsDefault.default.GEOMETRY_COLLECTION:
            var geometries = /** @type {import("./geom/GeometryCollection.js").default} */ geometry.getGeometries();
            for(i = 0, ii = geometries.length; i < ii; ++i)length += getLength(geometries[i], opt_options);
            break;
        default:
            throw new Error('Unsupported geometry type: ' + type);
    }
    return length;
}
/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */ function getAreaInternal(coordinates, radius) {
    var area = 0;
    var len = coordinates.length;
    var x1 = coordinates[len - 1][0];
    var y1 = coordinates[len - 1][1];
    for(var i = 0; i < len; i++){
        var x2 = coordinates[i][0];
        var y2 = coordinates[i][1];
        area += _mathJs.toRadians(x2 - x1) * (2 + Math.sin(_mathJs.toRadians(y1)) + Math.sin(_mathJs.toRadians(y2)));
        x1 = x2;
        y1 = y2;
    }
    return area * radius * radius / 2;
}
function getArea(geometry, opt_options) {
    var options = opt_options || {
    };
    var radius = options.radius || DEFAULT_RADIUS;
    var projection = options.projection || 'EPSG:3857';
    var type = geometry.getType();
    if (type !== _geometryTypeJsDefault.default.GEOMETRY_COLLECTION) geometry = geometry.clone().transform(projection, 'EPSG:4326');
    var area = 0;
    var coordinates, coords, i, ii, j, jj;
    switch(type){
        case _geometryTypeJsDefault.default.POINT:
        case _geometryTypeJsDefault.default.MULTI_POINT:
        case _geometryTypeJsDefault.default.LINE_STRING:
        case _geometryTypeJsDefault.default.MULTI_LINE_STRING:
        case _geometryTypeJsDefault.default.LINEAR_RING:
            break;
        case _geometryTypeJsDefault.default.POLYGON:
            coordinates = /** @type {import("./geom/Polygon.js").default} */ geometry.getCoordinates();
            area = Math.abs(getAreaInternal(coordinates[0], radius));
            for(i = 1, ii = coordinates.length; i < ii; ++i)area -= Math.abs(getAreaInternal(coordinates[i], radius));
            break;
        case _geometryTypeJsDefault.default.MULTI_POLYGON:
            coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ geometry.getCoordinates();
            for(i = 0, ii = coordinates.length; i < ii; ++i){
                coords = coordinates[i];
                area += Math.abs(getAreaInternal(coords[0], radius));
                for(j = 1, jj = coords.length; j < jj; ++j)area -= Math.abs(getAreaInternal(coords[j], radius));
            }
            break;
        case _geometryTypeJsDefault.default.GEOMETRY_COLLECTION:
            var geometries = /** @type {import("./geom/GeometryCollection.js").default} */ geometry.getGeometries();
            for(i = 0, ii = geometries.length; i < ii; ++i)area += getArea(geometries[i], opt_options);
            break;
        default:
            throw new Error('Unsupported geometry type: ' + type);
    }
    return area;
}
function offset(c1, distance, bearing, opt_radius) {
    var radius = opt_radius || DEFAULT_RADIUS;
    var lat1 = _mathJs.toRadians(c1[1]);
    var lon1 = _mathJs.toRadians(c1[0]);
    var dByR = distance / radius;
    var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
    var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
    return [
        _mathJs.toDegrees(lon),
        _mathJs.toDegrees(lat)
    ];
}

},{"./geom/GeometryType.js":"3sRlw","./math.js":"kI4rE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3sRlw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    POINT: 'Point',
    LINE_STRING: 'LineString',
    LINEAR_RING: 'LinearRing',
    POLYGON: 'Polygon',
    MULTI_POINT: 'MultiPoint',
    MULTI_LINE_STRING: 'MultiLineString',
    MULTI_POLYGON: 'MultiPolygon',
    GEOMETRY_COLLECTION: 'GeometryCollection',
    CIRCLE: 'Circle'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cmApa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */ /**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */ /**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */ parcelHelpers.export(exports, "add", ()=>add
);
/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */ parcelHelpers.export(exports, "closestOnCircle", ()=>closestOnCircle
);
/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */ parcelHelpers.export(exports, "closestOnSegment", ()=>closestOnSegment
);
/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */ parcelHelpers.export(exports, "createStringXY", ()=>createStringXY
);
/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */ parcelHelpers.export(exports, "degreesToStringHDMS", ()=>degreesToStringHDMS
);
/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */ parcelHelpers.export(exports, "format", ()=>format
);
/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */ parcelHelpers.export(exports, "equals", ()=>equals
);
/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */ parcelHelpers.export(exports, "squaredDistance", ()=>squaredDistance
);
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */ parcelHelpers.export(exports, "distance", ()=>distance
);
/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */ parcelHelpers.export(exports, "squaredDistanceToSegment", ()=>squaredDistanceToSegment
);
/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord);
 *     // out is now '47Â° 58â€² 60â€³ N 7Â° 50â€² 60â€³ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord, 1);
 *     // out is now '47Â° 58â€² 60.0â€³ N 7Â° 50â€² 60.0â€³ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */ parcelHelpers.export(exports, "toStringHDMS", ()=>toStringHDMS
);
/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [opt_fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */ parcelHelpers.export(exports, "toStringXY", ()=>toStringXY
);
/**
 * Modifies the provided coordinate in-place to be within the real world
 * extent. The lower projection extent boundary is inclusive, the upper one
 * exclusive.
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {Coordinate} The coordinate within the real world extent.
 */ parcelHelpers.export(exports, "wrapX", ()=>wrapX
);
/**
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {number} [opt_sourceExtentWidth] Width of the source extent.
 * @return {number} Offset in world widths.
 */ parcelHelpers.export(exports, "getWorldsAway", ()=>getWorldsAway
);
/**
 * @module ol/coordinate
 */ var _extentJs = require("./extent.js");
var _mathJs = require("./math.js");
var _stringJs = require("./string.js");
function add(coordinate, delta) {
    coordinate[0] += +delta[0];
    coordinate[1] += +delta[1];
    return coordinate;
}
function closestOnCircle(coordinate, circle) {
    var r = circle.getRadius();
    var center = circle.getCenter();
    var x0 = center[0];
    var y0 = center[1];
    var x1 = coordinate[0];
    var y1 = coordinate[1];
    var dx = x1 - x0;
    var dy = y1 - y0;
    if (dx === 0 && dy === 0) dx = 1;
    var d = Math.sqrt(dx * dx + dy * dy);
    var x = x0 + r * dx / d;
    var y = y0 + r * dy / d;
    return [
        x,
        y
    ];
}
function closestOnSegment(coordinate, segment) {
    var x0 = coordinate[0];
    var y0 = coordinate[1];
    var start = segment[0];
    var end = segment[1];
    var x1 = start[0];
    var y1 = start[1];
    var x2 = end[0];
    var y2 = end[1];
    var dx = x2 - x1;
    var dy = y2 - y1;
    var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
    var x, y;
    if (along <= 0) {
        x = x1;
        y = y1;
    } else if (along >= 1) {
        x = x2;
        y = y2;
    } else {
        x = x1 + along * dx;
        y = y1 + along * dy;
    }
    return [
        x,
        y
    ];
}
function createStringXY(opt_fractionDigits) {
    return(/**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */ function(coordinate) {
        return toStringXY(coordinate, opt_fractionDigits);
    });
}
function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {
    var normalizedDegrees = _mathJs.modulo(degrees + 180, 360) - 180;
    var x = Math.abs(3600 * normalizedDegrees);
    var dflPrecision = opt_fractionDigits || 0;
    var precision = Math.pow(10, dflPrecision);
    var deg = Math.floor(x / 3600);
    var min = Math.floor((x - deg * 3600) / 60);
    var sec = x - deg * 3600 - min * 60;
    sec = Math.ceil(sec * precision) / precision;
    if (sec >= 60) {
        sec = 0;
        min += 1;
    }
    if (min >= 60) {
        min = 0;
        deg += 1;
    }
    return deg + '\u00b0 ' + _stringJs.padNumber(min, 2) + '\u2032 ' + _stringJs.padNumber(sec, 2, dflPrecision) + '\u2033' + (normalizedDegrees == 0 ? '' : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));
}
function format(coordinate, template, opt_fractionDigits) {
    if (coordinate) return template.replace('{x}', coordinate[0].toFixed(opt_fractionDigits)).replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
    else return '';
}
function equals(coordinate1, coordinate2) {
    var equals1 = true;
    for(var i = coordinate1.length - 1; i >= 0; --i)if (coordinate1[i] != coordinate2[i]) {
        equals1 = false;
        break;
    }
    return equals1;
}
function rotate(coordinate, angle) {
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    coordinate[0] = x;
    coordinate[1] = y;
    return coordinate;
}
function scale(coordinate, scale1) {
    coordinate[0] *= scale1;
    coordinate[1] *= scale1;
    return coordinate;
}
function squaredDistance(coord1, coord2) {
    var dx = coord1[0] - coord2[0];
    var dy = coord1[1] - coord2[1];
    return dx * dx + dy * dy;
}
function distance(coord1, coord2) {
    return Math.sqrt(squaredDistance(coord1, coord2));
}
function squaredDistanceToSegment(coordinate, segment) {
    return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}
function toStringHDMS(coordinate, opt_fractionDigits) {
    if (coordinate) return degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) + ' ' + degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits);
    else return '';
}
function toStringXY(coordinate, opt_fractionDigits) {
    return format(coordinate, '{x}, {y}', opt_fractionDigits);
}
function wrapX(coordinate, projection) {
    if (projection.canWrapX()) {
        var worldWidth = _extentJs.getWidth(projection.getExtent());
        var worldsAway = getWorldsAway(coordinate, projection, worldWidth);
        if (worldsAway) coordinate[0] -= worldsAway * worldWidth;
    }
    return coordinate;
}
function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {
    var projectionExtent = projection.getExtent();
    var worldsAway = 0;
    if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
        var sourceExtentWidth = opt_sourceExtentWidth || _extentJs.getWidth(projectionExtent);
        worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
    }
    return worldsAway;
}

},{"./extent.js":"jgUz2","./math.js":"kI4rE","./string.js":"xxJZ3","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"xxJZ3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/string
 */ /**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number} [opt_precision] Precision of the output string (i.e. number of decimal places)
 * @return {string} Formatted string
 */ parcelHelpers.export(exports, "padNumber", ()=>padNumber
);
/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @return {number} Value
 */ parcelHelpers.export(exports, "compareVersions", ()=>compareVersions
);
function padNumber(number, width, opt_precision) {
    var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
    var decimal = numberString.indexOf('.');
    decimal = decimal === -1 ? numberString.length : decimal;
    return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
}
function compareVersions(v1, v2) {
    var s1 = ('' + v1).split('.');
    var s2 = ('' + v2).split('.');
    for(var i = 0; i < Math.max(s1.length, s2.length); i++){
        var n1 = parseInt(s1[i] || '0', 10);
        var n2 = parseInt(s2[i] || '0', 10);
        if (n1 > n2) return 1;
        if (n2 > n1) return -1;
    }
    return 0;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1wm9c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/TileCache
 */ var _lrucacheJs = require("./structs/LRUCache.js");
var _lrucacheJsDefault = parcelHelpers.interopDefault(_lrucacheJs);
var _tilecoordJs = require("./tilecoord.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var TileCache1 = function(_super) {
    __extends(TileCache2, _super);
    function TileCache2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {!Object<string, boolean>} usedTiles Used tiles.
     */ TileCache2.prototype.expireCache = function(usedTiles) {
        while(this.canExpireCache()){
            var tile = this.peekLast();
            if (tile.getKey() in usedTiles) break;
            else this.pop().release();
        }
    };
    /**
     * Prune all tiles from the cache that don't have the same z as the newest tile.
     */ TileCache2.prototype.pruneExceptNewestZ = function() {
        if (this.getCount() === 0) return;
        var key = this.peekFirstKey();
        var tileCoord = _tilecoordJs.fromKey(key);
        var z = tileCoord[0];
        this.forEach((function(tile) {
            if (tile.tileCoord[0] !== z) {
                this.remove(_tilecoordJs.getKey(tile.tileCoord));
                tile.release();
            }
        }).bind(this));
    };
    return TileCache2;
}(_lrucacheJsDefault.default);
exports.default = TileCache1;

},{"./structs/LRUCache.js":"cn9iq","./tilecoord.js":"gDmuU","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cn9iq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/structs/LRUCache
 */ var _assertsJs = require("../asserts.js");
/**
 * @typedef {Object} Entry
 * @property {string} key_ Key.
 * @property {Object} newer Newer.
 * @property {Object} older Older.
 * @property {*} value_ Value.
 */ /**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").default
 * @template T
 */ var LRUCache = function() {
    /**
     * @param {number} [opt_highWaterMark] High water mark.
     */ function LRUCache1(opt_highWaterMark) {
        /**
         * Desired max cache size after expireCache(). If set to 0, no cache entries
         * will be pruned at all.
         * @type {number}
         */ this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;
        /**
         * @private
         * @type {number}
         */ this.count_ = 0;
        /**
         * @private
         * @type {!Object<string, Entry>}
         */ this.entries_ = {
        };
        /**
         * @private
         * @type {?Entry}
         */ this.oldest_ = null;
        /**
         * @private
         * @type {?Entry}
         */ this.newest_ = null;
    }
    /**
     * @return {boolean} Can expire cache.
     */ LRUCache1.prototype.canExpireCache = function() {
        return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
    };
    /**
     * FIXME empty description for jsdoc
     */ LRUCache1.prototype.clear = function() {
        this.count_ = 0;
        this.entries_ = {
        };
        this.oldest_ = null;
        this.newest_ = null;
    };
    /**
     * @param {string} key Key.
     * @return {boolean} Contains key.
     */ LRUCache1.prototype.containsKey = function(key) {
        return this.entries_.hasOwnProperty(key);
    };
    /**
     * @param {function(T, string, LRUCache<T>): ?} f The function
     *     to call for every entry from the oldest to the newer. This function takes
     *     3 arguments (the entry value, the entry key and the LRUCache object).
     *     The return value is ignored.
     */ LRUCache1.prototype.forEach = function(f) {
        var entry = this.oldest_;
        while(entry){
            f(entry.value_, entry.key_, this);
            entry = entry.newer;
        }
    };
    /**
     * @param {string} key Key.
     * @param {*} [opt_options] Options (reserved for subclasses).
     * @return {T} Value.
     */ LRUCache1.prototype.get = function(key, opt_options) {
        var entry = this.entries_[key];
        _assertsJs.assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
        if (entry === this.newest_) return entry.value_;
        else if (entry === this.oldest_) {
            this.oldest_ = this.oldest_.newer;
            this.oldest_.older = null;
        } else {
            entry.newer.older = entry.older;
            entry.older.newer = entry.newer;
        }
        entry.newer = null;
        entry.older = this.newest_;
        this.newest_.newer = entry;
        this.newest_ = entry;
        return entry.value_;
    };
    /**
     * Remove an entry from the cache.
     * @param {string} key The entry key.
     * @return {T} The removed entry.
     */ LRUCache1.prototype.remove = function(key) {
        var entry = this.entries_[key];
        _assertsJs.assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
        if (entry === this.newest_) {
            this.newest_ = entry.older;
            if (this.newest_) this.newest_.newer = null;
        } else if (entry === this.oldest_) {
            this.oldest_ = entry.newer;
            if (this.oldest_) this.oldest_.older = null;
        } else {
            entry.newer.older = entry.older;
            entry.older.newer = entry.newer;
        }
        delete this.entries_[key];
        --this.count_;
        return entry.value_;
    };
    /**
     * @return {number} Count.
     */ LRUCache1.prototype.getCount = function() {
        return this.count_;
    };
    /**
     * @return {Array<string>} Keys.
     */ LRUCache1.prototype.getKeys = function() {
        var keys = new Array(this.count_);
        var i = 0;
        var entry;
        for(entry = this.newest_; entry; entry = entry.older)keys[i++] = entry.key_;
        return keys;
    };
    /**
     * @return {Array<T>} Values.
     */ LRUCache1.prototype.getValues = function() {
        var values = new Array(this.count_);
        var i = 0;
        var entry;
        for(entry = this.newest_; entry; entry = entry.older)values[i++] = entry.value_;
        return values;
    };
    /**
     * @return {T} Last value.
     */ LRUCache1.prototype.peekLast = function() {
        return this.oldest_.value_;
    };
    /**
     * @return {string} Last key.
     */ LRUCache1.prototype.peekLastKey = function() {
        return this.oldest_.key_;
    };
    /**
     * Get the key of the newest item in the cache.  Throws if the cache is empty.
     * @return {string} The newest key.
     */ LRUCache1.prototype.peekFirstKey = function() {
        return this.newest_.key_;
    };
    /**
     * @return {T} value Value.
     */ LRUCache1.prototype.pop = function() {
        var entry = this.oldest_;
        delete this.entries_[entry.key_];
        if (entry.newer) entry.newer.older = null;
        this.oldest_ = entry.newer;
        if (!this.oldest_) this.newest_ = null;
        --this.count_;
        return entry.value_;
    };
    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */ LRUCache1.prototype.replace = function(key, value) {
        this.get(key); // update `newest_`
        this.entries_[key].value_ = value;
    };
    /**
     * @param {string} key Key.
     * @param {T} value Value.
     */ LRUCache1.prototype.set = function(key, value) {
        _assertsJs.assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already
        var entry = {
            key_: key,
            newer: null,
            older: this.newest_,
            value_: value
        };
        if (!this.newest_) this.oldest_ = entry;
        else this.newest_.newer = entry;
        this.newest_ = entry;
        this.entries_[key] = entry;
        ++this.count_;
    };
    /**
     * Set a maximum number of entries for the cache.
     * @param {number} size Cache size.
     * @api
     */ LRUCache1.prototype.setSize = function(size) {
        this.highWaterMark = size;
    };
    return LRUCache1;
}();
exports.default = LRUCache;

},{"../asserts.js":"cnrP4","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"gDmuU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/tilecoord
 */ /**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
 * @typedef {Array<number>} TileCoord
 * @api
 */ /**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord} [opt_tileCoord] Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */ parcelHelpers.export(exports, "createOrUpdate", ()=>createOrUpdate
);
/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */ parcelHelpers.export(exports, "getKeyZXY", ()=>getKeyZXY
);
/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */ parcelHelpers.export(exports, "getKey", ()=>getKey
);
/**
 * Get the tile cache key for a tile key obtained through `tile.getKey()`.
 * @param {string} tileKey The tile key.
 * @return {string} The cache key.
 */ parcelHelpers.export(exports, "getCacheKeyForTileKey", ()=>getCacheKeyForTileKey
);
/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */ parcelHelpers.export(exports, "fromKey", ()=>fromKey
);
/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */ parcelHelpers.export(exports, "hash", ()=>hash
);
/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */ parcelHelpers.export(exports, "withinExtentAndZ", ()=>withinExtentAndZ
);
function createOrUpdate(z, x, y, opt_tileCoord) {
    if (opt_tileCoord !== undefined) {
        opt_tileCoord[0] = z;
        opt_tileCoord[1] = x;
        opt_tileCoord[2] = y;
        return opt_tileCoord;
    } else return [
        z,
        x,
        y
    ];
}
function getKeyZXY(z, x, y) {
    return z + '/' + x + '/' + y;
}
function getKey(tileCoord) {
    return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
function getCacheKeyForTileKey(tileKey) {
    var _a = tileKey.substring(tileKey.lastIndexOf('/') + 1, tileKey.length).split(',').map(Number), z = _a[0], x = _a[1], y = _a[2];
    return getKeyZXY(z, x, y);
}
function fromKey(key) {
    return key.split('/').map(Number);
}
function hash(tileCoord) {
    return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}
function withinExtentAndZ(tileCoord, tileGrid) {
    var z = tileCoord[0];
    var x = tileCoord[1];
    var y = tileCoord[2];
    if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) return false;
    var tileRange = tileGrid.getFullTileRange(z);
    if (!tileRange) return true;
    else return tileRange.containsXY(x, y);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"llps6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */ parcelHelpers.export(exports, "getForProjection", ()=>getForProjection
);
/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */ parcelHelpers.export(exports, "wrapX", ()=>wrapX
);
/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [opt_maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [opt_tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent/Corner.js").default} [opt_corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */ parcelHelpers.export(exports, "createForExtent", ()=>createForExtent
);
/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
 * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxResolution] Resolution at level zero.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */ /**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions} [opt_options] Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */ parcelHelpers.export(exports, "createXYZ", ()=>createXYZ
);
/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number} [opt_maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [opt_tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent/Corner.js").default} [opt_corner] Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */ parcelHelpers.export(exports, "createForProjection", ()=>createForProjection
);
/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */ parcelHelpers.export(exports, "extentFromProjection", ()=>extentFromProjection
);
/**
 * @module ol/tilegrid
 */ var _cornerJs = require("./extent/Corner.js");
var _cornerJsDefault = parcelHelpers.interopDefault(_cornerJs);
var _tileGridJs = require("./tilegrid/TileGrid.js");
var _tileGridJsDefault = parcelHelpers.interopDefault(_tileGridJs);
var _unitsJs = require("./proj/Units.js");
var _unitsJsDefault = parcelHelpers.interopDefault(_unitsJs);
var _commonJs = require("./tilegrid/common.js");
var _projJs = require("./proj.js");
var _extentJs = require("./extent.js");
var _sizeJs = require("./size.js");
function getForProjection(projection) {
    var tileGrid = projection.getDefaultTileGrid();
    if (!tileGrid) {
        tileGrid = createForProjection(projection);
        projection.setDefaultTileGrid(tileGrid);
    }
    return tileGrid;
}
function wrapX(tileGrid, tileCoord, projection) {
    var z = tileCoord[0];
    var center = tileGrid.getTileCoordCenter(tileCoord);
    var projectionExtent = extentFromProjection(projection);
    if (!_extentJs.containsCoordinate(projectionExtent, center)) {
        var worldWidth = _extentJs.getWidth(projectionExtent);
        var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
        center[0] += worldWidth * worldsAway;
        return tileGrid.getTileCoordForCoordAndZ(center, z);
    } else return tileCoord;
}
function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
    var corner = opt_corner !== undefined ? opt_corner : _cornerJsDefault.default.TOP_LEFT;
    var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);
    return new _tileGridJsDefault.default({
        extent: extent,
        origin: _extentJs.getCorner(extent, corner),
        resolutions: resolutions,
        tileSize: opt_tileSize
    });
}
function createXYZ(opt_options) {
    var xyzOptions = opt_options || {
    };
    var extent = xyzOptions.extent || _projJs.get('EPSG:3857').getExtent();
    var gridOptions = {
        extent: extent,
        minZoom: xyzOptions.minZoom,
        tileSize: xyzOptions.tileSize,
        resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)
    };
    return new _tileGridJsDefault.default(gridOptions);
}
/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} [opt_maxZoom] Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size} [opt_tileSize] Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {number} [opt_maxResolution] Resolution at level zero.
 * @return {!Array<number>} Resolutions array.
 */ function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {
    var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : _commonJs.DEFAULT_MAX_ZOOM;
    var height = _extentJs.getHeight(extent);
    var width = _extentJs.getWidth(extent);
    var tileSize = _sizeJs.toSize(opt_tileSize !== undefined ? opt_tileSize : _commonJs.DEFAULT_TILE_SIZE);
    var maxResolution = opt_maxResolution > 0 ? opt_maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
    var length = maxZoom + 1;
    var resolutions = new Array(length);
    for(var z = 0; z < length; ++z)resolutions[z] = maxResolution / Math.pow(2, z);
    return resolutions;
}
function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
    var extent = extentFromProjection(projection);
    return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
}
function extentFromProjection(projection) {
    projection = _projJs.get(projection);
    var extent = projection.getExtent();
    if (!extent) {
        var half = 180 * _projJs.METERS_PER_UNIT[_unitsJsDefault.default.DEGREES] / projection.getMetersPerUnit();
        extent = _extentJs.createOrUpdate(-half, -half, half, half);
    }
    return extent;
}

},{"./extent/Corner.js":"j9uRQ","./tilegrid/TileGrid.js":"7vmIN","./proj/Units.js":"g2gaW","./tilegrid/common.js":"euoxp","./proj.js":"hmdWM","./extent.js":"jgUz2","./size.js":"5PZ8p","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7vmIN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/tilegrid/TileGrid
 */ var _tileRangeJs = require("../TileRange.js");
var _tileRangeJsDefault = parcelHelpers.interopDefault(_tileRangeJs);
var _commonJs = require("./common.js");
var _assertsJs = require("../asserts.js");
var _mathJs = require("../math.js");
var _extentJs = require("../extent.js");
var _tilecoordJs = require("../tilecoord.js");
var _arrayJs = require("../array.js");
var _sizeJs = require("../size.js");
/**
 * @private
 * @type {import("../tilecoord.js").TileCoord}
 */ var tmpTileCoord = [
    0,
    0,
    0
];
/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. If specified the values
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent
 * for which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */ /**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */ var TileGrid = function() {
    /**
     * @param {Options} options Tile grid options.
     */ function TileGrid1(options) {
        /**
         * @protected
         * @type {number}
         */ this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;
        /**
         * @private
         * @type {!Array<number>}
         */ this.resolutions_ = options.resolutions;
        _assertsJs.assert(_arrayJs.isSorted(this.resolutions_, function(a, b) {
            return b - a;
        }, true), 17); // `resolutions` must be sorted in descending order
        // check if we've got a consistent zoom factor and origin
        var zoomFactor;
        if (!options.origins) for(var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i){
            if (!zoomFactor) zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
            else if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
                zoomFactor = undefined;
                break;
            }
        }
        /**
         * @private
         * @type {number|undefined}
         */ this.zoomFactor_ = zoomFactor;
        /**
         * @protected
         * @type {number}
         */ this.maxZoom = this.resolutions_.length - 1;
        /**
         * @private
         * @type {import("../coordinate.js").Coordinate}
         */ this.origin_ = options.origin !== undefined ? options.origin : null;
        /**
         * @private
         * @type {Array<import("../coordinate.js").Coordinate>}
         */ this.origins_ = null;
        if (options.origins !== undefined) {
            this.origins_ = options.origins;
            _assertsJs.assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
        }
        var extent = options.extent;
        if (extent !== undefined && !this.origin_ && !this.origins_) this.origin_ = _extentJs.getTopLeft(extent);
        _assertsJs.assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both
        /**
         * @private
         * @type {Array<number|import("../size.js").Size>}
         */ this.tileSizes_ = null;
        if (options.tileSizes !== undefined) {
            this.tileSizes_ = options.tileSizes;
            _assertsJs.assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
        }
        /**
         * @private
         * @type {number|import("../size.js").Size}
         */ this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? _commonJs.DEFAULT_TILE_SIZE : null;
        _assertsJs.assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both
        /**
         * @private
         * @type {import("../extent.js").Extent}
         */ this.extent_ = extent !== undefined ? extent : null;
        /**
         * @private
         * @type {Array<import("../TileRange.js").default>}
         */ this.fullTileRanges_ = null;
        /**
         * @private
         * @type {import("../size.js").Size}
         */ this.tmpSize_ = [
            0,
            0
        ];
        /**
         * @private
         * @type {import("../extent.js").Extent}
         */ this.tmpExtent_ = [
            0,
            0,
            0,
            0
        ];
        if (options.sizes !== undefined) this.fullTileRanges_ = options.sizes.map(function(size, z) {
            var tileRange = new _tileRangeJsDefault.default(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
            if (extent) {
                var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
                tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
                tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
                tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
                tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
            }
            return tileRange;
        }, this);
        else if (extent) this.calculateTileRanges_(extent);
    }
    /**
     * Call a function with each tile coordinate for a given extent and zoom level.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} zoom Integer zoom level.
     * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
     * @api
     */ TileGrid1.prototype.forEachTileCoord = function(extent, zoom, callback) {
        var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
        for(var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i)for(var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j)callback([
            zoom,
            i,
            j
        ]);
    };
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
     * @param {import("../TileRange.js").default} [opt_tileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [opt_extent] Temporary import("../extent.js").Extent object.
     * @return {boolean} Callback succeeded.
     */ TileGrid1.prototype.forEachTileCoordParentTileRange = function(tileCoord, callback, opt_tileRange, opt_extent) {
        var tileRange, x, y;
        var tileCoordExtent = null;
        var z = tileCoord[0] - 1;
        if (this.zoomFactor_ === 2) {
            x = tileCoord[1];
            y = tileCoord[2];
        } else tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
        while(z >= this.minZoom){
            if (this.zoomFactor_ === 2) {
                x = Math.floor(x / 2);
                y = Math.floor(y / 2);
                tileRange = _tileRangeJs.createOrUpdate(x, x, y, y, opt_tileRange);
            } else tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
            if (callback(z, tileRange)) return true;
            --z;
        }
        return false;
    };
    /**
     * Get the extent for this tile grid, if it was configured.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */ TileGrid1.prototype.getExtent = function() {
        return this.extent_;
    };
    /**
     * Get the maximum zoom level for the grid.
     * @return {number} Max zoom.
     * @api
     */ TileGrid1.prototype.getMaxZoom = function() {
        return this.maxZoom;
    };
    /**
     * Get the minimum zoom level for the grid.
     * @return {number} Min zoom.
     * @api
     */ TileGrid1.prototype.getMinZoom = function() {
        return this.minZoom;
    };
    /**
     * Get the origin for the grid at the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {import("../coordinate.js").Coordinate} Origin.
     * @api
     */ TileGrid1.prototype.getOrigin = function(z) {
        if (this.origin_) return this.origin_;
        else return this.origins_[z];
    };
    /**
     * Get the resolution for the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {number} Resolution.
     * @api
     */ TileGrid1.prototype.getResolution = function(z) {
        return this.resolutions_[z];
    };
    /**
     * Get the list of resolutions for the tile grid.
     * @return {Array<number>} Resolutions.
     * @api
     */ TileGrid1.prototype.getResolutions = function() {
        return this.resolutions_;
    };
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../TileRange.js").default} [opt_tileRange] Temporary import("../TileRange.js").default object.
     * @param {import("../extent.js").Extent} [opt_extent] Temporary import("../extent.js").Extent object.
     * @return {import("../TileRange.js").default} Tile range.
     */ TileGrid1.prototype.getTileCoordChildTileRange = function(tileCoord, opt_tileRange, opt_extent) {
        if (tileCoord[0] < this.maxZoom) {
            if (this.zoomFactor_ === 2) {
                var minX = tileCoord[1] * 2;
                var minY = tileCoord[2] * 2;
                return _tileRangeJs.createOrUpdate(minX, minX + 1, minY, minY + 1, opt_tileRange);
            }
            var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent || this.tmpExtent_);
            return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
        }
        return null;
    };
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [opt_tileRange] Temporary import("../TileRange.js").default object.
     * @return {import("../TileRange.js").default} Tile range.
     */ TileGrid1.prototype.getTileRangeForTileCoordAndZ = function(tileCoord, z, opt_tileRange) {
        if (z > this.maxZoom || z < this.minZoom) return null;
        var tileCoordZ = tileCoord[0];
        var tileCoordX = tileCoord[1];
        var tileCoordY = tileCoord[2];
        if (z === tileCoordZ) return _tileRangeJs.createOrUpdate(tileCoordX, tileCoordY, tileCoordX, tileCoordY, opt_tileRange);
        if (this.zoomFactor_) {
            var factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
            var minX = Math.floor(tileCoordX * factor);
            var minY = Math.floor(tileCoordY * factor);
            if (z < tileCoordZ) return _tileRangeJs.createOrUpdate(minX, minX, minY, minY, opt_tileRange);
            var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
            var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
            return _tileRangeJs.createOrUpdate(minX, maxX, minY, maxY, opt_tileRange);
        }
        var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
        return this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
    };
    /**
     * Get the extent for a tile range.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} tileRange Tile range.
     * @param {import("../extent.js").Extent} [opt_extent] Temporary import("../extent.js").Extent object.
     * @return {import("../extent.js").Extent} Extent.
     */ TileGrid1.prototype.getTileRangeExtent = function(z, tileRange, opt_extent) {
        var origin = this.getOrigin(z);
        var resolution = this.getResolution(z);
        var tileSize = _sizeJs.toSize(this.getTileSize(z), this.tmpSize_);
        var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
        var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
        var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
        var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
        return _extentJs.createOrUpdate(minX, minY, maxX, maxY, opt_extent);
    };
    /**
     * Get a tile range for the given extent and integer zoom level.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} z Integer zoom level.
     * @param {import("../TileRange.js").default} [opt_tileRange] Temporary tile range object.
     * @return {import("../TileRange.js").default} Tile range.
     */ TileGrid1.prototype.getTileRangeForExtentAndZ = function(extent, z, opt_tileRange) {
        var tileCoord = tmpTileCoord;
        this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);
        var minX = tileCoord[1];
        var minY = tileCoord[2];
        this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);
        return _tileRangeJs.createOrUpdate(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
    };
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {import("../coordinate.js").Coordinate} Tile center.
     */ TileGrid1.prototype.getTileCoordCenter = function(tileCoord) {
        var origin = this.getOrigin(tileCoord[0]);
        var resolution = this.getResolution(tileCoord[0]);
        var tileSize = _sizeJs.toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
        return [
            origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
            origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution, 
        ];
    };
    /**
     * Get the extent of a tile coordinate.
     *
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("../extent.js").Extent} [opt_extent] Temporary extent object.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */ TileGrid1.prototype.getTileCoordExtent = function(tileCoord, opt_extent) {
        var origin = this.getOrigin(tileCoord[0]);
        var resolution = this.getResolution(tileCoord[0]);
        var tileSize = _sizeJs.toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
        var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
        var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
        var maxX = minX + tileSize[0] * resolution;
        var maxY = minY + tileSize[1] * resolution;
        return _extentJs.createOrUpdate(minX, minY, maxX, maxY, opt_extent);
    };
    /**
     * Get the tile coordinate for the given map coordinate and resolution.  This
     * method considers that coordinates that intersect tile boundaries should be
     * assigned the higher tile coordinate.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */ TileGrid1.prototype.getTileCoordForCoordAndResolution = function(coordinate, resolution, opt_tileCoord) {
        return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
    };
    /**
     * Note that this method should not be called for resolutions that correspond
     * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {number} resolution Resolution (for a non-integer zoom level).
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */ TileGrid1.prototype.getTileCoordForXYAndResolution_ = function(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
        var z = this.getZForResolution(resolution);
        var scale = resolution / this.getResolution(z);
        var origin = this.getOrigin(z);
        var tileSize = _sizeJs.toSize(this.getTileSize(z), this.tmpSize_);
        var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
        var adjustY = reverseIntersectionPolicy ? 0.5 : 0;
        var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
        var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);
        var tileCoordX = scale * xFromOrigin / tileSize[0];
        var tileCoordY = scale * yFromOrigin / tileSize[1];
        if (reverseIntersectionPolicy) {
            tileCoordX = Math.ceil(tileCoordX) - 1;
            tileCoordY = Math.ceil(tileCoordY) - 1;
        } else {
            tileCoordX = Math.floor(tileCoordX);
            tileCoordY = Math.floor(tileCoordY);
        }
        return _tilecoordJs.createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
    };
    /**
     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
     * they should have separate implementations.  This method is for integer zoom
     * levels.  The other method should only be called for resolutions corresponding
     * to non-integer zoom levels.
     * @param {number} x Map x coordinate.
     * @param {number} y Map y coordinate.
     * @param {number} z Integer zoom level.
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *     intersections go to the higher tile coordinate, let edge intersections
     *     go to the lower tile coordinate.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @private
     */ TileGrid1.prototype.getTileCoordForXYAndZ_ = function(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
        var origin = this.getOrigin(z);
        var resolution = this.getResolution(z);
        var tileSize = _sizeJs.toSize(this.getTileSize(z), this.tmpSize_);
        var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
        var adjustY = reverseIntersectionPolicy ? 0.5 : 0;
        var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
        var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);
        var tileCoordX = xFromOrigin / tileSize[0];
        var tileCoordY = yFromOrigin / tileSize[1];
        if (reverseIntersectionPolicy) {
            tileCoordX = Math.ceil(tileCoordX) - 1;
            tileCoordY = Math.ceil(tileCoordY) - 1;
        } else {
            tileCoordX = Math.floor(tileCoordX);
            tileCoordY = Math.floor(tileCoordY);
        }
        return _tilecoordJs.createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
    };
    /**
     * Get a tile coordinate given a map coordinate and zoom level.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} z Zoom level.
     * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
     * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
     * @api
     */ TileGrid1.prototype.getTileCoordForCoordAndZ = function(coordinate, z, opt_tileCoord) {
        return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
    };
    /**
     * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {number} Tile resolution.
     */ TileGrid1.prototype.getTileCoordResolution = function(tileCoord) {
        return this.resolutions_[tileCoord[0]];
    };
    /**
     * Get the tile size for a zoom level. The type of the return value matches the
     * `tileSize` or `tileSizes` that the tile grid was configured with. To always
     * get an `import("../size.js").Size`, run the result through `import("../size.js").Size.toSize()`.
     * @param {number} z Z.
     * @return {number|import("../size.js").Size} Tile size.
     * @api
     */ TileGrid1.prototype.getTileSize = function(z) {
        if (this.tileSize_) return this.tileSize_;
        else return this.tileSizes_[z];
    };
    /**
     * @param {number} z Zoom level.
     * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
     */ TileGrid1.prototype.getFullTileRange = function(z) {
        if (!this.fullTileRanges_) return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
        else return this.fullTileRanges_[z];
    };
    /**
     * @param {number} resolution Resolution.
     * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
     *     If 0, the nearest resolution will be used.
     *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
     *     nearest lower resolution (higher Z) will be used. Default is 0.
     *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
     *
     * For example to change tile Z at the midpoint of zoom levels
     * ```js
     * function(value, high, low) {
     *   return value - low * Math.sqrt(high / low);
     * }
     * ```
     * @return {number} Z.
     * @api
     */ TileGrid1.prototype.getZForResolution = function(resolution, opt_direction) {
        var z = _arrayJs.linearFindNearest(this.resolutions_, resolution, opt_direction || 0);
        return _mathJs.clamp(z, this.minZoom, this.maxZoom);
    };
    /**
     * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
     * @private
     */ TileGrid1.prototype.calculateTileRanges_ = function(extent) {
        var length = this.resolutions_.length;
        var fullTileRanges = new Array(length);
        for(var z = this.minZoom; z < length; ++z)fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
        this.fullTileRanges_ = fullTileRanges;
    };
    return TileGrid1;
}();
exports.default = TileGrid;

},{"../TileRange.js":"lfGfv","./common.js":"euoxp","../asserts.js":"cnrP4","../math.js":"kI4rE","../extent.js":"jgUz2","../tilecoord.js":"gDmuU","../array.js":"jKNP0","../size.js":"5PZ8p","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lfGfv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {TileRange} [tileRange] TileRange.
 * @return {TileRange} Tile range.
 */ parcelHelpers.export(exports, "createOrUpdate", ()=>createOrUpdate
);
/**
 * @module ol/TileRange
 */ /**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */ var TileRange = function() {
    /**
     * @param {number} minX Minimum X.
     * @param {number} maxX Maximum X.
     * @param {number} minY Minimum Y.
     * @param {number} maxY Maximum Y.
     */ function TileRange1(minX, maxX, minY, maxY) {
        /**
         * @type {number}
         */ this.minX = minX;
        /**
         * @type {number}
         */ this.maxX = maxX;
        /**
         * @type {number}
         */ this.minY = minY;
        /**
         * @type {number}
         */ this.maxY = maxY;
    }
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {boolean} Contains tile coordinate.
     */ TileRange1.prototype.contains = function(tileCoord) {
        return this.containsXY(tileCoord[1], tileCoord[2]);
    };
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Contains.
     */ TileRange1.prototype.containsTileRange = function(tileRange) {
        return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
    };
    /**
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @return {boolean} Contains coordinate.
     */ TileRange1.prototype.containsXY = function(x, y) {
        return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
    };
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Equals.
     */ TileRange1.prototype.equals = function(tileRange) {
        return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
    };
    /**
     * @param {TileRange} tileRange Tile range.
     */ TileRange1.prototype.extend = function(tileRange) {
        if (tileRange.minX < this.minX) this.minX = tileRange.minX;
        if (tileRange.maxX > this.maxX) this.maxX = tileRange.maxX;
        if (tileRange.minY < this.minY) this.minY = tileRange.minY;
        if (tileRange.maxY > this.maxY) this.maxY = tileRange.maxY;
    };
    /**
     * @return {number} Height.
     */ TileRange1.prototype.getHeight = function() {
        return this.maxY - this.minY + 1;
    };
    /**
     * @return {import("./size.js").Size} Size.
     */ TileRange1.prototype.getSize = function() {
        return [
            this.getWidth(),
            this.getHeight()
        ];
    };
    /**
     * @return {number} Width.
     */ TileRange1.prototype.getWidth = function() {
        return this.maxX - this.minX + 1;
    };
    /**
     * @param {TileRange} tileRange Tile range.
     * @return {boolean} Intersects.
     */ TileRange1.prototype.intersects = function(tileRange) {
        return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
    };
    return TileRange1;
}();
function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
    if (tileRange !== undefined) {
        tileRange.minX = minX;
        tileRange.maxX = maxX;
        tileRange.minY = minY;
        tileRange.maxY = maxY;
        return tileRange;
    } else return new TileRange(minX, maxX, minY, maxY);
}
exports.default = TileRange;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"euoxp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_MAX_ZOOM", ()=>DEFAULT_MAX_ZOOM
);
parcelHelpers.export(exports, "DEFAULT_TILE_SIZE", ()=>DEFAULT_TILE_SIZE
);
var DEFAULT_MAX_ZOOM = 42;
var DEFAULT_TILE_SIZE = 256;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5PZ8p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/size
 */ /**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */ /**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size} [opt_size] Optional reusable size array.
 * @return {Size} The buffered size.
 */ parcelHelpers.export(exports, "buffer", ()=>buffer
);
/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */ parcelHelpers.export(exports, "hasArea", ()=>hasArea
);
/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size} [opt_size] Optional reusable size array.
 * @return {Size} The scaled size.
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size} [opt_size] Optional reusable size array.
 * @return {Size} Size.
 * @api
 */ parcelHelpers.export(exports, "toSize", ()=>toSize
);
function buffer(size, num, opt_size) {
    if (opt_size === undefined) opt_size = [
        0,
        0
    ];
    opt_size[0] = size[0] + 2 * num;
    opt_size[1] = size[1] + 2 * num;
    return opt_size;
}
function hasArea(size) {
    return size[0] > 0 && size[1] > 0;
}
function scale(size, ratio, opt_size) {
    if (opt_size === undefined) opt_size = [
        0,
        0
    ];
    opt_size[0] = size[0] * ratio + 0.5 | 0;
    opt_size[1] = size[1] * ratio + 0.5 | 0;
    return opt_size;
}
function toSize(size, opt_size) {
    if (Array.isArray(size)) return size;
    else {
        if (opt_size === undefined) opt_size = [
            size,
            size
        ];
        else {
            opt_size[0] = size;
            opt_size[1] = size;
        }
        return opt_size;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1tgV5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "globals", ()=>_globals
);
parcelHelpers.export(exports, "rgb", ()=>_rgb
);
parcelHelpers.export(exports, "getDecoder", ()=>_compression.getDecoder
);
parcelHelpers.export(exports, "addDecoder", ()=>_compression.addDecoder
);
parcelHelpers.export(exports, "setLogger", ()=>_logging.setLogger
);
parcelHelpers.export(exports, "GeoTIFF", ()=>GeoTIFF
);
parcelHelpers.export(exports, "MultiGeoTIFF", ()=>MultiGeoTIFF
);
/**
 * Creates a new GeoTIFF from a remote URL.
 * @param {string} url The URL to access the image from
 * @param {object} [options] Additional options to pass to the source.
 *                           See {@link makeRemoteSource} for details.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.
 */ parcelHelpers.export(exports, "fromUrl", ()=>fromUrl
);
/**
 * Construct a new GeoTIFF from an
 * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.
 * @param {ArrayBuffer} arrayBuffer The data to read the file from.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.
 */ parcelHelpers.export(exports, "fromArrayBuffer", ()=>fromArrayBuffer
);
/**
 * Construct a GeoTIFF from a local file path. This uses the node
 * [filesystem API]{@link https://nodejs.org/api/fs.html} and is
 * not available on browsers.
 *
 * N.B. After the GeoTIFF has been completely processed it needs
 * to be closed but only if it has been constructed from a file.
 * @param {string} path The file path to read from.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.
 */ parcelHelpers.export(exports, "fromFile", ()=>fromFile
);
/**
 * Construct a GeoTIFF from an HTML
 * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or
 * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}
 * object.
 * @param {Blob|File} blob The Blob or File object to read from.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise.<GeoTIFF>} The resulting GeoTIFF file.
 */ parcelHelpers.export(exports, "fromBlob", ()=>fromBlob
);
/**
 * Construct a MultiGeoTIFF from the given URLs.
 * @param {string} mainUrl The URL for the main file.
 * @param {string[]} overviewUrls An array of URLs for the overview images.
 * @param {object} [options] Additional options to pass to the source.
 *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}
 *                           for details.
 * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
 *                               to be aborted
 * @returns {Promise.<MultiGeoTIFF>} The resulting MultiGeoTIFF file.
 */ parcelHelpers.export(exports, "fromUrls", ()=>fromUrls
);
/**
 * Main creating function for GeoTIFF files.
 * @param {(Array)} array of pixel values
 * @returns {metadata} metadata
 */ parcelHelpers.export(exports, "writeArrayBuffer", ()=>writeArrayBuffer
);
parcelHelpers.export(exports, "Pool", ()=>_poolDefault.default
);
var _geotiffimage = require("./geotiffimage");
var _geotiffimageDefault = parcelHelpers.interopDefault(_geotiffimage);
var _dataview64 = require("./dataview64");
var _dataview64Default = parcelHelpers.interopDefault(_dataview64);
var _dataslice = require("./dataslice");
var _datasliceDefault = parcelHelpers.interopDefault(_dataslice);
var _pool = require("./pool");
var _poolDefault = parcelHelpers.interopDefault(_pool);
var _remote = require("./source/remote");
var _arraybuffer = require("./source/arraybuffer");
var _filereader = require("./source/filereader");
var _file = require("./source/file");
var _globals = require("./globals");
var _geotiffwriter = require("./geotiffwriter");
var _rgb = require("./rgb");
var _compression = require("./compression");
var _logging = require("./logging");
function getFieldTypeLength(fieldType) {
    switch(fieldType){
        case _globals.fieldTypes.BYTE:
        case _globals.fieldTypes.ASCII:
        case _globals.fieldTypes.SBYTE:
        case _globals.fieldTypes.UNDEFINED:
            return 1;
        case _globals.fieldTypes.SHORT:
        case _globals.fieldTypes.SSHORT:
            return 2;
        case _globals.fieldTypes.LONG:
        case _globals.fieldTypes.SLONG:
        case _globals.fieldTypes.FLOAT:
        case _globals.fieldTypes.IFD:
            return 4;
        case _globals.fieldTypes.RATIONAL:
        case _globals.fieldTypes.SRATIONAL:
        case _globals.fieldTypes.DOUBLE:
        case _globals.fieldTypes.LONG8:
        case _globals.fieldTypes.SLONG8:
        case _globals.fieldTypes.IFD8:
            return 8;
        default:
            throw new RangeError(`Invalid field type: ${fieldType}`);
    }
}
function parseGeoKeyDirectory(fileDirectory) {
    const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;
    if (!rawGeoKeyDirectory) return null;
    const geoKeyDirectory = {
    };
    for(let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4){
        const key = _globals.geoKeyNames[rawGeoKeyDirectory[i]];
        const location = rawGeoKeyDirectory[i + 1] ? _globals.fieldTagNames[rawGeoKeyDirectory[i + 1]] : null;
        const count = rawGeoKeyDirectory[i + 2];
        const offset = rawGeoKeyDirectory[i + 3];
        let value = null;
        if (!location) value = offset;
        else {
            value = fileDirectory[location];
            if (typeof value === 'undefined' || value === null) throw new Error(`Could not get value of geoKey '${key}'.`);
            else if (typeof value === 'string') value = value.substring(offset, offset + count - 1);
            else if (value.subarray) {
                value = value.subarray(offset, offset + count);
                if (count === 1) value = value[0];
            }
        }
        geoKeyDirectory[key] = value;
    }
    return geoKeyDirectory;
}
function getValues(dataSlice, fieldType, count, offset) {
    let values = null;
    let readMethod = null;
    const fieldTypeLength = getFieldTypeLength(fieldType);
    switch(fieldType){
        case _globals.fieldTypes.BYTE:
        case _globals.fieldTypes.ASCII:
        case _globals.fieldTypes.UNDEFINED:
            values = new Uint8Array(count);
            readMethod = dataSlice.readUint8;
            break;
        case _globals.fieldTypes.SBYTE:
            values = new Int8Array(count);
            readMethod = dataSlice.readInt8;
            break;
        case _globals.fieldTypes.SHORT:
            values = new Uint16Array(count);
            readMethod = dataSlice.readUint16;
            break;
        case _globals.fieldTypes.SSHORT:
            values = new Int16Array(count);
            readMethod = dataSlice.readInt16;
            break;
        case _globals.fieldTypes.LONG:
        case _globals.fieldTypes.IFD:
            values = new Uint32Array(count);
            readMethod = dataSlice.readUint32;
            break;
        case _globals.fieldTypes.SLONG:
            values = new Int32Array(count);
            readMethod = dataSlice.readInt32;
            break;
        case _globals.fieldTypes.LONG8:
        case _globals.fieldTypes.IFD8:
            values = new Array(count);
            readMethod = dataSlice.readUint64;
            break;
        case _globals.fieldTypes.SLONG8:
            values = new Array(count);
            readMethod = dataSlice.readInt64;
            break;
        case _globals.fieldTypes.RATIONAL:
            values = new Uint32Array(count * 2);
            readMethod = dataSlice.readUint32;
            break;
        case _globals.fieldTypes.SRATIONAL:
            values = new Int32Array(count * 2);
            readMethod = dataSlice.readInt32;
            break;
        case _globals.fieldTypes.FLOAT:
            values = new Float32Array(count);
            readMethod = dataSlice.readFloat32;
            break;
        case _globals.fieldTypes.DOUBLE:
            values = new Float64Array(count);
            readMethod = dataSlice.readFloat64;
            break;
        default:
            throw new RangeError(`Invalid field type: ${fieldType}`);
    }
    // normal fields
    if (!(fieldType === _globals.fieldTypes.RATIONAL || fieldType === _globals.fieldTypes.SRATIONAL)) for(let i = 0; i < count; ++i)values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);
    else for(let i1 = 0; i1 < count; i1 += 2){
        values[i1] = readMethod.call(dataSlice, offset + i1 * fieldTypeLength);
        values[i1 + 1] = readMethod.call(dataSlice, offset + (i1 * fieldTypeLength + 4));
    }
    if (fieldType === _globals.fieldTypes.ASCII) return new TextDecoder('utf-8').decode(values);
    return values;
}
/**
 * Data class to store the parsed file directory, geo key directory and
 * offset to the next IFD
 */ class ImageFileDirectory {
    constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset){
        this.fileDirectory = fileDirectory;
        this.geoKeyDirectory = geoKeyDirectory;
        this.nextIFDByteOffset = nextIFDByteOffset;
    }
}
/**
 * Error class for cases when an IFD index was requested, that does not exist
 * in the file.
 */ class GeoTIFFImageIndexError extends Error {
    constructor(index1){
        super(`No image at index ${index1}`);
        this.index = index1;
    }
}
class GeoTIFFBase {
    /**
   * (experimental) Reads raster data from the best fitting image. This function uses
   * the image with the lowest resolution that is still a higher resolution than the
   * requested resolution.
   * When specified, the `bbox` option is translated to the `window` option and the
   * `resX` and `resY` to `width` and `height` respectively.
   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected
   * image is called and the result returned.
   * @see GeoTIFFImage.readRasters
   * @param {Object} [options={}] optional parameters
   * @param {Array} [options.window=whole image] the subset to read data from.
   * @param {Array} [options.bbox=whole image] the subset to read data from in
   *                                           geographical coordinates.
   * @param {Array} [options.samples=all samples] the selection of samples to read from.
   * @param {Boolean} [options.interleave=false] whether the data shall be read
   *                                             in one single array or separate
   *                                             arrays.
   * @param {Number} [options.pool=null] The optional decoder pool to use.
   * @param {Number} [options.width] The desired width of the output. When the width is not the
   *                                 same as the images, resampling will be performed.
   * @param {Number} [options.height] The desired height of the output. When the width is not the
   *                                  same as the images, resampling will be performed.
   * @param {String} [options.resampleMethod='nearest'] The desired resampling method.
   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is
   *                                       to be aborted
   * @param {Number|Number[]} [options.fillValue] The value to use for parts of the image
   *                                              outside of the images extent. When multiple
   *                                              samples are requested, an array of fill values
   *                                              can be passed.
   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise
   */ async readRasters(options = {
    }) {
        const { window: imageWindow , width , height  } = options;
        let { resX , resY , bbox  } = options;
        const firstImage = await this.getImage();
        let usedImage = firstImage;
        const imageCount = await this.getImageCount();
        const imgBBox = firstImage.getBoundingBox();
        if (imageWindow && bbox) throw new Error('Both "bbox" and "window" passed.');
        // if width/height is passed, transform it to resolution
        if (width || height) {
            // if we have an image window (pixel coordinates), transform it to a BBox
            // using the origin/resolution of the first image.
            if (imageWindow) {
                const [oX, oY] = firstImage.getOrigin();
                const [rX, rY] = firstImage.getResolution();
                bbox = [
                    oX + imageWindow[0] * rX,
                    oY + imageWindow[1] * rY,
                    oX + imageWindow[2] * rX,
                    oY + imageWindow[3] * rY, 
                ];
            }
            // if we have a bbox (or calculated one)
            const usedBBox = bbox || imgBBox;
            if (width) {
                if (resX) throw new Error('Both width and resX passed');
                resX = (usedBBox[2] - usedBBox[0]) / width;
            }
            if (height) {
                if (resY) throw new Error('Both width and resY passed');
                resY = (usedBBox[3] - usedBBox[1]) / height;
            }
        }
        // if resolution is set or calculated, try to get the image with the worst acceptable resolution
        if (resX || resY) {
            const allImages = [];
            for(let i = 0; i < imageCount; ++i){
                const image = await this.getImage(i);
                const { SubfileType: subfileType , NewSubfileType: newSubfileType  } = image.fileDirectory;
                if (i === 0 || subfileType === 2 || newSubfileType & 1) allImages.push(image);
            }
            allImages.sort((a, b)=>a.getWidth() - b.getWidth()
            );
            for(let i1 = 0; i1 < allImages.length; ++i1){
                const image = allImages[i1];
                const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();
                const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();
                usedImage = image;
                if (resX && resX > imgResX || resY && resY > imgResY) break;
            }
        }
        let wnd = imageWindow;
        if (bbox) {
            const [oX, oY] = firstImage.getOrigin();
            const [imageResX, imageResY] = usedImage.getResolution(firstImage);
            wnd = [
                Math.round((bbox[0] - oX) / imageResX),
                Math.round((bbox[1] - oY) / imageResY),
                Math.round((bbox[2] - oX) / imageResX),
                Math.round((bbox[3] - oY) / imageResY), 
            ];
            wnd = [
                Math.min(wnd[0], wnd[2]),
                Math.min(wnd[1], wnd[3]),
                Math.max(wnd[0], wnd[2]),
                Math.max(wnd[1], wnd[3]), 
            ];
        }
        return usedImage.readRasters({
            ...options,
            window: wnd
        });
    }
}
/**
 * The abstraction for a whole GeoTIFF file.
 * @augments GeoTIFFBase
 */ class GeoTIFF extends GeoTIFFBase {
    /**
   * @constructor
   * @param {Source} source The datasource to read from.
   * @param {Boolean} littleEndian Whether the image uses little endian.
   * @param {Boolean} bigTiff Whether the image uses bigTIFF conventions.
   * @param {Number} firstIFDOffset The numeric byte-offset from the start of the image
   *                                to the first IFD.
   * @param {Object} [options] further options.
   * @param {Boolean} [options.cache=false] whether or not decoded tiles shall be cached.
   */ constructor(source1, littleEndian, bigTiff, firstIFDOffset, options1 = {
    }){
        super();
        this.source = source1;
        this.littleEndian = littleEndian;
        this.bigTiff = bigTiff;
        this.firstIFDOffset = firstIFDOffset;
        this.cache = options1.cache || false;
        this.ifdRequests = [];
        this.ghostValues = null;
    }
    async getSlice(offset, size) {
        const fallbackSize = this.bigTiff ? 4048 : 1024;
        return new _datasliceDefault.default((await this.source.fetch([
            {
                offset,
                length: typeof size !== 'undefined' ? size : fallbackSize
            }
        ]))[0], offset, this.littleEndian, this.bigTiff);
    }
    /**
   * Instructs to parse an image file directory at the given file offset.
   * As there is no way to ensure that a location is indeed the start of an IFD,
   * this function must be called with caution (e.g only using the IFD offsets from
   * the headers or other IFDs).
   * @param {number} offset the offset to parse the IFD at
   * @returns {ImageFileDirectory} the parsed IFD
   */ async parseFileDirectoryAt(offset) {
        const entrySize = this.bigTiff ? 20 : 12;
        const offsetSize = this.bigTiff ? 8 : 2;
        let dataSlice = await this.getSlice(offset);
        const numDirEntries = this.bigTiff ? dataSlice.readUint64(offset) : dataSlice.readUint16(offset);
        // if the slice does not cover the whole IFD, request a bigger slice, where the
        // whole IFD fits: num of entries + n x tag length + offset to next IFD
        const byteSize = numDirEntries * entrySize + (this.bigTiff ? 16 : 6);
        if (!dataSlice.covers(offset, byteSize)) dataSlice = await this.getSlice(offset, byteSize);
        const fileDirectory1 = {
        };
        // loop over the IFD and create a file directory object
        let i = offset + (this.bigTiff ? 8 : 2);
        for(let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount){
            const fieldTag = dataSlice.readUint16(i);
            const fieldType = dataSlice.readUint16(i + 2);
            const typeCount = this.bigTiff ? dataSlice.readUint64(i + 4) : dataSlice.readUint32(i + 4);
            let fieldValues;
            let value;
            const fieldTypeLength = getFieldTypeLength(fieldType);
            const valueOffset = i + (this.bigTiff ? 12 : 8);
            // check whether the value is directly encoded in the tag or refers to a
            // different external byte range
            if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);
            else {
                // resolve the reference to the actual byte range
                const actualOffset = dataSlice.readOffset(valueOffset);
                const length = getFieldTypeLength(fieldType) * typeCount;
                // check, whether we actually cover the referenced byte range; if not,
                // request a new slice of bytes to read from it
                if (dataSlice.covers(actualOffset, length)) fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);
                else {
                    const fieldDataSlice = await this.getSlice(actualOffset, length);
                    fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);
                }
            }
            // unpack single values from the array
            if (typeCount === 1 && _globals.arrayFields.indexOf(fieldTag) === -1 && !(fieldType === _globals.fieldTypes.RATIONAL || fieldType === _globals.fieldTypes.SRATIONAL)) value = fieldValues[0];
            else value = fieldValues;
            // write the tags value to the file directly
            fileDirectory1[_globals.fieldTagNames[fieldTag]] = value;
        }
        const geoKeyDirectory1 = parseGeoKeyDirectory(fileDirectory1);
        const nextIFDByteOffset1 = dataSlice.readOffset(offset + offsetSize + entrySize * numDirEntries);
        return new ImageFileDirectory(fileDirectory1, geoKeyDirectory1, nextIFDByteOffset1);
    }
    async requestIFD(index) {
        // see if we already have that IFD index requested.
        if (this.ifdRequests[index]) // attach to an already requested IFD
        return this.ifdRequests[index];
        else if (index === 0) {
            // special case for index 0
            this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);
            return this.ifdRequests[index];
        } else if (!this.ifdRequests[index - 1]) // if the previous IFD was not yet loaded, load that one first
        // this is the recursive call.
        try {
            this.ifdRequests[index - 1] = this.requestIFD(index - 1);
        } catch (e) {
            // if the previous one already was an index error, rethrow
            // with the current index
            if (e instanceof GeoTIFFImageIndexError) throw new GeoTIFFImageIndexError(index);
            // rethrow anything else
            throw e;
        }
        // if the previous IFD was loaded, we can finally fetch the one we are interested in.
        // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed
        this.ifdRequests[index] = (async ()=>{
            const previousIfd = await this.ifdRequests[index - 1];
            if (previousIfd.nextIFDByteOffset === 0) throw new GeoTIFFImageIndexError(index);
            return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);
        })();
        return this.ifdRequests[index];
    }
    /**
   * Get the n-th internal subfile of an image. By default, the first is returned.
   *
   * @param {Number} [index=0] the index of the image to return.
   * @returns {GeoTIFFImage} the image at the given index
   */ async getImage(index = 0) {
        const ifd = await this.requestIFD(index);
        return new _geotiffimageDefault.default(ifd.fileDirectory, ifd.geoKeyDirectory, this.dataView, this.littleEndian, this.cache, this.source);
    }
    /**
   * Returns the count of the internal subfiles.
   *
   * @returns {Number} the number of internal subfile images
   */ async getImageCount() {
        let index2 = 0;
        // loop until we run out of IFDs
        let hasNext = true;
        while(hasNext)try {
            await this.requestIFD(index2);
            ++index2;
        } catch (e) {
            if (e instanceof GeoTIFFImageIndexError) hasNext = false;
            else throw e;
        }
        return index2;
    }
    /**
   * Get the values of the COG ghost area as a parsed map.
   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference
   * @returns {Object} the parsed ghost area or null, if no such area was found
   */ async getGhostValues() {
        const offset = this.bigTiff ? 16 : 8;
        if (this.ghostValues) return this.ghostValues;
        const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';
        const heuristicAreaSize = detectionString.length + 100;
        let slice = await this.getSlice(offset, heuristicAreaSize);
        if (detectionString === getValues(slice, _globals.fieldTypes.ASCII, detectionString.length, offset)) {
            const valuesString = getValues(slice, _globals.fieldTypes.ASCII, heuristicAreaSize, offset);
            const firstLine = valuesString.split('\n')[0];
            const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;
            if (metadataSize > heuristicAreaSize) slice = await this.getSlice(offset, metadataSize);
            const fullString = getValues(slice, _globals.fieldTypes.ASCII, metadataSize, offset);
            this.ghostValues = {
            };
            fullString.split('\n').filter((line)=>line.length > 0
            ).map((line)=>line.split('=')
            ).forEach(([key, value])=>{
                this.ghostValues[key] = value;
            });
        }
        return this.ghostValues;
    }
    /**
   * Parse a (Geo)TIFF file from the given source.
   *
   * @param {source~Source} source The source of data to parse from.
   * @param {object} options Additional options.
   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
   *                               to be aborted
   */ static async fromSource(source, options, signal) {
        const headerData = (await source.fetch([
            {
                offset: 0,
                length: 1024
            }
        ], signal))[0];
        const dataView = new _dataview64Default.default(headerData);
        const BOM = dataView.getUint16(0, 0);
        let littleEndian1;
        if (BOM === 18761) littleEndian1 = true;
        else if (BOM === 19789) littleEndian1 = false;
        else throw new TypeError('Invalid byte order value.');
        const magicNumber = dataView.getUint16(2, littleEndian1);
        let bigTiff1;
        if (magicNumber === 42) bigTiff1 = false;
        else if (magicNumber === 43) {
            bigTiff1 = true;
            const offsetByteSize = dataView.getUint16(4, littleEndian1);
            if (offsetByteSize !== 8) throw new Error('Unsupported offset byte-size.');
        } else throw new TypeError('Invalid magic number.');
        const firstIFDOffset1 = bigTiff1 ? dataView.getUint64(8, littleEndian1) : dataView.getUint32(4, littleEndian1);
        return new GeoTIFF(source, littleEndian1, bigTiff1, firstIFDOffset1, options);
    }
    /**
   * Closes the underlying file buffer
   * N.B. After the GeoTIFF has been completely processed it needs
   * to be closed but only if it has been constructed from a file.
   */ close() {
        if (typeof this.source.close === 'function') return this.source.close();
        return false;
    }
}
exports.default = GeoTIFF;
/**
 * Wrapper for GeoTIFF files that have external overviews.
 * @augments GeoTIFFBase
 */ class MultiGeoTIFF extends GeoTIFFBase {
    /**
   * Construct a new MultiGeoTIFF from a main and several overview files.
   * @param {GeoTIFF} mainFile The main GeoTIFF file.
   * @param {GeoTIFF[]} overviewFiles An array of overview files.
   */ constructor(mainFile, overviewFiles){
        super();
        this.mainFile = mainFile;
        this.overviewFiles = overviewFiles;
        this.imageFiles = [
            mainFile
        ].concat(overviewFiles);
        this.fileDirectoriesPerFile = null;
        this.fileDirectoriesPerFileParsing = null;
        this.imageCount = null;
    }
    async parseFileDirectoriesPerFile() {
        const requests = [
            this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)
        ].concat(this.overviewFiles.map((file)=>file.parseFileDirectoryAt(file.firstIFDOffset)
        ));
        this.fileDirectoriesPerFile = await Promise.all(requests);
        return this.fileDirectoriesPerFile;
    }
    /**
   * Get the n-th internal subfile of an image. By default, the first is returned.
   *
   * @param {Number} [index=0] the index of the image to return.
   * @returns {GeoTIFFImage} the image at the given index
   */ async getImage(index = 0) {
        await this.getImageCount();
        await this.parseFileDirectoriesPerFile();
        let visited = 0;
        let relativeIndex = 0;
        for(let i = 0; i < this.imageFiles.length; i++){
            const imageFile = this.imageFiles[i];
            for(let ii = 0; ii < this.imageCounts[i]; ii++){
                if (index === visited) {
                    const ifd = await imageFile.requestIFD(relativeIndex);
                    return new _geotiffimageDefault.default(ifd.fileDirectory, ifd.geoKeyDirectory, imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source);
                }
                visited++;
                relativeIndex++;
            }
            relativeIndex = 0;
        }
        throw new RangeError('Invalid image index');
    }
    /**
   * Returns the count of the internal subfiles.
   *
   * @returns {Number} the number of internal subfile images
   */ async getImageCount() {
        if (this.imageCount !== null) return this.imageCount;
        const requests = [
            this.mainFile.getImageCount()
        ].concat(this.overviewFiles.map((file)=>file.getImageCount()
        ));
        this.imageCounts = await Promise.all(requests);
        this.imageCount = this.imageCounts.reduce((count, ifds)=>count + ifds
        , 0);
        return this.imageCount;
    }
}
async function fromUrl(url, options2 = {
}, signal) {
    return GeoTIFF.fromSource(_remote.makeRemoteSource(url, options2), signal);
}
async function fromArrayBuffer(arrayBuffer, signal) {
    return GeoTIFF.fromSource(_arraybuffer.makeBufferSource(arrayBuffer), signal);
}
async function fromFile(path, signal) {
    return GeoTIFF.fromSource(_file.makeFileSource(path), signal);
}
async function fromBlob(blob, signal) {
    return GeoTIFF.fromSource(_filereader.makeFileReaderSource(blob), signal);
}
async function fromUrls(mainUrl, overviewUrls = [], options2 = {
}, signal) {
    const mainFile1 = await GeoTIFF.fromSource(_remote.makeRemoteSource(mainUrl, options2), signal);
    const overviewFiles1 = await Promise.all(overviewUrls.map((url)=>GeoTIFF.fromSource(_remote.makeRemoteSource(url, options2))
    ));
    return new MultiGeoTIFF(mainFile1, overviewFiles1);
}
async function writeArrayBuffer(values, metadata) {
    return _geotiffwriter.writeGeotiff(values, metadata);
}

},{"./geotiffimage":"dqrTS","./dataview64":"wo5NL","./dataslice":"X7Rz0","./pool":"Zx1V5","./source/remote":"dp4t9","./source/arraybuffer":"bT2m1","./source/filereader":"7tsyU","./source/file":"4ps70","./globals":"jLznT","./geotiffwriter":"loqav","./rgb":"ixq6a","./compression":"eETM6","./logging":"12SlZ","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"dqrTS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint max-len: ["error", { "code": 120 }] */ var _float16 = require("@petamoriken/float16");
var _txml = require("txml/txml");
var _globals = require("./globals");
var _rgb = require("./rgb");
var _compression = require("./compression");
var _resample = require("./resample");
function sum(array, start, end) {
    let s = 0;
    for(let i = start; i < end; ++i)s += array[i];
    return s;
}
function arrayForType(format, bitsPerSample, size) {
    switch(format){
        case 1:
            if (bitsPerSample <= 8) return new Uint8Array(size);
            else if (bitsPerSample <= 16) return new Uint16Array(size);
            else if (bitsPerSample <= 32) return new Uint32Array(size);
            break;
        case 2:
            if (bitsPerSample === 8) return new Int8Array(size);
            else if (bitsPerSample === 16) return new Int16Array(size);
            else if (bitsPerSample === 32) return new Int32Array(size);
            break;
        case 3:
            switch(bitsPerSample){
                case 16:
                case 32:
                    return new Float32Array(size);
                case 64:
                    return new Float64Array(size);
                default:
                    break;
            }
            break;
        default:
            break;
    }
    throw Error('Unsupported data format/bitsPerSample');
}
function needsNormalization(format, bitsPerSample) {
    if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) return false;
    else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) return false;
    return true;
}
function normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {
    // const inByteArray = new Uint8Array(inBuffer);
    const view = new DataView(inBuffer);
    const outSize = planarConfiguration === 2 ? tileHeight * tileWidth : tileHeight * tileWidth * samplesPerPixel;
    const samplesToTransfer = planarConfiguration === 2 ? 1 : samplesPerPixel;
    const outArray = arrayForType(format, bitsPerSample, outSize);
    // let pixel = 0;
    const bitMask = parseInt('1'.repeat(bitsPerSample), 2);
    if (format === 1) {
        // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337
        let pixelBitSkip;
        // let sampleBitOffset = 0;
        if (planarConfiguration === 1) pixelBitSkip = samplesPerPixel * bitsPerSample;
        else pixelBitSkip = bitsPerSample;
        // Bits per line rounds up to next byte boundary.
        let bitsPerLine = tileWidth * pixelBitSkip;
        if ((bitsPerLine & 7) !== 0) bitsPerLine = bitsPerLine + 7 & -8;
        for(let y = 0; y < tileHeight; ++y){
            const lineBitOffset = y * bitsPerLine;
            for(let x = 0; x < tileWidth; ++x){
                const pixelBitOffset = lineBitOffset + x * samplesToTransfer * bitsPerSample;
                for(let i = 0; i < samplesToTransfer; ++i){
                    const bitOffset = pixelBitOffset + i * bitsPerSample;
                    const outIndex = (y * tileWidth + x) * samplesToTransfer + i;
                    const byteOffset = Math.floor(bitOffset / 8);
                    const innerBitOffset = bitOffset % 8;
                    if (innerBitOffset + bitsPerSample <= 8) outArray[outIndex] = view.getUint8(byteOffset) >> 8 - bitsPerSample - innerBitOffset & bitMask;
                    else if (innerBitOffset + bitsPerSample <= 16) outArray[outIndex] = view.getUint16(byteOffset) >> 16 - bitsPerSample - innerBitOffset & bitMask;
                    else if (innerBitOffset + bitsPerSample <= 24) {
                        const raw = view.getUint16(byteOffset) << 8 | view.getUint8(byteOffset + 2);
                        outArray[outIndex] = raw >> 24 - bitsPerSample - innerBitOffset & bitMask;
                    } else outArray[outIndex] = view.getUint32(byteOffset) >> 32 - bitsPerSample - innerBitOffset & bitMask;
                // let outWord = 0;
                // for (let bit = 0; bit < bitsPerSample; ++bit) {
                //   if (inByteArray[bitOffset >> 3]
                //     & (0x80 >> (bitOffset & 7))) {
                //     outWord |= (1 << (bitsPerSample - 1 - bit));
                //   }
                //   ++bitOffset;
                // }
                // outArray[outIndex] = outWord;
                // outArray[pixel] = outWord;
                // pixel += 1;
                }
            // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;
            }
        }
    }
    return outArray.buffer;
}
/**
 * GeoTIFF sub-file image.
 */ class GeoTIFFImage {
    /**
   * @constructor
   * @param {Object} fileDirectory The parsed file directory
   * @param {Object} geoKeys The parsed geo-keys
   * @param {DataView} dataView The DataView for the underlying file.
   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian
   * @param {Boolean} cache Whether or not decoded tiles shall be cached
   * @param {Source} source The datasource to read from
   */ constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source){
        this.fileDirectory = fileDirectory;
        this.geoKeys = geoKeys;
        this.dataView = dataView;
        this.littleEndian = littleEndian;
        this.tiles = cache ? {
        } : null;
        this.isTiled = !fileDirectory.StripOffsets;
        const planarConfiguration = fileDirectory.PlanarConfiguration;
        this.planarConfiguration = typeof planarConfiguration === 'undefined' ? 1 : planarConfiguration;
        if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) throw new Error('Invalid planar configuration.');
        this.source = source;
    }
    /**
   * Returns the associated parsed file directory.
   * @returns {Object} the parsed file directory
   */ getFileDirectory() {
        return this.fileDirectory;
    }
    /**
   * Returns the associated parsed geo keys.
   * @returns {Object} the parsed geo keys
   */ getGeoKeys() {
        return this.geoKeys;
    }
    /**
   * Returns the width of the image.
   * @returns {Number} the width of the image
   */ getWidth() {
        return this.fileDirectory.ImageWidth;
    }
    /**
   * Returns the height of the image.
   * @returns {Number} the height of the image
   */ getHeight() {
        return this.fileDirectory.ImageLength;
    }
    /**
   * Returns the number of samples per pixel.
   * @returns {Number} the number of samples per pixel
   */ getSamplesPerPixel() {
        return typeof this.fileDirectory.SamplesPerPixel !== 'undefined' ? this.fileDirectory.SamplesPerPixel : 1;
    }
    /**
   * Returns the width of each tile.
   * @returns {Number} the width of each tile
   */ getTileWidth() {
        return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();
    }
    /**
   * Returns the height of each tile.
   * @returns {Number} the height of each tile
   */ getTileHeight() {
        if (this.isTiled) return this.fileDirectory.TileLength;
        if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());
        return this.getHeight();
    }
    getBlockWidth() {
        return this.getTileWidth();
    }
    getBlockHeight(y) {
        if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) return this.getTileHeight();
        else return this.getHeight() - y * this.getTileHeight();
    }
    /**
   * Calculates the number of bytes for each pixel across all samples. Only full
   * bytes are supported, an exception is thrown when this is not the case.
   * @returns {Number} the bytes per pixel
   */ getBytesPerPixel() {
        let bytes = 0;
        for(let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i)bytes += this.getSampleByteSize(i);
        return bytes;
    }
    getSampleByteSize(i) {
        if (i >= this.fileDirectory.BitsPerSample.length) throw new RangeError(`Sample index ${i} is out of range.`);
        return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);
    }
    getReaderForSample(sampleIndex) {
        const format = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;
        const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];
        switch(format){
            case 1:
                if (bitsPerSample <= 8) return DataView.prototype.getUint8;
                else if (bitsPerSample <= 16) return DataView.prototype.getUint16;
                else if (bitsPerSample <= 32) return DataView.prototype.getUint32;
                break;
            case 2:
                if (bitsPerSample <= 8) return DataView.prototype.getInt8;
                else if (bitsPerSample <= 16) return DataView.prototype.getInt16;
                else if (bitsPerSample <= 32) return DataView.prototype.getInt32;
                break;
            case 3:
                switch(bitsPerSample){
                    case 16:
                        return function(offset, littleEndian1) {
                            return _float16.getFloat16(this, offset, littleEndian1);
                        };
                    case 32:
                        return DataView.prototype.getFloat32;
                    case 64:
                        return DataView.prototype.getFloat64;
                    default:
                        break;
                }
                break;
            default:
                break;
        }
        throw Error('Unsupported data format/bitsPerSample');
    }
    getSampleFormat(sampleIndex = 0) {
        return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;
    }
    getBitsPerSample(sampleIndex = 0) {
        return this.fileDirectory.BitsPerSample[sampleIndex];
    }
    getArrayForSample(sampleIndex, size) {
        const format = this.getSampleFormat(sampleIndex);
        const bitsPerSample = this.getBitsPerSample(sampleIndex);
        return arrayForType(format, bitsPerSample, size);
    }
    /**
   * Returns the decoded strip or tile.
   * @param {Number} x the strip or tile x-offset
   * @param {Number} y the tile y-offset (0 for stripped images)
   * @param {Number} sample the sample to get for separated samples
   * @param {Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool
   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
   *                               to be aborted
   * @returns {Promise.<ArrayBuffer>}
   */ async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {
        const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());
        const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());
        let index;
        const { tiles  } = this;
        if (this.planarConfiguration === 1) index = y * numTilesPerRow + x;
        else if (this.planarConfiguration === 2) index = sample * numTilesPerRow * numTilesPerCol + y * numTilesPerRow + x;
        let offset;
        let byteCount;
        if (this.isTiled) {
            offset = this.fileDirectory.TileOffsets[index];
            byteCount = this.fileDirectory.TileByteCounts[index];
        } else {
            offset = this.fileDirectory.StripOffsets[index];
            byteCount = this.fileDirectory.StripByteCounts[index];
        }
        const slice = (await this.source.fetch([
            {
                offset,
                length: byteCount
            }
        ], signal))[0];
        let request;
        if (tiles === null || !tiles[index]) {
            // resolve each request by potentially applying array normalization
            request = (async ()=>{
                let data = await poolOrDecoder.decode(this.fileDirectory, slice);
                const sampleFormat = this.getSampleFormat();
                const bitsPerSample = this.getBitsPerSample();
                if (needsNormalization(sampleFormat, bitsPerSample)) data = normalizeArray(data, sampleFormat, this.planarConfiguration, this.getSamplesPerPixel(), bitsPerSample, this.getTileWidth(), this.getBlockHeight(y));
                return data;
            })();
            // set the cache
            if (tiles !== null) tiles[index] = request;
        } else // get from the cache
        request = tiles[index];
        // cache the tile request
        return {
            x,
            y,
            sample,
            data: await request
        };
    }
    /**
   * Internal read function.
   * @private
   * @param {Array} imageWindow The image window in pixel coordinates
   * @param {Array} samples The selected samples (0-based indices)
   * @param {TypedArray[]|TypedArray} valueArrays The array(s) to write into
   * @param {Boolean} interleave Whether or not to write in an interleaved manner
   * @param {Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool
   * @param {number} width the width of window to be read into
   * @param {number} height the height of window to be read into
   * @param {number} resampleMethod the resampling method to be used when interpolating
   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is
   *                               to be aborted
   * @returns {Promise<TypedArray[]>|Promise<TypedArray>}
   */ async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal) {
        const tileWidth = this.getTileWidth();
        const tileHeight = this.getTileHeight();
        const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);
        const maxXTile = Math.min(Math.ceil(imageWindow[2] / tileWidth), Math.ceil(this.getWidth() / this.getTileWidth()));
        const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);
        const maxYTile = Math.min(Math.ceil(imageWindow[3] / tileHeight), Math.ceil(this.getHeight() / this.getTileHeight()));
        const windowWidth = imageWindow[2] - imageWindow[0];
        let bytesPerPixel = this.getBytesPerPixel();
        const srcSampleOffsets = [];
        const sampleReaders = [];
        for(let i = 0; i < samples.length; ++i){
            if (this.planarConfiguration === 1) srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);
            else srcSampleOffsets.push(0);
            sampleReaders.push(this.getReaderForSample(samples[i]));
        }
        const promises = [];
        const { littleEndian: littleEndian1  } = this;
        for(let yTile = minYTile; yTile < maxYTile; ++yTile){
            for(let xTile = minXTile; xTile < maxXTile; ++xTile)for(let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex){
                const si = sampleIndex;
                const sample = samples[sampleIndex];
                if (this.planarConfiguration === 2) bytesPerPixel = this.getSampleByteSize(sampleIndex);
                const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);
                promises.push(promise);
                promise.then((tile)=>{
                    const buffer = tile.data;
                    const dataView1 = new DataView(buffer);
                    const blockHeight = this.getBlockHeight(tile.y);
                    const firstLine = tile.y * tileHeight;
                    const firstCol = tile.x * tileWidth;
                    const lastLine = firstLine + blockHeight;
                    const lastCol = (tile.x + 1) * tileWidth;
                    const reader = sampleReaders[si];
                    const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]));
                    const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]));
                    for(let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y)for(let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x){
                        const pixelOffset = (y * tileWidth + x) * bytesPerPixel;
                        const value = reader.call(dataView1, pixelOffset + srcSampleOffsets[si], littleEndian1);
                        let windowCoordinate;
                        if (interleave) {
                            windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth * samples.length + (x + firstCol - imageWindow[0]) * samples.length + si;
                            valueArrays[windowCoordinate] = value;
                        } else {
                            windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth + x + firstCol - imageWindow[0];
                            valueArrays[si][windowCoordinate] = value;
                        }
                    }
                });
            }
        }
        await Promise.all(promises);
        if (width && imageWindow[2] - imageWindow[0] !== width || height && imageWindow[3] - imageWindow[1] !== height) {
            let resampled;
            if (interleave) resampled = _resample.resampleInterleaved(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, samples.length, resampleMethod);
            else resampled = _resample.resample(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, resampleMethod);
            resampled.width = width;
            resampled.height = height;
            return resampled;
        }
        valueArrays.width = width || imageWindow[2] - imageWindow[0];
        valueArrays.height = height || imageWindow[3] - imageWindow[1];
        return valueArrays;
    }
    /**
   * Reads raster data from the image. This function reads all selected samples
   * into separate arrays of the correct type for that sample or into a single
   * combined array when `interleave` is set. When provided, only a subset
   * of the raster is read for each sample.
   *
   * @param {Object} [options={}] optional parameters
   * @param {Array} [options.window=whole image] the subset to read data from.
   * @param {Array} [options.samples=all samples] the selection of samples to read from.
   * @param {Boolean} [options.interleave=false] whether the data shall be read
   *                                             in one single array or separate
   *                                             arrays.
   * @param {Number} [options.pool=null] The optional decoder pool to use.
   * @param {number} [options.width] The desired width of the output. When the width is
   *                                 not the same as the images, resampling will be
   *                                 performed.
   * @param {number} [options.height] The desired height of the output. When the width
   *                                  is not the same as the images, resampling will
   *                                  be performed.
   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.
   * @param {number|number[]} [options.fillValue] The value to use for parts of the image
   *                                              outside of the images extent. When
   *                                              multiple samples are requested, an
   *                                              array of fill values can be passed.
   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is
   *                                       to be aborted
   * @returns {Promise.<(TypedArray|TypedArray[])>} the decoded arrays as a promise
   */ async readRasters({ window: wnd , samples =[] , interleave , pool =null , width , height , resampleMethod , fillValue , signal ,  } = {
    }) {
        const imageWindow = wnd || [
            0,
            0,
            this.getWidth(),
            this.getHeight()
        ];
        // check parameters
        if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) throw new Error('Invalid subsets');
        const imageWindowWidth = imageWindow[2] - imageWindow[0];
        const imageWindowHeight = imageWindow[3] - imageWindow[1];
        const numPixels = imageWindowWidth * imageWindowHeight;
        const samplesPerPixel = this.getSamplesPerPixel();
        if (!samples || !samples.length) for(let i = 0; i < samplesPerPixel; ++i)samples.push(i);
        else for(let i1 = 0; i1 < samples.length; ++i1){
            if (samples[i1] >= samplesPerPixel) return Promise.reject(new RangeError(`Invalid sample index '${samples[i1]}'.`));
        }
        let valueArrays;
        if (interleave) {
            const format = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;
            const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);
            valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);
            if (fillValue) valueArrays.fill(fillValue);
        } else {
            valueArrays = [];
            for(let i2 = 0; i2 < samples.length; ++i2){
                const valueArray = this.getArrayForSample(samples[i2], numPixels);
                if (Array.isArray(fillValue) && i2 < fillValue.length) valueArray.fill(fillValue[i2]);
                else if (fillValue && !Array.isArray(fillValue)) valueArray.fill(fillValue);
                valueArrays.push(valueArray);
            }
        }
        const poolOrDecoder = pool || await _compression.getDecoder(this.fileDirectory);
        const result = await this._readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal);
        return result;
    }
    /**
   * Reads raster data from the image as RGB. The result is always an
   * interleaved typed array.
   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.
   * When no other method is applicable, the first sample is used to produce a
   * greayscale image.
   * When provided, only a subset of the raster is read for each sample.
   *
   * @param {Object} [options] optional parameters
   * @param {Array} [options.window=whole image] the subset to read data from.
   * @param {Boolean} [options.interleave=true] whether the data shall be read
   *                                             in one single array or separate
   *                                             arrays.
   * @param {Number} [options.pool=null] The optional decoder pool to use.
   * @param {number} [options.width] The desired width of the output. When the width is no the
   *                                 same as the images, resampling will be performed.
   * @param {number} [options.height] The desired height of the output. When the width is no the
   *                                  same as the images, resampling will be performed.
   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.
   * @param {bool} [options.enableAlpha=false] Enable reading alpha channel if present.
   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is
   *                                       to be aborted
   * @returns {Promise.<TypedArray|TypedArray[]>} the RGB array as a Promise
   */ async readRGB({ window , interleave =true , pool =null , width , height , resampleMethod , enableAlpha =false , signal  } = {
    }) {
        const imageWindow = window || [
            0,
            0,
            this.getWidth(),
            this.getHeight()
        ];
        // check parameters
        if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) throw new Error('Invalid subsets');
        const pi = this.fileDirectory.PhotometricInterpretation;
        if (pi === _globals.photometricInterpretations.RGB) {
            let s = [
                0,
                1,
                2
            ];
            if (!(this.fileDirectory.ExtraSamples === _globals.ExtraSamplesValues.Unspecified) && enableAlpha) {
                s = [];
                for(let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1)s.push(i);
            }
            return this.readRasters({
                window,
                interleave,
                samples: s,
                pool,
                width,
                height,
                resampleMethod,
                signal
            });
        }
        let samples;
        switch(pi){
            case _globals.photometricInterpretations.WhiteIsZero:
            case _globals.photometricInterpretations.BlackIsZero:
            case _globals.photometricInterpretations.Palette:
                samples = [
                    0
                ];
                break;
            case _globals.photometricInterpretations.CMYK:
                samples = [
                    0,
                    1,
                    2,
                    3
                ];
                break;
            case _globals.photometricInterpretations.YCbCr:
            case _globals.photometricInterpretations.CIELab:
                samples = [
                    0,
                    1,
                    2
                ];
                break;
            default:
                throw new Error('Invalid or unsupported photometric interpretation.');
        }
        const subOptions = {
            window: imageWindow,
            interleave: true,
            samples,
            pool,
            width,
            height,
            resampleMethod,
            signal
        };
        const { fileDirectory: fileDirectory1  } = this;
        const raster = await this.readRasters(subOptions);
        const max = 2 ** this.fileDirectory.BitsPerSample[0];
        let data;
        switch(pi){
            case _globals.photometricInterpretations.WhiteIsZero:
                data = _rgb.fromWhiteIsZero(raster, max);
                break;
            case _globals.photometricInterpretations.BlackIsZero:
                data = _rgb.fromBlackIsZero(raster, max);
                break;
            case _globals.photometricInterpretations.Palette:
                data = _rgb.fromPalette(raster, fileDirectory1.ColorMap);
                break;
            case _globals.photometricInterpretations.CMYK:
                data = _rgb.fromCMYK(raster);
                break;
            case _globals.photometricInterpretations.YCbCr:
                data = _rgb.fromYCbCr(raster);
                break;
            case _globals.photometricInterpretations.CIELab:
                data = _rgb.fromCIELab(raster);
                break;
            default:
                throw new Error('Unsupported photometric interpretation.');
        }
        // if non-interleaved data is requested, we must split the channels
        // into their respective arrays
        if (!interleave) {
            const red = new Uint8Array(data.length / 3);
            const green = new Uint8Array(data.length / 3);
            const blue = new Uint8Array(data.length / 3);
            for(let i = 0, j = 0; i < data.length; i += 3, ++j){
                red[j] = data[i];
                green[j] = data[i + 1];
                blue[j] = data[i + 2];
            }
            data = [
                red,
                green,
                blue
            ];
        }
        data.width = raster.width;
        data.height = raster.height;
        return data;
    }
    /**
   * Returns an array of tiepoints.
   * @returns {Object[]}
   */ getTiePoints() {
        if (!this.fileDirectory.ModelTiepoint) return [];
        const tiePoints = [];
        for(let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6)tiePoints.push({
            i: this.fileDirectory.ModelTiepoint[i],
            j: this.fileDirectory.ModelTiepoint[i + 1],
            k: this.fileDirectory.ModelTiepoint[i + 2],
            x: this.fileDirectory.ModelTiepoint[i + 3],
            y: this.fileDirectory.ModelTiepoint[i + 4],
            z: this.fileDirectory.ModelTiepoint[i + 5]
        });
        return tiePoints;
    }
    /**
   * Returns the parsed GDAL metadata items.
   *
   * If sample is passed to null, dataset-level metadata will be returned.
   * Otherwise only metadata specific to the provided sample will be returned.
   *
   * @param {Number} [sample=null] The sample index.
   * @returns {Object}
   */ getGDALMetadata(sample = null) {
        const metadata = {
        };
        if (!this.fileDirectory.GDAL_METADATA) return null;
        const string = this.fileDirectory.GDAL_METADATA;
        const xmlDom = _txml.parse(string.substring(0, string.length - 1));
        if (!xmlDom[0].tagName) throw new Error('Failed to parse GDAL metadata XML.');
        const root = xmlDom[0];
        if (root.tagName !== 'GDALMetadata') throw new Error('Unexpected GDAL metadata XML tag.');
        let items = root.children.filter((child)=>child.tagName === 'Item'
        );
        if (sample !== null) items = items.filter((item)=>Number(item.attributes.sample) === sample
        );
        for(let i = 0; i < items.length; ++i){
            const item = items[i];
            metadata[item.attributes.name] = item.children[0];
        }
        return metadata;
    }
    /**
   * Returns the GDAL nodata value
   * @returns {Number} or null
   */ getGDALNoData() {
        if (!this.fileDirectory.GDAL_NODATA) return null;
        const string = this.fileDirectory.GDAL_NODATA;
        return Number(string.substring(0, string.length - 1));
    }
    /**
   * Returns the image origin as a XYZ-vector. When the image has no affine
   * transformation, then an exception is thrown.
   * @returns {Array} The origin as a vector
   */ getOrigin() {
        const tiePoints = this.fileDirectory.ModelTiepoint;
        const modelTransformation = this.fileDirectory.ModelTransformation;
        if (tiePoints && tiePoints.length === 6) return [
            tiePoints[3],
            tiePoints[4],
            tiePoints[5], 
        ];
        if (modelTransformation) return [
            modelTransformation[3],
            modelTransformation[7],
            modelTransformation[11], 
        ];
        throw new Error('The image does not have an affine transformation.');
    }
    /**
   * Returns the image resolution as a XYZ-vector. When the image has no affine
   * transformation, then an exception is thrown.
   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from
   *                                             in cases when the current image does not have the
   *                                             required tags on its own.
   * @returns {Array} The resolution as a vector
   */ getResolution(referenceImage = null) {
        const modelPixelScale = this.fileDirectory.ModelPixelScale;
        const modelTransformation = this.fileDirectory.ModelTransformation;
        if (modelPixelScale) return [
            modelPixelScale[0],
            -modelPixelScale[1],
            modelPixelScale[2], 
        ];
        if (modelTransformation) return [
            modelTransformation[0],
            modelTransformation[5],
            modelTransformation[10], 
        ];
        if (referenceImage) {
            const [refResX, refResY, refResZ] = referenceImage.getResolution();
            return [
                refResX * referenceImage.getWidth() / this.getWidth(),
                refResY * referenceImage.getHeight() / this.getHeight(),
                refResZ * referenceImage.getWidth() / this.getWidth(), 
            ];
        }
        throw new Error('The image does not have an affine transformation.');
    }
    /**
   * Returns whether or not the pixels of the image depict an area (or point).
   * @returns {Boolean} Whether the pixels are a point
   */ pixelIsArea() {
        return this.geoKeys.GTRasterTypeGeoKey === 1;
    }
    /**
   * Returns the image bounding box as an array of 4 values: min-x, min-y,
   * max-x and max-y. When the image has no affine transformation, then an
   * exception is thrown.
   * @returns {Array} The bounding box
   */ getBoundingBox() {
        const origin = this.getOrigin();
        const resolution = this.getResolution();
        const x1 = origin[0];
        const y1 = origin[1];
        const x2 = x1 + resolution[0] * this.getWidth();
        const y2 = y1 + resolution[1] * this.getHeight();
        return [
            Math.min(x1, x2),
            Math.min(y1, y2),
            Math.max(x1, x2),
            Math.max(y1, y2), 
        ];
    }
}
exports.default = GeoTIFFImage;

},{"@petamoriken/float16":"aYQcx","txml/txml":"jIgXl","./globals":"jLznT","./rgb":"ixq6a","./compression":"eETM6","./resample":"6yaYB","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aYQcx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hfround", ()=>_hfroundDefault.default
);
parcelHelpers.export(exports, "Float16Array", ()=>_float16ArrayDefault.default
);
parcelHelpers.export(exports, "getFloat16", ()=>_dataViewJs.getFloat16
);
parcelHelpers.export(exports, "setFloat16", ()=>_dataViewJs.setFloat16
);
var _hfround = require("./hfround");
var _hfroundDefault = parcelHelpers.interopDefault(_hfround);
var _float16Array = require("./Float16Array");
var _float16ArrayDefault = parcelHelpers.interopDefault(_float16Array);
var _dataViewJs = require("./dataView.js");

},{"./hfround":"9ASvC","./Float16Array":"6WCj8","./dataView.js":"9nvLC","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9ASvC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lib = require("./lib");
function hfround(num) {
    num = Number(num);
    // for optimization
    if (!Number.isFinite(num) || num === 0) return num;
    const x16 = _lib.roundToFloat16Bits(num);
    return _lib.convertToNumber(x16);
}
exports.default = hfround;

},{"./lib":"huubr","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"huubr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * round a number to a half float number bits.
 * @param {number} num
 */ parcelHelpers.export(exports, "roundToFloat16Bits", ()=>roundToFloat16Bits
);
/**
 * convert a half float number bits to a number.
 * @param {number} float16bits - half float number bits
 */ parcelHelpers.export(exports, "convertToNumber", ()=>convertToNumber
);
// algorithm: ftp://ftp.fox-toolkit.org/pub/fasthalffloatconversion.pdf
const buffer = new ArrayBuffer(4);
const floatView = new Float32Array(buffer);
const uint32View = new Uint32Array(buffer);
const baseTable = new Uint32Array(512);
const shiftTable = new Uint32Array(512);
for(let i = 0; i < 256; ++i){
    const e = i - 127;
    // very small number (0, -0)
    if (e < -27) {
        baseTable[i | 0] = 0;
        baseTable[i | 256] = 32768;
        shiftTable[i | 0] = 24;
        shiftTable[i | 256] = 24;
    // small number (denorm)
    } else if (e < -14) {
        baseTable[i | 0] = 1024 >> -e - 14;
        baseTable[i | 256] = 1024 >> -e - 14 | 32768;
        shiftTable[i | 0] = -e - 1;
        shiftTable[i | 256] = -e - 1;
    // normal number
    } else if (e <= 15) {
        baseTable[i | 0] = e + 15 << 10;
        baseTable[i | 256] = e + 15 << 10 | 32768;
        shiftTable[i | 0] = 13;
        shiftTable[i | 256] = 13;
    // large number (Infinity, -Infinity)
    } else if (e < 128) {
        baseTable[i | 0] = 31744;
        baseTable[i | 256] = 64512;
        shiftTable[i | 0] = 24;
        shiftTable[i | 256] = 24;
    // stay (NaN, Infinity, -Infinity)
    } else {
        baseTable[i | 0] = 31744;
        baseTable[i | 256] = 64512;
        shiftTable[i | 0] = 13;
        shiftTable[i | 256] = 13;
    }
}
function roundToFloat16Bits(num) {
    floatView[0] = num;
    const f = uint32View[0];
    const e = f >> 23 & 511;
    return baseTable[e] + ((f & 8388607) >> shiftTable[e]);
}
const mantissaTable = new Uint32Array(2048);
const exponentTable = new Uint32Array(64);
const offsetTable = new Uint32Array(64);
mantissaTable[0] = 0;
for(let i1 = 1; i1 < 1024; ++i1){
    let m = i1 << 13; // zero pad mantissa bits
    let e = 0; // zero exponent
    // normalized
    while((m & 8388608) === 0){
        e -= 8388608; // decrement exponent
        m <<= 1;
    }
    m &= -8388609; // clear leading 1 bit
    e += 947912704; // adjust bias
    mantissaTable[i1] = m | e;
}
for(let i2 = 1024; i2 < 2048; ++i2)mantissaTable[i2] = 939524096 + (i2 - 1024 << 13);
exponentTable[0] = 0;
for(let i3 = 1; i3 < 31; ++i3)exponentTable[i3] = i3 << 23;
exponentTable[31] = 1199570944;
exponentTable[32] = 2147483648;
for(let i4 = 33; i4 < 63; ++i4)exponentTable[i4] = 2147483648 + (i4 - 32 << 23);
exponentTable[63] = 3347054592;
offsetTable[0] = 0;
for(let i5 = 1; i5 < 64; ++i5)if (i5 === 32) offsetTable[i5] = 0;
else offsetTable[i5] = 1024;
function convertToNumber(float16bits) {
    const m = float16bits >> 10;
    uint32View[0] = mantissaTable[offsetTable[m] + (float16bits & 1023)] + exponentTable[m];
    return floatView[0];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6WCj8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _spec = require("./spec");
var _is = require("./is");
var _private = require("./private");
var _memoize = require("lodash-es/memoize");
var _memoizeDefault = parcelHelpers.interopDefault(_memoize);
var _lib = require("./lib");
var _bug = require("./bug");
const _ = _private.createPrivateStorage();
function isFloat16Array(target) {
    return target instanceof Float16Array;
}
function assertFloat16Array(target) {
    if (!isFloat16Array(target)) throw new TypeError("This is not a Float16Array");
}
function isDefaultFloat16ArrayMethods(target) {
    return typeof target === "function" && defaultFloat16ArrayMethods.has(target);
}
function copyToArray(float16bits) {
    const length = float16bits.length;
    const array = new Array(length);
    for(let i = 0; i < length; ++i)array[i] = _lib.convertToNumber(float16bits[i]);
    return array;
}
// proxy handler
const applyHandler = {
    apply (func, thisArg, args) {
        // peel off proxy
        if (isFloat16Array(thisArg) && isDefaultFloat16ArrayMethods(func)) return Reflect.apply(func, _(thisArg).target, args);
        return Reflect.apply(func, thisArg, args);
    }
};
const handler = {
    get (target, key) {
        let wrapper = null;
        if (!_bug.isTypedArrayIndexedPropertyWritable) {
            wrapper = target;
            target = _(wrapper).target;
        }
        if (_is.isStringNumberKey(key)) return Reflect.has(target, key) ? _lib.convertToNumber(Reflect.get(target, key)) : undefined;
        else {
            const ret = wrapper !== null && Reflect.has(wrapper, key) ? Reflect.get(wrapper, key) : Reflect.get(target, key);
            if (typeof ret !== "function") return ret;
            // TypedArray methods can't be called by Proxy Object
            let proxy = _(ret).proxy;
            if (proxy === undefined) proxy = _(ret).proxy = new Proxy(ret, applyHandler);
            return proxy;
        }
    },
    set (target, key, value) {
        let wrapper = null;
        if (!_bug.isTypedArrayIndexedPropertyWritable) {
            wrapper = target;
            target = _(wrapper).target;
        }
        if (_is.isStringNumberKey(key)) return Reflect.set(target, key, _lib.roundToFloat16Bits(value));
        else {
            // frozen object can't change prototype property
            if (wrapper !== null && (!Reflect.has(target, key) || Object.isFrozen(wrapper))) return Reflect.set(wrapper, key, value);
            else return Reflect.set(target, key, value);
        }
    }
};
if (!_bug.isTypedArrayIndexedPropertyWritable) {
    handler.getPrototypeOf = (wrapper)=>Reflect.getPrototypeOf(_(wrapper).target)
    ;
    handler.setPrototypeOf = (wrapper, prototype)=>Reflect.setPrototypeOf(_(wrapper).target, prototype)
    ;
    handler.defineProperty = (wrapper, key, descriptor)=>{
        const target = _(wrapper).target;
        return !Reflect.has(target, key) || Object.isFrozen(wrapper) ? Reflect.defineProperty(wrapper, key, descriptor) : Reflect.defineProperty(target, key, descriptor);
    };
    handler.deleteProperty = (wrapper, key)=>{
        const target = _(wrapper).target;
        return Reflect.has(wrapper, key) ? Reflect.deleteProperty(wrapper, key) : Reflect.deleteProperty(target, key);
    };
    handler.has = (wrapper, key)=>Reflect.has(wrapper, key) || Reflect.has(_(wrapper).target, key)
    ;
    handler.isExtensible = (wrapper)=>Reflect.isExtensible(wrapper)
    ;
    handler.preventExtensions = (wrapper)=>Reflect.preventExtensions(wrapper)
    ;
    handler.getOwnPropertyDescriptor = (wrapper, key)=>Reflect.getOwnPropertyDescriptor(wrapper, key)
    ;
    handler.ownKeys = (wrapper)=>Reflect.ownKeys(wrapper)
    ;
}
class Float16Array extends Uint16Array {
    constructor(input1, byteOffset, length){
        // input Float16Array
        if (isFloat16Array(input1)) super(_(input1).target);
        else if (input1 !== null && typeof input1 === "object" && !_is.isArrayBuffer(input1)) {
            // if input is not ArrayLike and Iterable, get Array
            const arrayLike = !Reflect.has(input1, "length") && input1[Symbol.iterator] !== undefined ? [
                ...input1
            ] : input1;
            const length1 = arrayLike.length;
            super(length1);
            for(let i = 0; i < length1; ++i)// super (Uint16Array)
            this[i] = _lib.roundToFloat16Bits(arrayLike[i]);
        // 22.2.1.2, 22.2.1.5 primitive, ArrayBuffer
        } else switch(arguments.length){
            case 0:
                super();
                break;
            case 1:
                super(input1);
                break;
            case 2:
                super(input1, byteOffset);
                break;
            case 3:
                super(input1, byteOffset, length);
                break;
            default:
                super(...arguments);
        }
        let proxy;
        if (_bug.isTypedArrayIndexedPropertyWritable) proxy = new Proxy(this, handler);
        else {
            const wrapper = Object.create(null);
            _(wrapper).target = this;
            proxy = new Proxy(wrapper, handler);
        }
        // proxy private storage
        _(proxy).target = this;
        // this private storage
        _(this).proxy = proxy;
        return proxy;
    }
    // static methods
    static from(src, ...opts) {
        if (opts.length === 0) return new Float16Array(Uint16Array.from(src, _lib.roundToFloat16Bits).buffer);
        const mapFunc = opts[0];
        const thisArg = opts[1];
        return new Float16Array(Uint16Array.from(src, function(val, ...args) {
            return _lib.roundToFloat16Bits(mapFunc.call(this, val, ...args));
        }, thisArg).buffer);
    }
    static of(...args) {
        return new Float16Array(args);
    }
    // iterate methods
    *[Symbol.iterator]() {
        for (const val of super[Symbol.iterator]())yield _lib.convertToNumber(val);
    }
    keys() {
        return super.keys();
    }
    *values() {
        for (const val of super.values())yield _lib.convertToNumber(val);
    }
    *entries() {
        for (const [i, val] of super.entries())yield [
            i,
            _lib.convertToNumber(val)
        ];
    }
    // functional methods
    map(callback, ...opts) {
        assertFloat16Array(this);
        const thisArg = opts[0];
        const array = [];
        for(let i = 0, l = this.length; i < l; ++i){
            const val = _lib.convertToNumber(this[i]);
            array.push(callback.call(thisArg, val, i, _(this).proxy));
        }
        return new Float16Array(array);
    }
    filter(callback, ...opts) {
        assertFloat16Array(this);
        const thisArg = opts[0];
        const array = [];
        for(let i = 0, l = this.length; i < l; ++i){
            const val = _lib.convertToNumber(this[i]);
            if (callback.call(thisArg, val, i, _(this).proxy)) array.push(val);
        }
        return new Float16Array(array);
    }
    reduce(callback, ...opts) {
        assertFloat16Array(this);
        let val, start;
        if (opts.length === 0) {
            val = _lib.convertToNumber(this[0]);
            start = 1;
        } else {
            val = opts[0];
            start = 0;
        }
        for(let i = start, l = this.length; i < l; ++i)val = callback(val, _lib.convertToNumber(this[i]), i, _(this).proxy);
        return val;
    }
    reduceRight(callback, ...opts) {
        assertFloat16Array(this);
        let val, start;
        const length1 = this.length;
        if (opts.length === 0) {
            val = _lib.convertToNumber(this[length1 - 1]);
            start = length1 - 1;
        } else {
            val = opts[0];
            start = length1;
        }
        for(let i = start; i--;)val = callback(val, _lib.convertToNumber(this[i]), i, _(this).proxy);
        return val;
    }
    forEach(callback, ...opts) {
        assertFloat16Array(this);
        const thisArg = opts[0];
        for(let i = 0, l = this.length; i < l; ++i)callback.call(thisArg, _lib.convertToNumber(this[i]), i, _(this).proxy);
    }
    find(callback, ...opts) {
        assertFloat16Array(this);
        const thisArg = opts[0];
        for(let i = 0, l = this.length; i < l; ++i){
            const value = _lib.convertToNumber(this[i]);
            if (callback.call(thisArg, value, i, _(this).proxy)) return value;
        }
    }
    findIndex(callback, ...opts) {
        assertFloat16Array(this);
        const thisArg = opts[0];
        for(let i = 0, l = this.length; i < l; ++i){
            const value = _lib.convertToNumber(this[i]);
            if (callback.call(thisArg, value, i, _(this).proxy)) return i;
        }
        return -1;
    }
    every(callback, ...opts) {
        assertFloat16Array(this);
        const thisArg = opts[0];
        for(let i = 0, l = this.length; i < l; ++i){
            if (!callback.call(thisArg, _lib.convertToNumber(this[i]), i, _(this).proxy)) return false;
        }
        return true;
    }
    some(callback, ...opts) {
        assertFloat16Array(this);
        const thisArg = opts[0];
        for(let i = 0, l = this.length; i < l; ++i){
            if (callback.call(thisArg, _lib.convertToNumber(this[i]), i, _(this).proxy)) return true;
        }
        return false;
    }
    // change element methods
    set(input, ...opts) {
        assertFloat16Array(this);
        const offset = opts[0];
        let float16bits;
        // input Float16Array
        if (isFloat16Array(input)) float16bits = _(input).target;
        else {
            const arrayLike = !Reflect.has(input, "length") && input[Symbol.iterator] !== undefined ? [
                ...input
            ] : input;
            const length1 = arrayLike.length;
            float16bits = new Uint16Array(length1);
            for(let i = 0, l = arrayLike.length; i < l; ++i)float16bits[i] = _lib.roundToFloat16Bits(arrayLike[i]);
        }
        super.set(float16bits, offset);
    }
    reverse() {
        assertFloat16Array(this);
        super.reverse();
        return _(this).proxy;
    }
    fill(value, ...opts) {
        assertFloat16Array(this);
        super.fill(_lib.roundToFloat16Bits(value), ...opts);
        return _(this).proxy;
    }
    copyWithin(target, start, ...opts) {
        assertFloat16Array(this);
        super.copyWithin(target, start, ...opts);
        return _(this).proxy;
    }
    sort(...opts) {
        assertFloat16Array(this);
        let compareFunction = opts[0];
        if (compareFunction === undefined) compareFunction = _spec.defaultCompareFunction;
        const _convertToNumber = _memoizeDefault.default(_lib.convertToNumber);
        super.sort((x, y)=>compareFunction(_convertToNumber(x), _convertToNumber(y))
        );
        return _(this).proxy;
    }
    // copy element methods
    slice(...opts) {
        assertFloat16Array(this);
        let float16bits;
        // V8, SpiderMonkey, JavaScriptCore, Chakra throw TypeError
        try {
            float16bits = super.slice(...opts);
        } catch (e) {
            if (e instanceof TypeError) {
                const uint16 = new Uint16Array(this.buffer, this.byteOffset, this.length);
                float16bits = uint16.slice(...opts);
            } else throw e;
        }
        return new Float16Array(float16bits.buffer);
    }
    subarray(...opts) {
        assertFloat16Array(this);
        let float16bits;
        // V8, SpiderMonkey, JavaScriptCore, Chakra throw TypeError
        try {
            float16bits = super.subarray(...opts);
        } catch (e) {
            if (e instanceof TypeError) {
                const uint16 = new Uint16Array(this.buffer, this.byteOffset, this.length);
                float16bits = uint16.subarray(...opts);
            } else throw e;
        }
        return new Float16Array(float16bits.buffer, float16bits.byteOffset, float16bits.length);
    }
    // contains methods
    indexOf(element, ...opts) {
        assertFloat16Array(this);
        const length1 = this.length;
        let from = _spec.ToInteger(opts[0]);
        if (from < 0) {
            from += length1;
            if (from < 0) from = 0;
        }
        for(let i = from, l = length1; i < l; ++i){
            if (_lib.convertToNumber(this[i]) === element) return i;
        }
        return -1;
    }
    lastIndexOf(element, ...opts) {
        assertFloat16Array(this);
        const length1 = this.length;
        let from = _spec.ToInteger(opts[0]);
        from = from === 0 ? length1 : from + 1;
        if (from >= 0) from = from < length1 ? from : length1;
        else from += length1;
        for(let i = from; i--;){
            if (_lib.convertToNumber(this[i]) === element) return i;
        }
        return -1;
    }
    includes(element, ...opts) {
        assertFloat16Array(this);
        const length1 = this.length;
        let from = _spec.ToInteger(opts[0]);
        if (from < 0) {
            from += length1;
            if (from < 0) from = 0;
        }
        const isNaN = Number.isNaN(element);
        for(let i = from, l = length1; i < l; ++i){
            const value = _lib.convertToNumber(this[i]);
            if (isNaN && Number.isNaN(value)) return true;
            if (value === element) return true;
        }
        return false;
    }
    // string methods
    join(...opts) {
        assertFloat16Array(this);
        const array = copyToArray(this);
        return array.join(...opts);
    }
    toLocaleString(...opts) {
        assertFloat16Array(this);
        const array = copyToArray(this);
        return array.toLocaleString(...opts);
    }
    get [Symbol.toStringTag]() {
        if (isFloat16Array(this)) return "Float16Array";
    }
}
exports.default = Float16Array;
const Float16Array$prototype = Float16Array.prototype;
const defaultFloat16ArrayMethods = new WeakSet();
for (const key of Reflect.ownKeys(Float16Array$prototype)){
    const val = Float16Array$prototype[key];
    if (typeof val === "function") defaultFloat16ArrayMethods.add(val);
}

},{"./spec":"eBwuI","./is":"hl0oN","./private":"3HFbU","lodash-es/memoize":"1d29b","./lib":"huubr","./bug":"5gzly","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eBwuI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ToInteger", ()=>ToInteger
);
parcelHelpers.export(exports, "defaultCompareFunction", ()=>defaultCompareFunction
);
function ToInteger(num) {
    if (typeof num !== "number") num = Number(num);
    if (Number.isNaN(num)) num = 0;
    return Math.trunc(num);
}
function defaultCompareFunction(x, y) {
    const [isNaN_x, isNaN_y] = [
        Number.isNaN(x),
        Number.isNaN(y)
    ];
    if (isNaN_x && isNaN_y) return 0;
    if (isNaN_x) return 1;
    if (isNaN_y) return -1;
    if (x < y) return -1;
    if (x > y) return 1;
    if (x === 0 && y === 0) {
        const [isPlusZero_x, isPlusZero_y] = [
            Object.is(x, 0),
            Object.is(y, 0)
        ];
        if (!isPlusZero_x && isPlusZero_y) return -1;
        if (isPlusZero_x && !isPlusZero_y) return 1;
    }
    return 0;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hl0oN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isArrayBuffer", ()=>_isArrayBufferDefault.default
);
parcelHelpers.export(exports, "isDataView", ()=>isDataView
);
parcelHelpers.export(exports, "isStringNumberKey", ()=>isStringNumberKey
);
var _spec = require("./spec");
var _isArrayBuffer = require("lodash-es/isArrayBuffer");
var _isArrayBufferDefault = parcelHelpers.interopDefault(_isArrayBuffer);
function isDataView(view) {
    return view instanceof DataView;
}
function isStringNumberKey(key) {
    return typeof key === "string" && key === _spec.ToInteger(key) + "";
}

},{"./spec":"eBwuI","lodash-es/isArrayBuffer":"gyupv","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"gyupv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsArrayBufferJs = require("./_baseIsArrayBuffer.js");
var _baseIsArrayBufferJsDefault = parcelHelpers.interopDefault(_baseIsArrayBufferJs);
var _baseUnaryJs = require("./_baseUnary.js");
var _baseUnaryJsDefault = parcelHelpers.interopDefault(_baseUnaryJs);
var _nodeUtilJs = require("./_nodeUtil.js");
var _nodeUtilJsDefault = parcelHelpers.interopDefault(_nodeUtilJs);
/* Node.js helper references. */ var nodeIsArrayBuffer = _nodeUtilJsDefault.default && _nodeUtilJsDefault.default.isArrayBuffer;
/**
 * Checks if `value` is classified as an `ArrayBuffer` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
 * @example
 *
 * _.isArrayBuffer(new ArrayBuffer(2));
 * // => true
 *
 * _.isArrayBuffer(new Array(2));
 * // => false
 */ var isArrayBuffer = nodeIsArrayBuffer ? _baseUnaryJsDefault.default(nodeIsArrayBuffer) : _baseIsArrayBufferJsDefault.default;
exports.default = isArrayBuffer;

},{"./_baseIsArrayBuffer.js":"5SbEg","./_baseUnary.js":"3cdEI","./_nodeUtil.js":"cnNtI","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5SbEg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetTagJs = require("./_baseGetTag.js");
var _baseGetTagJsDefault = parcelHelpers.interopDefault(_baseGetTagJs);
var _isObjectLikeJs = require("./isObjectLike.js");
var _isObjectLikeJsDefault = parcelHelpers.interopDefault(_isObjectLikeJs);
var arrayBufferTag = '[object ArrayBuffer]';
/**
 * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
 */ function baseIsArrayBuffer(value) {
    return _isObjectLikeJsDefault.default(value) && _baseGetTagJsDefault.default(value) == arrayBufferTag;
}
exports.default = baseIsArrayBuffer;

},{"./_baseGetTag.js":"aZJzp","./isObjectLike.js":"KrkRc","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aZJzp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _symbolJs = require("./_Symbol.js");
var _symbolJsDefault = parcelHelpers.interopDefault(_symbolJs);
var _getRawTagJs = require("./_getRawTag.js");
var _getRawTagJsDefault = parcelHelpers.interopDefault(_getRawTagJs);
var _objectToStringJs = require("./_objectToString.js");
var _objectToStringJsDefault = parcelHelpers.interopDefault(_objectToStringJs);
/** `Object#toString` result references. */ var nullTag = '[object Null]', undefinedTag = '[object Undefined]';
/** Built-in value references. */ var symToStringTag = _symbolJsDefault.default ? _symbolJsDefault.default.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    if (value == null) return value === undefined ? undefinedTag : nullTag;
    return symToStringTag && symToStringTag in Object(value) ? _getRawTagJsDefault.default(value) : _objectToStringJsDefault.default(value);
}
exports.default = baseGetTag;

},{"./_Symbol.js":"lUHHK","./_getRawTag.js":"7x3x3","./_objectToString.js":"bAUP7","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lUHHK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/** Built-in value references. */ var Symbol1 = _rootJsDefault.default.Symbol;
exports.default = Symbol1;

},{"./_root.js":"bVBU6","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bVBU6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _freeGlobalJs = require("./_freeGlobal.js");
var _freeGlobalJsDefault = parcelHelpers.interopDefault(_freeGlobalJs);
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = _freeGlobalJsDefault.default || freeSelf || Function('return this')();
exports.default = root;

},{"./_freeGlobal.js":"bwA9E","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bwA9E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var global = arguments[3];
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
exports.default = freeGlobal;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7x3x3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _symbolJs = require("./_Symbol.js");
var _symbolJsDefault = parcelHelpers.interopDefault(_symbolJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/** Built-in value references. */ var symToStringTag = _symbolJsDefault.default ? _symbolJsDefault.default.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */ function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) value[symToStringTag] = tag;
        else delete value[symToStringTag];
    }
    return result;
}
exports.default = getRawTag;

},{"./_Symbol.js":"lUHHK","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bAUP7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */ function objectToString(value) {
    return nativeObjectToString.call(value);
}
exports.default = objectToString;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"KrkRc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
exports.default = isObjectLike;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3cdEI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */ function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
exports.default = baseUnary;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cnNtI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _freeGlobalJs = require("./_freeGlobal.js");
var _freeGlobalJsDefault = parcelHelpers.interopDefault(_freeGlobalJs);
/** Detect free variable `exports`. */ var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && _freeGlobalJsDefault.default.process;
/** Used to access faster Node.js helpers. */ var nodeUtil = function() {
    try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;
        if (types) return types;
        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {
    }
}();
exports.default = nodeUtil;

},{"./_freeGlobal.js":"bwA9E","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3HFbU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createPrivateStorage", ()=>createPrivateStorage
);
function createPrivateStorage() {
    const wm = new WeakMap();
    return (self)=>{
        let obj = wm.get(self);
        if (obj) return obj;
        else {
            obj = Object.create(null);
            wm.set(self, obj);
            return obj;
        }
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1d29b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapCacheJs = require("./_MapCache.js");
var _mapCacheJsDefault = parcelHelpers.interopDefault(_mapCacheJs);
/** Error message constants. */ var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */ function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') throw new TypeError(FUNC_ERROR_TEXT);
    var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) return cache.get(key);
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
    };
    memoized.cache = new (memoize.Cache || _mapCacheJsDefault.default);
    return memoized;
}
// Expose `MapCache`.
memoize.Cache = _mapCacheJsDefault.default;
exports.default = memoize;

},{"./_MapCache.js":"kj55V","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kj55V":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _mapCacheClearJs = require("./_mapCacheClear.js");
var _mapCacheClearJsDefault = parcelHelpers.interopDefault(_mapCacheClearJs);
var _mapCacheDeleteJs = require("./_mapCacheDelete.js");
var _mapCacheDeleteJsDefault = parcelHelpers.interopDefault(_mapCacheDeleteJs);
var _mapCacheGetJs = require("./_mapCacheGet.js");
var _mapCacheGetJsDefault = parcelHelpers.interopDefault(_mapCacheGetJs);
var _mapCacheHasJs = require("./_mapCacheHas.js");
var _mapCacheHasJsDefault = parcelHelpers.interopDefault(_mapCacheHasJs);
var _mapCacheSetJs = require("./_mapCacheSet.js");
var _mapCacheSetJsDefault = parcelHelpers.interopDefault(_mapCacheSetJs);
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while((++index) < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClearJsDefault.default;
MapCache.prototype['delete'] = _mapCacheDeleteJsDefault.default;
MapCache.prototype.get = _mapCacheGetJsDefault.default;
MapCache.prototype.has = _mapCacheHasJsDefault.default;
MapCache.prototype.set = _mapCacheSetJsDefault.default;
exports.default = MapCache;

},{"./_mapCacheClear.js":"8FFqL","./_mapCacheDelete.js":"hazkx","./_mapCacheGet.js":"ljBn1","./_mapCacheHas.js":"6W3ia","./_mapCacheSet.js":"3mIjP","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"8FFqL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hashJs = require("./_Hash.js");
var _hashJsDefault = parcelHelpers.interopDefault(_hashJs);
var _listCacheJs = require("./_ListCache.js");
var _listCacheJsDefault = parcelHelpers.interopDefault(_listCacheJs);
var _mapJs = require("./_Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
        'hash': new _hashJsDefault.default,
        'map': new (_mapJsDefault.default || _listCacheJsDefault.default),
        'string': new _hashJsDefault.default
    };
}
exports.default = mapCacheClear;

},{"./_Hash.js":"iemcg","./_ListCache.js":"dXWbg","./_Map.js":"exPzb","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"iemcg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _hashClearJs = require("./_hashClear.js");
var _hashClearJsDefault = parcelHelpers.interopDefault(_hashClearJs);
var _hashDeleteJs = require("./_hashDelete.js");
var _hashDeleteJsDefault = parcelHelpers.interopDefault(_hashDeleteJs);
var _hashGetJs = require("./_hashGet.js");
var _hashGetJsDefault = parcelHelpers.interopDefault(_hashGetJs);
var _hashHasJs = require("./_hashHas.js");
var _hashHasJsDefault = parcelHelpers.interopDefault(_hashHasJs);
var _hashSetJs = require("./_hashSet.js");
var _hashSetJsDefault = parcelHelpers.interopDefault(_hashSetJs);
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while((++index) < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `Hash`.
Hash.prototype.clear = _hashClearJsDefault.default;
Hash.prototype['delete'] = _hashDeleteJsDefault.default;
Hash.prototype.get = _hashGetJsDefault.default;
Hash.prototype.has = _hashHasJsDefault.default;
Hash.prototype.set = _hashSetJsDefault.default;
exports.default = Hash;

},{"./_hashClear.js":"izzBG","./_hashDelete.js":"jH8Pc","./_hashGet.js":"14kaq","./_hashHas.js":"5sFqX","./_hashSet.js":"j069T","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"izzBG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeCreateJs = require("./_nativeCreate.js");
var _nativeCreateJsDefault = parcelHelpers.interopDefault(_nativeCreateJs);
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = _nativeCreateJsDefault.default ? _nativeCreateJsDefault.default(null) : {
    };
    this.size = 0;
}
exports.default = hashClear;

},{"./_nativeCreate.js":"aTAQu","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aTAQu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
/* Built-in method references that are verified to be native. */ var nativeCreate = _getNativeJsDefault.default(Object, 'create');
exports.default = nativeCreate;

},{"./_getNative.js":"9Rjmo","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9Rjmo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseIsNativeJs = require("./_baseIsNative.js");
var _baseIsNativeJsDefault = parcelHelpers.interopDefault(_baseIsNativeJs);
var _getValueJs = require("./_getValue.js");
var _getValueJsDefault = parcelHelpers.interopDefault(_getValueJs);
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = _getValueJsDefault.default(object, key);
    return _baseIsNativeJsDefault.default(value) ? value : undefined;
}
exports.default = getNative;

},{"./_baseIsNative.js":"loJwm","./_getValue.js":"bFVBd","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"loJwm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isFunctionJs = require("./isFunction.js");
var _isFunctionJsDefault = parcelHelpers.interopDefault(_isFunctionJs);
var _isMaskedJs = require("./_isMasked.js");
var _isMaskedJsDefault = parcelHelpers.interopDefault(_isMaskedJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _toSourceJs = require("./_toSource.js");
var _toSourceJsDefault = parcelHelpers.interopDefault(_toSourceJs);
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!_isObjectJsDefault.default(value) || _isMaskedJsDefault.default(value)) return false;
    var pattern = _isFunctionJsDefault.default(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSourceJsDefault.default(value));
}
exports.default = baseIsNative;

},{"./isFunction.js":"flqKI","./_isMasked.js":"kBpQ6","./isObject.js":"1IOOk","./_toSource.js":"jExaW","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"flqKI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _baseGetTagJs = require("./_baseGetTag.js");
var _baseGetTagJsDefault = parcelHelpers.interopDefault(_baseGetTagJs);
var _isObjectJs = require("./isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
/** `Object#toString` result references. */ var asyncTag = '[object AsyncFunction]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    if (!_isObjectJsDefault.default(value)) return false;
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = _baseGetTagJsDefault.default(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
exports.default = isFunction;

},{"./_baseGetTag.js":"aZJzp","./isObject.js":"1IOOk","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1IOOk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
}
exports.default = isObject;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kBpQ6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _coreJsDataJs = require("./_coreJsData.js");
var _coreJsDataJsDefault = parcelHelpers.interopDefault(_coreJsDataJs);
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(_coreJsDataJsDefault.default && _coreJsDataJsDefault.default.keys && _coreJsDataJsDefault.default.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
exports.default = isMasked;

},{"./_coreJsData.js":"aSgeD","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aSgeD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/** Used to detect overreaching core-js shims. */ var coreJsData = _rootJsDefault.default['__core-js_shared__'];
exports.default = coreJsData;

},{"./_root.js":"bVBU6","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jExaW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Used for built-in method references. */ var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e) {
        }
    }
    return '';
}
exports.default = toSource;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bFVBd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
exports.default = getValue;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jH8Pc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
}
exports.default = hashDelete;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"14kaq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeCreateJs = require("./_nativeCreate.js");
var _nativeCreateJsDefault = parcelHelpers.interopDefault(_nativeCreateJs);
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (_nativeCreateJsDefault.default) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
exports.default = hashGet;

},{"./_nativeCreate.js":"aTAQu","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5sFqX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeCreateJs = require("./_nativeCreate.js");
var _nativeCreateJsDefault = parcelHelpers.interopDefault(_nativeCreateJs);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return _nativeCreateJsDefault.default ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
exports.default = hashHas;

},{"./_nativeCreate.js":"aTAQu","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"j069T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeCreateJs = require("./_nativeCreate.js");
var _nativeCreateJsDefault = parcelHelpers.interopDefault(_nativeCreateJs);
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = _nativeCreateJsDefault.default && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
exports.default = hashSet;

},{"./_nativeCreate.js":"aTAQu","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"dXWbg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _listCacheClearJs = require("./_listCacheClear.js");
var _listCacheClearJsDefault = parcelHelpers.interopDefault(_listCacheClearJs);
var _listCacheDeleteJs = require("./_listCacheDelete.js");
var _listCacheDeleteJsDefault = parcelHelpers.interopDefault(_listCacheDeleteJs);
var _listCacheGetJs = require("./_listCacheGet.js");
var _listCacheGetJsDefault = parcelHelpers.interopDefault(_listCacheGetJs);
var _listCacheHasJs = require("./_listCacheHas.js");
var _listCacheHasJsDefault = parcelHelpers.interopDefault(_listCacheHasJs);
var _listCacheSetJs = require("./_listCacheSet.js");
var _listCacheSetJsDefault = parcelHelpers.interopDefault(_listCacheSetJs);
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while((++index) < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClearJsDefault.default;
ListCache.prototype['delete'] = _listCacheDeleteJsDefault.default;
ListCache.prototype.get = _listCacheGetJsDefault.default;
ListCache.prototype.has = _listCacheHasJsDefault.default;
ListCache.prototype.set = _listCacheSetJsDefault.default;
exports.default = ListCache;

},{"./_listCacheClear.js":"26TOp","./_listCacheDelete.js":"a0IC8","./_listCacheGet.js":"3xbq3","./_listCacheHas.js":"CpucY","./_listCacheSet.js":"1gm5g","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"26TOp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
}
exports.default = listCacheClear;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"a0IC8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assocIndexOfJs = require("./_assocIndexOf.js");
var _assocIndexOfJsDefault = parcelHelpers.interopDefault(_assocIndexOfJs);
/** Used for built-in method references. */ var arrayProto = Array.prototype;
/** Built-in value references. */ var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = _assocIndexOfJsDefault.default(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    --this.size;
    return true;
}
exports.default = listCacheDelete;

},{"./_assocIndexOf.js":"dVWJY","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"dVWJY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eqJs = require("./eq.js");
var _eqJsDefault = parcelHelpers.interopDefault(_eqJs);
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (_eqJsDefault.default(array[length][0], key)) return length;
    }
    return -1;
}
exports.default = assocIndexOf;

},{"./eq.js":"1PtGj","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1PtGj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
exports.default = eq;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3xbq3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assocIndexOfJs = require("./_assocIndexOf.js");
var _assocIndexOfJsDefault = parcelHelpers.interopDefault(_assocIndexOfJs);
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = _assocIndexOfJsDefault.default(data, key);
    return index < 0 ? undefined : data[index][1];
}
exports.default = listCacheGet;

},{"./_assocIndexOf.js":"dVWJY","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"CpucY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assocIndexOfJs = require("./_assocIndexOf.js");
var _assocIndexOfJsDefault = parcelHelpers.interopDefault(_assocIndexOfJs);
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return _assocIndexOfJsDefault.default(this.__data__, key) > -1;
}
exports.default = listCacheHas;

},{"./_assocIndexOf.js":"dVWJY","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1gm5g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _assocIndexOfJs = require("./_assocIndexOf.js");
var _assocIndexOfJsDefault = parcelHelpers.interopDefault(_assocIndexOfJs);
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = _assocIndexOfJsDefault.default(data, key);
    if (index < 0) {
        ++this.size;
        data.push([
            key,
            value
        ]);
    } else data[index][1] = value;
    return this;
}
exports.default = listCacheSet;

},{"./_assocIndexOf.js":"dVWJY","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"exPzb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getNativeJs = require("./_getNative.js");
var _getNativeJsDefault = parcelHelpers.interopDefault(_getNativeJs);
var _rootJs = require("./_root.js");
var _rootJsDefault = parcelHelpers.interopDefault(_rootJs);
/* Built-in method references that are verified to be native. */ var Map1 = _getNativeJsDefault.default(_rootJsDefault.default, 'Map');
exports.default = Map1;

},{"./_getNative.js":"9Rjmo","./_root.js":"bVBU6","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hazkx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getMapDataJs = require("./_getMapData.js");
var _getMapDataJsDefault = parcelHelpers.interopDefault(_getMapDataJs);
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    var result = _getMapDataJsDefault.default(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
}
exports.default = mapCacheDelete;

},{"./_getMapData.js":"i3Dn0","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"i3Dn0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _isKeyableJs = require("./_isKeyable.js");
var _isKeyableJsDefault = parcelHelpers.interopDefault(_isKeyableJs);
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyableJsDefault.default(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
exports.default = getMapData;

},{"./_isKeyable.js":"lHYqj","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lHYqj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
exports.default = isKeyable;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"ljBn1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getMapDataJs = require("./_getMapData.js");
var _getMapDataJsDefault = parcelHelpers.interopDefault(_getMapDataJs);
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return _getMapDataJsDefault.default(this, key).get(key);
}
exports.default = mapCacheGet;

},{"./_getMapData.js":"i3Dn0","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6W3ia":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getMapDataJs = require("./_getMapData.js");
var _getMapDataJsDefault = parcelHelpers.interopDefault(_getMapDataJs);
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return _getMapDataJsDefault.default(this, key).has(key);
}
exports.default = mapCacheHas;

},{"./_getMapData.js":"i3Dn0","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3mIjP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _getMapDataJs = require("./_getMapData.js");
var _getMapDataJsDefault = parcelHelpers.interopDefault(_getMapDataJs);
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    var data = _getMapDataJsDefault.default(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
}
exports.default = mapCacheSet;

},{"./_getMapData.js":"i3Dn0","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5gzly":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isTypedArrayIndexedPropertyWritable", ()=>isTypedArrayIndexedPropertyWritable
);
const isTypedArrayIndexedPropertyWritable = Object.getOwnPropertyDescriptor(new Uint8Array(1), 0).writable;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9nvLC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView.
 * @param {DataView} dataView
 * @param {nunmber} byteOffset
 * @param {*} opts
 */ parcelHelpers.export(exports, "getFloat16", ()=>getFloat16
);
/**
 * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView.
 * @param {DataView} dataView
 * @param {number} byteOffset
 * @param {number} value
 * @param {*} opts
 */ parcelHelpers.export(exports, "setFloat16", ()=>setFloat16
);
var _is = require("./is");
var _lib = require("./lib");
function getFloat16(dataView, byteOffset, ...opts) {
    if (!_is.isDataView(dataView)) throw new TypeError("First argument to getFloat16 function must be a DataView");
    return _lib.convertToNumber(dataView.getUint16(byteOffset, ...opts));
}
function setFloat16(dataView, byteOffset, value, ...opts) {
    if (!_is.isDataView(dataView)) throw new TypeError("First argument to setFloat16 function must be a DataView");
    dataView.setUint16(byteOffset, _lib.roundToFloat16Bits(value), ...opts);
}

},{"./is":"hl0oN","./lib":"huubr","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jIgXl":[function(require,module,exports) {
'use strict';
Object.defineProperty(exports, '__esModule', {
    value: true
});
// ==ClosureCompiler==
// @output_file_name default.js
// @compilation_level SIMPLE_OPTIMIZATIONS
// ==/ClosureCompiler==
// module.exports = {
//     parse: parse,
//     simplify: simplify,
//     simplifyLostLess: simplifyLostLess,
//     filter: filter,
//     stringify: stringify,
//     toContentString: toContentString,
//     getElementById: getElementById,
//     getElementsByClassName: getElementsByClassName,
//     transformStream: transformStream,
// };
/**
 * @author: Tobias Nickel
 * @created: 06.04.2015
 * I needed a small xmlparser chat can be used in a worker.
 */ /**
 * @typedef tNode 
 * @property {string} tagName 
 * @property {object} attributes
 * @property {(tNode|string)[]} children 
 **/ /**
 * @typedef TParseOptions
 * @property {number} [pos]
 * @property {string[]} [noChildNodes]
 * @property {boolean} [setPos]
 * @property {boolean} [keepComments] 
 * @property {boolean} [keepWhitespace]
 * @property {boolean} [simplify]
 * @property {(a: tNode, b: tNode) => boolean} [filter]
 */ /**
 * parseXML / html into a DOM Object. with no validation and some failur tolerance
 * @param {string} S your XML to parse
 * @param {TParseOptions} [options]  all other options:
 * @return {(tNode | string)[]}
 */ function parse(S, options) {
    options = options || {
    };
    var pos = options.pos || 0;
    var keepComments = !!options.keepComments;
    var keepWhitespace = !!options.keepWhitespace;
    var openBracket = "<";
    var openBracketCC = "<".charCodeAt(0);
    var closeBracket = ">";
    var closeBracketCC = ">".charCodeAt(0);
    var minusCC = "-".charCodeAt(0);
    var slashCC = "/".charCodeAt(0);
    var exclamationCC = '!'.charCodeAt(0);
    var singleQuoteCC = "'".charCodeAt(0);
    var doubleQuoteCC = '"'.charCodeAt(0);
    var openCornerBracketCC = '['.charCodeAt(0);
    var closeCornerBracketCC = ']'.charCodeAt(0);
    /**
     * parsing a list of entries
     */ function parseChildren(tagName) {
        var children = [];
        while(S[pos])if (S.charCodeAt(pos) == openBracketCC) {
            if (S.charCodeAt(pos + 1) === slashCC) {
                var closeStart = pos + 2;
                pos = S.indexOf(closeBracket, pos);
                var closeTag = S.substring(closeStart, pos);
                if (closeTag.indexOf(tagName) == -1) {
                    var parsedText = S.substring(0, pos).split('\n');
                    throw new Error('Unexpected close tag\nLine: ' + (parsedText.length - 1) + '\nColumn: ' + (parsedText[parsedText.length - 1].length + 1) + '\nChar: ' + S[pos]);
                }
                if (pos + 1) pos += 1;
                return children;
            } else if (S.charCodeAt(pos + 1) === exclamationCC) {
                if (S.charCodeAt(pos + 2) == minusCC) {
                    //comment support
                    const startCommentPos = pos;
                    while(pos !== -1 && !(S.charCodeAt(pos) === closeBracketCC && S.charCodeAt(pos - 1) == minusCC && S.charCodeAt(pos - 2) == minusCC && pos != -1))pos = S.indexOf(closeBracket, pos + 1);
                    if (pos === -1) pos = S.length;
                    if (keepComments) children.push(S.substring(startCommentPos, pos + 1));
                } else if (S.charCodeAt(pos + 2) === openCornerBracketCC && S.charCodeAt(pos + 8) === openCornerBracketCC && S.substr(pos + 3, 5).toLowerCase() === 'cdata') {
                    // cdata
                    var cdataEndIndex = S.indexOf(']]>', pos);
                    if (cdataEndIndex == -1) {
                        children.push(S.substr(pos + 9));
                        pos = S.length;
                    } else {
                        children.push(S.substring(pos + 9, cdataEndIndex));
                        pos = cdataEndIndex + 3;
                    }
                    continue;
                } else {
                    // doctypesupport
                    const startDoctype = pos + 1;
                    pos += 2;
                    var encapsuled = false;
                    while((S.charCodeAt(pos) !== closeBracketCC || encapsuled === true) && S[pos]){
                        if (S.charCodeAt(pos) === openCornerBracketCC) encapsuled = true;
                        else if (encapsuled === true && S.charCodeAt(pos) === closeCornerBracketCC) encapsuled = false;
                        pos++;
                    }
                    children.push(S.substring(startDoctype, pos));
                }
                pos++;
                continue;
            }
            var node = parseNode();
            children.push(node);
            if (node.tagName[0] === '?') {
                children.push(...node.children);
                node.children = [];
            }
        } else {
            var text = parseText();
            if (keepWhitespace) {
                if (text.length > 0) children.push(text);
            } else {
                var trimmed = text.trim();
                if (trimmed.length > 0) children.push(trimmed);
            }
            pos++;
        }
        return children;
    }
    /**
     *    returns the text outside of texts until the first '<'
     */ function parseText() {
        var start = pos;
        pos = S.indexOf(openBracket, pos) - 1;
        if (pos === -2) pos = S.length;
        return S.slice(start, pos + 1);
    }
    /**
     *    returns text until the first nonAlphabetic letter
     */ var nameSpacer = '\r\n\t>/= ';
    function parseName() {
        var start = pos;
        while(nameSpacer.indexOf(S[pos]) === -1 && S[pos])pos++;
        return S.slice(start, pos);
    }
    /**
     *    is parsing a node, including tagName, Attributes and its children,
     * to parse children it uses the parseChildren again, that makes the parsing recursive
     */ var NoChildNodes = options.noChildNodes || [
        'img',
        'br',
        'input',
        'meta',
        'link',
        'hr'
    ];
    function parseNode() {
        pos++;
        const tagName = parseName();
        const attributes = {
        };
        let children = [];
        // parsing attributes
        while(S.charCodeAt(pos) !== closeBracketCC && S[pos]){
            var c = S.charCodeAt(pos);
            if (c > 64 && c < 91 || c > 96 && c < 123) {
                //if('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(S[pos])!==-1 ){
                var name = parseName();
                // search beginning of the string
                var code = S.charCodeAt(pos);
                while(code && code !== singleQuoteCC && code !== doubleQuoteCC && !(code > 64 && code < 91 || code > 96 && code < 123) && code !== closeBracketCC){
                    pos++;
                    code = S.charCodeAt(pos);
                }
                if (code === singleQuoteCC || code === doubleQuoteCC) {
                    var value = parseString();
                    if (pos === -1) return {
                        tagName,
                        attributes,
                        children
                    };
                } else {
                    value = null;
                    pos--;
                }
                attributes[name] = value;
            }
            pos++;
        }
        // optional parsing of children
        if (S.charCodeAt(pos - 1) !== slashCC) {
            if (tagName == "script") {
                var start = pos + 1;
                pos = S.indexOf('</script>', pos);
                children = [
                    S.slice(start, pos)
                ];
                pos += 9;
            } else if (tagName == "style") {
                var start = pos + 1;
                pos = S.indexOf('</style>', pos);
                children = [
                    S.slice(start, pos)
                ];
                pos += 8;
            } else if (NoChildNodes.indexOf(tagName) === -1) {
                pos++;
                children = parseChildren(tagName);
            } else pos++;
        } else pos++;
        return {
            tagName,
            attributes,
            children
        };
    }
    /**
     *    is parsing a string, that starts with a char and with the same usually  ' or "
     */ function parseString() {
        var startChar = S[pos];
        var startpos = pos + 1;
        pos = S.indexOf(startChar, startpos);
        return S.slice(startpos, pos);
    }
    /**
     *
     */ function findElements() {
        var r = new RegExp('\\s' + options.attrName + '\\s*=[\'"]' + options.attrValue + '[\'"]').exec(S);
        if (r) return r.index;
        else return -1;
    }
    var out = null;
    if (options.attrValue !== undefined) {
        options.attrName = options.attrName || 'id';
        var out = [];
        while((pos = findElements()) !== -1){
            pos = S.lastIndexOf('<', pos);
            if (pos !== -1) out.push(parseNode());
            S = S.substr(pos);
            pos = 0;
        }
    } else if (options.parseNode) out = parseNode();
    else out = parseChildren('');
    if (options.filter) out = filter(out, options.filter);
    if (options.simplify) return simplify(Array.isArray(out) ? out : [
        out
    ]);
    if (options.setPos) out.pos = pos;
    return out;
}
/**
 * transform the DomObject to an object that is like the object of PHP`s simple_xmp_load_*() methods.
 * this format helps you to write that is more likely to keep your program working, even if there a small changes in the XML schema.
 * be aware, that it is not possible to reproduce the original xml from a simplified version, because the order of elements is not saved.
 * therefore your program will be more flexible and easier to read.
 *
 * @param {tNode[]} children the childrenList
 */ function simplify(children) {
    var out = {
    };
    if (!children.length) return '';
    if (children.length === 1 && typeof children[0] == 'string') return children[0];
    // map each object
    children.forEach(function(child) {
        if (typeof child !== 'object') return;
        if (!out[child.tagName]) out[child.tagName] = [];
        var kids = simplify(child.children);
        out[child.tagName].push(kids);
        if (Object.keys(child.attributes).length && typeof kids !== 'string') {
            console.log('kids', kids);
            kids._attributes = child.attributes;
        }
    });
    for(var i in out)if (out[i].length == 1) out[i] = out[i][0];
    return out;
}
/**
 * similar to simplify, but lost less
 *
 * @param {tNode[]} children the childrenList
 */ function simplifyLostLess(children, parentAttributes = {
}) {
    var out = {
    };
    if (!children.length) return out;
    if (children.length === 1 && typeof children[0] == 'string') return Object.keys(parentAttributes).length ? {
        _attributes: parentAttributes,
        value: children[0]
    } : children[0];
    // map each object
    children.forEach(function(child) {
        if (typeof child !== 'object') return;
        if (!out[child.tagName]) out[child.tagName] = [];
        var kids = simplifyLostLess(child.children || [], child.attributes);
        out[child.tagName].push(kids);
        if (Object.keys(child.attributes).length) kids._attributes = child.attributes;
    });
    return out;
}
/**
 * behaves the same way as Array.filter, if the filter method return true, the element is in the resultList
 * @params children{Array} the children of a node
 * @param f{function} the filter method
 */ function filter(children, f, dept = 0, path = '') {
    var out = [];
    children.forEach(function(child, i) {
        if (typeof child === 'object' && f(child, i, dept, path)) out.push(child);
        if (child.children) {
            var kids = filter(child.children, f, dept + 1, (path ? path + '.' : '') + i + '.' + child.tagName);
            out = out.concat(kids);
        }
    });
    return out;
}
/**
 * stringify a previously parsed string object.
 * this is useful,
 *  1. to remove whitespace
 * 2. to recreate xml data, with some changed data.
 * @param {tNode} O the object to Stringify
 */ function stringify(O) {
    var out = '';
    function writeChildren(O1) {
        if (O1) {
            for(var i = 0; i < O1.length; i++)if (typeof O1[i] == 'string') out += O1[i].trim();
            else writeNode(O1[i]);
        }
    }
    function writeNode(N) {
        out += "<" + N.tagName;
        for(var i in N.attributes){
            if (N.attributes[i] === null) out += ' ' + i;
            else if (N.attributes[i].indexOf('"') === -1) out += ' ' + i + '="' + N.attributes[i].trim() + '"';
            else out += ' ' + i + "='" + N.attributes[i].trim() + "'";
        }
        if (N.tagName[0] === '?') {
            out += '?>';
            return;
        }
        out += '>';
        writeChildren(N.children);
        out += '</' + N.tagName + '>';
    }
    writeChildren(O);
    return out;
}
/**
 * use this method to read the text content, of some node.
 * It is great if you have mixed content like:
 * this text has some <b>big</b> text and a <a href=''>link</a>
 * @return {string}
 */ function toContentString(tDom) {
    if (Array.isArray(tDom)) {
        var out = '';
        tDom.forEach(function(e) {
            out += ' ' + toContentString(e);
            out = out.trim();
        });
        return out;
    } else if (typeof tDom === 'object') return toContentString(tDom.children);
    else return ' ' + tDom;
}
function getElementById(S, id, simplified) {
    var out = parse(S, {
        attrValue: id
    });
    return simplified ? tXml.simplify(out) : out[0];
}
function getElementsByClassName(S, classname, simplified) {
    const out = parse(S, {
        attrName: 'class',
        attrValue: '[a-zA-Z0-9- ]*' + classname + '[a-zA-Z0-9- ]*'
    });
    return simplified ? tXml.simplify(out) : out;
}
exports.filter = filter;
exports.getElementById = getElementById;
exports.getElementsByClassName = getElementsByClassName;
exports.parse = parse;
exports.simplify = simplify;
exports.simplifyLostLess = simplifyLostLess;
exports.stringify = stringify;
exports.toContentString = toContentString;

},{}],"jLznT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fieldTagNames", ()=>fieldTagNames
);
parcelHelpers.export(exports, "fieldTags", ()=>fieldTags
);
parcelHelpers.export(exports, "fieldTagTypes", ()=>fieldTagTypes
);
parcelHelpers.export(exports, "arrayFields", ()=>arrayFields
);
parcelHelpers.export(exports, "fieldTypeNames", ()=>fieldTypeNames
);
parcelHelpers.export(exports, "fieldTypes", ()=>fieldTypes
);
parcelHelpers.export(exports, "photometricInterpretations", ()=>photometricInterpretations
);
parcelHelpers.export(exports, "ExtraSamplesValues", ()=>ExtraSamplesValues
);
parcelHelpers.export(exports, "LercParameters", ()=>LercParameters
);
parcelHelpers.export(exports, "LercAddCompression", ()=>LercAddCompression
);
parcelHelpers.export(exports, "geoKeyNames", ()=>geoKeyNames
);
parcelHelpers.export(exports, "geoKeys", ()=>geoKeys
);
const fieldTagNames = {
    // TIFF Baseline
    315: 'Artist',
    258: 'BitsPerSample',
    265: 'CellLength',
    264: 'CellWidth',
    320: 'ColorMap',
    259: 'Compression',
    33432: 'Copyright',
    306: 'DateTime',
    338: 'ExtraSamples',
    266: 'FillOrder',
    289: 'FreeByteCounts',
    288: 'FreeOffsets',
    291: 'GrayResponseCurve',
    290: 'GrayResponseUnit',
    316: 'HostComputer',
    270: 'ImageDescription',
    257: 'ImageLength',
    256: 'ImageWidth',
    271: 'Make',
    281: 'MaxSampleValue',
    280: 'MinSampleValue',
    272: 'Model',
    254: 'NewSubfileType',
    274: 'Orientation',
    262: 'PhotometricInterpretation',
    284: 'PlanarConfiguration',
    296: 'ResolutionUnit',
    278: 'RowsPerStrip',
    277: 'SamplesPerPixel',
    305: 'Software',
    279: 'StripByteCounts',
    273: 'StripOffsets',
    255: 'SubfileType',
    263: 'Threshholding',
    282: 'XResolution',
    283: 'YResolution',
    // TIFF Extended
    326: 'BadFaxLines',
    327: 'CleanFaxData',
    343: 'ClipPath',
    328: 'ConsecutiveBadFaxLines',
    433: 'Decode',
    434: 'DefaultImageColor',
    269: 'DocumentName',
    336: 'DotRange',
    321: 'HalftoneHints',
    346: 'Indexed',
    347: 'JPEGTables',
    285: 'PageName',
    297: 'PageNumber',
    317: 'Predictor',
    319: 'PrimaryChromaticities',
    532: 'ReferenceBlackWhite',
    339: 'SampleFormat',
    340: 'SMinSampleValue',
    341: 'SMaxSampleValue',
    559: 'StripRowCounts',
    330: 'SubIFDs',
    292: 'T4Options',
    293: 'T6Options',
    325: 'TileByteCounts',
    323: 'TileLength',
    324: 'TileOffsets',
    322: 'TileWidth',
    301: 'TransferFunction',
    318: 'WhitePoint',
    344: 'XClipPathUnits',
    286: 'XPosition',
    529: 'YCbCrCoefficients',
    531: 'YCbCrPositioning',
    530: 'YCbCrSubSampling',
    345: 'YClipPathUnits',
    287: 'YPosition',
    // EXIF
    37378: 'ApertureValue',
    40961: 'ColorSpace',
    36868: 'DateTimeDigitized',
    36867: 'DateTimeOriginal',
    34665: 'Exif IFD',
    36864: 'ExifVersion',
    33434: 'ExposureTime',
    41728: 'FileSource',
    37385: 'Flash',
    40960: 'FlashpixVersion',
    33437: 'FNumber',
    42016: 'ImageUniqueID',
    37384: 'LightSource',
    37500: 'MakerNote',
    37377: 'ShutterSpeedValue',
    37510: 'UserComment',
    // IPTC
    33723: 'IPTC',
    // ICC
    34675: 'ICC Profile',
    // XMP
    700: 'XMP',
    // GDAL
    42112: 'GDAL_METADATA',
    42113: 'GDAL_NODATA',
    // Photoshop
    34377: 'Photoshop',
    // GeoTiff
    33550: 'ModelPixelScale',
    33922: 'ModelTiepoint',
    34264: 'ModelTransformation',
    34735: 'GeoKeyDirectory',
    34736: 'GeoDoubleParams',
    34737: 'GeoAsciiParams',
    // LERC
    50674: 'LercParameters'
};
const fieldTags = {
};
for(const key in fieldTagNames)if (fieldTagNames.hasOwnProperty(key)) fieldTags[fieldTagNames[key]] = parseInt(key, 10);
const fieldTagTypes = {
    256: 'SHORT',
    257: 'SHORT',
    258: 'SHORT',
    259: 'SHORT',
    262: 'SHORT',
    273: 'LONG',
    274: 'SHORT',
    277: 'SHORT',
    278: 'LONG',
    279: 'LONG',
    282: 'RATIONAL',
    283: 'RATIONAL',
    284: 'SHORT',
    286: 'SHORT',
    287: 'RATIONAL',
    296: 'SHORT',
    305: 'ASCII',
    306: 'ASCII',
    338: 'SHORT',
    339: 'SHORT',
    513: 'LONG',
    514: 'LONG',
    1024: 'SHORT',
    1025: 'SHORT',
    2048: 'SHORT',
    2049: 'ASCII',
    33550: 'DOUBLE',
    33922: 'DOUBLE',
    34665: 'LONG',
    34735: 'SHORT',
    34737: 'ASCII',
    42113: 'ASCII'
};
const arrayFields = [
    fieldTags.BitsPerSample,
    fieldTags.ExtraSamples,
    fieldTags.SampleFormat,
    fieldTags.StripByteCounts,
    fieldTags.StripOffsets,
    fieldTags.StripRowCounts,
    fieldTags.TileByteCounts,
    fieldTags.TileOffsets,
    fieldTags.SubIFDs, 
];
const fieldTypeNames = {
    1: 'BYTE',
    2: 'ASCII',
    3: 'SHORT',
    4: 'LONG',
    5: 'RATIONAL',
    6: 'SBYTE',
    7: 'UNDEFINED',
    8: 'SSHORT',
    9: 'SLONG',
    10: 'SRATIONAL',
    11: 'FLOAT',
    12: 'DOUBLE',
    // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html
    13: 'IFD',
    // introduced by BigTIFF
    16: 'LONG8',
    17: 'SLONG8',
    18: 'IFD8'
};
const fieldTypes = {
};
for(const key1 in fieldTypeNames)if (fieldTypeNames.hasOwnProperty(key1)) fieldTypes[fieldTypeNames[key1]] = parseInt(key1, 10);
const photometricInterpretations = {
    WhiteIsZero: 0,
    BlackIsZero: 1,
    RGB: 2,
    Palette: 3,
    TransparencyMask: 4,
    CMYK: 5,
    YCbCr: 6,
    CIELab: 8,
    ICCLab: 9
};
const ExtraSamplesValues = {
    Unspecified: 0,
    Assocalpha: 1,
    Unassalpha: 2
};
const LercParameters = {
    Version: 0,
    AddCompression: 1
};
const LercAddCompression = {
    None: 0,
    Deflate: 1
};
const geoKeyNames = {
    1024: 'GTModelTypeGeoKey',
    1025: 'GTRasterTypeGeoKey',
    1026: 'GTCitationGeoKey',
    2048: 'GeographicTypeGeoKey',
    2049: 'GeogCitationGeoKey',
    2050: 'GeogGeodeticDatumGeoKey',
    2051: 'GeogPrimeMeridianGeoKey',
    2052: 'GeogLinearUnitsGeoKey',
    2053: 'GeogLinearUnitSizeGeoKey',
    2054: 'GeogAngularUnitsGeoKey',
    2055: 'GeogAngularUnitSizeGeoKey',
    2056: 'GeogEllipsoidGeoKey',
    2057: 'GeogSemiMajorAxisGeoKey',
    2058: 'GeogSemiMinorAxisGeoKey',
    2059: 'GeogInvFlatteningGeoKey',
    2060: 'GeogAzimuthUnitsGeoKey',
    2061: 'GeogPrimeMeridianLongGeoKey',
    2062: 'GeogTOWGS84GeoKey',
    3072: 'ProjectedCSTypeGeoKey',
    3073: 'PCSCitationGeoKey',
    3074: 'ProjectionGeoKey',
    3075: 'ProjCoordTransGeoKey',
    3076: 'ProjLinearUnitsGeoKey',
    3077: 'ProjLinearUnitSizeGeoKey',
    3078: 'ProjStdParallel1GeoKey',
    3079: 'ProjStdParallel2GeoKey',
    3080: 'ProjNatOriginLongGeoKey',
    3081: 'ProjNatOriginLatGeoKey',
    3082: 'ProjFalseEastingGeoKey',
    3083: 'ProjFalseNorthingGeoKey',
    3084: 'ProjFalseOriginLongGeoKey',
    3085: 'ProjFalseOriginLatGeoKey',
    3086: 'ProjFalseOriginEastingGeoKey',
    3087: 'ProjFalseOriginNorthingGeoKey',
    3088: 'ProjCenterLongGeoKey',
    3089: 'ProjCenterLatGeoKey',
    3090: 'ProjCenterEastingGeoKey',
    3091: 'ProjCenterNorthingGeoKey',
    3092: 'ProjScaleAtNatOriginGeoKey',
    3093: 'ProjScaleAtCenterGeoKey',
    3094: 'ProjAzimuthAngleGeoKey',
    3095: 'ProjStraightVertPoleLongGeoKey',
    3096: 'ProjRectifiedGridAngleGeoKey',
    4096: 'VerticalCSTypeGeoKey',
    4097: 'VerticalCitationGeoKey',
    4098: 'VerticalDatumGeoKey',
    4099: 'VerticalUnitsGeoKey'
};
const geoKeys = {
};
for(const key2 in geoKeyNames)if (geoKeyNames.hasOwnProperty(key2)) geoKeys[geoKeyNames[key2]] = parseInt(key2, 10);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"ixq6a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromWhiteIsZero", ()=>fromWhiteIsZero
);
parcelHelpers.export(exports, "fromBlackIsZero", ()=>fromBlackIsZero
);
parcelHelpers.export(exports, "fromPalette", ()=>fromPalette
);
parcelHelpers.export(exports, "fromCMYK", ()=>fromCMYK
);
parcelHelpers.export(exports, "fromYCbCr", ()=>fromYCbCr
);
// from https://github.com/antimatter15/rgb-lab/blob/master/color.js
parcelHelpers.export(exports, "fromCIELab", ()=>fromCIELab
);
function fromWhiteIsZero(raster, max) {
    const { width , height  } = raster;
    const rgbRaster = new Uint8Array(width * height * 3);
    let value;
    for(let i = 0, j = 0; i < raster.length; ++i, j += 3){
        value = 256 - raster[i] / max * 256;
        rgbRaster[j] = value;
        rgbRaster[j + 1] = value;
        rgbRaster[j + 2] = value;
    }
    return rgbRaster;
}
function fromBlackIsZero(raster, max) {
    const { width , height  } = raster;
    const rgbRaster = new Uint8Array(width * height * 3);
    let value;
    for(let i = 0, j = 0; i < raster.length; ++i, j += 3){
        value = raster[i] / max * 256;
        rgbRaster[j] = value;
        rgbRaster[j + 1] = value;
        rgbRaster[j + 2] = value;
    }
    return rgbRaster;
}
function fromPalette(raster, colorMap) {
    const { width , height  } = raster;
    const rgbRaster = new Uint8Array(width * height * 3);
    const greenOffset = colorMap.length / 3;
    const blueOffset = colorMap.length / 3 * 2;
    for(let i = 0, j = 0; i < raster.length; ++i, j += 3){
        const mapIndex = raster[i];
        rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;
        rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;
        rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;
    }
    return rgbRaster;
}
function fromCMYK(cmykRaster) {
    const { width , height  } = cmykRaster;
    const rgbRaster = new Uint8Array(width * height * 3);
    for(let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3){
        const c = cmykRaster[i];
        const m = cmykRaster[i + 1];
        const y = cmykRaster[i + 2];
        const k = cmykRaster[i + 3];
        rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);
        rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);
        rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);
    }
    return rgbRaster;
}
function fromYCbCr(yCbCrRaster) {
    const { width , height  } = yCbCrRaster;
    const rgbRaster = new Uint8ClampedArray(width * height * 3);
    for(let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3){
        const y = yCbCrRaster[i];
        const cb = yCbCrRaster[i + 1];
        const cr = yCbCrRaster[i + 2];
        rgbRaster[j] = y + 1.402 * (cr - 128);
        rgbRaster[j + 1] = y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128);
        rgbRaster[j + 2] = y + 1.772 * (cb - 128);
    }
    return rgbRaster;
}
const Xn = 0.95047;
const Yn = 1;
const Zn = 1.08883;
function fromCIELab(cieLabRaster) {
    const { width , height  } = cieLabRaster;
    const rgbRaster = new Uint8Array(width * height * 3);
    for(let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3){
        const L = cieLabRaster[i + 0];
        const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8
        const b_ = cieLabRaster[i + 2] << 24 >> 24; // same
        let y = (L + 16) / 116;
        let x = a_ / 500 + y;
        let z = y - b_ / 200;
        let r;
        let g;
        let b;
        x = Xn * (x * x * x > 0.008856 ? x * x * x : (x - 16 / 116) / 7.787);
        y = Yn * (y * y * y > 0.008856 ? y * y * y : (y - 16 / 116) / 7.787);
        z = Zn * (z * z * z > 0.008856 ? z * z * z : (z - 16 / 116) / 7.787);
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.204 + z * 1.057;
        r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : 12.92 * r;
        g = g > 0.0031308 ? 1.055 * g ** (1 / 2.4) - 0.055 : 12.92 * g;
        b = b > 0.0031308 ? 1.055 * b ** (1 / 2.4) - 0.055 : 12.92 * b;
        rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;
        rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;
        rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;
    }
    return rgbRaster;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eETM6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addDecoder", ()=>addDecoder
);
parcelHelpers.export(exports, "getDecoder", ()=>getDecoder
);
const registry = new Map();
function addDecoder(cases, importFn) {
    if (!Array.isArray(cases)) cases = [
        cases
    ];
    cases.forEach((c)=>registry.set(c, importFn)
    );
}
async function getDecoder(fileDirectory) {
    const importFn = registry.get(fileDirectory.Compression);
    if (!importFn) throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);
    const Decoder = await importFn();
    return new Decoder(fileDirectory);
}
// Add default decoders to registry (end-user may override with other implementations)
addDecoder([
    undefined,
    1
], ()=>require("294168fe2262e57b").then((m)=>m.default
    )
);
addDecoder(5, ()=>require("aa0d549abf3cbad0").then((m)=>m.default
    )
);
addDecoder(6, ()=>{
    throw new Error('old style JPEG compression is not supported.');
});
addDecoder(7, ()=>require("ec387da548f62c99").then((m)=>m.default
    )
);
addDecoder([
    8,
    32946
], ()=>require("76a093f79c59b14f").then((m)=>m.default
    )
);
addDecoder(32773, ()=>require("bb81b60dc1425180").then((m)=>m.default
    )
);
addDecoder(34887, ()=>require("89103b803af79ed1").then((m)=>m.default
    )
);

},{"294168fe2262e57b":"hswZl","aa0d549abf3cbad0":"fyBfM","ec387da548f62c99":"P301O","76a093f79c59b14f":"gLVXA","bb81b60dc1425180":"3Bu3C","89103b803af79ed1":"1juUS","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hswZl":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require('./helpers/bundle-url').getBundleURL('f71VD') + "raw.dd78c019.js").catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root('y4hI3')
);

},{"./helpers/browser/js-loader":"eLFUM","./helpers/bundle-url":"8YnfL"}],"eLFUM":[function(require,module,exports) {
"use strict";
var cacheLoader = require('../cacheLoader');
module.exports = cacheLoader(function(bundle) {
    return new Promise(function(resolve, reject) {
        // Don't insert the same script twice (e.g. if it was already in the HTML)
        var existingScripts = document.getElementsByTagName('script');
        if ([].concat(existingScripts).some(function isCurrentBundle(script) {
            return script.src === bundle;
        })) {
            resolve();
            return;
        }
        var script = document.createElement('script');
        script.async = true;
        script.type = 'text/javascript';
        script.charset = 'utf-8';
        script.src = bundle;
        script.onerror = function(e) {
            script.onerror = script.onload = null;
            script.remove();
            reject(e);
        };
        script.onload = function() {
            script.onerror = script.onload = null;
            resolve();
        };
        document.getElementsByTagName('head')[0].appendChild(script);
    });
});

},{"../cacheLoader":"5Ry56"}],"5Ry56":[function(require,module,exports) {
"use strict";
var cachedBundles = {
};
var cachedPreloads = {
};
var cachedPrefetches = {
};
function getCache(type) {
    switch(type){
        case 'preload':
            return cachedPreloads;
        case 'prefetch':
            return cachedPrefetches;
        default:
            return cachedBundles;
    }
}
module.exports = function(loader, type) {
    return function(bundle) {
        var cache = getCache(type);
        if (cache[bundle]) return cache[bundle];
        return cache[bundle] = loader.apply(null, arguments).catch(function(e) {
            delete cache[bundle];
            throw e;
        });
    };
};

},{}],"8YnfL":[function(require,module,exports) {
"use strict";
var bundleURL = {
};
function getBundleURLCached(id) {
    var value = bundleURL[id];
    if (!value) {
        value = getBundleURL();
        bundleURL[id] = value;
    }
    return value;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ('' + err.stack).match(/(https?|file|ftp):\/\/[^)\n]+/g);
        if (matches) // The first two stack frames will be this function and getBundleURLCached.
        // Use the 3rd one, which will be a runtime in the original bundle.
        return getBaseURL(matches[2]);
    }
    return '/';
}
function getBaseURL(url) {
    return ('' + url).replace(/^((?:https?|file|ftp):\/\/.+)\/[^/]+$/, '$1') + '/';
} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    var matches = ('' + url).match(/(https?|file|ftp):\/\/[^/]+/);
    if (!matches) throw new Error('Origin not found');
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"fyBfM":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require('./helpers/bundle-url').getBundleURL('f71VD') + "lzw.a0610a98.js").catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root('hFtUx')
);

},{"./helpers/browser/js-loader":"eLFUM","./helpers/bundle-url":"8YnfL"}],"P301O":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require('./helpers/bundle-url').getBundleURL('f71VD') + "jpeg.474c85ce.js").catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root('6IP4I')
);

},{"./helpers/browser/js-loader":"eLFUM","./helpers/bundle-url":"8YnfL"}],"gLVXA":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require('./helpers/bundle-url').getBundleURL('f71VD') + "deflate.fe393973.js").catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root('cj9Gk')
);

},{"./helpers/browser/js-loader":"eLFUM","./helpers/bundle-url":"8YnfL"}],"3Bu3C":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require('./helpers/bundle-url').getBundleURL('f71VD') + "packbits.83da299f.js").catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root('kK4v8')
);

},{"./helpers/browser/js-loader":"eLFUM","./helpers/bundle-url":"8YnfL"}],"1juUS":[function(require,module,exports) {
module.exports = require("./helpers/browser/js-loader")(require('./helpers/bundle-url').getBundleURL('f71VD') + "lerc.17ca0dfc.js").catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root('2DIV7')
);

},{"./helpers/browser/js-loader":"eLFUM","./helpers/bundle-url":"8YnfL"}],"6yaYB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Resample the input arrays using nearest neighbor value selection.
 * @param {TypedArray[]} valueArrays The input arrays to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @returns {TypedArray[]} The resampled rasters
 */ parcelHelpers.export(exports, "resampleNearest", ()=>resampleNearest
);
/**
 * Resample the input arrays using bilinear interpolation.
 * @param {TypedArray[]} valueArrays The input arrays to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @returns {TypedArray[]} The resampled rasters
 */ parcelHelpers.export(exports, "resampleBilinear", ()=>resampleBilinear
);
/**
 * Resample the input arrays using the selected resampling method.
 * @param {TypedArray[]} valueArrays The input arrays to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @param {string} [method = 'nearest'] The desired resampling method
 * @returns {TypedArray[]} The resampled rasters
 */ parcelHelpers.export(exports, "resample", ()=>resample
);
/**
 * Resample the pixel interleaved input array using nearest neighbor value selection.
 * @param {TypedArray} valueArrays The input arrays to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @param {number} samples The number of samples per pixel for pixel
 *                         interleaved data
 * @returns {TypedArray} The resampled raster
 */ parcelHelpers.export(exports, "resampleNearestInterleaved", ()=>resampleNearestInterleaved
);
/**
 * Resample the pixel interleaved input array using bilinear interpolation.
 * @param {TypedArray} valueArrays The input arrays to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @param {number} samples The number of samples per pixel for pixel
 *                         interleaved data
 * @returns {TypedArray} The resampled raster
 */ parcelHelpers.export(exports, "resampleBilinearInterleaved", ()=>resampleBilinearInterleaved
);
/**
 * Resample the pixel interleaved input array using the selected resampling method.
 * @param {TypedArray} valueArray The input array to resample
 * @param {number} inWidth The width of the input rasters
 * @param {number} inHeight The height of the input rasters
 * @param {number} outWidth The desired width of the output rasters
 * @param {number} outHeight The desired height of the output rasters
 * @param {number} samples The number of samples per pixel for pixel
 *                                 interleaved data
 * @param {string} [method = 'nearest'] The desired resampling method
 * @returns {TypedArray} The resampled rasters
 */ parcelHelpers.export(exports, "resampleInterleaved", ()=>resampleInterleaved
);
/**
 * @module resample
 */ function copyNewSize(array, width, height, samplesPerPixel = 1) {
    return new (Object.getPrototypeOf(array)).constructor(width * height * samplesPerPixel);
}
function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {
    const relX = inWidth / outWidth;
    const relY = inHeight / outHeight;
    return valueArrays.map((array)=>{
        const newArray = copyNewSize(array, outWidth, outHeight);
        for(let y = 0; y < outHeight; ++y){
            const cy = Math.min(Math.round(relY * y), inHeight - 1);
            for(let x = 0; x < outWidth; ++x){
                const cx = Math.min(Math.round(relX * x), inWidth - 1);
                const value = array[cy * inWidth + cx];
                newArray[y * outWidth + x] = value;
            }
        }
        return newArray;
    });
}
// simple linear interpolation, code from:
// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support
function lerp(v0, v1, t) {
    return (1 - t) * v0 + t * v1;
}
function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {
    const relX = inWidth / outWidth;
    const relY = inHeight / outHeight;
    return valueArrays.map((array)=>{
        const newArray = copyNewSize(array, outWidth, outHeight);
        for(let y = 0; y < outHeight; ++y){
            const rawY = relY * y;
            const yl = Math.floor(rawY);
            const yh = Math.min(Math.ceil(rawY), inHeight - 1);
            for(let x = 0; x < outWidth; ++x){
                const rawX = relX * x;
                const tx = rawX % 1;
                const xl = Math.floor(rawX);
                const xh = Math.min(Math.ceil(rawX), inWidth - 1);
                const ll = array[yl * inWidth + xl];
                const hl = array[yl * inWidth + xh];
                const lh = array[yh * inWidth + xl];
                const hh = array[yh * inWidth + xh];
                const value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);
                newArray[y * outWidth + x] = value;
            }
        }
        return newArray;
    });
}
function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {
    switch(method.toLowerCase()){
        case 'nearest':
            return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);
        case 'bilinear':
        case 'linear':
            return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);
        default:
            throw new Error(`Unsupported resampling method: '${method}'`);
    }
}
function resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {
    const relX = inWidth / outWidth;
    const relY = inHeight / outHeight;
    const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);
    for(let y = 0; y < outHeight; ++y){
        const cy = Math.min(Math.round(relY * y), inHeight - 1);
        for(let x = 0; x < outWidth; ++x){
            const cx = Math.min(Math.round(relX * x), inWidth - 1);
            for(let i = 0; i < samples; ++i){
                const value = valueArray[cy * inWidth * samples + cx * samples + i];
                newArray[y * outWidth * samples + x * samples + i] = value;
            }
        }
    }
    return newArray;
}
function resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {
    const relX = inWidth / outWidth;
    const relY = inHeight / outHeight;
    const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);
    for(let y = 0; y < outHeight; ++y){
        const rawY = relY * y;
        const yl = Math.floor(rawY);
        const yh = Math.min(Math.ceil(rawY), inHeight - 1);
        for(let x = 0; x < outWidth; ++x){
            const rawX = relX * x;
            const tx = rawX % 1;
            const xl = Math.floor(rawX);
            const xh = Math.min(Math.ceil(rawX), inWidth - 1);
            for(let i = 0; i < samples; ++i){
                const ll = valueArray[yl * inWidth * samples + xl * samples + i];
                const hl = valueArray[yl * inWidth * samples + xh * samples + i];
                const lh = valueArray[yh * inWidth * samples + xl * samples + i];
                const hh = valueArray[yh * inWidth * samples + xh * samples + i];
                const value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);
                newArray[y * outWidth * samples + x * samples + i] = value;
            }
        }
    }
    return newArray;
}
function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {
    switch(method.toLowerCase()){
        case 'nearest':
            return resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);
        case 'bilinear':
        case 'linear':
            return resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);
        default:
            throw new Error(`Unsupported resampling method: '${method}'`);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"wo5NL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _float16 = require("@petamoriken/float16");
class DataView64 {
    constructor(arrayBuffer){
        this._dataView = new DataView(arrayBuffer);
    }
    get buffer() {
        return this._dataView.buffer;
    }
    getUint64(offset, littleEndian) {
        const left = this.getUint32(offset, littleEndian);
        const right = this.getUint32(offset + 4, littleEndian);
        let combined;
        if (littleEndian) {
            combined = left + 2 ** 32 * right;
            if (!Number.isSafeInteger(combined)) throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
            return combined;
        }
        combined = 2 ** 32 * left + right;
        if (!Number.isSafeInteger(combined)) throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
        return combined;
    }
    // adapted from https://stackoverflow.com/a/55338384/8060591
    getInt64(offset, littleEndian) {
        let value = 0;
        const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 128) > 0;
        let carrying = true;
        for(let i = 0; i < 8; i++){
            let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));
            if (isNegative) {
                if (carrying) {
                    if (byte !== 0) {
                        byte = ~(byte - 1) & 255;
                        carrying = false;
                    }
                } else byte = ~byte & 255;
            }
            value += byte * 256 ** i;
        }
        if (isNegative) value = -value;
        return value;
    }
    getUint8(offset, littleEndian) {
        return this._dataView.getUint8(offset, littleEndian);
    }
    getInt8(offset, littleEndian) {
        return this._dataView.getInt8(offset, littleEndian);
    }
    getUint16(offset, littleEndian) {
        return this._dataView.getUint16(offset, littleEndian);
    }
    getInt16(offset, littleEndian) {
        return this._dataView.getInt16(offset, littleEndian);
    }
    getUint32(offset, littleEndian) {
        return this._dataView.getUint32(offset, littleEndian);
    }
    getInt32(offset, littleEndian) {
        return this._dataView.getInt32(offset, littleEndian);
    }
    getFloat16(offset, littleEndian) {
        return _float16.getFloat16(this._dataView, offset, littleEndian);
    }
    getFloat32(offset, littleEndian) {
        return this._dataView.getFloat32(offset, littleEndian);
    }
    getFloat64(offset, littleEndian) {
        return this._dataView.getFloat64(offset, littleEndian);
    }
}
exports.default = DataView64;

},{"@petamoriken/float16":"aYQcx","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"X7Rz0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class DataSlice {
    constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff){
        this._dataView = new DataView(arrayBuffer);
        this._sliceOffset = sliceOffset;
        this._littleEndian = littleEndian;
        this._bigTiff = bigTiff;
    }
    get sliceOffset() {
        return this._sliceOffset;
    }
    get sliceTop() {
        return this._sliceOffset + this.buffer.byteLength;
    }
    get littleEndian() {
        return this._littleEndian;
    }
    get bigTiff() {
        return this._bigTiff;
    }
    get buffer() {
        return this._dataView.buffer;
    }
    covers(offset, length) {
        return this.sliceOffset <= offset && this.sliceTop >= offset + length;
    }
    readUint8(offset) {
        return this._dataView.getUint8(offset - this._sliceOffset, this._littleEndian);
    }
    readInt8(offset) {
        return this._dataView.getInt8(offset - this._sliceOffset, this._littleEndian);
    }
    readUint16(offset) {
        return this._dataView.getUint16(offset - this._sliceOffset, this._littleEndian);
    }
    readInt16(offset) {
        return this._dataView.getInt16(offset - this._sliceOffset, this._littleEndian);
    }
    readUint32(offset) {
        return this._dataView.getUint32(offset - this._sliceOffset, this._littleEndian);
    }
    readInt32(offset) {
        return this._dataView.getInt32(offset - this._sliceOffset, this._littleEndian);
    }
    readFloat32(offset) {
        return this._dataView.getFloat32(offset - this._sliceOffset, this._littleEndian);
    }
    readFloat64(offset) {
        return this._dataView.getFloat64(offset - this._sliceOffset, this._littleEndian);
    }
    readUint64(offset) {
        const left = this.readUint32(offset);
        const right = this.readUint32(offset + 4);
        let combined;
        if (this._littleEndian) {
            combined = left + 2 ** 32 * right;
            if (!Number.isSafeInteger(combined)) throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
            return combined;
        }
        combined = 2 ** 32 * left + right;
        if (!Number.isSafeInteger(combined)) throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
        return combined;
    }
    // adapted from https://stackoverflow.com/a/55338384/8060591
    readInt64(offset) {
        let value = 0;
        const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 128) > 0;
        let carrying = true;
        for(let i = 0; i < 8; i++){
            let byte = this._dataView.getUint8(offset + (this._littleEndian ? i : 7 - i));
            if (isNegative) {
                if (carrying) {
                    if (byte !== 0) {
                        byte = ~(byte - 1) & 255;
                        carrying = false;
                    }
                } else byte = ~byte & 255;
            }
            value += byte * 256 ** i;
        }
        if (isNegative) value = -value;
        return value;
    }
    readOffset(offset) {
        if (this._bigTiff) return this.readUint64(offset);
        return this.readUint32(offset);
    }
}
exports.default = DataSlice;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"Zx1V5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _threads = require("threads");
const defaultPoolSize = typeof navigator !== 'undefined' ? navigator.hardwareConcurrency : null;
/**
 * @module pool
 */ /**
 * Pool for workers to decode chunks of the images.
 */ class Pool {
    /**
   * @constructor
   * @param {Number} size The size of the pool. Defaults to the number of CPUs
   *                      available. When this parameter is `null` or 0, then the
   *                      decoding will be done in the main thread.
   * @param {Worker} worker The decoder worker, loaded and initialised. Enables
   *                        loading the worker using worker-loader(or others) externally
   *                        when using this library as a webpack dependency.
   */ constructor(size = defaultPoolSize, worker = new _threads.Worker('./decoder.worker.js')){
        this.pool = _threads.Pool(()=>_threads.spawn(worker)
        , size);
    }
    /**
   * Decode the given block of bytes with the set compression method.
   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.
   * @returns {Promise.<ArrayBuffer>} the decoded result as a `Promise`
   */ async decode(fileDirectory, buffer) {
        return new Promise((resolve, reject)=>{
            this.pool.queue(async (decode)=>{
                try {
                    const data = await decode(fileDirectory, _threads.Transfer(buffer));
                    resolve(data);
                } catch (err) {
                    reject(err);
                }
            });
        });
    }
    destroy() {
        this.pool.terminate(true);
    }
}
exports.default = Pool;

},{"threads":"bNUM1","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bNUM1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerSerializer", ()=>_common.registerSerializer
);
parcelHelpers.export(exports, "expose", ()=>_index1.expose
);
parcelHelpers.export(exports, "DefaultSerializer", ()=>_serializers.DefaultSerializer
);
parcelHelpers.export(exports, "Transfer", ()=>_transferable.Transfer
);
var _common = require("./common");
var _index = require("./master/index");
parcelHelpers.exportAll(_index, exports);
var _index1 = require("./worker/index");
var _serializers = require("./serializers");
var _transferable = require("./transferable");

},{"./common":"6SvEV","./master/index":"jvwdE","./worker/index":"c4MKZ","./serializers":"evNan","./transferable":"87TpM","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6SvEV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerSerializer", ()=>registerSerializer
);
parcelHelpers.export(exports, "deserialize", ()=>deserialize
);
parcelHelpers.export(exports, "serialize", ()=>serialize
);
var _serializers = require("./serializers");
let registeredSerializer = _serializers.DefaultSerializer;
function registerSerializer(serializer) {
    registeredSerializer = _serializers.extendSerializer(registeredSerializer, serializer);
}
function deserialize(message) {
    return registeredSerializer.deserialize(message);
}
function serialize(input) {
    return registeredSerializer.serialize(input);
}

},{"./serializers":"evNan","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"evNan":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extendSerializer", ()=>extendSerializer
);
parcelHelpers.export(exports, "DefaultSerializer", ()=>DefaultSerializer
);
function extendSerializer(extend, implementation) {
    const fallbackDeserializer = extend.deserialize.bind(extend);
    const fallbackSerializer = extend.serialize.bind(extend);
    return {
        deserialize (message) {
            return implementation.deserialize(message, fallbackDeserializer);
        },
        serialize (input) {
            return implementation.serialize(input, fallbackSerializer);
        }
    };
}
const DefaultErrorSerializer = {
    deserialize (message) {
        return Object.assign(Error(message.message), {
            name: message.name,
            stack: message.stack
        });
    },
    serialize (error) {
        return {
            __error_marker: "$$error",
            message: error.message,
            name: error.name,
            stack: error.stack
        };
    }
};
const isSerializedError = (thing)=>thing && typeof thing === "object" && "__error_marker" in thing && thing.__error_marker === "$$error"
;
const DefaultSerializer = {
    deserialize (message) {
        if (isSerializedError(message)) return DefaultErrorSerializer.deserialize(message);
        else return message;
    },
    serialize (input) {
        if (input instanceof Error) return DefaultErrorSerializer.serialize(input);
        else return input;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jvwdE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Pool", ()=>_pool.Pool
);
parcelHelpers.export(exports, "spawn", ()=>_spawn.spawn
);
parcelHelpers.export(exports, "Thread", ()=>_thread.Thread
);
parcelHelpers.export(exports, "isWorkerRuntime", ()=>_implementation.isWorkerRuntime
);
parcelHelpers.export(exports, "BlobWorker", ()=>BlobWorker
);
parcelHelpers.export(exports, "Worker", ()=>Worker1
);
var _implementation = require("./implementation");
var _pool = require("./pool");
var _spawn = require("./spawn");
var _thread = require("./thread");
const BlobWorker = _implementation.getWorkerImplementation().blob;
const Worker1 = _implementation.getWorkerImplementation().default;

},{"./implementation":"ekiHT","./pool":"5AJWF","./spawn":"6sW3k","./thread":"g4mmB","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"ekiHT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultPoolSize", ()=>defaultPoolSize
);
parcelHelpers.export(exports, "getWorkerImplementation", ()=>getWorkerImplementation
);
parcelHelpers.export(exports, "isWorkerRuntime", ()=>isWorkerRuntime
);
// tslint:disable max-classes-per-file
var _getBundleUrlBrowser = require("./get-bundle-url.browser");
const defaultPoolSize = typeof navigator !== "undefined" && navigator.hardwareConcurrency ? navigator.hardwareConcurrency : 4;
const isAbsoluteURL = (value)=>/^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(value)
;
function createSourceBlobURL(code) {
    const blob = new Blob([
        code
    ], {
        type: "application/javascript"
    });
    return URL.createObjectURL(blob);
}
function selectWorkerImplementation() {
    if (typeof Worker === "undefined") // Might happen on Safari, for instance
    // The idea is to only fail if the constructor is actually used
    return class NoWebWorker {
        constructor(){
            throw Error("No web worker implementation available. You might have tried to spawn a worker within a worker in a browser that doesn't support workers in workers.");
        }
    };
    class WebWorker extends Worker {
        constructor(url, options2){
            var _a, _b;
            if (typeof url === "string" && options2 && options2._baseURL) url = new URL(url, options2._baseURL);
            else if (typeof url === "string" && !isAbsoluteURL(url) && _getBundleUrlBrowser.getBundleURL().match(/^file:\/\//i)) {
                url = new URL(url, _getBundleUrlBrowser.getBundleURL().replace(/\/[^\/]+$/, "/"));
                if ((_a = options2 === null || options2 === void 0 ? void 0 : options2.CORSWorkaround) !== null && _a !== void 0 ? _a : true) url = createSourceBlobURL(`importScripts(${JSON.stringify(url)});`);
            }
            if (typeof url === "string" && isAbsoluteURL(url)) // Create source code blob loading JS file via `importScripts()`
            // to circumvent worker CORS restrictions
            {
                if ((_b = options2 === null || options2 === void 0 ? void 0 : options2.CORSWorkaround) !== null && _b !== void 0 ? _b : true) url = createSourceBlobURL(`importScripts(${JSON.stringify(url)});`);
            }
            super(url, options2);
        }
    }
    class BlobWorker extends WebWorker {
        constructor(blob, options1){
            const url1 = window.URL.createObjectURL(blob);
            super(url1, options1);
        }
        static fromText(source, options) {
            const blob1 = new window.Blob([
                source
            ], {
                type: "text/javascript"
            });
            return new BlobWorker(blob1, options);
        }
    }
    return {
        blob: BlobWorker,
        default: WebWorker
    };
}
let implementation;
function getWorkerImplementation() {
    if (!implementation) implementation = selectWorkerImplementation();
    return implementation;
}
function isWorkerRuntime() {
    const isWindowContext = typeof self !== "undefined" && typeof Window !== "undefined" && self instanceof Window;
    return typeof self !== "undefined" && self.postMessage && !isWindowContext ? true : false;
}

},{"./get-bundle-url.browser":"1v6SG","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1v6SG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getBaseURL", ()=>getBaseURL
);
parcelHelpers.export(exports, "getBundleURL", ()=>getBundleURLCached
);
// Source: <https://github.com/parcel-bundler/parcel/blob/master/packages/core/parcel-bundler/src/builtins/bundle-url.js>
let bundleURL;
function getBundleURLCached() {
    if (!bundleURL) bundleURL = getBundleURL();
    return bundleURL;
}
function getBundleURL() {
    // Attempt to find the URL of the current script and use that as the base URL
    try {
        throw new Error;
    } catch (err) {
        const matches = ("" + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);
        if (matches) return getBaseURL(matches[0]);
    }
    return "/";
}
function getBaseURL(url) {
    return ("" + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)?\/[^/]+(?:\?.*)?$/, '$1') + '/';
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5AJWF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PoolEventType", ()=>_poolTypes.PoolEventType
);
parcelHelpers.export(exports, "Thread", ()=>_thread.Thread
);
parcelHelpers.export(exports, "Pool", ()=>Pool
);
var _debug = require("debug");
var _debugDefault = parcelHelpers.interopDefault(_debug);
var _observableFns = require("observable-fns");
var _ponyfills = require("../ponyfills");
var _implementation = require("./implementation");
var _poolTypes = require("./pool-types");
var _thread = require("./thread");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
let nextPoolID = 1;
function createArray(size) {
    const array = [];
    for(let index = 0; index < size; index++)array.push(index);
    return array;
}
function delay(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms)
    );
}
function flatMap(array, mapper) {
    return array.reduce((flattened, element)=>[
            ...flattened,
            ...mapper(element)
        ]
    , []);
}
function slugify(text) {
    return text.replace(/\W/g, " ").trim().replace(/\s+/g, "-");
}
function spawnWorkers(spawnWorker, count) {
    return createArray(count).map(()=>({
            init: spawnWorker(),
            runningTasks: []
        })
    );
}
class WorkerPool {
    constructor(spawnWorker, optionsOrSize){
        this.eventSubject = new _observableFns.Subject();
        this.initErrors = [];
        this.isClosing = false;
        this.nextTaskID = 1;
        this.taskQueue = [];
        const options = typeof optionsOrSize === "number" ? {
            size: optionsOrSize
        } : optionsOrSize || {
        };
        const { size =_implementation.defaultPoolSize  } = options;
        this.debug = _debugDefault.default(`threads:pool:${slugify(options.name || String(nextPoolID++))}`);
        this.options = options;
        this.workers = spawnWorkers(spawnWorker, size);
        this.eventObservable = _observableFns.multicast(_observableFns.Observable.from(this.eventSubject));
        Promise.all(this.workers.map((worker)=>worker.init
        )).then(()=>this.eventSubject.next({
                type: _poolTypes.PoolEventType.initialized,
                size: this.workers.length
            })
        , (error)=>{
            this.debug("Error while initializing pool worker:", error);
            this.eventSubject.error(error);
            this.initErrors.push(error);
        });
    }
    findIdlingWorker() {
        const { concurrency =1  } = this.options;
        return this.workers.find((worker)=>worker.runningTasks.length < concurrency
        );
    }
    runPoolTask(worker, task) {
        return __awaiter(this, void 0, void 0, function*() {
            const workerID = this.workers.indexOf(worker) + 1;
            this.debug(`Running task #${task.id} on worker #${workerID}...`);
            this.eventSubject.next({
                type: _poolTypes.PoolEventType.taskStart,
                taskID: task.id,
                workerID
            });
            try {
                const returnValue = yield task.run((yield worker.init));
                this.debug(`Task #${task.id} completed successfully`);
                this.eventSubject.next({
                    type: _poolTypes.PoolEventType.taskCompleted,
                    returnValue,
                    taskID: task.id,
                    workerID
                });
            } catch (error) {
                this.debug(`Task #${task.id} failed`);
                this.eventSubject.next({
                    type: _poolTypes.PoolEventType.taskFailed,
                    taskID: task.id,
                    error,
                    workerID
                });
            }
        });
    }
    run(worker, task) {
        return __awaiter(this, void 0, void 0, function*() {
            const runPromise = (()=>__awaiter(this, void 0, void 0, function*() {
                    const removeTaskFromWorkersRunningTasks = ()=>{
                        worker.runningTasks = worker.runningTasks.filter((someRunPromise)=>someRunPromise !== runPromise
                        );
                    };
                    // Defer task execution by one tick to give handlers time to subscribe
                    yield delay(0);
                    try {
                        yield this.runPoolTask(worker, task);
                    } finally{
                        removeTaskFromWorkersRunningTasks();
                        if (!this.isClosing) this.scheduleWork();
                    }
                })
            )();
            worker.runningTasks.push(runPromise);
        });
    }
    scheduleWork() {
        this.debug(`Attempt de-queueing a task in order to run it...`);
        const availableWorker = this.findIdlingWorker();
        if (!availableWorker) return;
        const nextTask = this.taskQueue.shift();
        if (!nextTask) {
            this.debug(`Task queue is empty`);
            this.eventSubject.next({
                type: _poolTypes.PoolEventType.taskQueueDrained
            });
            return;
        }
        this.run(availableWorker, nextTask);
    }
    taskCompletion(taskID) {
        return new Promise((resolve, reject)=>{
            const eventSubscription = this.events().subscribe((event)=>{
                if (event.type === _poolTypes.PoolEventType.taskCompleted && event.taskID === taskID) {
                    eventSubscription.unsubscribe();
                    resolve(event.returnValue);
                } else if (event.type === _poolTypes.PoolEventType.taskFailed && event.taskID === taskID) {
                    eventSubscription.unsubscribe();
                    reject(event.error);
                } else if (event.type === _poolTypes.PoolEventType.terminated) {
                    eventSubscription.unsubscribe();
                    reject(Error("Pool has been terminated before task was run."));
                }
            });
        });
    }
    settled(allowResolvingImmediately = false) {
        return __awaiter(this, void 0, void 0, function*() {
            const getCurrentlyRunningTasks = ()=>flatMap(this.workers, (worker)=>worker.runningTasks
                )
            ;
            const taskFailures = [];
            const failureSubscription = this.eventObservable.subscribe((event)=>{
                if (event.type === _poolTypes.PoolEventType.taskFailed) taskFailures.push(event.error);
            });
            if (this.initErrors.length > 0) return Promise.reject(this.initErrors[0]);
            if (allowResolvingImmediately && this.taskQueue.length === 0) {
                yield _ponyfills.allSettled(getCurrentlyRunningTasks());
                return taskFailures;
            }
            yield new Promise((resolve, reject)=>{
                const subscription = this.eventObservable.subscribe({
                    next (event) {
                        if (event.type === _poolTypes.PoolEventType.taskQueueDrained) {
                            subscription.unsubscribe();
                            resolve(void 0);
                        }
                    },
                    error: reject // make a pool-wide error reject the completed() result promise
                });
            });
            yield _ponyfills.allSettled(getCurrentlyRunningTasks());
            failureSubscription.unsubscribe();
            return taskFailures;
        });
    }
    completed(allowResolvingImmediately = false) {
        return __awaiter(this, void 0, void 0, function*() {
            const settlementPromise = this.settled(allowResolvingImmediately);
            const earlyExitPromise = new Promise((resolve, reject)=>{
                const subscription = this.eventObservable.subscribe({
                    next (event) {
                        if (event.type === _poolTypes.PoolEventType.taskQueueDrained) {
                            subscription.unsubscribe();
                            resolve(settlementPromise);
                        } else if (event.type === _poolTypes.PoolEventType.taskFailed) {
                            subscription.unsubscribe();
                            reject(event.error);
                        }
                    },
                    error: reject // make a pool-wide error reject the completed() result promise
                });
            });
            const errors = yield Promise.race([
                settlementPromise,
                earlyExitPromise
            ]);
            if (errors.length > 0) throw errors[0];
        });
    }
    events() {
        return this.eventObservable;
    }
    queue(taskFunction) {
        const { maxQueuedJobs =Infinity  } = this.options;
        if (this.isClosing) throw Error(`Cannot schedule pool tasks after terminate() has been called.`);
        if (this.initErrors.length > 0) throw this.initErrors[0];
        const taskID = this.nextTaskID++;
        const taskCompletion = this.taskCompletion(taskID);
        taskCompletion.catch((error)=>{
            // Prevent unhandled rejections here as we assume the user will use
            // `pool.completed()`, `pool.settled()` or `task.catch()` to handle errors
            this.debug(`Task #${taskID} errored:`, error);
        });
        const task = {
            id: taskID,
            run: taskFunction,
            cancel: ()=>{
                if (this.taskQueue.indexOf(task) === -1) return;
                this.taskQueue = this.taskQueue.filter((someTask)=>someTask !== task
                );
                this.eventSubject.next({
                    type: _poolTypes.PoolEventType.taskCanceled,
                    taskID: task.id
                });
            },
            then: taskCompletion.then.bind(taskCompletion)
        };
        if (this.taskQueue.length >= maxQueuedJobs) throw Error("Maximum number of pool tasks queued. Refusing to queue another one.\nThis usually happens for one of two reasons: We are either at peak workload right now or some tasks just won't finish, thus blocking the pool.");
        this.debug(`Queueing task #${task.id}...`);
        this.taskQueue.push(task);
        this.eventSubject.next({
            type: _poolTypes.PoolEventType.taskQueued,
            taskID: task.id
        });
        this.scheduleWork();
        return task;
    }
    terminate(force) {
        return __awaiter(this, void 0, void 0, function*() {
            this.isClosing = true;
            if (!force) yield this.completed(true);
            this.eventSubject.next({
                type: _poolTypes.PoolEventType.terminated,
                remainingQueue: [
                    ...this.taskQueue
                ]
            });
            this.eventSubject.complete();
            yield Promise.all(this.workers.map((worker)=>__awaiter(this, void 0, void 0, function*() {
                    return _thread.Thread.terminate((yield worker.init));
                })
            ));
        });
    }
}
WorkerPool.EventType = _poolTypes.PoolEventType;
/**
 * Thread pool constructor. Creates a new pool and spawns its worker threads.
 */ function PoolConstructor(spawnWorker1, optionsOrSize1) {
    // The function exists only so we don't need to use `new` to create a pool (we still can, though).
    // If the Pool is a class or not is an implementation detail that should not concern the user.
    return new WorkerPool(spawnWorker1, optionsOrSize1);
}
PoolConstructor.EventType = _poolTypes.PoolEventType;
const Pool = PoolConstructor;

},{"debug":"k8UUl","observable-fns":"2iolv","../ponyfills":"37gOA","./implementation":"ekiHT","./pool-types":"eIZUQ","./thread":"g4mmB","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"k8UUl":[function(require,module,exports) {
var process = require("process");
/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) return true;
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) return;
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') return;
        index++;
        if (match === '%c') // We only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{
});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) exports.storage.setItem('debug', namespaces);
        else exports.storage.removeItem('debug');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) r = undefined;
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = require('./common')(exports);
const { formatters  } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};

},{"process":"6Upk8","./common":"jg8oR"}],"6Upk8":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {
};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e1) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e1) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while((++queueIndex) < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {
};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {
};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};

},{}],"jg8oR":[function(require,module,exports) {
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require('ms');
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {
    };
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) return;
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') // Anything else let's inspect with %O
            args.unshift('%O');
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') return '%';
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) return enableOverride;
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') createDebug.init(debug);
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
        const len = split.length;
        for(i = 0; i < len; i++){
            if (!split[i]) continue;
            namespaces = split[i].replace(/\*/g, '.*?');
            if (namespaces[0] === '-') createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
            else createDebug.names.push(new RegExp('^' + namespaces + '$'));
        }
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace)=>'-' + namespace
            )
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        if (name[name.length - 1] === '*') return true;
        let i;
        let len;
        for(i = 0, len = createDebug.skips.length; i < len; i++){
            if (createDebug.skips[i].test(name)) return false;
        }
        for(i = 0, len = createDebug.names.length; i < len; i++){
            if (createDebug.names[i].test(name)) return true;
        }
        return false;
    }
    /**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/ function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;

},{"ms":"5w07u"}],"5w07u":[function(require,module,exports) {
/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {
    };
    var type = typeof val;
    if (type === 'string' && val.length > 0) return parse(val);
    else if (type === 'number' && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) return;
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) return;
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) return Math.round(ms / d) + 'd';
    if (msAbs >= h) return Math.round(ms / h) + 'h';
    if (msAbs >= m) return Math.round(ms / m) + 'm';
    if (msAbs >= s) return Math.round(ms / s) + 's';
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) return plural(ms, msAbs, d, 'day');
    if (msAbs >= h) return plural(ms, msAbs, h, 'hour');
    if (msAbs >= m) return plural(ms, msAbs, m, 'minute');
    if (msAbs >= s) return plural(ms, msAbs, s, 'second');
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],"2iolv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filter", ()=>_filterDefault.default
);
parcelHelpers.export(exports, "flatMap", ()=>_flatMapDefault.default
);
parcelHelpers.export(exports, "interval", ()=>_intervalDefault.default
);
parcelHelpers.export(exports, "map", ()=>_mapDefault.default
);
parcelHelpers.export(exports, "merge", ()=>_mergeDefault.default
);
parcelHelpers.export(exports, "multicast", ()=>_multicastDefault.default
);
parcelHelpers.export(exports, "Observable", ()=>_observableDefault.default
);
parcelHelpers.export(exports, "scan", ()=>_scanDefault.default
);
parcelHelpers.export(exports, "Subject", ()=>_subjectDefault.default
);
parcelHelpers.export(exports, "unsubscribe", ()=>_unsubscribeDefault.default
);
var _filter = require("./filter");
var _filterDefault = parcelHelpers.interopDefault(_filter);
var _flatMap = require("./flatMap");
var _flatMapDefault = parcelHelpers.interopDefault(_flatMap);
var _interval = require("./interval");
var _intervalDefault = parcelHelpers.interopDefault(_interval);
var _map = require("./map");
var _mapDefault = parcelHelpers.interopDefault(_map);
var _merge = require("./merge");
var _mergeDefault = parcelHelpers.interopDefault(_merge);
var _multicast = require("./multicast");
var _multicastDefault = parcelHelpers.interopDefault(_multicast);
var _observable = require("./observable");
var _observableDefault = parcelHelpers.interopDefault(_observable);
var _scan = require("./scan");
var _scanDefault = parcelHelpers.interopDefault(_scan);
var _subject = require("./subject");
var _subjectDefault = parcelHelpers.interopDefault(_subject);
var _unsubscribe = require("./unsubscribe");
var _unsubscribeDefault = parcelHelpers.interopDefault(_unsubscribe);

},{"./filter":"fSm1p","./flatMap":"cKuIA","./interval":"64Mjg","./map":"7bmbM","./merge":"fY3su","./multicast":"3Ml4G","./observable":"aPcZZ","./scan":"3zMkd","./subject":"aAD8A","./unsubscribe":"8bAUj","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"fSm1p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _scheduler = require("./_scheduler");
var _observable = require("./observable");
var _observableDefault = parcelHelpers.interopDefault(_observable);
var _unsubscribe = require("./unsubscribe");
var _unsubscribeDefault = parcelHelpers.interopDefault(_unsubscribe);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Filters the values emitted by another observable.
 * To be applied to an input observable using `pipe()`.
 */ function filter(test) {
    return (observable)=>{
        return new _observableDefault.default((observer)=>{
            const scheduler = new _scheduler.AsyncSerialScheduler(observer);
            const subscription = observable.subscribe({
                complete () {
                    scheduler.complete();
                },
                error (error) {
                    scheduler.error(error);
                },
                next (input) {
                    scheduler.schedule((next)=>__awaiter(this, void 0, void 0, function*() {
                            if (yield test(input)) next(input);
                        })
                    );
                }
            });
            return ()=>_unsubscribeDefault.default(subscription)
            ;
        });
    };
}
exports.default = filter;

},{"./_scheduler":"3sas9","./observable":"aPcZZ","./unsubscribe":"8bAUj","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3sas9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsyncSerialScheduler", ()=>AsyncSerialScheduler
);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class AsyncSerialScheduler {
    constructor(observer){
        this._baseObserver = observer;
        this._pendingPromises = new Set();
    }
    complete() {
        Promise.all(this._pendingPromises).then(()=>this._baseObserver.complete()
        ).catch((error)=>this._baseObserver.error(error)
        );
    }
    error(error) {
        this._baseObserver.error(error);
    }
    schedule(task) {
        const prevPromisesCompletion = Promise.all(this._pendingPromises);
        const values = [];
        const next = (value)=>values.push(value)
        ;
        const promise = Promise.resolve().then(()=>__awaiter(this, void 0, void 0, function*() {
                yield prevPromisesCompletion;
                yield task(next);
                this._pendingPromises.delete(promise);
                for (const value of values)this._baseObserver.next(value);
            })
        ).catch((error)=>{
            this._pendingPromises.delete(promise);
            this._baseObserver.error(error);
        });
        this._pendingPromises.add(promise);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aPcZZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Subscription", ()=>Subscription
);
parcelHelpers.export(exports, "SubscriptionObserver", ()=>SubscriptionObserver
);
/**
 * The basic Observable class. This primitive is used to wrap asynchronous
 * data streams in a common standardized data type that is interoperable
 * between libraries and can be composed to represent more complex processes.
 */ parcelHelpers.export(exports, "Observable", ()=>Observable
);
/**
 * Based on <https://raw.githubusercontent.com/zenparsing/zen-observable/master/src/Observable.js>
 * At commit: f63849a8c60af5d514efc8e9d6138d8273c49ad6
 */ var _symbols = require("./symbols");
var _symbols1 = require("./_symbols");
const SymbolIterator = _symbols1.getSymbol("iterator");
const SymbolObservable = _symbols1.getSymbol("observable");
const SymbolSpecies = _symbols1.getSymbol("species");
// === Abstract Operations ===
function getMethod(obj, key) {
    const value = obj[key];
    if (value == null) return undefined;
    if (typeof value !== "function") throw new TypeError(value + " is not a function");
    return value;
}
function getSpecies(obj) {
    let ctor = obj.constructor;
    if (ctor !== undefined) {
        ctor = ctor[SymbolSpecies];
        if (ctor === null) ctor = undefined;
    }
    return ctor !== undefined ? ctor : Observable;
}
function isObservable(x) {
    return x instanceof Observable; // SPEC: Brand check
}
function hostReportError(error) {
    if (hostReportError.log) hostReportError.log(error);
    else setTimeout(()=>{
        throw error;
    }, 0);
}
function enqueue(fn) {
    Promise.resolve().then(()=>{
        try {
            fn();
        } catch (e) {
            hostReportError(e);
        }
    });
}
function cleanupSubscription(subscription) {
    const cleanup = subscription._cleanup;
    if (cleanup === undefined) return;
    subscription._cleanup = undefined;
    if (!cleanup) return;
    try {
        if (typeof cleanup === "function") cleanup();
        else {
            const unsubscribe = getMethod(cleanup, "unsubscribe");
            if (unsubscribe) unsubscribe.call(cleanup);
        }
    } catch (e) {
        hostReportError(e);
    }
}
function closeSubscription(subscription) {
    subscription._observer = undefined;
    subscription._queue = undefined;
    subscription._state = "closed";
}
function flushSubscription(subscription) {
    const queue = subscription._queue;
    if (!queue) return;
    subscription._queue = undefined;
    subscription._state = "ready";
    for (const item of queue){
        notifySubscription(subscription, item.type, item.value);
        if (subscription._state === "closed") break;
    }
}
function notifySubscription(subscription, type, value) {
    subscription._state = "running";
    const observer = subscription._observer;
    try {
        const m = observer ? getMethod(observer, type) : undefined;
        switch(type){
            case "next":
                if (m) m.call(observer, value);
                break;
            case "error":
                closeSubscription(subscription);
                if (m) m.call(observer, value);
                else throw value;
                break;
            case "complete":
                closeSubscription(subscription);
                if (m) m.call(observer);
                break;
        }
    } catch (e) {
        hostReportError(e);
    }
    if (subscription._state === "closed") cleanupSubscription(subscription);
    else if (subscription._state === "running") subscription._state = "ready";
}
function onNotify(subscription, type, value) {
    if (subscription._state === "closed") return;
    if (subscription._state === "buffering") {
        subscription._queue = subscription._queue || [];
        subscription._queue.push({
            type,
            value
        });
        return;
    }
    if (subscription._state !== "ready") {
        subscription._state = "buffering";
        subscription._queue = [
            {
                type,
                value
            }
        ];
        enqueue(()=>flushSubscription(subscription)
        );
        return;
    }
    notifySubscription(subscription, type, value);
}
class Subscription {
    constructor(observer, subscriber){
        // ASSERT: observer is an object
        // ASSERT: subscriber is callable
        this._cleanup = undefined;
        this._observer = observer;
        this._queue = undefined;
        this._state = "initializing";
        const subscriptionObserver = new SubscriptionObserver(this);
        try {
            this._cleanup = subscriber.call(undefined, subscriptionObserver);
        } catch (e) {
            subscriptionObserver.error(e);
        }
        if (this._state === "initializing") this._state = "ready";
    }
    get closed() {
        return this._state === "closed";
    }
    unsubscribe() {
        if (this._state !== "closed") {
            closeSubscription(this);
            cleanupSubscription(this);
        }
    }
}
class SubscriptionObserver {
    constructor(subscription1){
        this._subscription = subscription1;
    }
    get closed() {
        return this._subscription._state === "closed";
    }
    next(value) {
        onNotify(this._subscription, "next", value);
    }
    error(value) {
        onNotify(this._subscription, "error", value);
    }
    complete() {
        onNotify(this._subscription, "complete");
    }
}
class Observable {
    constructor(subscriber1){
        if (!(this instanceof Observable)) throw new TypeError("Observable cannot be called as a function");
        if (typeof subscriber1 !== "function") throw new TypeError("Observable initializer must be a function");
        this._subscriber = subscriber1;
    }
    subscribe(nextOrObserver, onError, onComplete) {
        if (typeof nextOrObserver !== "object" || nextOrObserver === null) nextOrObserver = {
            next: nextOrObserver,
            error: onError,
            complete: onComplete
        };
        return new Subscription(nextOrObserver, this._subscriber);
    }
    pipe(first, ...mappers) {
        // tslint:disable-next-line no-this-assignment
        let intermediate = this;
        for (const mapper of [
            first,
            ...mappers
        ])intermediate = mapper(intermediate);
        return intermediate;
    }
    tap(nextOrObserver, onError, onComplete) {
        const tapObserver = typeof nextOrObserver !== "object" || nextOrObserver === null ? {
            next: nextOrObserver,
            error: onError,
            complete: onComplete
        } : nextOrObserver;
        return new Observable((observer1)=>{
            return this.subscribe({
                next (value) {
                    tapObserver.next && tapObserver.next(value);
                    observer1.next(value);
                },
                error (error) {
                    tapObserver.error && tapObserver.error(error);
                    observer1.error(error);
                },
                complete () {
                    tapObserver.complete && tapObserver.complete();
                    observer1.complete();
                },
                start (subscription) {
                    tapObserver.start && tapObserver.start(subscription);
                }
            });
        });
    }
    forEach(fn) {
        return new Promise((resolve, reject)=>{
            if (typeof fn !== "function") {
                reject(new TypeError(fn + " is not a function"));
                return;
            }
            function done() {
                subscription2.unsubscribe();
                resolve(undefined);
            }
            const subscription2 = this.subscribe({
                next (value) {
                    try {
                        fn(value, done);
                    } catch (e) {
                        reject(e);
                        subscription2.unsubscribe();
                    }
                },
                error (error) {
                    reject(error);
                },
                complete () {
                    resolve(undefined);
                }
            });
        });
    }
    map(fn) {
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        const C = getSpecies(this);
        return new C((observer1)=>this.subscribe({
                next (value) {
                    let propagatedValue = value;
                    try {
                        propagatedValue = fn(value);
                    } catch (e) {
                        return observer1.error(e);
                    }
                    observer1.next(propagatedValue);
                },
                error (e) {
                    observer1.error(e);
                },
                complete () {
                    observer1.complete();
                }
            })
        );
    }
    filter(fn) {
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        const C = getSpecies(this);
        return new C((observer1)=>this.subscribe({
                next (value) {
                    try {
                        if (!fn(value)) return;
                    } catch (e) {
                        return observer1.error(e);
                    }
                    observer1.next(value);
                },
                error (e) {
                    observer1.error(e);
                },
                complete () {
                    observer1.complete();
                }
            })
        );
    }
    reduce(fn, seed) {
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        const C = getSpecies(this);
        const hasSeed = arguments.length > 1;
        let hasValue = false;
        let acc = seed;
        return new C((observer1)=>this.subscribe({
                next (value) {
                    const first = !hasValue;
                    hasValue = true;
                    if (!first || hasSeed) try {
                        acc = fn(acc, value);
                    } catch (e) {
                        return observer1.error(e);
                    }
                    else acc = value;
                },
                error (e) {
                    observer1.error(e);
                },
                complete () {
                    if (!hasValue && !hasSeed) return observer1.error(new TypeError("Cannot reduce an empty sequence"));
                    observer1.next(acc);
                    observer1.complete();
                }
            })
        );
    }
    concat(...sources) {
        const C = getSpecies(this);
        return new C((observer1)=>{
            let subscription2;
            let index = 0;
            function startNext(next) {
                subscription2 = next.subscribe({
                    next (v) {
                        observer1.next(v);
                    },
                    error (e) {
                        observer1.error(e);
                    },
                    complete () {
                        if (index === sources.length) {
                            subscription2 = undefined;
                            observer1.complete();
                        } else startNext(C.from(sources[index++]));
                    }
                });
            }
            startNext(this);
            return ()=>{
                if (subscription2) {
                    subscription2.unsubscribe();
                    subscription2 = undefined;
                }
            };
        });
    }
    flatMap(fn) {
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        const C = getSpecies(this);
        return new C((observer1)=>{
            const subscriptions = [];
            const outer = this.subscribe({
                next (value) {
                    let normalizedValue;
                    if (fn) try {
                        normalizedValue = fn(value);
                    } catch (e) {
                        return observer1.error(e);
                    }
                    else normalizedValue = value;
                    const inner = C.from(normalizedValue).subscribe({
                        next (innerValue) {
                            observer1.next(innerValue);
                        },
                        error (e) {
                            observer1.error(e);
                        },
                        complete () {
                            const i = subscriptions.indexOf(inner);
                            if (i >= 0) subscriptions.splice(i, 1);
                            completeIfDone();
                        }
                    });
                    subscriptions.push(inner);
                },
                error (e) {
                    observer1.error(e);
                },
                complete () {
                    completeIfDone();
                }
            });
            function completeIfDone() {
                if (outer.closed && subscriptions.length === 0) observer1.complete();
            }
            return ()=>{
                subscriptions.forEach((s)=>s.unsubscribe()
                );
                outer.unsubscribe();
            };
        });
    }
    [(Symbol.observable, SymbolObservable)]() {
        return this;
    }
    static from(x) {
        const C = typeof this === "function" ? this : Observable;
        if (x == null) throw new TypeError(x + " is not an object");
        const observableMethod = getMethod(x, SymbolObservable);
        if (observableMethod) {
            const observable = observableMethod.call(x);
            if (Object(observable) !== observable) throw new TypeError(observable + " is not an object");
            if (isObservable(observable) && observable.constructor === C) return observable;
            return new C((observer1)=>observable.subscribe(observer1)
            );
        }
        if (_symbols1.hasSymbol("iterator")) {
            const iteratorMethod = getMethod(x, SymbolIterator);
            if (iteratorMethod) return new C((observer1)=>{
                enqueue(()=>{
                    if (observer1.closed) return;
                    for (const item of iteratorMethod.call(x)){
                        observer1.next(item);
                        if (observer1.closed) return;
                    }
                    observer1.complete();
                });
            });
        }
        if (Array.isArray(x)) return new C((observer1)=>{
            enqueue(()=>{
                if (observer1.closed) return;
                for (const item of x){
                    observer1.next(item);
                    if (observer1.closed) return;
                }
                observer1.complete();
            });
        });
        throw new TypeError(x + " is not observable");
    }
    static of(...items) {
        const C = typeof this === "function" ? this : Observable;
        return new C((observer1)=>{
            enqueue(()=>{
                if (observer1.closed) return;
                for (const item of items){
                    observer1.next(item);
                    if (observer1.closed) return;
                }
                observer1.complete();
            });
        });
    }
    static get [SymbolSpecies]() {
        return this;
    }
}
if (_symbols1.hasSymbols()) Object.defineProperty(Observable, Symbol("extensions"), {
    value: {
        symbol: SymbolObservable,
        hostReportError
    },
    configurable: true
});
exports.default = Observable;

},{"./symbols":"7ns86","./_symbols":"jHAym","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7ns86":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jHAym":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hasSymbols", ()=>hasSymbols
);
parcelHelpers.export(exports, "hasSymbol", ()=>hasSymbol
);
parcelHelpers.export(exports, "getSymbol", ()=>getSymbol
);
parcelHelpers.export(exports, "registerObservableSymbol", ()=>registerObservableSymbol
);
const hasSymbols = ()=>typeof Symbol === "function"
;
const hasSymbol = (name)=>hasSymbols() && Boolean(Symbol[name])
;
const getSymbol = (name)=>hasSymbol(name) ? Symbol[name] : "@@" + name
;
function registerObservableSymbol() {
    if (hasSymbols() && !hasSymbol("observable")) Symbol.observable = Symbol("observable");
}
if (!hasSymbol("asyncIterator")) Symbol.asyncIterator = Symbol.asyncIterator || Symbol.for("Symbol.asyncIterator");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"8bAUj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Unsubscribe from a subscription returned by something that looks like an observable,
 * but is not necessarily our observable implementation.
 */ function unsubscribe(subscription) {
    if (typeof subscription === "function") subscription();
    else if (subscription && typeof subscription.unsubscribe === "function") subscription.unsubscribe();
}
exports.default = unsubscribe;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cKuIA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _scheduler = require("./_scheduler");
var _util = require("./_util");
var _observable = require("./observable");
var _observableDefault = parcelHelpers.interopDefault(_observable);
var _unsubscribe = require("./unsubscribe");
var _unsubscribeDefault = parcelHelpers.interopDefault(_unsubscribe);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = undefined && undefined.__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v1) {
            resolve({
                value: v1,
                done: d
            });
        }, reject);
    }
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {
    }, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
};
/**
 * Maps the values emitted by another observable. In contrast to `map()`
 * the `mapper` function returns an array of values that will be emitted
 * separately.
 * Use `flatMap()` to map input values to zero, one or multiple output
 * values. To be applied to an input observable using `pipe()`.
 */ function flatMap(mapper) {
    return (observable)=>{
        return new _observableDefault.default((observer)=>{
            const scheduler = new _scheduler.AsyncSerialScheduler(observer);
            const subscription = observable.subscribe({
                complete () {
                    scheduler.complete();
                },
                error (error) {
                    scheduler.error(error);
                },
                next (input) {
                    scheduler.schedule((next)=>__awaiter(this, void 0, void 0, function*() {
                            var e_1, _a;
                            const mapped = yield mapper(input);
                            if (_util.isIterator(mapped) || _util.isAsyncIterator(mapped)) try {
                                for(var mapped_1 = __asyncValues(mapped), mapped_1_1; mapped_1_1 = yield mapped_1.next(), !mapped_1_1.done;){
                                    const element = mapped_1_1.value;
                                    next(element);
                                }
                            } catch (e_1_1) {
                                e_1 = {
                                    error: e_1_1
                                };
                            } finally{
                                try {
                                    if (mapped_1_1 && !mapped_1_1.done && (_a = mapped_1.return)) yield _a.call(mapped_1);
                                } finally{
                                    if (e_1) throw e_1.error;
                                }
                            }
                            else mapped.map((output)=>next(output)
                            );
                        })
                    );
                }
            });
            return ()=>_unsubscribeDefault.default(subscription)
            ;
        });
    };
}
exports.default = flatMap;

},{"./_scheduler":"3sas9","./_util":"2wZ5z","./observable":"aPcZZ","./unsubscribe":"8bAUj","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"2wZ5z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isAsyncIterator", ()=>isAsyncIterator
);
parcelHelpers.export(exports, "isIterator", ()=>isIterator
);
/// <reference lib="es2018" />
var _symbols = require("./_symbols");
function isAsyncIterator(thing) {
    return thing && _symbols.hasSymbol("asyncIterator") && thing[Symbol.asyncIterator];
}
function isIterator(thing) {
    return thing && _symbols.hasSymbol("iterator") && thing[Symbol.iterator];
}

},{"./_symbols":"jHAym","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"64Mjg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _observable = require("./observable");
function interval(period) {
    return new _observable.Observable((observer)=>{
        let counter = 0;
        const handle = setInterval(()=>{
            observer.next(counter++);
        }, period);
        return ()=>clearInterval(handle)
        ;
    });
}
exports.default = interval;

},{"./observable":"aPcZZ","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7bmbM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _scheduler = require("./_scheduler");
var _observable = require("./observable");
var _observableDefault = parcelHelpers.interopDefault(_observable);
var _unsubscribe = require("./unsubscribe");
var _unsubscribeDefault = parcelHelpers.interopDefault(_unsubscribe);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * Maps the values emitted by another observable to different values.
 * To be applied to an input observable using `pipe()`.
 */ function map(mapper) {
    return (observable)=>{
        return new _observableDefault.default((observer)=>{
            const scheduler = new _scheduler.AsyncSerialScheduler(observer);
            const subscription = observable.subscribe({
                complete () {
                    scheduler.complete();
                },
                error (error) {
                    scheduler.error(error);
                },
                next (input) {
                    scheduler.schedule((next)=>__awaiter(this, void 0, void 0, function*() {
                            const mapped = yield mapper(input);
                            next(mapped);
                        })
                    );
                }
            });
            return ()=>_unsubscribeDefault.default(subscription)
            ;
        });
    };
}
exports.default = map;

},{"./_scheduler":"3sas9","./observable":"aPcZZ","./unsubscribe":"8bAUj","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"fY3su":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _observable = require("./observable");
var _unsubscribe = require("./unsubscribe");
var _unsubscribeDefault = parcelHelpers.interopDefault(_unsubscribe);
function merge(...observables) {
    if (observables.length === 0) return _observable.Observable.from([]);
    return new _observable.Observable((observer)=>{
        let completed = 0;
        const subscriptions = observables.map((input)=>{
            return input.subscribe({
                error (error) {
                    observer.error(error);
                    unsubscribeAll();
                },
                next (value) {
                    observer.next(value);
                },
                complete () {
                    if ((++completed) === observables.length) {
                        observer.complete();
                        unsubscribeAll();
                    }
                }
            });
        });
        const unsubscribeAll = ()=>{
            subscriptions.forEach((subscription)=>_unsubscribeDefault.default(subscription)
            );
        };
        return unsubscribeAll;
    });
}
exports.default = merge;

},{"./observable":"aPcZZ","./unsubscribe":"8bAUj","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3Ml4G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _observable = require("./observable");
var _observableDefault = parcelHelpers.interopDefault(_observable);
var _subject = require("./subject");
var _subjectDefault = parcelHelpers.interopDefault(_subject);
var _unsubscribe = require("./unsubscribe");
var _unsubscribeDefault = parcelHelpers.interopDefault(_unsubscribe);
// TODO: Subject already creates additional observables "under the hood",
//       now we introduce even more. A true native MulticastObservable
//       would be preferable.
/**
 * Takes a "cold" observable and returns a wrapping "hot" observable that
 * proxies the input observable's values and errors.
 *
 * An observable is called "cold" when its initialization function is run
 * for each new subscriber. This is how observable-fns's `Observable`
 * implementation works.
 *
 * A hot observable is an observable where new subscribers subscribe to
 * the upcoming values of an already-initialiazed observable.
 *
 * The multicast observable will lazily subscribe to the source observable
 * once it has its first own subscriber and will unsubscribe from the
 * source observable when its last own subscriber unsubscribed.
 */ function multicast(coldObservable) {
    const subject = new _subjectDefault.default();
    let sourceSubscription;
    let subscriberCount = 0;
    return new _observableDefault.default((observer)=>{
        // Init source subscription lazily
        if (!sourceSubscription) sourceSubscription = coldObservable.subscribe(subject);
        // Pipe all events from `subject` into this observable
        const subscription = subject.subscribe(observer);
        subscriberCount++;
        return ()=>{
            subscriberCount--;
            subscription.unsubscribe();
            // Close source subscription once last subscriber has unsubscribed
            if (subscriberCount === 0) {
                _unsubscribeDefault.default(sourceSubscription);
                sourceSubscription = undefined;
            }
        };
    });
}
exports.default = multicast;

},{"./observable":"aPcZZ","./subject":"aAD8A","./unsubscribe":"8bAUj","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aAD8A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _observable = require("./observable");
var _observableDefault = parcelHelpers.interopDefault(_observable);
// TODO: This observer iteration approach looks inelegant and expensive
// Idea: Come up with super class for Subscription that contains the
//       notify*, ... methods and use it here
/**
 * A subject is a "hot" observable (see `multicast`) that has its observer
 * methods (`.next(value)`, `.error(error)`, `.complete()`) exposed.
 *
 * Be careful, though! With great power comes great responsibility. Only use
 * the `Subject` when you really need to trigger updates "from the outside" and
 * try to keep the code that can access it to a minimum. Return
 * `Observable.from(mySubject)` to not allow other code to mutate.
 */ class MulticastSubject extends _observableDefault.default {
    constructor(){
        super((observer)=>{
            this._observers.add(observer);
            return ()=>this._observers.delete(observer)
            ;
        });
        this._observers = new Set();
    }
    next(value) {
        for (const observer of this._observers)observer.next(value);
    }
    error(error) {
        for (const observer of this._observers)observer.error(error);
    }
    complete() {
        for (const observer of this._observers)observer.complete();
    }
}
exports.default = MulticastSubject;

},{"./observable":"aPcZZ","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3zMkd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _scheduler = require("./_scheduler");
var _observable = require("./observable");
var _observableDefault = parcelHelpers.interopDefault(_observable);
var _unsubscribe = require("./unsubscribe");
var _unsubscribeDefault = parcelHelpers.interopDefault(_unsubscribe);
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function scan(accumulator, seed) {
    return (observable)=>{
        return new _observableDefault.default((observer)=>{
            let accumulated;
            let index = 0;
            const scheduler = new _scheduler.AsyncSerialScheduler(observer);
            const subscription = observable.subscribe({
                complete () {
                    scheduler.complete();
                },
                error (error) {
                    scheduler.error(error);
                },
                next (value) {
                    scheduler.schedule((next)=>__awaiter(this, void 0, void 0, function*() {
                            const prevAcc = index === 0 ? typeof seed === "undefined" ? value : seed : accumulated;
                            accumulated = yield accumulator(prevAcc, value, index++);
                            next(accumulated);
                        })
                    );
                }
            });
            return ()=>_unsubscribeDefault.default(subscription)
            ;
        });
    };
}
exports.default = scan;

},{"./_scheduler":"3sas9","./observable":"aPcZZ","./unsubscribe":"8bAUj","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"37gOA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Based on <https://github.com/es-shims/Promise.allSettled/blob/master/implementation.js>
parcelHelpers.export(exports, "allSettled", ()=>allSettled
);
function allSettled(values) {
    return Promise.all(values.map((item)=>{
        const onFulfill = (value)=>{
            return {
                status: 'fulfilled',
                value
            };
        };
        const onReject = (reason)=>{
            return {
                status: 'rejected',
                reason
            };
        };
        const itemPromise = Promise.resolve(item);
        try {
            return itemPromise.then(onFulfill, onReject);
        } catch (error) {
            return Promise.reject(error);
        }
    }));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eIZUQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PoolEventType", ()=>PoolEventType
);
var PoolEventType;
(function(PoolEventType1) {
    PoolEventType1["initialized"] = "initialized";
    PoolEventType1["taskCanceled"] = "taskCanceled";
    PoolEventType1["taskCompleted"] = "taskCompleted";
    PoolEventType1["taskFailed"] = "taskFailed";
    PoolEventType1["taskQueued"] = "taskQueued";
    PoolEventType1["taskQueueDrained"] = "taskQueueDrained";
    PoolEventType1["taskStart"] = "taskStart";
    PoolEventType1["terminated"] = "terminated";
})(PoolEventType || (PoolEventType = {
}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"g4mmB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Thread", ()=>Thread
);
var _symbols = require("../symbols");
function fail(message) {
    throw Error(message);
}
const Thread = {
    /** Return an observable that can be used to subscribe to all errors happening in the thread. */ errors (thread) {
        return thread[_symbols.$errors] || fail("Error observable not found. Make sure to pass a thread instance as returned by the spawn() promise.");
    },
    /** Return an observable that can be used to subscribe to internal events happening in the thread. Useful for debugging. */ events (thread) {
        return thread[_symbols.$events] || fail("Events observable not found. Make sure to pass a thread instance as returned by the spawn() promise.");
    },
    /** Terminate a thread. Remember to terminate every thread when you are done using it. */ terminate (thread) {
        return thread[_symbols.$terminate]();
    }
};

},{"../symbols":"aKpb7","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aKpb7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "$errors", ()=>$errors
);
parcelHelpers.export(exports, "$events", ()=>$events
);
parcelHelpers.export(exports, "$terminate", ()=>$terminate
);
parcelHelpers.export(exports, "$transferable", ()=>$transferable
);
parcelHelpers.export(exports, "$worker", ()=>$worker
);
const $errors = Symbol("thread.errors");
const $events = Symbol("thread.events");
const $terminate = Symbol("thread.terminate");
const $transferable = Symbol("thread.transferable");
const $worker = Symbol("thread.worker");

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6sW3k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Spawn a new thread. Takes a fresh worker instance, wraps it in a thin
 * abstraction layer to provide the transparent API and verifies that
 * the worker has initialized successfully.
 *
 * @param worker Instance of `Worker`. Either a web worker, `worker_threads` worker or `tiny-worker` worker.
 * @param [options]
 * @param [options.timeout] Init message timeout. Default: 10000 or set by environment variable.
 */ parcelHelpers.export(exports, "spawn", ()=>spawn
);
var _debug = require("debug");
var _debugDefault = parcelHelpers.interopDefault(_debug);
var _observableFns = require("observable-fns");
var _common = require("../common");
var _promise = require("../promise");
var _symbols = require("../symbols");
var _master = require("../types/master");
var _invocationProxy = require("./invocation-proxy");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const debugMessages = _debugDefault.default("threads:master:messages");
const debugSpawn = _debugDefault.default("threads:master:spawn");
const debugThreadUtils = _debugDefault.default("threads:master:thread-utils");
const isInitMessage = (data)=>data && data.type === "init"
;
const isUncaughtErrorMessage = (data)=>data && data.type === "uncaughtError"
;
const initMessageTimeout = 10000;
function withTimeout(promise, timeoutInMs, errorMessage) {
    return __awaiter(this, void 0, void 0, function*() {
        let timeoutHandle;
        const timeout = new Promise((resolve, reject)=>{
            timeoutHandle = setTimeout(()=>reject(Error(errorMessage))
            , timeoutInMs);
        });
        const result = yield Promise.race([
            promise,
            timeout
        ]);
        clearTimeout(timeoutHandle);
        return result;
    });
}
function receiveInitMessage(worker) {
    return new Promise((resolve, reject)=>{
        const messageHandler = (event)=>{
            debugMessages("Message from worker before finishing initialization:", event.data);
            if (isInitMessage(event.data)) {
                worker.removeEventListener("message", messageHandler);
                resolve(event.data);
            } else if (isUncaughtErrorMessage(event.data)) {
                worker.removeEventListener("message", messageHandler);
                reject(_common.deserialize(event.data.error));
            }
        };
        worker.addEventListener("message", messageHandler);
    });
}
function createEventObservable(worker, workerTermination) {
    return new _observableFns.Observable((observer)=>{
        const messageHandler = (messageEvent)=>{
            const workerEvent = {
                type: _master.WorkerEventType.message,
                data: messageEvent.data
            };
            observer.next(workerEvent);
        };
        const rejectionHandler = (errorEvent)=>{
            debugThreadUtils("Unhandled promise rejection event in thread:", errorEvent);
            const workerEvent = {
                type: _master.WorkerEventType.internalError,
                error: Error(errorEvent.reason)
            };
            observer.next(workerEvent);
        };
        worker.addEventListener("message", messageHandler);
        worker.addEventListener("unhandledrejection", rejectionHandler);
        workerTermination.then(()=>{
            const terminationEvent = {
                type: _master.WorkerEventType.termination
            };
            worker.removeEventListener("message", messageHandler);
            worker.removeEventListener("unhandledrejection", rejectionHandler);
            observer.next(terminationEvent);
            observer.complete();
        });
    });
}
function createTerminator(worker) {
    const [termination, resolver] = _promise.createPromiseWithResolver();
    const terminate = ()=>__awaiter(this, void 0, void 0, function*() {
            debugThreadUtils("Terminating worker");
            // Newer versions of worker_threads workers return a promise
            yield worker.terminate();
            resolver();
        })
    ;
    return {
        terminate,
        termination
    };
}
function setPrivateThreadProps(raw, worker, workerEvents, terminate) {
    const workerErrors = workerEvents.filter((event)=>event.type === _master.WorkerEventType.internalError
    ).map((errorEvent)=>errorEvent.error
    );
    // tslint:disable-next-line prefer-object-spread
    return Object.assign(raw, {
        [_symbols.$errors]: workerErrors,
        [_symbols.$events]: workerEvents,
        [_symbols.$terminate]: terminate,
        [_symbols.$worker]: worker
    });
}
function spawn(worker, options) {
    return __awaiter(this, void 0, void 0, function*() {
        debugSpawn("Initializing new thread");
        const timeout = options && options.timeout ? options.timeout : initMessageTimeout;
        const initMessage = yield withTimeout(receiveInitMessage(worker), timeout, `Timeout: Did not receive an init message from worker after ${timeout}ms. Make sure the worker calls expose().`);
        const exposed = initMessage.exposed;
        const { termination , terminate  } = createTerminator(worker);
        const events = createEventObservable(worker, termination);
        if (exposed.type === "function") {
            const proxy = _invocationProxy.createProxyFunction(worker);
            return setPrivateThreadProps(proxy, worker, events, terminate);
        } else if (exposed.type === "module") {
            const proxy = _invocationProxy.createProxyModule(worker, exposed.methods);
            return setPrivateThreadProps(proxy, worker, events, terminate);
        } else {
            const type = exposed.type;
            throw Error(`Worker init message states unexpected type of expose(): ${type}`);
        }
    });
}

},{"debug":"k8UUl","observable-fns":"2iolv","../common":"6SvEV","../promise":"79Gq6","../symbols":"aKpb7","../types/master":"5Ushw","./invocation-proxy":"20GMb","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"79Gq6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a new promise and exposes its resolver function.
 * Use with care!
 */ parcelHelpers.export(exports, "createPromiseWithResolver", ()=>createPromiseWithResolver
);
const doNothing = ()=>undefined
;
function createPromiseWithResolver() {
    let alreadyResolved = false;
    let resolvedTo;
    let resolver = doNothing;
    const promise = new Promise((resolve)=>{
        if (alreadyResolved) resolve(resolvedTo);
        else resolver = resolve;
    });
    const exposedResolver = (value)=>{
        alreadyResolved = true;
        resolvedTo = value;
        resolver(resolvedTo);
    };
    return [
        promise,
        exposedResolver
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5Ushw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WorkerEventType", ()=>WorkerEventType
);
/// <reference lib="dom" />
// tslint:disable max-classes-per-file
var _symbols = require("../symbols");
var WorkerEventType;
(function(WorkerEventType1) {
    WorkerEventType1["internalError"] = "internalError";
    WorkerEventType1["message"] = "message";
    WorkerEventType1["termination"] = "termination";
})(WorkerEventType || (WorkerEventType = {
}));

},{"../symbols":"aKpb7","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"20GMb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createProxyFunction", ()=>createProxyFunction
);
parcelHelpers.export(exports, "createProxyModule", ()=>createProxyModule
);
/*
 * This source file contains the code for proxying calls in the master thread to calls in the workers
 * by `.postMessage()`-ing.
 *
 * Keep in mind that this code can make or break the program's performance! Need to optimize moreâ€¦
 */ var _debug = require("debug");
var _debugDefault = parcelHelpers.interopDefault(_debug);
var _observableFns = require("observable-fns");
var _common = require("../common");
var _observablePromise = require("../observable-promise");
var _transferable = require("../transferable");
var _messages = require("../types/messages");
const debugMessages = _debugDefault.default("threads:master:messages");
let nextJobUID = 1;
const dedupe = (array)=>Array.from(new Set(array))
;
const isJobErrorMessage = (data)=>data && data.type === _messages.WorkerMessageType.error
;
const isJobResultMessage = (data)=>data && data.type === _messages.WorkerMessageType.result
;
const isJobStartMessage = (data)=>data && data.type === _messages.WorkerMessageType.running
;
function createObservableForJob(worker, jobUID) {
    return new _observableFns.Observable((observer)=>{
        let asyncType;
        const messageHandler = (event)=>{
            debugMessages("Message from worker:", event.data);
            if (!event.data || event.data.uid !== jobUID) return;
            if (isJobStartMessage(event.data)) asyncType = event.data.resultType;
            else if (isJobResultMessage(event.data)) {
                if (asyncType === "promise") {
                    if (typeof event.data.payload !== "undefined") observer.next(_common.deserialize(event.data.payload));
                    observer.complete();
                    worker.removeEventListener("message", messageHandler);
                } else {
                    if (event.data.payload) observer.next(_common.deserialize(event.data.payload));
                    if (event.data.complete) {
                        observer.complete();
                        worker.removeEventListener("message", messageHandler);
                    }
                }
            } else if (isJobErrorMessage(event.data)) {
                const error = _common.deserialize(event.data.error);
                if (asyncType === "promise" || !asyncType) observer.error(error);
                else observer.error(error);
                worker.removeEventListener("message", messageHandler);
            }
        };
        worker.addEventListener("message", messageHandler);
        return ()=>{
            if (asyncType === "observable" || !asyncType) {
                const cancelMessage = {
                    type: _messages.MasterMessageType.cancel,
                    uid: jobUID
                };
                worker.postMessage(cancelMessage);
            }
            worker.removeEventListener("message", messageHandler);
        };
    });
}
function prepareArguments(rawArgs) {
    if (rawArgs.length === 0) // Exit early if possible
    return {
        args: [],
        transferables: []
    };
    const args = [];
    const transferables = [];
    for (const arg of rawArgs)if (_transferable.isTransferDescriptor(arg)) {
        args.push(_common.serialize(arg.send));
        transferables.push(...arg.transferables);
    } else args.push(_common.serialize(arg));
    return {
        args,
        transferables: transferables.length === 0 ? transferables : dedupe(transferables)
    };
}
function createProxyFunction(worker, method) {
    return (...rawArgs)=>{
        const uid = nextJobUID++;
        const { args , transferables  } = prepareArguments(rawArgs);
        const runMessage = {
            type: _messages.MasterMessageType.run,
            uid,
            method,
            args
        };
        debugMessages("Sending command to run function to worker:", runMessage);
        try {
            worker.postMessage(runMessage, transferables);
        } catch (error) {
            return _observablePromise.ObservablePromise.from(Promise.reject(error));
        }
        return _observablePromise.ObservablePromise.from(_observableFns.multicast(createObservableForJob(worker, uid)));
    };
}
function createProxyModule(worker, methodNames) {
    const proxy = {
    };
    for (const methodName of methodNames)proxy[methodName] = createProxyFunction(worker, methodName);
    return proxy;
}

},{"debug":"k8UUl","observable-fns":"2iolv","../common":"6SvEV","../observable-promise":"cKqBS","../transferable":"87TpM","../types/messages":"5rPds","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cKqBS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a hybrid, combining the APIs of an Observable and a Promise.
 *
 * It is used to proxy async process states when we are initially not sure
 * if that async process will yield values once (-> Promise) or multiple
 * times (-> Observable).
 *
 * Note that the observable promise inherits some of the observable's characteristics:
 * The `init` function will be called *once for every time anyone subscribes to it*.
 *
 * If this is undesired, derive a hot observable from it using `makeHot()` and
 * subscribe to that.
 */ parcelHelpers.export(exports, "ObservablePromise", ()=>ObservablePromise
);
var _observableFns = require("observable-fns");
const doNothing = ()=>undefined
;
const returnInput = (input)=>input
;
const runDeferred = (fn)=>Promise.resolve().then(fn)
;
function fail(error) {
    throw error;
}
function isThenable(thing) {
    return thing && typeof thing.then === "function";
}
class ObservablePromise extends _observableFns.Observable {
    constructor(init){
        super((originalObserver)=>{
            // tslint:disable-next-line no-this-assignment
            const self = this;
            const observer = Object.assign(Object.assign({
            }, originalObserver), {
                complete () {
                    originalObserver.complete();
                    self.onCompletion();
                },
                error (error) {
                    originalObserver.error(error);
                    self.onError(error);
                },
                next (value) {
                    originalObserver.next(value);
                    self.onNext(value);
                }
            });
            try {
                this.initHasRun = true;
                return init(observer);
            } catch (error) {
                observer.error(error);
            }
        });
        this.initHasRun = false;
        this.fulfillmentCallbacks = [];
        this.rejectionCallbacks = [];
        this.firstValueSet = false;
        this.state = "pending";
    }
    onNext(value) {
        if (!this.firstValueSet) {
            this.firstValue = value;
            this.firstValueSet = true;
        }
    }
    onError(error) {
        this.state = "rejected";
        this.rejection = error;
        for (const onRejected of this.rejectionCallbacks)// Promisifying the call to turn errors into unhandled promise rejections
        // instead of them failing sync and cancelling the iteration
        runDeferred(()=>onRejected(error)
        );
    }
    onCompletion() {
        this.state = "fulfilled";
        for (const onFulfilled of this.fulfillmentCallbacks)// Promisifying the call to turn errors into unhandled promise rejections
        // instead of them failing sync and cancelling the iteration
        runDeferred(()=>onFulfilled(this.firstValue)
        );
    }
    then(onFulfilledRaw, onRejectedRaw) {
        const onFulfilled = onFulfilledRaw || returnInput;
        const onRejected = onRejectedRaw || fail;
        let onRejectedCalled = false;
        return new Promise((resolve, reject)=>{
            const rejectionCallback = (error)=>{
                if (onRejectedCalled) return;
                onRejectedCalled = true;
                try {
                    resolve(onRejected(error));
                } catch (anotherError) {
                    reject(anotherError);
                }
            };
            const fulfillmentCallback = (value)=>{
                try {
                    resolve(onFulfilled(value));
                } catch (error) {
                    rejectionCallback(error);
                }
            };
            if (!this.initHasRun) this.subscribe({
                error: rejectionCallback
            });
            if (this.state === "fulfilled") return resolve(onFulfilled(this.firstValue));
            if (this.state === "rejected") {
                onRejectedCalled = true;
                return resolve(onRejected(this.rejection));
            }
            this.fulfillmentCallbacks.push(fulfillmentCallback);
            this.rejectionCallbacks.push(rejectionCallback);
        });
    }
    catch(onRejected) {
        return this.then(undefined, onRejected);
    }
    finally(onCompleted) {
        const handler = onCompleted || doNothing;
        return this.then((value)=>{
            handler();
            return value;
        }, ()=>handler()
        );
    }
    static from(thing) {
        if (isThenable(thing)) return new ObservablePromise((observer)=>{
            const onFulfilled = (value)=>{
                observer.next(value);
                observer.complete();
            };
            const onRejected = (error)=>{
                observer.error(error);
            };
            thing.then(onFulfilled, onRejected);
        });
        else return super.from(thing);
    }
}

},{"observable-fns":"2iolv","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"87TpM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isTransferDescriptor", ()=>isTransferDescriptor
);
parcelHelpers.export(exports, "Transfer", ()=>Transfer
);
var _symbols = require("./symbols");
function isTransferable(thing) {
    if (!thing || typeof thing !== "object") return false;
    // Don't check too thoroughly, since the list of transferable things in JS might grow over time
    return true;
}
function isTransferDescriptor(thing) {
    return thing && typeof thing === "object" && thing[_symbols.$transferable];
}
function Transfer(payload, transferables) {
    if (!transferables) {
        if (!isTransferable(payload)) throw Error();
        transferables = [
            payload
        ];
    }
    return {
        [_symbols.$transferable]: true,
        send: payload,
        transferables
    };
}

},{"./symbols":"aKpb7","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5rPds":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MasterMessageType", ()=>MasterMessageType
);
parcelHelpers.export(exports, "WorkerMessageType", ()=>WorkerMessageType
);
var MasterMessageType;
(function(MasterMessageType1) {
    MasterMessageType1["cancel"] = "cancel";
    MasterMessageType1["run"] = "run";
})(MasterMessageType || (MasterMessageType = {
}));
var WorkerMessageType;
(function(WorkerMessageType1) {
    WorkerMessageType1["error"] = "error";
    WorkerMessageType1["init"] = "init";
    WorkerMessageType1["result"] = "result";
    WorkerMessageType1["running"] = "running";
    WorkerMessageType1["uncaughtError"] = "uncaughtError";
})(WorkerMessageType || (WorkerMessageType = {
}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"c4MKZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "registerSerializer", ()=>_common.registerSerializer
);
parcelHelpers.export(exports, "Transfer", ()=>_transferable.Transfer
);
parcelHelpers.export(exports, "isWorkerRuntime", ()=>isWorkerRuntime
);
/**
 * Expose a function or a module (an object whose values are functions)
 * to the main thread. Must be called exactly once in every worker thread
 * to signal its API to the main thread.
 *
 * @param exposed Function or object whose values are functions
 */ parcelHelpers.export(exports, "expose", ()=>expose
);
var _isObservable = require("is-observable");
var _isObservableDefault = parcelHelpers.interopDefault(_isObservable);
var _common = require("../common");
var _transferable = require("../transferable");
var _messages = require("../types/messages");
var _implementation = require("./implementation");
var _implementationDefault = parcelHelpers.interopDefault(_implementation);
var process = require("process");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const isWorkerRuntime = _implementationDefault.default.isWorkerRuntime;
let exposeCalled = false;
const activeSubscriptions = new Map();
const isMasterJobCancelMessage = (thing)=>thing && thing.type === _messages.MasterMessageType.cancel
;
const isMasterJobRunMessage = (thing)=>thing && thing.type === _messages.MasterMessageType.run
;
/**
 * There are issues with `is-observable` not recognizing zen-observable's instances.
 * We are using `observable-fns`, but it's based on zen-observable, too.
 */ const isObservable = (thing)=>_isObservableDefault.default(thing) || isZenObservable(thing)
;
function isZenObservable(thing) {
    return thing && typeof thing === "object" && typeof thing.subscribe === "function";
}
function deconstructTransfer(thing) {
    return _transferable.isTransferDescriptor(thing) ? {
        payload: thing.send,
        transferables: thing.transferables
    } : {
        payload: thing,
        transferables: undefined
    };
}
function postFunctionInitMessage() {
    const initMessage = {
        type: _messages.WorkerMessageType.init,
        exposed: {
            type: "function"
        }
    };
    _implementationDefault.default.postMessageToMaster(initMessage);
}
function postModuleInitMessage(methodNames) {
    const initMessage = {
        type: _messages.WorkerMessageType.init,
        exposed: {
            type: "module",
            methods: methodNames
        }
    };
    _implementationDefault.default.postMessageToMaster(initMessage);
}
function postJobErrorMessage(uid, rawError) {
    const { payload: error , transferables  } = deconstructTransfer(rawError);
    const errorMessage = {
        type: _messages.WorkerMessageType.error,
        uid,
        error: _common.serialize(error)
    };
    _implementationDefault.default.postMessageToMaster(errorMessage, transferables);
}
function postJobResultMessage(uid, completed, resultValue) {
    const { payload , transferables  } = deconstructTransfer(resultValue);
    const resultMessage = {
        type: _messages.WorkerMessageType.result,
        uid,
        complete: completed ? true : undefined,
        payload
    };
    _implementationDefault.default.postMessageToMaster(resultMessage, transferables);
}
function postJobStartMessage(uid, resultType) {
    const startMessage = {
        type: _messages.WorkerMessageType.running,
        uid,
        resultType
    };
    _implementationDefault.default.postMessageToMaster(startMessage);
}
function postUncaughtErrorMessage(error) {
    try {
        const errorMessage = {
            type: _messages.WorkerMessageType.uncaughtError,
            error: _common.serialize(error)
        };
        _implementationDefault.default.postMessageToMaster(errorMessage);
    } catch (subError) {
        // tslint:disable-next-line no-console
        console.error("Not reporting uncaught error back to master thread as it occured while reporting an uncaught error already.\nLatest error:", subError, "\nOriginal error:", error);
    }
}
function runFunction(jobUID, fn, args) {
    return __awaiter(this, void 0, void 0, function*() {
        let syncResult;
        try {
            syncResult = fn(...args);
        } catch (error) {
            return postJobErrorMessage(jobUID, error);
        }
        const resultType = isObservable(syncResult) ? "observable" : "promise";
        postJobStartMessage(jobUID, resultType);
        if (isObservable(syncResult)) {
            const subscription = syncResult.subscribe((value)=>postJobResultMessage(jobUID, false, _common.serialize(value))
            , (error)=>{
                postJobErrorMessage(jobUID, _common.serialize(error));
                activeSubscriptions.delete(jobUID);
            }, ()=>{
                postJobResultMessage(jobUID, true);
                activeSubscriptions.delete(jobUID);
            });
            activeSubscriptions.set(jobUID, subscription);
        } else try {
            const result = yield syncResult;
            postJobResultMessage(jobUID, true, _common.serialize(result));
        } catch (error) {
            postJobErrorMessage(jobUID, _common.serialize(error));
        }
    });
}
function expose(exposed) {
    if (!_implementationDefault.default.isWorkerRuntime()) throw Error("expose() called in the master thread.");
    if (exposeCalled) throw Error("expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.");
    exposeCalled = true;
    if (typeof exposed === "function") {
        _implementationDefault.default.subscribeToMasterMessages((messageData)=>{
            if (isMasterJobRunMessage(messageData) && !messageData.method) runFunction(messageData.uid, exposed, messageData.args.map(_common.deserialize));
        });
        postFunctionInitMessage();
    } else if (typeof exposed === "object" && exposed) {
        _implementationDefault.default.subscribeToMasterMessages((messageData)=>{
            if (isMasterJobRunMessage(messageData) && messageData.method) runFunction(messageData.uid, exposed[messageData.method], messageData.args.map(_common.deserialize));
        });
        const methodNames = Object.keys(exposed).filter((key)=>typeof exposed[key] === "function"
        );
        postModuleInitMessage(methodNames);
    } else throw Error(`Invalid argument passed to expose(). Expected a function or an object, got: ${exposed}`);
    _implementationDefault.default.subscribeToMasterMessages((messageData)=>{
        if (isMasterJobCancelMessage(messageData)) {
            const jobUID = messageData.uid;
            const subscription = activeSubscriptions.get(jobUID);
            if (subscription) {
                subscription.unsubscribe();
                activeSubscriptions.delete(jobUID);
            }
        }
    });
}
if (typeof self !== "undefined" && typeof self.addEventListener === "function" && _implementationDefault.default.isWorkerRuntime()) {
    self.addEventListener("error", (event)=>{
        // Post with some delay, so the master had some time to subscribe to messages
        setTimeout(()=>postUncaughtErrorMessage(event.error || event)
        , 250);
    });
    self.addEventListener("unhandledrejection", (event)=>{
        const error = event.reason;
        if (error && typeof error.message === "string") // Post with some delay, so the master had some time to subscribe to messages
        setTimeout(()=>postUncaughtErrorMessage(error)
        , 250);
    });
}
if (typeof process !== "undefined" && typeof process.on === "function" && _implementationDefault.default.isWorkerRuntime()) {
    process.on("uncaughtException", (error)=>{
        // Post with some delay, so the master had some time to subscribe to messages
        setTimeout(()=>postUncaughtErrorMessage(error)
        , 250);
    });
    process.on("unhandledRejection", (error)=>{
        if (error && typeof error.message === "string") // Post with some delay, so the master had some time to subscribe to messages
        setTimeout(()=>postUncaughtErrorMessage(error)
        , 250);
    });
}

},{"process":"6Upk8","is-observable":"k7dUP","../common":"6SvEV","../transferable":"87TpM","../types/messages":"5rPds","./implementation":"5XEwV","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"k7dUP":[function(require,module,exports) {
'use strict';
module.exports = (value)=>{
    if (!value) return false;
    // eslint-disable-next-line no-use-extend-native/no-use-extend-native
    if (typeof Symbol.observable === 'symbol' && typeof value[Symbol.observable] === 'function') // eslint-disable-next-line no-use-extend-native/no-use-extend-native
    return value === value[Symbol.observable]();
    if (typeof value['@@observable'] === 'function') return value === value['@@observable']();
    return false;
};

},{}],"5XEwV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/// <reference lib="dom" />
// tslint:disable no-shadowed-variable
const isWorkerRuntime = function isWorkerRuntime1() {
    const isWindowContext = typeof self !== "undefined" && typeof Window !== "undefined" && self instanceof Window;
    return typeof self !== "undefined" && self.postMessage && !isWindowContext ? true : false;
};
const postMessageToMaster = function postMessageToMaster1(data, transferList) {
    self.postMessage(data, transferList);
};
const subscribeToMasterMessages = function subscribeToMasterMessages1(onMessage) {
    const messageHandler = (messageEvent)=>{
        onMessage(messageEvent.data);
    };
    const unsubscribe = ()=>{
        self.removeEventListener("message", messageHandler);
    };
    self.addEventListener("message", messageHandler);
    return unsubscribe;
};
exports.default = {
    isWorkerRuntime,
    postMessageToMaster,
    subscribeToMasterMessages
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"dp4t9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeFetchSource", ()=>makeFetchSource
);
parcelHelpers.export(exports, "makeXHRSource", ()=>makeXHRSource
);
parcelHelpers.export(exports, "makeHttpSource", ()=>makeHttpSource
);
/**
 *
 * @param {string} url
 * @param {object} options
 */ parcelHelpers.export(exports, "makeRemoteSource", ()=>makeRemoteSource
);
var _httputils = require("./httputils");
var _basesource = require("./basesource");
var _blockedsource = require("./blockedsource");
var _fetch = require("./client/fetch");
var _xhr = require("./client/xhr");
var _http = require("./client/http");
class RemoteSource extends _basesource.BaseSource {
    /**
   *
   * @param {BaseClient} client
   * @param {object} headers
   * @param {numbers} maxRanges
   * @param {boolean} allowFullFile
   */ constructor(client, headers, maxRanges, allowFullFile){
        super();
        this.client = client;
        this.headers = headers;
        this.maxRanges = maxRanges;
        this.allowFullFile = allowFullFile;
        this._fileSize = null;
    }
    /**
   *
   * @param {Slice[]} slices
   */ async fetch(slices, signal) {
        // if we allow multi-ranges, split the incoming request into that many sub-requests
        // and join them afterwards
        if (this.maxRanges >= slices.length) return this.fetchSlices(slices, signal);
        else this.maxRanges > 0 && slices.length;
        // otherwise make a single request for each slice
        return await Promise.all(slices.map((slice)=>this.fetchSlice(slice, signal)
        ));
    }
    async fetchSlices(slices, signal) {
        const response = await this.client.request({
            headers: {
                ...this.headers,
                Range: `bytes=${slices.map(({ offset , length  })=>`${offset}-${offset + length}`
                ).join(',')}`
            },
            signal
        });
        if (!response.ok) throw new Error('Error fetching data.');
        else if (response.status === 206) {
            const { type , params  } = _httputils.parseContentType(response.getHeader('content-type'));
            if (type === 'multipart/byteranges') {
                const byteRanges = _httputils.parseByteRanges(await response.getData(), params.boundary);
                this._fileSize = byteRanges[0].fileSize || null;
                return byteRanges;
            }
            const data = await response.getData();
            const { start , end , total  } = _httputils.parseContentRange(response.getHeader('content-range'));
            this._fileSize = total || null;
            const first = [
                {
                    data,
                    offset: start,
                    length: end - start
                }
            ];
            if (slices.length > 1) {
                // we requested more than one slice, but got only the first
                // unfortunately, some HTTP Servers don't support multi-ranges
                // and return onyl the first
                // get the rest of the slices and fetch them iteratetively
                const others = await Promise.all(slices.slice(1).map((slice)=>this.fetchSlice(slice, signal)
                ));
                return first.concat(others);
            }
            return first;
        } else {
            if (!this.allowFullFile) throw new Error('Server responded with full file');
            const data = await response.getData();
            this._fileSize = data.byteLength;
            return [
                {
                    data,
                    offset: 0,
                    length: data.byteLength
                }
            ];
        }
    }
    async fetchSlice(slice, signal) {
        const { offset , length  } = slice;
        const response = await this.client.request({
            headers: {
                ...this.headers,
                Range: `bytes=${offset}-${offset + length}`
            },
            signal
        });
        // check the response was okay and if the server actually understands range requests
        if (!response.ok) throw new Error('Error fetching data.');
        else if (response.status === 206) {
            const data = await response.getData();
            const { total  } = _httputils.parseContentRange(response.getHeader('content-range'));
            this._fileSize = total || null;
            return {
                data,
                offset,
                length
            };
        } else {
            if (!this.allowFullFile) throw new Error('Server responded with full file');
            const data = await response.getData();
            this._fileSize = data.byteLength;
            return {
                data,
                offset: 0,
                length: data.byteLength
            };
        }
    }
    get fileSize() {
        return this._fileSize;
    }
}
function maybeWrapInBlockedSource(source, { blockSize , cacheSize  }) {
    if (blockSize === null) return source;
    return new _blockedsource.BlockedSource(source, blockSize, cacheSize);
}
function makeFetchSource(url, { headers: headers1 = {
} , credentials , maxRanges: maxRanges1 = 0 , allowFullFile: allowFullFile1 = false , ...blockOptions } = {
}) {
    const client1 = new _fetch.FetchClient(url, credentials);
    const source = new RemoteSource(client1, headers1, maxRanges1, allowFullFile1);
    return maybeWrapInBlockedSource(source, blockOptions);
}
function makeXHRSource(url, { headers: headers1 = {
} , maxRanges: maxRanges1 = 0 , allowFullFile: allowFullFile1 = false , ...blockOptions } = {
}) {
    const client1 = new _xhr.XHRClient(url);
    const source = new RemoteSource(client1, headers1, maxRanges1, allowFullFile1);
    return maybeWrapInBlockedSource(source, blockOptions);
}
function makeHttpSource(url, { headers: headers1 = {
} , maxRanges: maxRanges1 = 0 , allowFullFile: allowFullFile1 = false , ...blockOptions } = {
}) {
    const client1 = new _http.HttpClient(url);
    const source = new RemoteSource(client1, headers1, maxRanges1, allowFullFile1);
    return maybeWrapInBlockedSource(source, blockOptions);
}
function makeRemoteSource(url, { forceXHR =false , ...clientOptions } = {
}) {
    if (typeof fetch === 'function' && !forceXHR) return makeFetchSource(url, clientOptions);
    if (typeof XMLHttpRequest !== 'undefined') return makeXHRSource(url, clientOptions);
    return makeHttpSource(url, clientOptions);
}

},{"./httputils":"gvOxq","./basesource":"43qzc","./blockedsource":"ftRdF","./client/fetch":"2AWs4","./client/xhr":"8Qe4o","./client/http":"8nbvX","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"gvOxq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Parse a 'Content-Type' header value to the content-type and parameters
 * @param {String} rawContentType the raw string to parse from
 * @returns {Object} the parsed content type with the fields: type and params
 */ parcelHelpers.export(exports, "parseContentType", ()=>parseContentType
);
/**
 * Parse a 'Content-Range' header value to its start, end, and total parts
 * @param {String} rawContentRange the raw string to parse from
 * @returns {Object} the parsed parts
 */ parcelHelpers.export(exports, "parseContentRange", ()=>parseContentRange
);
/**
 * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.
 * Each item in the list has the following properties:
 * - headers: the HTTP headers
 * - data: the sliced ArrayBuffer for that specific part
 * - offset: the offset of the byterange within its originating file
 * - length: the length of the byterange
 * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split
 * @param {String} boundary the boundary string used to split the sections
 * @returns {Object[]} the parsed byteranges
 */ parcelHelpers.export(exports, "parseByteRanges", ()=>parseByteRanges
);
const CRLFCRLF = '\r\n\r\n';
/*
 * Shim for 'Object.fromEntries'
 */ function itemsToObject(items) {
    if (typeof Object.fromEntries !== 'undefined') return Object.fromEntries(items);
    const obj = {
    };
    for (const [key, value] of items)obj[key.toLowerCase()] = value;
    return obj;
}
/**
 * Parse HTTP headers from a given string.
 * @param {String} text the text to parse the headers from
 * @returns {Object} the parsed headers with lowercase keys
 */ function parseHeaders(text) {
    const items = text.split('\r\n').map((line)=>{
        const kv = line.split(':').map((str)=>str.trim()
        );
        kv[0] = kv[0].toLowerCase();
        return kv;
    });
    return itemsToObject(items);
}
function parseContentType(rawContentType) {
    const [type, ...rawParams] = rawContentType.split(';').map((s)=>s.trim()
    );
    const paramsItems = rawParams.map((param)=>param.split('=')
    );
    return {
        type,
        params: itemsToObject(paramsItems)
    };
}
function parseContentRange(rawContentRange) {
    let start;
    let end;
    let total;
    if (rawContentRange) {
        [, start, end, total] = rawContentRange.match(/bytes (\d+)-(\d+)\/(\d+)/);
        start = parseInt(start, 10);
        end = parseInt(end, 10);
        total = parseInt(total, 10);
    }
    return {
        start,
        end,
        total
    };
}
function parseByteRanges(responseArrayBuffer, boundary) {
    let offset = null;
    const decoder = new TextDecoder('ascii');
    const out = [];
    const startBoundary = `--${boundary}`;
    const endBoundary = `${startBoundary}--`;
    // search for the initial boundary, may be offset by some bytes
    // TODO: more efficient to check for `--` in bytes directly
    for(let i = 0; i < 10; ++i){
        const text = decoder.decode(new Uint8Array(responseArrayBuffer, i, startBoundary.length));
        if (text === startBoundary) offset = i;
    }
    if (offset === null) throw new Error("Could not find initial boundary");
    while(offset < responseArrayBuffer.byteLength){
        const text = decoder.decode(new Uint8Array(responseArrayBuffer, offset, Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset)));
        // break if we arrived at the end
        if (text.length === 0 || text.startsWith(endBoundary)) break;
        // assert that we are actually dealing with a byterange and are at the correct offset
        if (!text.startsWith(startBoundary)) throw new Error('Part does not start with boundary');
        // get a substring from where we read the headers
        const innerText = text.substr(startBoundary.length + 2);
        if (innerText.length === 0) break;
        // find the double linebreak that denotes the end of the headers
        const endOfHeaders = innerText.indexOf(CRLFCRLF);
        // parse the headers to get the content range size
        const headers = parseHeaders(innerText.substr(0, endOfHeaders));
        const { start , end , total  } = parseContentRange(headers['content-range']);
        // calculate the length of the slice and the next offset
        const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;
        const length = parseInt(end, 10) + 1 - parseInt(start, 10);
        out.push({
            headers,
            data: responseArrayBuffer.slice(startOfData, startOfData + length),
            offset: start,
            length,
            fileSize: total
        });
        offset = startOfData + length + 4;
    }
    return out;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"43qzc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef Slice
 * @property {number} offset
 * @property {number} length
 */ parcelHelpers.export(exports, "BaseSource", ()=>BaseSource
);
class BaseSource {
    /**
   *
   * @param {Slice[]} slices
   * @returns {ArrayBuffer[]}
   */ async fetch(slices, signal) {
        return await Promise.all(slices.map((slice)=>this.fetchSlice(slice, signal)
        ));
    }
    /**
   *
   * @param {Slice} slice
   * @returns {ArrayBuffer}
   */ async fetchSlice(slice) {
        throw new Error(`fetching of slice ${slice} not possible, not implemented`);
    }
    /**
   * Returns the filesize if already determined and null otherwise
   */ get fileSize() {
        return null;
    }
    async close() {
    // no-op by default
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"ftRdF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BlockedSource", ()=>BlockedSource
);
var _lruCache = require("lru-cache");
var _lruCacheDefault = parcelHelpers.interopDefault(_lruCache);
var _basesource = require("./basesource");
var _utils = require("../utils");
class Block {
    /**
   *
   * @param {number} offset
   * @param {number} length
   * @param {ArrayBuffer} [data]
   */ constructor(offset, length, data = null){
        this.offset = offset;
        this.length = length;
        this.data = data;
    }
    /**
   * @returns {number} the top byte border
   */ get top() {
        return this.offset + this.length;
    }
}
class BlockGroup {
    /**
   *
   * @param {number} offset
   * @param {number} length
   * @param {number[]} blockIds
   */ constructor(offset1, length1, blockIds1){
        this.offset = offset1;
        this.length = length1;
        this.blockIds = blockIds1;
    }
}
class BlockedSource extends _basesource.BaseSource {
    /**
   *
   * @param {Source} source The underlying source that shall be blocked and cached
   * @param {object} options
   */ constructor(source, { blockSize =65536 , cacheSize =100  } = {
    }){
        super();
        this.source = source;
        this.blockSize = blockSize;
        this.blockCache = new _lruCacheDefault.default({
            max: cacheSize
        });
        // mapping blockId -> Block instance
        this.blockRequests = new Map();
        // set of blockIds missing for the current requests
        this.blockIdsToFetch = new Set();
    }
    get fileSize() {
        return this.source.fileSize;
    }
    /**
   *
   * @param {basesource/Slice[]} slices
   */ async fetch(slices, signal) {
        const cachedBlocks = new Map();
        const blockRequests = new Map();
        const missingBlockIds = new Set();
        for (const { offset: offset2 , length: length2  } of slices){
            let top = offset2 + length2;
            const { fileSize  } = this;
            if (fileSize !== null) top = Math.min(top, fileSize);
            const firstBlockOffset = Math.floor(offset2 / this.blockSize) * this.blockSize;
            // chunk the current slice into blocks
            for(let current = firstBlockOffset; current < top; current += this.blockSize){
                // check if the block is cached, being requested or still missing
                const blockId = Math.floor(current / this.blockSize);
                if (this.blockCache.has(blockId)) cachedBlocks.set(blockId, this.blockCache.get(blockId));
                else if (this.blockRequests.has(blockId)) blockRequests.set(blockId, this.blockRequests.get(blockId));
                else if (this.blockIdsToFetch.has(blockId)) missingBlockIds.add(blockId);
                else {
                    this.blockIdsToFetch.add(blockId);
                    missingBlockIds.add(blockId);
                }
            }
        }
        // allow additional block requests to accumulate
        await _utils.wait();
        this.fetchBlocks(signal);
        for (const blockId of missingBlockIds){
            const block = this.blockRequests.get(blockId);
            const cachedBlock = this.blockCache.get(blockId);
            if (block) blockRequests.set(blockId, block);
            else if (cachedBlock) cachedBlocks.set(blockId, cachedBlock);
            else throw new Error(`Block ${blockId} is not in the block requests`);
        }
        // actually await all pending requests
        let results = await Promise.allSettled(blockRequests.values());
        // perform retries if a block was interrupted by a previous signal
        if (results.some((result)=>result.status === 'rejected'
        )) {
            const retriedBlockRequests = new Set();
            for (const [blockId1, result] of _utils.zip(blockRequests.keys(), results)){
                const { rejected , reason  } = result;
                if (rejected) // push some blocks back to the to-fetch list if they were
                // aborted, but only when a different signal was used
                {
                    if (reason.name === 'AbortError' && reason.signal !== signal) {
                        this.blockIdsToFetch.add(blockId1);
                        retriedBlockRequests.add(blockId1);
                    }
                }
            }
            // start the retry of some blocks if required
            if (this.blockIdsToFetch.length > 0) {
                this.fetchBlocks(signal);
                for (const blockId2 of retriedBlockRequests){
                    const block = this.blockRequests.get(blockId2);
                    if (!block) throw new Error(`Block ${blockId2} is not in the block requests`);
                    blockRequests.set(blockId2, block);
                }
                results = await Promise.allSettled(Array.from(blockRequests.values()));
            }
        }
        // throw an error (either abort error or AggregateError if no abort was done)
        if (results.some((result)=>result.status === 'rejected'
        )) {
            if (signal && signal.aborted) throw new _utils.AbortError('Request was aborted');
            throw new _utils.AggregateError(results.filter((result)=>result.status === 'rejected'
            ).map((result)=>result.reason
            ), 'Request failed');
        }
        // extract the actual block responses
        const values = results.map((result)=>result.value
        );
        // create a final Map, with all required blocks for this request to satisfy
        const requiredBlocks = new Map(_utils.zip(Array.from(blockRequests.keys()), values));
        for (const [blockId1, block] of cachedBlocks)requiredBlocks.set(blockId1, block);
        // TODO: satisfy each slice
        return this.readSliceData(slices, requiredBlocks);
    }
    /**
   *
   * @param {AbortSignal} signal
   */ fetchBlocks(signal) {
        // check if we still need to
        if (this.blockIdsToFetch.size > 0) {
            const groups = this.groupBlocks(this.blockIdsToFetch);
            // start requesting slices of data
            const groupRequests = this.source.fetch(groups, signal);
            for(let groupIndex = 0; groupIndex < groups.length; ++groupIndex){
                const group = groups[groupIndex];
                for (const blockId of group.blockIds){
                    // make an async IIFE for each block
                    const blockRequest = (async ()=>{
                        try {
                            const response = (await groupRequests)[groupIndex];
                            const blockOffset = blockId * this.blockSize;
                            const o = blockOffset - response.offset;
                            const t = Math.min(o + this.blockSize, response.data.byteLength);
                            const data1 = response.data.slice(o, t);
                            const block = new Block(blockOffset, data1.byteLength, data1);
                            this.blockCache.set(blockId, block);
                            return block;
                        } catch (err) {
                            if (err.name === 'AbortError') // store the signal here, we need it to determine later if an
                            // error was caused by this signal
                            err.signal = signal;
                            throw err;
                        } finally{
                            this.blockRequests.delete(blockId);
                        }
                    })();
                    this.blockRequests.set(blockId, blockRequest);
                }
            }
            this.blockIdsToFetch.clear();
        }
    }
    /**
   *
   * @param {Set} blockIds
   * @returns {BlockGroup[]}
   */ groupBlocks(blockIds) {
        const sortedBlockIds = Array.from(blockIds).sort((a, b)=>a - b
        );
        if (sortedBlockIds.length === 0) return [];
        let current = [];
        let lastBlockId = null;
        const groups = [];
        for (const blockId of sortedBlockIds)if (lastBlockId === null || lastBlockId + 1 === blockId) {
            current.push(blockId);
            lastBlockId = blockId;
        } else {
            groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));
            current = [
                blockId
            ];
            lastBlockId = blockId;
        }
        groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));
        return groups;
    }
    /**
   *
   * @param {Slice[]} slices
   * @param {Map} blocks
   */ readSliceData(slices, blocks) {
        return slices.map((slice)=>{
            const top = slice.offset + slice.length;
            const blockIdLow = Math.floor(slice.offset / this.blockSize);
            const blockIdHigh = Math.floor((slice.offset + slice.length) / this.blockSize);
            const sliceData = new ArrayBuffer(slice.length);
            const sliceView = new Uint8Array(sliceData);
            for(let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId){
                const block = blocks.get(blockId);
                const delta = block.offset - slice.offset;
                const topDelta = block.top - top;
                let blockInnerOffset = 0;
                let rangeInnerOffset = 0;
                let usedBlockLength;
                if (delta < 0) blockInnerOffset = -delta;
                else if (delta > 0) rangeInnerOffset = delta;
                if (topDelta < 0) usedBlockLength = block.length - blockInnerOffset;
                else usedBlockLength = top - block.offset - blockInnerOffset;
                const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);
                sliceView.set(blockView, rangeInnerOffset);
            }
            return sliceData;
        });
    }
}

},{"lru-cache":"56atl","./basesource":"43qzc","../utils":"2mD3O","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"56atl":[function(require,module,exports) {
'use strict';
// A linked list to keep track of recently-used-ness
const Yallist = require('yallist');
const MAX = Symbol('max');
const LENGTH = Symbol('length');
const LENGTH_CALCULATOR = Symbol('lengthCalculator');
const ALLOW_STALE = Symbol('allowStale');
const MAX_AGE = Symbol('maxAge');
const DISPOSE = Symbol('dispose');
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
const LRU_LIST = Symbol('lruList');
const CACHE = Symbol('cache');
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');
const naiveLength = ()=>1
;
// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
    constructor(options){
        if (typeof options === 'number') options = {
            max: options
        };
        if (!options) options = {
        };
        if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number');
        // Kind of weird to have a default max of Infinity, but oh well.
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
    }
    // resize the cache when the max changes.
    set max(mL) {
        if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
        this[MAX] = mL || Infinity;
        trim(this);
    }
    get max() {
        return this[MAX];
    }
    set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
        return this[ALLOW_STALE];
    }
    set maxAge(mA) {
        if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
        this[MAX_AGE] = mA;
        trim(this);
    }
    get maxAge() {
        return this[MAX_AGE];
    }
    // resize the cache when the lengthCalculator changes.
    set lengthCalculator(lC) {
        if (typeof lC !== 'function') lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC;
            this[LENGTH] = 0;
            this[LRU_LIST].forEach((hit)=>{
                hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
                this[LENGTH] += hit.length;
            });
        }
        trim(this);
    }
    get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
    }
    get length() {
        return this[LENGTH];
    }
    get itemCount() {
        return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
        thisp = thisp || this;
        for(let walker = this[LRU_LIST].tail; walker !== null;){
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp);
            walker = prev;
        }
    }
    forEach(fn, thisp) {
        thisp = thisp || this;
        for(let walker = this[LRU_LIST].head; walker !== null;){
            const next = walker.next;
            forEachStep(this, fn, walker, thisp);
            walker = next;
        }
    }
    keys() {
        return this[LRU_LIST].toArray().map((k)=>k.key
        );
    }
    values() {
        return this[LRU_LIST].toArray().map((k)=>k.value
        );
    }
    reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) this[LRU_LIST].forEach((hit)=>this[DISPOSE](hit.key, hit.value)
        );
        this[CACHE] = new Map() // hash of items by key
        ;
        this[LRU_LIST] = new Yallist() // list of items in order of use recency
        ;
        this[LENGTH] = 0 // length of items in the list
        ;
    }
    dump() {
        return this[LRU_LIST].map((hit)=>isStale(this, hit) ? false : {
                k: hit.key,
                v: hit.value,
                e: hit.now + (hit.maxAge || 0)
            }
        ).toArray().filter((h)=>h
        );
    }
    dumpLru() {
        return this[LRU_LIST];
    }
    set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
            if (len > this[MAX]) {
                del(this, this[CACHE].get(key));
                return false;
            }
            const node = this[CACHE].get(key);
            const item = node.value;
            // dispose of the old one before overwriting
            // split out into 2 ifs for better coverage tracking
            if (this[DISPOSE]) {
                if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            trim(this);
            return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        // oversized objects fall out of cache automatically.
        if (hit.length > this[MAX]) {
            if (this[DISPOSE]) this[DISPOSE](key, value);
            return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
    }
    has(key) {
        if (!this[CACHE].has(key)) return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
    }
    get(key) {
        return get(this, key, true);
    }
    peek(key) {
        return get(this, key, false);
    }
    pop() {
        const node = this[LRU_LIST].tail;
        if (!node) return null;
        del(this, node);
        return node.value;
    }
    del(key) {
        del(this, this[CACHE].get(key));
    }
    load(arr) {
        // reset the cache
        this.reset();
        const now = Date.now();
        // A previous serialized cache has the most recent items first
        for(let l = arr.length - 1; l >= 0; l--){
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0) // the item was created without expiration in a non aged cache
            this.set(hit.k, hit.v);
            else {
                const maxAge = expiresAt - now;
                // dont add already expired items
                if (maxAge > 0) this.set(hit.k, hit.v, maxAge);
            }
        }
    }
    prune() {
        this[CACHE].forEach((value, key)=>get(this, key, false)
        );
    }
}
const get = (self, key, doUse)=>{
    const node = self[CACHE].get(key);
    if (node) {
        const hit = node.value;
        if (isStale(self, hit)) {
            del(self, node);
            if (!self[ALLOW_STALE]) return undefined;
        } else if (doUse) {
            if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
            self[LRU_LIST].unshiftNode(node);
        }
        return hit.value;
    }
};
const isStale = (self, hit)=>{
    if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};
const trim = (self)=>{
    if (self[LENGTH] > self[MAX]) for(let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;){
        // We know that we're about to delete this one, and also
        // what the next least recently used key will be, so just
        // go ahead and set it now.
        const prev = walker.prev;
        del(self, walker);
        walker = prev;
    }
};
const del = (self, node)=>{
    if (node) {
        const hit = node.value;
        if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
        self[LENGTH] -= hit.length;
        self[CACHE].delete(hit.key);
        self[LRU_LIST].removeNode(node);
    }
};
class Entry {
    constructor(key, value, length, now, maxAge){
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
    }
}
const forEachStep = (self, fn, node, thisp)=>{
    let hit = node.value;
    if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE]) hit = undefined;
    }
    if (hit) fn.call(thisp, hit.value, hit.key, self);
};
module.exports = LRUCache;

},{"yallist":"hmcey"}],"hmcey":[function(require,module,exports) {
'use strict';
module.exports = Yallist;
Yallist.Node = Node1;
Yallist.create = Yallist;
function Yallist(list) {
    var self = this;
    if (!(self instanceof Yallist)) self = new Yallist();
    self.tail = null;
    self.head = null;
    self.length = 0;
    if (list && typeof list.forEach === 'function') list.forEach(function(item) {
        self.push(item);
    });
    else if (arguments.length > 0) for(var i = 0, l = arguments.length; i < l; i++)self.push(arguments[i]);
    return self;
}
Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) throw new Error('removing node which does not belong to this list');
    var next = node.next;
    var prev = node.prev;
    if (next) next.prev = prev;
    if (prev) prev.next = next;
    if (node === this.head) this.head = next;
    if (node === this.tail) this.tail = prev;
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
};
Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) return;
    if (node.list) node.list.removeNode(node);
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) head.prev = node;
    this.head = node;
    if (!this.tail) this.tail = node;
    this.length++;
};
Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) return;
    if (node.list) node.list.removeNode(node);
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) tail.next = node;
    this.tail = node;
    if (!this.head) this.head = node;
    this.length++;
};
Yallist.prototype.push = function() {
    for(var i = 0, l = arguments.length; i < l; i++)push(this, arguments[i]);
    return this.length;
};
Yallist.prototype.unshift = function() {
    for(var i = 0, l = arguments.length; i < l; i++)unshift(this, arguments[i]);
    return this.length;
};
Yallist.prototype.pop = function() {
    if (!this.tail) return undefined;
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) this.tail.next = null;
    else this.head = null;
    this.length--;
    return res;
};
Yallist.prototype.shift = function() {
    if (!this.head) return undefined;
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) this.head.prev = null;
    else this.tail = null;
    this.length--;
    return res;
};
Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.head, i = 0; walker !== null; i++){
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
    }
};
Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.tail, i = this.length - 1; walker !== null; i--){
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
    }
};
Yallist.prototype.get = function(n) {
    for(var i = 0, walker = this.head; walker !== null && i < n; i++)// abort out of the list early if we hit a cycle
    walker = walker.next;
    if (i === n && walker !== null) return walker.value;
};
Yallist.prototype.getReverse = function(n) {
    for(var i = 0, walker = this.tail; walker !== null && i < n; i++)// abort out of the list early if we hit a cycle
    walker = walker.prev;
    if (i === n && walker !== null) return walker.value;
};
Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for(var walker = this.head; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
    }
    return res;
};
Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for(var walker = this.tail; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
    }
    return res;
};
Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) acc = initial;
    else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
    } else throw new TypeError('Reduce of empty list with no initial value');
    for(var i = 0; walker !== null; i++){
        acc = fn(acc, walker.value, i);
        walker = walker.next;
    }
    return acc;
};
Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) acc = initial;
    else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
    } else throw new TypeError('Reduce of empty list with no initial value');
    for(var i = this.length - 1; walker !== null; i--){
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
    }
    return acc;
};
Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.head; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.next;
    }
    return arr;
};
Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.tail; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.prev;
    }
    return arr;
};
Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) to += this.length;
    from = from || 0;
    if (from < 0) from += this.length;
    var ret = new Yallist();
    if (to < from || to < 0) return ret;
    if (from < 0) from = 0;
    if (to > this.length) to = this.length;
    for(var i = 0, walker = this.head; walker !== null && i < from; i++)walker = walker.next;
    for(; walker !== null && i < to; i++, walker = walker.next)ret.push(walker.value);
    return ret;
};
Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) to += this.length;
    from = from || 0;
    if (from < 0) from += this.length;
    var ret = new Yallist();
    if (to < from || to < 0) return ret;
    if (from < 0) from = 0;
    if (to > this.length) to = this.length;
    for(var i = this.length, walker = this.tail; walker !== null && i > to; i--)walker = walker.prev;
    for(; walker !== null && i > from; i--, walker = walker.prev)ret.push(walker.value);
    return ret;
};
Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) start = this.length - 1;
    if (start < 0) start = this.length + start;
    for(var i = 0, walker = this.head; walker !== null && i < start; i++)walker = walker.next;
    var ret = [];
    for(var i = 0; walker && i < deleteCount; i++){
        ret.push(walker.value);
        walker = this.removeNode(walker);
    }
    if (walker === null) walker = this.tail;
    if (walker !== this.head && walker !== this.tail) walker = walker.prev;
    for(var i = 0; i < nodes.length; i++)walker = insert(this, walker, nodes[i]);
    return ret;
};
Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for(var walker = head; walker !== null; walker = walker.prev){
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
};
function insert(self, node, value) {
    var inserted = node === self.head ? new Node1(value, null, node, self) : new Node1(value, node, node.next, self);
    if (inserted.next === null) self.tail = inserted;
    if (inserted.prev === null) self.head = inserted;
    self.length++;
    return inserted;
}
function push(self, item) {
    self.tail = new Node1(item, self.tail, null, self);
    if (!self.head) self.head = self.tail;
    self.length++;
}
function unshift(self, item) {
    self.head = new Node1(item, null, self.head, self);
    if (!self.tail) self.tail = self.head;
    self.length++;
}
function Node1(value, prev, next, list) {
    if (!(this instanceof Node1)) return new Node1(value, prev, next, list);
    this.list = list;
    this.value = value;
    if (prev) {
        prev.next = this;
        this.prev = prev;
    } else this.prev = null;
    if (next) {
        next.prev = this;
        this.next = next;
    } else this.next = null;
}
try {
    // add if support for Symbol.iterator is present
    require('./iterator.js')(Yallist);
} catch (er) {
}

},{"./iterator.js":"iagEe"}],"iagEe":[function(require,module,exports) {
'use strict';
module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function*() {
        for(let walker = this.head; walker; walker = walker.next)yield walker.value;
    };
};

},{}],"2mD3O":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "assign", ()=>assign
);
parcelHelpers.export(exports, "chunk", ()=>chunk
);
parcelHelpers.export(exports, "endsWith", ()=>endsWith
);
parcelHelpers.export(exports, "forEach", ()=>forEach
);
parcelHelpers.export(exports, "invert", ()=>invert
);
parcelHelpers.export(exports, "range", ()=>range
);
parcelHelpers.export(exports, "times", ()=>times
);
parcelHelpers.export(exports, "toArray", ()=>toArray
);
parcelHelpers.export(exports, "toArrayRecursively", ()=>toArrayRecursively
);
// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js
parcelHelpers.export(exports, "parseContentRange", ()=>parseContentRange
);
/*
 * Promisified wrapper around 'setTimeout' to allow 'await'
 */ parcelHelpers.export(exports, "wait", ()=>wait
);
parcelHelpers.export(exports, "zip", ()=>zip
);
// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error
parcelHelpers.export(exports, "AbortError", ()=>AbortError
);
parcelHelpers.export(exports, "CustomAggregateError", ()=>CustomAggregateError
);
parcelHelpers.export(exports, "AggregateError", ()=>AggregateError
);
function assign(target, source) {
    for(const key in source)if (source.hasOwnProperty(key)) target[key] = source[key];
}
function chunk(iterable, length) {
    const results = [];
    const lengthOfIterable = iterable.length;
    for(let i = 0; i < lengthOfIterable; i += length){
        const chunked = [];
        for(let ci = i; ci < i + length; ci++)chunked.push(iterable[ci]);
        results.push(chunked);
    }
    return results;
}
function endsWith(string, expectedEnding) {
    if (string.length < expectedEnding.length) return false;
    const actualEnding = string.substr(string.length - expectedEnding.length);
    return actualEnding === expectedEnding;
}
function forEach(iterable, func) {
    const { length  } = iterable;
    for(let i = 0; i < length; i++)func(iterable[i], i);
}
function invert(oldObj) {
    const newObj = {
    };
    for(const key in oldObj)if (oldObj.hasOwnProperty(key)) {
        const value = oldObj[key];
        newObj[value] = key;
    }
    return newObj;
}
function range(n) {
    const results = [];
    for(let i = 0; i < n; i++)results.push(i);
    return results;
}
function times(numTimes, func) {
    const results = [];
    for(let i = 0; i < numTimes; i++)results.push(func(i));
    return results;
}
function toArray(iterable) {
    const results = [];
    const { length  } = iterable;
    for(let i = 0; i < length; i++)results.push(iterable[i]);
    return results;
}
function toArrayRecursively(input) {
    if (input.length) return toArray(input).map(toArrayRecursively);
    return input;
}
function parseContentRange(headerValue) {
    if (!headerValue) return null;
    if (typeof headerValue !== 'string') throw new Error('invalid argument');
    const parseInt = (number)=>Number.parseInt(number, 10)
    ;
    // Check for presence of unit
    let matches = headerValue.match(/^(\w*) /);
    const unit = matches && matches[1];
    // check for start-end/size header format
    matches = headerValue.match(/(\d+)-(\d+)\/(\d+|\*)/);
    if (matches) return {
        unit,
        first: parseInt(matches[1]),
        last: parseInt(matches[2]),
        length: matches[3] === '*' ? null : parseInt(matches[3])
    };
    // check for size header format
    matches = headerValue.match(/(\d+|\*)/);
    if (matches) return {
        unit,
        first: null,
        last: null,
        length: matches[1] === '*' ? null : parseInt(matches[1])
    };
    return null;
}
async function wait(milliseconds) {
    return new Promise((resolve)=>setTimeout(resolve, milliseconds)
    );
}
function zip(a, b) {
    const A = Array.isArray(a) ? a : Array.from(a);
    const B = Array.isArray(b) ? b : Array.from(b);
    return A.map((k, i)=>[
            k,
            B[i]
        ]
    );
}
class AbortError extends Error {
    constructor(params){
        // Pass remaining arguments (including vendor specific ones) to parent constructor
        super(params);
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        if (Error.captureStackTrace) Error.captureStackTrace(this, AbortError);
        this.name = 'AbortError';
    }
}
class CustomAggregateError extends Error {
    constructor(errors, message){
        super(message);
        this.errors = errors;
        this.message = message;
        this.name = 'AggregateError';
    }
}
const AggregateError = CustomAggregateError;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"2AWs4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FetchClient", ()=>FetchClient
);
var _base = require("./base");
class FetchResponse extends _base.BaseResponse {
    /**
   * BaseResponse facade for fetch API Response
   * @param {Response} response
   */ constructor(response){
        super();
        this.response = response;
    }
    get status() {
        return this.response.status;
    }
    getHeader(name) {
        return this.response.headers.get(name);
    }
    async getData() {
        const data = this.response.arrayBuffer ? await this.response.arrayBuffer() : (await this.response.buffer()).buffer;
        return data;
    }
}
class FetchClient extends _base.BaseClient {
    constructor(url, credentials1){
        super(url);
        this.credentials = credentials1;
    }
    async request({ headers , credentials , signal  } = {
    }) {
        const response1 = await fetch(this.url, {
            headers,
            credentials,
            signal
        });
        return new FetchResponse(response1);
    }
}

},{"./base":"kyzfi","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kyzfi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseResponse", ()=>BaseResponse
);
parcelHelpers.export(exports, "BaseClient", ()=>BaseClient
);
class BaseResponse {
    /**
   * Returns whether the response has an ok'ish status code
   */ get ok() {
        return this.status >= 200 && this.status <= 299;
    }
    /**
   * Returns the status code of the response
   */ get status() {
        throw new Error('not implemented');
    }
    /**
   * Returns the value of the specified header
   * @param {string} headerName the header name
   * @returns {string} the header value
   */ getHeader(headerName) {
        throw new Error('not implemented');
    }
    /**
   * @returns {ArrayBuffer} the response data of the request
   */ async getData() {
        throw new Error('not implemented');
    }
}
class BaseClient {
    constructor(url){
        this.url = url;
    }
    /**
   * Send a request with the options
   * @param {object} [options]
   */ async request({ headers , credentials , signal  } = {
    }) {
        throw new Error(`request is not implemented`);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"8Qe4o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "XHRClient", ()=>XHRClient
);
var _base = require("./base");
var _utils = require("../../utils");
class XHRResponse extends _base.BaseResponse {
    /**
   * BaseResponse facade for XMLHttpRequest
   * @param {XMLHttpRequest} xhr
   * @param {ArrayBuffer} data
   */ constructor(xhr, data){
        super();
        this.xhr = xhr;
        this.data = data;
    }
    get status() {
        return this.xhr.status;
    }
    getHeader(name) {
        return this.xhr.getResponseHeader(name);
    }
    async getData() {
        return this.data;
    }
}
class XHRClient extends _base.BaseClient {
    constructRequest(headers, signal) {
        return new Promise((resolve, reject)=>{
            const xhr1 = new XMLHttpRequest();
            xhr1.open('GET', this.url);
            xhr1.responseType = 'arraybuffer';
            for (const [key, value] of Object.entries(headers))xhr1.setRequestHeader(key, value);
            // hook signals
            xhr1.onload = ()=>{
                const data1 = xhr1.response;
                resolve(new XHRResponse(xhr1, data1));
            };
            xhr1.onerror = reject;
            xhr1.onabort = ()=>reject(new _utils.AbortError('Request aborted'))
            ;
            xhr1.send();
            if (signal) {
                if (signal.aborted) xhr1.abort();
                signal.addEventListener('abort', ()=>xhr1.abort()
                );
            }
        });
    }
    async request({ headers , signal  } = {
    }) {
        const response = await this.constructRequest(headers, signal);
        return response;
    }
}

},{"./base":"kyzfi","../../utils":"2mD3O","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"8nbvX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HttpClient", ()=>HttpClient
);
var _http = require("http");
var _httpDefault = parcelHelpers.interopDefault(_http);
var _https = require("https");
var _httpsDefault = parcelHelpers.interopDefault(_https);
var _url = require("url");
var _urlDefault = parcelHelpers.interopDefault(_url);
var _base = require("./base");
var _utils = require("../../utils");
var Buffer = require("buffer").Buffer;
class HttpResponse extends _base.BaseResponse {
    /**
   * BaseResponse facade for node HTTP/HTTPS API Response
   * @param {http.ServerResponse} response
   */ constructor(response, dataPromise){
        super();
        this.response = response;
        this.dataPromise = dataPromise;
    }
    get status() {
        return this.response.statusCode;
    }
    getHeader(name) {
        return this.response.headers[name];
    }
    async getData() {
        const data = await this.dataPromise;
        return data;
    }
}
class HttpClient extends _base.BaseClient {
    constructor(url){
        super(url);
        this.parsedUrl = _urlDefault.default.parse(this.url);
        this.httpApi = this.parsedUrl.protocol === 'http:' ? _httpDefault.default : _httpsDefault.default;
    }
    constructRequest(headers, signal) {
        return new Promise((resolve, reject)=>{
            const request = this.httpApi.get({
                ...this.parsedUrl,
                headers
            }, (response1)=>{
                const dataPromise1 = new Promise((resolve1)=>{
                    const chunks = [];
                    // collect chunks
                    response1.on('data', (chunk)=>{
                        chunks.push(chunk);
                    });
                    // concatenate all chunks and resolve the promise with the resulting buffer
                    response1.on('end', ()=>{
                        const data = Buffer.concat(chunks).buffer;
                        resolve1(data);
                    });
                    response1.on('error', reject);
                });
                resolve(new HttpResponse(response1, dataPromise1));
            });
            request.on('error', reject);
            if (signal) {
                if (signal.aborted) request.destroy(new _utils.AbortError('Request aborted'));
                signal.addEventListener('abort', ()=>request.destroy(new _utils.AbortError('Request aborted'))
                );
            }
        });
    }
    async request({ headers , signal  } = {
    }) {
        const response1 = await this.constructRequest(headers, signal);
        return response1;
    }
}

},{"buffer":"bpNHw","http":"8VSUO","https":"8VSUO","url":"8VSUO","./base":"kyzfi","../../utils":"2mD3O","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bpNHw":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
var base64 = require('base64-js');
var ieee754 = require('ieee754');
var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 2147483647;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) Buffer.from(buf).copy(buffer, pos);
            else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError("The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type " + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare1(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError("The \"target\" argument must be one of type Buffer or Uint8Array. Received type " + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 2147483647) byteOffset = 2147483647;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 255 // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 127);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';
    for(var i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while((++i) < byteLength1 && (mul *= 256))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    var val = this[offset + --byteLength1];
    var mul = 1;
    while(byteLength1 > 0 && (mul *= 256))val += this[offset + --byteLength1] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while((++i) < byteLength1 && (mul *= 256))val += this[offset + i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength1);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    var i = byteLength1;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 256))val += this[offset + --i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength1);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength1, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength1) - 1;
        checkInt(this, value, offset, byteLength1, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while((++i) < byteLength1 && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength1;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength1, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength1) - 1;
        checkInt(this, value, offset, byteLength1, maxBytes, 0);
    }
    var i = byteLength1 - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while((--i) >= 0 && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength1;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength1, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength1 - 1);
        checkInt(this, value, offset, byteLength1, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while((++i) < byteLength1 && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength1;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength1, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength1 - 1);
        checkInt(this, value, offset, byteLength1, limit - 1, -limit);
    }
    var i = byteLength1 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while((--i) >= 0 && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength1;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 55295 && codePoint < 57344) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 56319) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 56320) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 255);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function() {
    var alphabet = '0123456789abcdef';
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();

},{"base64-js":"2vMBM","ieee754":"lz1we"}],"2vMBM":[function(require,module,exports) {
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len1 = b64.length;
    if (len1 % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len1;
    var placeHoldersLen = validLen === len1 ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len1 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i1;
    for(i1 = 0; i1 < len1; i1 += 4){
        tmp = revLookup[b64.charCodeAt(i1)] << 18 | revLookup[b64.charCodeAt(i1 + 1)] << 12 | revLookup[b64.charCodeAt(i1 + 2)] << 6 | revLookup[b64.charCodeAt(i1 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i1)] << 2 | revLookup[b64.charCodeAt(i1 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i1)] << 10 | revLookup[b64.charCodeAt(i1 + 1)] << 4 | revLookup[b64.charCodeAt(i1 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i1 = start; i1 < end; i1 += 3){
        tmp = (uint8[i1] << 16 & 16711680) + (uint8[i1 + 1] << 8 & 65280) + (uint8[i1 + 2] & 255);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len1 = uint8.length;
    var extraBytes = len1 % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i1 = 0, len2 = len1 - extraBytes; i1 < len2; i1 += maxChunkLength)parts.push(encodeChunk(uint8, i1, i1 + maxChunkLength > len2 ? len2 : i1 + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len1 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len1 - 2] << 8) + uint8[len1 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + '=');
    }
    return parts.join('');
}

},{}],"lz1we":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"8VSUO":[function(require,module,exports) {
"use strict";

},{}],"bT2m1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeBufferSource", ()=>makeBufferSource
);
var _basesource = require("./basesource");
var _utils = require("../utils");
class ArrayBufferSource extends _basesource.BaseSource {
    constructor(arrayBuffer){
        super();
        this.arrayBuffer = arrayBuffer;
    }
    fetchSlice(slice, signal) {
        if (signal && signal.aborted) throw new _utils.AbortError('Request aborted');
        return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);
    }
}
function makeBufferSource(arrayBuffer1) {
    return new ArrayBufferSource(arrayBuffer1);
}

},{"./basesource":"43qzc","../utils":"2mD3O","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7tsyU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create a new source from a given file/blob.
 * @param {Blob} file The file or blob to read from.
 * @returns The constructed source
 */ parcelHelpers.export(exports, "makeFileReaderSource", ()=>makeFileReaderSource
);
var _basesource = require("./basesource");
class FileReaderSource extends _basesource.BaseSource {
    constructor(file){
        super();
        this.file = file;
    }
    async fetchSlice(slice, signal) {
        return new Promise((resolve, reject)=>{
            const blob = this.file.slice(slice.offset, slice.offset + slice.length);
            const reader = new FileReader();
            reader.onload = (event)=>resolve(event.target.result)
            ;
            reader.onerror = reject;
            reader.onabort = reject;
            reader.readAsArrayBuffer(blob);
            if (signal) signal.addEventListener('abort', ()=>reader.abort()
            );
        });
    }
}
function makeFileReaderSource(file1) {
    return new FileReaderSource(file1);
}

},{"./basesource":"43qzc","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"4ps70":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeFileSource", ()=>makeFileSource
);
var _fs = require("fs");
var _fsDefault = parcelHelpers.interopDefault(_fs);
var _basesource = require("./basesource");
var Buffer = require("buffer").Buffer;
function closeAsync(fd) {
    return new Promise((resolve, reject)=>{
        _fsDefault.default.close(fd, (err)=>{
            if (err) reject(err);
            else resolve();
        });
    });
}
function openAsync(path, flags, mode) {
    return new Promise((resolve, reject)=>{
        _fsDefault.default.open(path, flags, mode, (err, fd)=>{
            if (err) reject(err);
            else resolve(fd);
        });
    });
}
function readAsync(...args) {
    return new Promise((resolve, reject)=>{
        _fsDefault.default.read(...args, (err, bytesRead, buffer)=>{
            if (err) reject(err);
            else resolve({
                bytesRead,
                buffer
            });
        });
    });
}
class FileSource extends _basesource.BaseSource {
    constructor(path){
        super();
        this.path = path;
        this.openRequest = openAsync(path, 'r');
    }
    async fetchSlice(slice) {
        // TODO: use `signal`
        const fd = await this.openRequest;
        const { buffer  } = await readAsync(fd, Buffer.alloc(slice.length), 0, slice.length, slice.offset);
        return buffer.buffer;
    }
    async close() {
        const fd = await this.openRequest;
        await closeAsync(fd);
    }
}
function makeFileSource(path1) {
    return new FileSource(path1);
}

},{"buffer":"bpNHw","fs":"8VSUO","./basesource":"43qzc","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"loqav":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "writeGeotiff", ()=>writeGeotiff
);
/*
  Some parts of this file are based on UTIF.js,
  which was released under the MIT License.
  You can view that here:
  https://github.com/photopea/UTIF.js/blob/master/LICENSE
*/ var _globals = require("./globals");
var _utils = require("./utils");
const tagName2Code = _utils.invert(_globals.fieldTagNames);
const geoKeyName2Code = _utils.invert(_globals.geoKeyNames);
const name2code = {
};
_utils.assign(name2code, tagName2Code);
_utils.assign(name2code, geoKeyName2Code);
const typeName2byte = _utils.invert(_globals.fieldTypeNames);
// config variables
const numBytesInIfd = 1000;
const _binBE = {
    nextZero: (data, o)=>{
        let oincr = o;
        while(data[oincr] !== 0)oincr++;
        return oincr;
    },
    readUshort: (buff, p)=>{
        return buff[p] << 8 | buff[p + 1];
    },
    readShort: (buff, p)=>{
        const a = _binBE.ui8;
        a[0] = buff[p + 1];
        a[1] = buff[p + 0];
        return _binBE.i16[0];
    },
    readInt: (buff, p)=>{
        const a = _binBE.ui8;
        a[0] = buff[p + 3];
        a[1] = buff[p + 2];
        a[2] = buff[p + 1];
        a[3] = buff[p + 0];
        return _binBE.i32[0];
    },
    readUint: (buff, p)=>{
        const a = _binBE.ui8;
        a[0] = buff[p + 3];
        a[1] = buff[p + 2];
        a[2] = buff[p + 1];
        a[3] = buff[p + 0];
        return _binBE.ui32[0];
    },
    readASCII: (buff, p, l)=>{
        return l.map((i)=>String.fromCharCode(buff[p + i])
        ).join('');
    },
    readFloat: (buff, p)=>{
        const a = _binBE.ui8;
        _utils.times(4, (i)=>{
            a[i] = buff[p + 3 - i];
        });
        return _binBE.fl32[0];
    },
    readDouble: (buff, p)=>{
        const a = _binBE.ui8;
        _utils.times(8, (i)=>{
            a[i] = buff[p + 7 - i];
        });
        return _binBE.fl64[0];
    },
    writeUshort: (buff, p, n)=>{
        buff[p] = n >> 8 & 255;
        buff[p + 1] = n & 255;
    },
    writeUint: (buff, p, n)=>{
        buff[p] = n >> 24 & 255;
        buff[p + 1] = n >> 16 & 255;
        buff[p + 2] = n >> 8 & 255;
        buff[p + 3] = n >> 0 & 255;
    },
    writeASCII: (buff, p, s)=>{
        _utils.times(s.length, (i)=>{
            buff[p + i] = s.charCodeAt(i);
        });
    },
    ui8: new Uint8Array(8)
};
_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);
_binBE.writeDouble = (buff, p, n)=>{
    _binBE.fl64[0] = n;
    _utils.times(8, (i)=>{
        buff[p + i] = _binBE.ui8[7 - i];
    });
};
const _writeIFD = (bin, data, _offset, ifd)=>{
    let offset = _offset;
    const keys = Object.keys(ifd).filter((key)=>{
        return key !== undefined && key !== null && key !== 'undefined';
    });
    bin.writeUshort(data, offset, keys.length);
    offset += 2;
    let eoff = offset + 12 * keys.length + 4;
    for (const key of keys){
        let tag = null;
        if (typeof key === 'number') tag = key;
        else if (typeof key === 'string') tag = parseInt(key, 10);
        const typeName = _globals.fieldTagTypes[tag];
        const typeNum = typeName2byte[typeName];
        if (typeName == null || typeName === undefined || typeof typeName === 'undefined') throw new Error(`unknown type of tag: ${tag}`);
        let val = ifd[key];
        if (typeof val === 'undefined') throw new Error(`failed to get value for key ${key}`);
        // ASCIIZ format with trailing 0 character
        // http://www.fileformat.info/format/tiff/corion.htm
        // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii
        if (typeName === 'ASCII' && typeof val === 'string' && _utils.endsWith(val, '\u0000') === false) val += '\u0000';
        const num = val.length;
        bin.writeUshort(data, offset, tag);
        offset += 2;
        bin.writeUshort(data, offset, typeNum);
        offset += 2;
        bin.writeUint(data, offset, num);
        offset += 4;
        let dlen = [
            -1,
            1,
            1,
            2,
            4,
            8,
            0,
            0,
            0,
            0,
            0,
            0,
            8
        ][typeNum] * num;
        let toff = offset;
        if (dlen > 4) {
            bin.writeUint(data, offset, eoff);
            toff = eoff;
        }
        if (typeName === 'ASCII') bin.writeASCII(data, toff, val);
        else if (typeName === 'SHORT') _utils.times(num, (i)=>{
            bin.writeUshort(data, toff + 2 * i, val[i]);
        });
        else if (typeName === 'LONG') _utils.times(num, (i)=>{
            bin.writeUint(data, toff + 4 * i, val[i]);
        });
        else if (typeName === 'RATIONAL') _utils.times(num, (i)=>{
            bin.writeUint(data, toff + 8 * i, Math.round(val[i] * 10000));
            bin.writeUint(data, toff + 8 * i + 4, 10000);
        });
        else if (typeName === 'DOUBLE') _utils.times(num, (i)=>{
            bin.writeDouble(data, toff + 8 * i, val[i]);
        });
        if (dlen > 4) {
            dlen += dlen & 1;
            eoff += dlen;
        }
        offset += 4;
    }
    return [
        offset,
        eoff
    ];
};
const encodeIfds = (ifds)=>{
    const data = new Uint8Array(numBytesInIfd);
    let offset = 4;
    const bin = _binBE;
    // set big-endian byte-order
    // https://en.wikipedia.org/wiki/TIFF#Byte_order
    data[0] = 77;
    data[1] = 77;
    // set format-version number
    // https://en.wikipedia.org/wiki/TIFF#Byte_order
    data[3] = 42;
    let ifdo = 8;
    bin.writeUint(data, offset, ifdo);
    offset += 4;
    ifds.forEach((ifd, i)=>{
        const noffs = _writeIFD(bin, data, ifdo, ifd);
        ifdo = noffs[1];
        if (i < ifds.length - 1) bin.writeUint(data, noffs[0], ifdo);
    });
    if (data.slice) return data.slice(0, ifdo).buffer;
    // node hasn't implemented slice on Uint8Array yet
    const result = new Uint8Array(ifdo);
    for(let i = 0; i < ifdo; i++)result[i] = data[i];
    return result.buffer;
};
const encodeImage = (values, width, height, metadata)=>{
    if (height === undefined || height === null) throw new Error(`you passed into encodeImage a width of type ${height}`);
    if (width === undefined || width === null) throw new Error(`you passed into encodeImage a width of type ${width}`);
    const ifd = {
        256: [
            width
        ],
        257: [
            height
        ],
        273: [
            numBytesInIfd
        ],
        278: [
            height
        ],
        305: 'geotiff.js'
    };
    if (metadata) {
        for(const i in metadata)if (metadata.hasOwnProperty(i)) ifd[i] = metadata[i];
    }
    const prfx = new Uint8Array(encodeIfds([
        ifd
    ]));
    const img = new Uint8Array(values);
    const samplesPerPixel = ifd[277];
    const data = new Uint8Array(numBytesInIfd + width * height * samplesPerPixel);
    _utils.times(prfx.length, (i)=>{
        data[i] = prfx[i];
    });
    _utils.forEach(img, (value, i)=>{
        data[numBytesInIfd + i] = value;
    });
    return data.buffer;
};
const convertToTids = (input)=>{
    const result = {
    };
    for(const key in input)if (key !== 'StripOffsets') {
        if (!name2code[key]) console.error(key, 'not in name2code:', Object.keys(name2code));
        result[name2code[key]] = input[key];
    }
    return result;
};
const toArray = (input)=>{
    if (Array.isArray(input)) return input;
    return [
        input
    ];
};
const metadataDefaults = [
    [
        'Compression',
        1
    ],
    [
        'PlanarConfiguration',
        1
    ],
    [
        'XPosition',
        0
    ],
    [
        'YPosition',
        0
    ],
    [
        'ResolutionUnit',
        1
    ],
    [
        'ExtraSamples',
        0
    ],
    [
        'GeoAsciiParams',
        'WGS 84\u0000'
    ],
    [
        'ModelTiepoint',
        [
            0,
            0,
            0,
            -180,
            90,
            0
        ]
    ],
    [
        'GTModelTypeGeoKey',
        2
    ],
    [
        'GTRasterTypeGeoKey',
        1
    ],
    [
        'GeographicTypeGeoKey',
        4326
    ],
    [
        'GeogCitationGeoKey',
        'WGS 84'
    ], 
];
function writeGeotiff(data, metadata) {
    const isFlattened = typeof data[0] === 'number';
    let height;
    let numBands;
    let width;
    let flattenedValues;
    if (isFlattened) {
        height = metadata.height || metadata.ImageLength;
        width = metadata.width || metadata.ImageWidth;
        numBands = data.length / (height * width);
        flattenedValues = data;
    } else {
        numBands = data.length;
        height = data[0].length;
        width = data[0][0].length;
        flattenedValues = [];
        _utils.times(height, (rowIndex)=>{
            _utils.times(width, (columnIndex)=>{
                _utils.times(numBands, (bandIndex)=>{
                    flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);
                });
            });
        });
    }
    metadata.ImageLength = height;
    delete metadata.height;
    metadata.ImageWidth = width;
    delete metadata.width;
    // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml
    if (!metadata.BitsPerSample) metadata.BitsPerSample = _utils.times(numBands, ()=>8
    );
    metadataDefaults.forEach((tag)=>{
        const key = tag[0];
        if (!metadata[key]) {
            const value = tag[1];
            metadata[key] = value;
        }
    });
    // The color space of the image data.
    // 1=black is zero and 2=RGB.
    if (!metadata.PhotometricInterpretation) metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;
    // The number of components per pixel.
    if (!metadata.SamplesPerPixel) metadata.SamplesPerPixel = [
        numBands
    ];
    if (!metadata.StripByteCounts) // we are only writing one strip
    metadata.StripByteCounts = [
        numBands * height * width
    ];
    if (!metadata.ModelPixelScale) // assumes raster takes up exactly the whole globe
    metadata.ModelPixelScale = [
        360 / width,
        180 / height,
        0
    ];
    if (!metadata.SampleFormat) metadata.SampleFormat = _utils.times(numBands, ()=>1
    );
    const geoKeys = Object.keys(metadata).filter((key)=>_utils.endsWith(key, 'GeoKey')
    ).sort((a, b)=>name2code[a] - name2code[b]
    );
    if (!metadata.GeoKeyDirectory) {
        const NumberOfKeys = geoKeys.length;
        const GeoKeyDirectory = [
            1,
            1,
            0,
            NumberOfKeys
        ];
        geoKeys.forEach((geoKey)=>{
            const KeyID = Number(name2code[geoKey]);
            GeoKeyDirectory.push(KeyID);
            let Count;
            let TIFFTagLocation;
            let valueOffset;
            if (_globals.fieldTagTypes[KeyID] === 'SHORT') {
                Count = 1;
                TIFFTagLocation = 0;
                valueOffset = metadata[geoKey];
            } else if (geoKey === 'GeogCitationGeoKey') {
                Count = metadata.GeoAsciiParams.length;
                TIFFTagLocation = Number(name2code.GeoAsciiParams);
                valueOffset = 0;
            } else console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);
            GeoKeyDirectory.push(TIFFTagLocation);
            GeoKeyDirectory.push(Count);
            GeoKeyDirectory.push(valueOffset);
        });
        metadata.GeoKeyDirectory = GeoKeyDirectory;
    }
    // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag
    for(const geoKey in geoKeys)if (geoKeys.hasOwnProperty(geoKey)) delete metadata[geoKey];
    [
        'Compression',
        'ExtraSamples',
        'GeographicTypeGeoKey',
        'GTModelTypeGeoKey',
        'GTRasterTypeGeoKey',
        'ImageLength',
        'ImageWidth',
        'PhotometricInterpretation',
        'PlanarConfiguration',
        'ResolutionUnit',
        'SamplesPerPixel',
        'XPosition',
        'YPosition', 
    ].forEach((name)=>{
        if (metadata[name]) metadata[name] = toArray(metadata[name]);
    });
    const encodedMetadata = convertToTids(metadata);
    const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);
    return outputImage;
}

},{"./globals":"jLznT","./utils":"2mD3O","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"12SlZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 *
 * @param {object} logger the new logger. e.g `console`
 */ parcelHelpers.export(exports, "setLogger", ()=>setLogger
);
parcelHelpers.export(exports, "debug", ()=>debug
);
parcelHelpers.export(exports, "log", ()=>log
);
parcelHelpers.export(exports, "info", ()=>info
);
parcelHelpers.export(exports, "warn", ()=>warn
);
parcelHelpers.export(exports, "error", ()=>error
);
parcelHelpers.export(exports, "time", ()=>time
);
parcelHelpers.export(exports, "timeEnd", ()=>timeEnd
);
/**
 * A no-op logger
 */ class DummyLogger {
    log() {
    }
    debug() {
    }
    info() {
    }
    warn() {
    }
    error() {
    }
    time() {
    }
    timeEnd() {
    }
}
let LOGGER = new DummyLogger();
function setLogger(logger = new DummyLogger()) {
    LOGGER = logger;
}
function debug(...args) {
    return LOGGER.debug(...args);
}
function log(...args) {
    return LOGGER.log(...args);
}
function info(...args) {
    return LOGGER.info(...args);
}
function warn(...args) {
    return LOGGER.warn(...args);
}
function error(...args) {
    return LOGGER.error(...args);
}
function time(...args) {
    return LOGGER.time(...args);
}
function timeEnd(...args) {
    return LOGGER.timeEnd(...args);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"4LmLV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create
);
var source = "function _typeof(e){return(_typeof=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function asyncGeneratorStep(e,t,r,n,a,i,o){try{var s=e[i](o),l=s.value}catch(e){return void r(e)}s.done?t(l):Promise.resolve(l).then(n,a)}function _asyncToGenerator(e){return function(){var t=this,r=arguments;return new Promise((function(n,a){var i=e.apply(t,r);function o(e){asyncGeneratorStep(i,n,a,o,s,\"next\",e)}function s(e){asyncGeneratorStep(i,n,a,o,s,\"throw\",e)}o(void 0)}))}}function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function _defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function _createClass(e,t,r){return t&&_defineProperties(e.prototype,t),r&&_defineProperties(e,r),e}function _defineProperty(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function _inherits(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&_setPrototypeOf(e,t)}function _getPrototypeOf(e){return(_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function _setPrototypeOf(e,t){return(_setPrototypeOf=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function _isNativeReflectConstruct(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}function _possibleConstructorReturn(e,t){if(t&&(\"object\"==typeof t||\"function\"==typeof t))return t;if(void 0!==t)throw new TypeError(\"Derived constructors may only return object or undefined\");return _assertThisInitialized(e)}function _createSuper(e){var t=_isNativeReflectConstruct();return function(){var r,n=_getPrototypeOf(e);if(t){var a=_getPrototypeOf(this).constructor;r=Reflect.construct(n,arguments,a)}else r=n.apply(this,arguments);return _possibleConstructorReturn(this,r)}}function _toConsumableArray(e){return _arrayWithoutHoles(e)||_iterableToArray(e)||_unsupportedIterableToArray(e)||_nonIterableSpread()}function _arrayWithoutHoles(e){if(Array.isArray(e))return _arrayLikeToArray(e)}function _iterableToArray(e){if(\"undefined\"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e[\"@@iterator\"])return Array.from(e)}function _unsupportedIterableToArray(e,t){if(e){if(\"string\"==typeof e)return _arrayLikeToArray(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return\"Object\"===r&&e.constructor&&(r=e.constructor.name),\"Map\"===r||\"Set\"===r?Array.from(e):\"Arguments\"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?_arrayLikeToArray(e,t):void 0}}function _arrayLikeToArray(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function _nonIterableSpread(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}var commonjsGlobal=\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:{};function getDefaultExportFromCjs(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,\"default\")?e.default:e}var runtime={exports:{}};!function(e){var t=function(e){var t,r=Object.prototype,n=r.hasOwnProperty,a=\"function\"==typeof Symbol?Symbol:{},i=a.iterator||\"@@iterator\",o=a.asyncIterator||\"@@asyncIterator\",s=a.toStringTag||\"@@toStringTag\";function l(e,t,r){return Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{l({},\"\")}catch(e){l=function(e,t,r){return e[t]=r}}function f(e,t,r,n){var a=t&&t.prototype instanceof g?t:g,i=Object.create(a.prototype),o=new A(n||[]);return i._invoke=function(e,t,r){var n=u;return function(a,i){if(n===h)throw new Error(\"Generator is already running\");if(n===p){if(\"throw\"===a)throw i;return I()}for(r.method=a,r.arg=i;;){var o=r.delegate;if(o){var s=x(o,r);if(s){if(s===m)continue;return s}}if(\"next\"===r.method)r.sent=r._sent=r.arg;else if(\"throw\"===r.method){if(n===u)throw n=p,r.arg;r.dispatchException(r.arg)}else\"return\"===r.method&&r.abrupt(\"return\",r.arg);n=h;var l=c(e,t,r);if(\"normal\"===l.type){if(n=r.done?p:d,l.arg===m)continue;return{value:l.arg,done:r.done}}\"throw\"===l.type&&(n=p,r.method=\"throw\",r.arg=l.arg)}}}(e,r,o),i}function c(e,t,r){try{return{type:\"normal\",arg:e.call(t,r)}}catch(e){return{type:\"throw\",arg:e}}}e.wrap=f;var u=\"suspendedStart\",d=\"suspendedYield\",h=\"executing\",p=\"completed\",m={};function g(){}function y(){}function _(){}var b={};l(b,i,(function(){return this}));var v=Object.getPrototypeOf,w=v&&v(v(M([])));w&&w!==r&&n.call(w,i)&&(b=w);var k=_.prototype=g.prototype=Object.create(b);function T(e){[\"next\",\"throw\",\"return\"].forEach((function(t){l(e,t,(function(e){return this._invoke(t,e)}))}))}function E(e,t){function r(a,i,o,s){var l=c(e[a],e,i);if(\"throw\"!==l.type){var f=l.arg,u=f.value;return u&&\"object\"===_typeof(u)&&n.call(u,\"__await\")?t.resolve(u.__await).then((function(e){r(\"next\",e,o,s)}),(function(e){r(\"throw\",e,o,s)})):t.resolve(u).then((function(e){f.value=e,o(f)}),(function(e){return r(\"throw\",e,o,s)}))}s(l.arg)}var a;this._invoke=function(e,n){function i(){return new t((function(t,a){r(e,n,t,a)}))}return a=a?a.then(i,i):i()}}function x(e,r){var n=e.iterator[r.method];if(n===t){if(r.delegate=null,\"throw\"===r.method){if(e.iterator.return&&(r.method=\"return\",r.arg=t,x(e,r),\"throw\"===r.method))return m;r.method=\"throw\",r.arg=new TypeError(\"The iterator does not provide a 'throw' method\")}return m}var a=c(n,e.iterator,r.arg);if(\"throw\"===a.type)return r.method=\"throw\",r.arg=a.arg,r.delegate=null,m;var i=a.arg;return i?i.done?(r[e.resultName]=i.value,r.next=e.nextLoc,\"return\"!==r.method&&(r.method=\"next\",r.arg=t),r.delegate=null,m):i:(r.method=\"throw\",r.arg=new TypeError(\"iterator result is not an object\"),r.delegate=null,m)}function S(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function D(e){var t=e.completion||{};t.type=\"normal\",delete t.arg,e.completion=t}function A(e){this.tryEntries=[{tryLoc:\"root\"}],e.forEach(S,this),this.reset(!0)}function M(e){if(e){var r=e[i];if(r)return r.call(e);if(\"function\"==typeof e.next)return e;if(!isNaN(e.length)){var a=-1,o=function r(){for(;++a<e.length;)if(n.call(e,a))return r.value=e[a],r.done=!1,r;return r.value=t,r.done=!0,r};return o.next=o}}return{next:I}}function I(){return{value:t,done:!0}}return y.prototype=_,l(k,\"constructor\",_),l(_,\"constructor\",y),y.displayName=l(_,s,\"GeneratorFunction\"),e.isGeneratorFunction=function(e){var t=\"function\"==typeof e&&e.constructor;return!!t&&(t===y||\"GeneratorFunction\"===(t.displayName||t.name))},e.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,_):(e.__proto__=_,l(e,s,\"GeneratorFunction\")),e.prototype=Object.create(k),e},e.awrap=function(e){return{__await:e}},T(E.prototype),l(E.prototype,o,(function(){return this})),e.AsyncIterator=E,e.async=function(t,r,n,a,i){void 0===i&&(i=Promise);var o=new E(f(t,r,n,a),i);return e.isGeneratorFunction(r)?o:o.next().then((function(e){return e.done?e.value:o.next()}))},T(k),l(k,s,\"Generator\"),l(k,i,(function(){return this})),l(k,\"toString\",(function(){return\"[object Generator]\"})),e.keys=function(e){var t=[];for(var r in e)t.push(r);return t.reverse(),function r(){for(;t.length;){var n=t.pop();if(n in e)return r.value=n,r.done=!1,r}return r.done=!0,r}},e.values=M,A.prototype={constructor:A,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method=\"next\",this.arg=t,this.tryEntries.forEach(D),!e)for(var r in this)\"t\"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if(\"throw\"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function a(n,a){return s.type=\"throw\",s.arg=e,r.next=n,a&&(r.method=\"next\",r.arg=t),!!a}for(var i=this.tryEntries.length-1;i>=0;--i){var o=this.tryEntries[i],s=o.completion;if(\"root\"===o.tryLoc)return a(\"end\");if(o.tryLoc<=this.prev){var l=n.call(o,\"catchLoc\"),f=n.call(o,\"finallyLoc\");if(l&&f){if(this.prev<o.catchLoc)return a(o.catchLoc,!0);if(this.prev<o.finallyLoc)return a(o.finallyLoc)}else if(l){if(this.prev<o.catchLoc)return a(o.catchLoc,!0)}else{if(!f)throw new Error(\"try statement without catch or finally\");if(this.prev<o.finallyLoc)return a(o.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var a=this.tryEntries[r];if(a.tryLoc<=this.prev&&n.call(a,\"finallyLoc\")&&this.prev<a.finallyLoc){var i=a;break}}i&&(\"break\"===e||\"continue\"===e)&&i.tryLoc<=t&&t<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=e,o.arg=t,i?(this.method=\"next\",this.next=i.finallyLoc,m):this.complete(o)},complete:function(e,t){if(\"throw\"===e.type)throw e.arg;return\"break\"===e.type||\"continue\"===e.type?this.next=e.arg:\"return\"===e.type?(this.rval=this.arg=e.arg,this.method=\"return\",this.next=\"end\"):\"normal\"===e.type&&t&&(this.next=t),m},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.finallyLoc===e)return this.complete(r.completion,r.afterLoc),D(r),m}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc===e){var n=r.completion;if(\"throw\"===n.type){var a=n.arg;D(r)}return a}}throw new Error(\"illegal catch attempt\")},delegateYield:function(e,r,n){return this.delegate={iterator:M(e),resultName:r,nextLoc:n},\"next\"===this.method&&(this.arg=t),m}},e}(e.exports);try{regeneratorRuntime=t}catch(e){\"object\"===(\"undefined\"==typeof globalThis?\"undefined\":_typeof(globalThis))?globalThis.regeneratorRuntime=t:Function(\"r\",\"regeneratorRuntime = r\")(t)}}(runtime);var worker={},isObservable=function(e){return!!e&&(\"symbol\"===_typeof(Symbol.observable)&&\"function\"==typeof e[Symbol.observable]?e===e[Symbol.observable]():\"function\"==typeof e[\"@@observable\"]&&e===e[\"@@observable\"]())},common$1={},serializers={};function extendSerializer(e,t){var r=e.deserialize.bind(e),n=e.serialize.bind(e);return{deserialize:function(e){return t.deserialize(e,r)},serialize:function(e){return t.serialize(e,n)}}}Object.defineProperty(serializers,\"__esModule\",{value:!0}),serializers.DefaultSerializer=serializers.extendSerializer=void 0,serializers.extendSerializer=extendSerializer;var DefaultErrorSerializer={deserialize:function(e){return Object.assign(Error(e.message),{name:e.name,stack:e.stack})},serialize:function(e){return{__error_marker:\"$$error\",message:e.message,name:e.name,stack:e.stack}}},isSerializedError=function(e){return e&&\"object\"===_typeof(e)&&\"__error_marker\"in e&&\"$$error\"===e.__error_marker};serializers.DefaultSerializer={deserialize:function(e){return isSerializedError(e)?DefaultErrorSerializer.deserialize(e):e},serialize:function(e){return e instanceof Error?DefaultErrorSerializer.serialize(e):e}},Object.defineProperty(common$1,\"__esModule\",{value:!0}),common$1.serialize=common$1.deserialize=common$1.registerSerializer=void 0;var serializers_1=serializers,registeredSerializer=serializers_1.DefaultSerializer;function registerSerializer(e){registeredSerializer=serializers_1.extendSerializer(registeredSerializer,e)}function deserialize(e){return registeredSerializer.deserialize(e)}function serialize(e){return registeredSerializer.serialize(e)}common$1.registerSerializer=registerSerializer,common$1.deserialize=deserialize,common$1.serialize=serialize;var transferable={},symbols={};Object.defineProperty(symbols,\"__esModule\",{value:!0}),symbols.$worker=symbols.$transferable=symbols.$terminate=symbols.$events=symbols.$errors=void 0,symbols.$errors=Symbol(\"thread.errors\"),symbols.$events=Symbol(\"thread.events\"),symbols.$terminate=Symbol(\"thread.terminate\"),symbols.$transferable=Symbol(\"thread.transferable\"),symbols.$worker=Symbol(\"thread.worker\"),Object.defineProperty(transferable,\"__esModule\",{value:!0}),transferable.Transfer=transferable.isTransferDescriptor=void 0;var symbols_1=symbols;function isTransferable(e){return!(!e||\"object\"!==_typeof(e))}function isTransferDescriptor(e){return e&&\"object\"===_typeof(e)&&e[symbols_1.$transferable]}function Transfer$1(e,t){var r;if(!t){if(!isTransferable(e))throw Error();t=[e]}return _defineProperty(r={},symbols_1.$transferable,!0),_defineProperty(r,\"send\",e),_defineProperty(r,\"transferables\",t),r}transferable.isTransferDescriptor=isTransferDescriptor,transferable.Transfer=Transfer$1;var messages$1={},exports,MasterMessageType,WorkerMessageType;exports=messages$1,Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.WorkerMessageType=exports.MasterMessageType=void 0,(MasterMessageType=exports.MasterMessageType||(exports.MasterMessageType={})).cancel=\"cancel\",MasterMessageType.run=\"run\",(WorkerMessageType=exports.WorkerMessageType||(exports.WorkerMessageType={})).error=\"error\",WorkerMessageType.init=\"init\",WorkerMessageType.result=\"result\",WorkerMessageType.running=\"running\",WorkerMessageType.uncaughtError=\"uncaughtError\";var implementation$1={},implementation_browser={};Object.defineProperty(implementation_browser,\"__esModule\",{value:!0});var isWorkerRuntime$2=function(){var e=\"undefined\"!=typeof self&&\"undefined\"!=typeof Window&&self instanceof Window;return!(\"undefined\"==typeof self||!self.postMessage||e)},postMessageToMaster$2=function(e,t){self.postMessage(e,t)},subscribeToMasterMessages$2=function(e){var t=function(t){e(t.data)};return self.addEventListener(\"message\",t),function(){self.removeEventListener(\"message\",t)}};implementation_browser.default={isWorkerRuntime:isWorkerRuntime$2,postMessageToMaster:postMessageToMaster$2,subscribeToMasterMessages:subscribeToMasterMessages$2};var implementation_tinyWorker={};Object.defineProperty(implementation_tinyWorker,\"__esModule\",{value:!0}),\"undefined\"==typeof self&&(commonjsGlobal.self=commonjsGlobal);var isWorkerRuntime$1=function(){return!(\"undefined\"==typeof self||!self.postMessage)},postMessageToMaster$1=function(e){self.postMessage(e)},muxingHandlerSetUp=!1,messageHandlers=new Set,subscribeToMasterMessages$1=function(e){muxingHandlerSetUp||(self.addEventListener(\"message\",(function(e){messageHandlers.forEach((function(t){return t(e.data)}))})),muxingHandlerSetUp=!0),messageHandlers.add(e);return function(){return messageHandlers.delete(e)}};implementation_tinyWorker.default={isWorkerRuntime:isWorkerRuntime$1,postMessageToMaster:postMessageToMaster$1,subscribeToMasterMessages:subscribeToMasterMessages$1};var implementation_worker_threads={},worker_threads={},implementation;function selectImplementation(){return\"function\"==typeof __non_webpack_require__?__non_webpack_require__(\"worker_threads\"):eval(\"require\")(\"worker_threads\")}function getImplementation(){return implementation||(implementation=selectImplementation()),implementation}Object.defineProperty(worker_threads,\"__esModule\",{value:!0}),worker_threads.default=getImplementation;var __importDefault$1=commonjsGlobal&&commonjsGlobal.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(implementation_worker_threads,\"__esModule\",{value:!0});var worker_threads_1=__importDefault$1(worker_threads);function assertMessagePort(e){if(!e)throw Error(\"Invariant violation: MessagePort to parent is not available.\");return e}var isWorkerRuntime=function(){return!worker_threads_1.default().isMainThread},postMessageToMaster=function(e,t){assertMessagePort(worker_threads_1.default().parentPort).postMessage(e,t)},subscribeToMasterMessages=function(e){var t=worker_threads_1.default().parentPort;if(!t)throw Error(\"Invariant violation: MessagePort to parent is not available.\");var r=function(t){e(t)};return assertMessagePort(t).on(\"message\",r),function(){assertMessagePort(t).off(\"message\",r)}};function testImplementation(){worker_threads_1.default()}implementation_worker_threads.default={isWorkerRuntime:isWorkerRuntime,postMessageToMaster:postMessageToMaster,subscribeToMasterMessages:subscribeToMasterMessages,testImplementation:testImplementation};var __importDefault=commonjsGlobal&&commonjsGlobal.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(implementation$1,\"__esModule\",{value:!0});var implementation_browser_1=__importDefault(implementation_browser),implementation_tiny_worker_1=__importDefault(implementation_tinyWorker),implementation_worker_threads_1=__importDefault(implementation_worker_threads),runningInNode=\"undefined\"!=typeof process&&\"browser\"!==process.arch&&\"pid\"in process;function selectNodeImplementation(){try{return implementation_worker_threads_1.default.testImplementation(),implementation_worker_threads_1.default}catch(e){return implementation_tiny_worker_1.default}}implementation$1.default=runningInNode?selectNodeImplementation():implementation_browser_1.default,function(e){var t=commonjsGlobal&&commonjsGlobal.__awaiter||function(e,t,r,n){return new(r||(r=Promise))((function(a,i){function o(e){try{l(n.next(e))}catch(e){i(e)}}function s(e){try{l(n.throw(e))}catch(e){i(e)}}function l(e){var t;e.done?a(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(o,s)}l((n=n.apply(e,t||[])).next())}))},r=commonjsGlobal&&commonjsGlobal.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(e,\"__esModule\",{value:!0}),e.expose=e.isWorkerRuntime=e.Transfer=e.registerSerializer=void 0;var n=r(isObservable),a=common$1,i=transferable,o=messages$1,s=r(implementation$1),l=common$1;Object.defineProperty(e,\"registerSerializer\",{enumerable:!0,get:function(){return l.registerSerializer}});var f=transferable;Object.defineProperty(e,\"Transfer\",{enumerable:!0,get:function(){return f.Transfer}}),e.isWorkerRuntime=s.default.isWorkerRuntime;var c=!1,u=new Map,d=function(e){return e&&e.type===o.MasterMessageType.run},h=function(e){return n.default(e)||function(e){return e&&\"object\"===_typeof(e)&&\"function\"==typeof e.subscribe}(e)};function p(e){return i.isTransferDescriptor(e)?{payload:e.send,transferables:e.transferables}:{payload:e,transferables:void 0}}function m(e,t){var r=p(t),n=r.payload,i=r.transferables,l={type:o.WorkerMessageType.error,uid:e,error:a.serialize(n)};s.default.postMessageToMaster(l,i)}function g(e,t,r){var n=p(r),a=n.payload,i=n.transferables,l={type:o.WorkerMessageType.result,uid:e,complete:!!t||void 0,payload:a};s.default.postMessageToMaster(l,i)}function y(e,t){var r={type:o.WorkerMessageType.running,uid:e,resultType:t};s.default.postMessageToMaster(r)}function _(e){try{var t={type:o.WorkerMessageType.uncaughtError,error:a.serialize(e)};s.default.postMessageToMaster(t)}catch(t){console.error(\"Not reporting uncaught error back to master thread as it occured while reporting an uncaught error already.\\nLatest error:\",t,\"\\nOriginal error:\",e)}}function b(e,r,n){return t(this,void 0,void 0,regeneratorRuntime.mark((function t(){var i,o,s,l;return regeneratorRuntime.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:t.prev=0,i=r.apply(void 0,_toConsumableArray(n)),t.next=7;break;case 4:return t.prev=4,t.t0=t.catch(0),t.abrupt(\"return\",m(e,t.t0));case 7:if(o=h(i)?\"observable\":\"promise\",y(e,o),!h(i)){t.next=14;break}s=i.subscribe((function(t){return g(e,!1,a.serialize(t))}),(function(t){m(e,a.serialize(t)),u.delete(e)}),(function(){g(e,!0),u.delete(e)})),u.set(e,s),t.next=24;break;case 14:return t.prev=14,t.next=17,i;case 17:l=t.sent,g(e,!0,a.serialize(l)),t.next=24;break;case 21:t.prev=21,t.t1=t.catch(14),m(e,a.serialize(t.t1));case 24:case\"end\":return t.stop()}}),t,null,[[0,4],[14,21]])})))}e.expose=function(e){if(!s.default.isWorkerRuntime())throw Error(\"expose() called in the master thread.\");if(c)throw Error(\"expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.\");if(c=!0,\"function\"==typeof e)s.default.subscribeToMasterMessages((function(t){d(t)&&!t.method&&b(t.uid,e,t.args.map(a.deserialize))})),t={type:o.WorkerMessageType.init,exposed:{type:\"function\"}},s.default.postMessageToMaster(t);else{if(\"object\"!==_typeof(e)||!e)throw Error(\"Invalid argument passed to expose(). Expected a function or an object, got: \".concat(e));s.default.subscribeToMasterMessages((function(t){d(t)&&t.method&&b(t.uid,e[t.method],t.args.map(a.deserialize))})),function(e){var t={type:o.WorkerMessageType.init,exposed:{type:\"module\",methods:e}};s.default.postMessageToMaster(t)}(Object.keys(e).filter((function(t){return\"function\"==typeof e[t]})))}var t;s.default.subscribeToMasterMessages((function(e){if((n=e)&&n.type===o.MasterMessageType.cancel){var t=e.uid,r=u.get(t);r&&(r.unsubscribe(),u.delete(t))}var n}))},\"undefined\"!=typeof self&&\"function\"==typeof self.addEventListener&&s.default.isWorkerRuntime()&&(self.addEventListener(\"error\",(function(e){setTimeout((function(){return _(e.error||e)}),250)})),self.addEventListener(\"unhandledrejection\",(function(e){var t=e.reason;t&&\"string\"==typeof t.message&&setTimeout((function(){return _(t)}),250)}))),\"undefined\"!=typeof process&&\"function\"==typeof process.on&&s.default.isWorkerRuntime()&&(process.on(\"uncaughtException\",(function(e){setTimeout((function(){return _(e)}),250)})),process.on(\"unhandledRejection\",(function(e){e&&\"string\"==typeof e.message&&setTimeout((function(){return _(e)}),250)})))}(worker);var WorkerContext=getDefaultExportFromCjs(worker),expose=WorkerContext.expose;WorkerContext.registerSerializer;var Transfer=WorkerContext.Transfer,registry=new Map;function addDecoder(e,t){Array.isArray(e)||(e=[e]),e.forEach((function(e){return registry.set(e,t)}))}function getDecoder(e){return _getDecoder.apply(this,arguments)}function _getDecoder(){return(_getDecoder=_asyncToGenerator(regeneratorRuntime.mark((function e(t){var r,n;return regeneratorRuntime.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(r=registry.get(t.Compression)){e.next=3;break}throw new Error(\"Unknown compression method identifier: \".concat(t.Compression));case 3:return e.next=5,r();case 5:return n=e.sent,e.abrupt(\"return\",new n(t));case 7:case\"end\":return e.stop()}}),e)})))).apply(this,arguments)}function decode(e,t){return _decode.apply(this,arguments)}function _decode(){return(_decode=_asyncToGenerator(regeneratorRuntime.mark((function e(t,r){var n,a;return regeneratorRuntime.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,getDecoder(t);case 2:return n=e.sent,e.next=5,n.decode(t,r);case 5:return a=e.sent,e.abrupt(\"return\",Transfer(a));case 7:case\"end\":return e.stop()}}),e)})))).apply(this,arguments)}function decodeRowAcc(e,t){var r=e.length-t,n=0;do{for(var a=t;a>0;a--)e[n+t]+=e[n],n++;r-=t}while(r>0)}function decodeRowFloatingPoint(e,t,r){for(var n=0,a=e.length,i=a/r;a>t;){for(var o=t;o>0;--o)e[n+t]+=e[n],++n;a-=t}for(var s=e.slice(),l=0;l<i;++l)for(var f=0;f<r;++f)e[r*l+f]=s[(r-f-1)*i+l]}function applyPredictor(e,t,r,n,a,i){if(!t||1===t)return e;for(var o=0;o<a.length;++o){if(a[o]%8!=0)throw new Error(\"When decoding with predictor, only multiple of 8 bits are supported.\");if(a[o]!==a[0])throw new Error(\"When decoding with predictor, all samples must have the same size.\")}for(var s=a[0]/8,l=2===i?1:a.length,f=0;f<n&&!(f*l*r*s>=e.byteLength);++f){var c=void 0;if(2===t){switch(a[0]){case 8:c=new Uint8Array(e,f*l*r*s,l*r*s);break;case 16:c=new Uint16Array(e,f*l*r*s,l*r*s/2);break;case 32:c=new Uint32Array(e,f*l*r*s,l*r*s/4);break;default:throw new Error(\"Predictor 2 not allowed with \".concat(a[0],\" bits per sample.\"))}decodeRowAcc(c,l)}else 3===t&&decodeRowFloatingPoint(c=new Uint8Array(e,f*l*r*s,l*r*s),l,s)}return e}addDecoder([void 0,1],(function(){return Promise.resolve().then((function(){return raw})).then((function(e){return e.default}))})),addDecoder(5,(function(){return Promise.resolve().then((function(){return lzw})).then((function(e){return e.default}))})),addDecoder(6,(function(){throw new Error(\"old style JPEG compression is not supported.\")})),addDecoder(7,(function(){return Promise.resolve().then((function(){return jpeg})).then((function(e){return e.default}))})),addDecoder([8,32946],(function(){return Promise.resolve().then((function(){return deflate})).then((function(e){return e.default}))})),addDecoder(32773,(function(){return Promise.resolve().then((function(){return packbits})).then((function(e){return e.default}))})),addDecoder(34887,(function(){return Promise.resolve().then((function(){return lerc})).then((function(e){return e.default}))})),expose(decode);var BaseDecoder=function(){function e(){_classCallCheck(this,e)}return _createClass(e,[{key:\"decode\",value:function(){var e=_asyncToGenerator(regeneratorRuntime.mark((function e(t,r){var n,a,i,o,s;return regeneratorRuntime.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.decodeBlock(r);case 2:if(n=e.sent,1===(a=t.Predictor||1)){e.next=9;break}return i=!t.StripOffsets,o=i?t.TileWidth:t.ImageWidth,s=i?t.TileLength:t.RowsPerStrip||t.ImageLength,e.abrupt(\"return\",applyPredictor(n,a,o,s,t.BitsPerSample,t.PlanarConfiguration));case 9:return e.abrupt(\"return\",n);case 10:case\"end\":return e.stop()}}),e,this)})));return function(t,r){return e.apply(this,arguments)}}()}]),e}(),RawDecoder=function(e){_inherits(r,BaseDecoder);var t=_createSuper(r);function r(){return _classCallCheck(this,r),t.apply(this,arguments)}return _createClass(r,[{key:\"decodeBlock\",value:function(e){return e}}]),r}(),raw=Object.freeze({__proto__:null,default:RawDecoder}),MIN_BITS=9,CLEAR_CODE=256,EOI_CODE=257,MAX_BYTELENGTH=12;function getByte(e,t,r){var n=t%8,a=Math.floor(t/8),i=8-n,o=t+r-8*(a+1),s=8*(a+2)-(t+r),l=8*(a+2)-t;if(s=Math.max(0,s),a>=e.length)return console.warn(\"ran off the end of the buffer before finding EOI_CODE (end on input code)\"),EOI_CODE;var f=e[a]&Math.pow(2,8-n)-1,c=f<<=r-i;if(a+1<e.length){var u=e[a+1]>>>s;c+=u<<=Math.max(0,r-l)}if(o>8&&a+2<e.length){var d=8*(a+3)-(t+r);c+=e[a+2]>>>d}return c}function appendReversed(e,t){for(var r=t.length-1;r>=0;r--)e.push(t[r]);return e}function decompress(e){for(var t=new Uint16Array(4093),r=new Uint8Array(4093),n=0;n<=257;n++)t[n]=4096,r[n]=n;var a=258,i=MIN_BITS,o=0;function s(){a=258,i=MIN_BITS}function l(e){var t=getByte(e,o,i);return o+=i,t}function f(e,n){return r[a]=n,t[a]=e,++a-1}function c(e){for(var n=[],a=e;4096!==a;a=t[a])n.push(r[a]);return n}var u=[];s();for(var d,h=new Uint8Array(e),p=l(h);p!==EOI_CODE;){if(p===CLEAR_CODE){for(s(),p=l(h);p===CLEAR_CODE;)p=l(h);if(p===EOI_CODE)break;if(p>CLEAR_CODE)throw new Error(\"corrupted code at scanline \".concat(p));appendReversed(u,c(p)),d=p}else if(p<a){var m=c(p);appendReversed(u,m),f(d,m[m.length-1]),d=p}else{var g=c(d);if(!g)throw new Error(\"Bogus entry. Not in dictionary, \".concat(d,\" / \").concat(a,\", position: \").concat(o));appendReversed(u,g),u.push(g[g.length-1]),f(d,g[g.length-1]),d=p}a+1>=Math.pow(2,i)&&(i===MAX_BYTELENGTH?d=void 0:i++),p=l(h)}return new Uint8Array(u)}var LZWDecoder=function(e){_inherits(r,BaseDecoder);var t=_createSuper(r);function r(){return _classCallCheck(this,r),t.apply(this,arguments)}return _createClass(r,[{key:\"decodeBlock\",value:function(e){return decompress(e).buffer}}]),r}(),lzw=Object.freeze({__proto__:null,default:LZWDecoder}),dctZigZag=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),dctCos1=4017,dctSin1=799,dctCos3=3406,dctSin3=2276,dctCos6=1567,dctSin6=3784,dctSqrt2=5793,dctSqrt1d2=2896;function buildHuffmanTable(e,t){for(var r=0,n=[],a=16;a>0&&!e[a-1];)--a;n.push({children:[],index:0});for(var i,o=n[0],s=0;s<a;s++){for(var l=0;l<e[s];l++){for((o=n.pop()).children[o.index]=t[r];o.index>0;)o=n.pop();for(o.index++,n.push(o);n.length<=s;)n.push(i={children:[],index:0}),o.children[o.index]=i.children,o=i;r++}s+1<a&&(n.push(i={children:[],index:0}),o.children[o.index]=i.children,o=i)}return n[0].children}function decodeScan(e,t,r,n,a,i,o,s,l){var f=r.mcusPerLine,c=r.progressive,u=t,d=t,h=0,p=0;function m(){if(p>0)return p--,h>>p&1;if(255===(h=e[d++])){var t=e[d++];if(t)throw new Error(\"unexpected marker: \".concat((h<<8|t).toString(16)))}return p=7,h>>>7}function g(e){for(var t,r=e;null!==(t=m());){if(\"number\"==typeof(r=r[t]))return r;if(\"object\"!==_typeof(r))throw new Error(\"invalid huffman sequence\")}return null}function y(e){for(var t=e,r=0;t>0;){var n=m();if(null===n)return;r=r<<1|n,--t}return r}function _(e){var t=y(e);return t>=1<<e-1?t:t+(-1<<e)+1}var b=0;var v,w=0;function k(e,t,r,n,a){var i=r%f,o=(r/f|0)*e.v+n,s=i*e.h+a;t(e,e.blocks[o][s])}function T(e,t,r){var n=r/e.blocksPerLine|0,a=r%e.blocksPerLine;t(e,e.blocks[n][a])}var E,x,S,D,A,M,I=n.length;M=c?0===i?0===s?function(e,t){var r=g(e.huffmanTableDC),n=0===r?0:_(r)<<l;e.pred+=n,t[0]=e.pred}:function(e,t){t[0]|=m()<<l}:0===s?function(e,t){if(b>0)b--;else for(var r=i,n=o;r<=n;){var a=g(e.huffmanTableAC),s=15&a,f=a>>4;if(0===s){if(f<15){b=y(f)+(1<<f)-1;break}r+=16}else t[dctZigZag[r+=f]]=_(s)*(1<<l),r++}}:function(e,t){for(var r=i,n=o,a=0;r<=n;){var s=dctZigZag[r],f=t[s]<0?-1:1;switch(w){case 0:var c=g(e.huffmanTableAC),u=15&c;if(a=c>>4,0===u)a<15?(b=y(a)+(1<<a),w=4):(a=16,w=1);else{if(1!==u)throw new Error(\"invalid ACn encoding\");v=_(u),w=a?2:3}continue;case 1:case 2:t[s]?t[s]+=(m()<<l)*f:0==--a&&(w=2===w?3:0);break;case 3:t[s]?t[s]+=(m()<<l)*f:(t[s]=v<<l,w=0);break;case 4:t[s]&&(t[s]+=(m()<<l)*f)}r++}4===w&&0==--b&&(w=0)}:function(e,t){var r=g(e.huffmanTableDC),n=0===r?0:_(r);e.pred+=n,t[0]=e.pred;for(var a=1;a<64;){var i=g(e.huffmanTableAC),o=15&i,s=i>>4;if(0===o){if(s<15)break;a+=16}else t[dctZigZag[a+=s]]=_(o),a++}};var R,O,C=0;O=1===I?n[0].blocksPerLine*n[0].blocksPerColumn:f*r.mcusPerColumn;for(var P=a||O;C<O;){for(x=0;x<I;x++)n[x].pred=0;if(b=0,1===I)for(E=n[0],A=0;A<P;A++)T(E,M,C),C++;else for(A=0;A<P;A++){for(x=0;x<I;x++){var L=E=n[x],U=L.h,B=L.v;for(S=0;S<B;S++)for(D=0;D<U;D++)k(E,M,C,S,D)}if(++C===O)break}if(p=0,(R=e[d]<<8|e[d+1])<65280)throw new Error(\"marker was not found\");if(!(R>=65488&&R<=65495))break;d+=2}return d-u}function buildComponentData(e,t){var r=[],n=t.blocksPerLine,a=t.blocksPerColumn,i=n<<3,o=new Int32Array(64),s=new Uint8Array(64);function l(e,r,n){var a,i,o,s,l,f,c,u,d,h,p=t.quantizationTable,m=n;for(h=0;h<64;h++)m[h]=e[h]*p[h];for(h=0;h<8;++h){var g=8*h;0!==m[1+g]||0!==m[2+g]||0!==m[3+g]||0!==m[4+g]||0!==m[5+g]||0!==m[6+g]||0!==m[7+g]?(a=dctSqrt2*m[0+g]+128>>8,i=dctSqrt2*m[4+g]+128>>8,o=m[2+g],s=m[6+g],l=dctSqrt1d2*(m[1+g]-m[7+g])+128>>8,u=dctSqrt1d2*(m[1+g]+m[7+g])+128>>8,f=m[3+g]<<4,c=m[5+g]<<4,d=a-i+1>>1,a=a+i+1>>1,i=d,d=o*dctSin6+s*dctCos6+128>>8,o=o*dctCos6-s*dctSin6+128>>8,s=d,d=l-c+1>>1,l=l+c+1>>1,c=d,d=u+f+1>>1,f=u-f+1>>1,u=d,d=a-s+1>>1,a=a+s+1>>1,s=d,d=i-o+1>>1,i=i+o+1>>1,o=d,d=l*dctSin3+u*dctCos3+2048>>12,l=l*dctCos3-u*dctSin3+2048>>12,u=d,d=f*dctSin1+c*dctCos1+2048>>12,f=f*dctCos1-c*dctSin1+2048>>12,c=d,m[0+g]=a+u,m[7+g]=a-u,m[1+g]=i+c,m[6+g]=i-c,m[2+g]=o+f,m[5+g]=o-f,m[3+g]=s+l,m[4+g]=s-l):(d=dctSqrt2*m[0+g]+512>>10,m[0+g]=d,m[1+g]=d,m[2+g]=d,m[3+g]=d,m[4+g]=d,m[5+g]=d,m[6+g]=d,m[7+g]=d)}for(h=0;h<8;++h){var y=h;0!==m[8+y]||0!==m[16+y]||0!==m[24+y]||0!==m[32+y]||0!==m[40+y]||0!==m[48+y]||0!==m[56+y]?(a=dctSqrt2*m[0+y]+2048>>12,i=dctSqrt2*m[32+y]+2048>>12,o=m[16+y],s=m[48+y],l=dctSqrt1d2*(m[8+y]-m[56+y])+2048>>12,u=dctSqrt1d2*(m[8+y]+m[56+y])+2048>>12,f=m[24+y],c=m[40+y],d=a-i+1>>1,a=a+i+1>>1,i=d,d=o*dctSin6+s*dctCos6+2048>>12,o=o*dctCos6-s*dctSin6+2048>>12,s=d,d=l-c+1>>1,l=l+c+1>>1,c=d,d=u+f+1>>1,f=u-f+1>>1,u=d,d=a-s+1>>1,a=a+s+1>>1,s=d,d=i-o+1>>1,i=i+o+1>>1,o=d,d=l*dctSin3+u*dctCos3+2048>>12,l=l*dctCos3-u*dctSin3+2048>>12,u=d,d=f*dctSin1+c*dctCos1+2048>>12,f=f*dctCos1-c*dctSin1+2048>>12,c=d,m[0+y]=a+u,m[56+y]=a-u,m[8+y]=i+c,m[48+y]=i-c,m[16+y]=o+f,m[40+y]=o-f,m[24+y]=s+l,m[32+y]=s-l):(d=dctSqrt2*n[h+0]+8192>>14,m[0+y]=d,m[8+y]=d,m[16+y]=d,m[24+y]=d,m[32+y]=d,m[40+y]=d,m[48+y]=d,m[56+y]=d)}for(h=0;h<64;++h){var _=128+(m[h]+8>>4);r[h]=_<0?0:_>255?255:_}}for(var f=0;f<a;f++){for(var c=f<<3,u=0;u<8;u++)r.push(new Uint8Array(i));for(var d=0;d<n;d++){l(t.blocks[f][d],s,o);for(var h=0,p=d<<3,m=0;m<8;m++)for(var g=r[c+m],y=0;y<8;y++)g[p+y]=s[h++]}}return r}var JpegStreamReader=function(){function e(){_classCallCheck(this,e),this.jfif=null,this.adobe=null,this.quantizationTables=[],this.huffmanTablesAC=[],this.huffmanTablesDC=[],this.resetFrames()}return _createClass(e,[{key:\"resetFrames\",value:function(){this.frames=[]}},{key:\"parse\",value:function(e){var t=0;function r(){var r=e[t]<<8|e[t+1];return t+=2,r}function n(e){var t,r,n=0,a=0;for(r in e.components)e.components.hasOwnProperty(r)&&(n<(t=e.components[r]).h&&(n=t.h),a<t.v&&(a=t.v));var i=Math.ceil(e.samplesPerLine/8/n),o=Math.ceil(e.scanLines/8/a);for(r in e.components)if(e.components.hasOwnProperty(r)){t=e.components[r];for(var s=Math.ceil(Math.ceil(e.samplesPerLine/8)*t.h/n),l=Math.ceil(Math.ceil(e.scanLines/8)*t.v/a),f=i*t.h,c=o*t.v,u=[],d=0;d<c;d++){for(var h=[],p=0;p<f;p++)h.push(new Int32Array(64));u.push(h)}t.blocksPerLine=s,t.blocksPerColumn=l,t.blocks=u}e.maxH=n,e.maxV=a,e.mcusPerLine=i,e.mcusPerColumn=o}var a,i,o=r();if(65496!==o)throw new Error(\"SOI not found\");for(o=r();65497!==o;){switch(o){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var s=(a=void 0,i=void 0,a=r(),i=e.subarray(t,t+a-2),t+=i.length,i);65504===o&&74===s[0]&&70===s[1]&&73===s[2]&&70===s[3]&&0===s[4]&&(this.jfif={version:{major:s[5],minor:s[6]},densityUnits:s[7],xDensity:s[8]<<8|s[9],yDensity:s[10]<<8|s[11],thumbWidth:s[12],thumbHeight:s[13],thumbData:s.subarray(14,14+3*s[12]*s[13])}),65518===o&&65===s[0]&&100===s[1]&&111===s[2]&&98===s[3]&&101===s[4]&&0===s[5]&&(this.adobe={version:s[6],flags0:s[7]<<8|s[8],flags1:s[9]<<8|s[10],transformCode:s[11]});break;case 65499:for(var l=r()+t-2;t<l;){var f=e[t++],c=new Int32Array(64);if(f>>4==0)for(var u=0;u<64;u++){c[dctZigZag[u]]=e[t++]}else{if(f>>4!=1)throw new Error(\"DQT: invalid table spec\");for(var d=0;d<64;d++){c[dctZigZag[d]]=r()}}this.quantizationTables[15&f]=c}break;case 65472:case 65473:case 65474:r();for(var h={extended:65473===o,progressive:65474===o,precision:e[t++],scanLines:r(),samplesPerLine:r(),components:{},componentsOrder:[]},p=e[t++],m=void 0,g=0;g<p;g++){m=e[t];var y=e[t+1]>>4,_=15&e[t+1],b=e[t+2];h.componentsOrder.push(m),h.components[m]={h:y,v:_,quantizationIdx:b},t+=3}n(h),this.frames.push(h);break;case 65476:for(var v=r(),w=2;w<v;){for(var k=e[t++],T=new Uint8Array(16),E=0,x=0;x<16;x++,t++)T[x]=e[t],E+=T[x];for(var S=new Uint8Array(E),D=0;D<E;D++,t++)S[D]=e[t];w+=17+E,k>>4==0?this.huffmanTablesDC[15&k]=buildHuffmanTable(T,S):this.huffmanTablesAC[15&k]=buildHuffmanTable(T,S)}break;case 65501:r(),this.resetInterval=r();break;case 65498:r();for(var A=e[t++],M=[],I=this.frames[0],R=0;R<A;R++){var O=I.components[e[t++]],C=e[t++];O.huffmanTableDC=this.huffmanTablesDC[C>>4],O.huffmanTableAC=this.huffmanTablesAC[15&C],M.push(O)}var P=e[t++],L=e[t++],U=e[t++],B=decodeScan(e,t,I,M,this.resetInterval,P,L,U>>4,15&U);t+=B;break;case 65535:255!==e[t]&&t--;break;default:if(255===e[t-3]&&e[t-2]>=192&&e[t-2]<=254){t-=3;break}throw new Error(\"unknown JPEG marker \".concat(o.toString(16)))}o=r()}}},{key:\"getResult\",value:function(){var e=this.frames;if(0===this.frames.length)throw new Error(\"no frames were decoded\");this.frames.length>1&&console.warn(\"more than one frame is not supported\");for(var t=0;t<this.frames.length;t++)for(var r=this.frames[t].components,n=0,a=Object.keys(r);n<a.length;n++){var i=a[n];r[i].quantizationTable=this.quantizationTables[r[i].quantizationIdx],delete r[i].quantizationIdx}for(var o=e[0],s=o.components,l=o.componentsOrder,f=[],c=o.samplesPerLine,u=o.scanLines,d=0;d<l.length;d++){var h=s[l[d]];f.push({lines:buildComponentData(o,h),scaleX:h.h/o.maxH,scaleY:h.v/o.maxV})}for(var p=new Uint8Array(c*u*f.length),m=0,g=0;g<u;++g)for(var y=0;y<c;++y)for(var _=0;_<f.length;++_){var b=f[_];p[m]=b.lines[0|g*b.scaleY][0|y*b.scaleX],++m}return p}}]),e}(),JpegDecoder=function(e){_inherits(r,BaseDecoder);var t=_createSuper(r);function r(e){var n;return _classCallCheck(this,r),(n=t.call(this)).reader=new JpegStreamReader,e.JPEGTables&&n.reader.parse(e.JPEGTables),n}return _createClass(r,[{key:\"decodeBlock\",value:function(e){return this.reader.resetFrames(),this.reader.parse(new Uint8Array(e)),this.reader.getResult().buffer}}]),r}(),jpeg=Object.freeze({__proto__:null,default:JpegDecoder});function zero$1(e){for(var t=e.length;--t>=0;)e[t]=0}var MIN_MATCH$1=3,MAX_MATCH$1=258,LENGTH_CODES$1=29,LITERALS$1=256,L_CODES$1=LITERALS$1+1+LENGTH_CODES$1,D_CODES$1=30,DIST_CODE_LEN=512,static_ltree=new Array(2*(L_CODES$1+2));zero$1(static_ltree);var static_dtree=new Array(2*D_CODES$1);zero$1(static_dtree);var _dist_code=new Array(DIST_CODE_LEN);zero$1(_dist_code);var _length_code=new Array(MAX_MATCH$1-MIN_MATCH$1+1);zero$1(_length_code);var base_length=new Array(LENGTH_CODES$1);zero$1(base_length);var base_dist=new Array(D_CODES$1);zero$1(base_dist);var adler32=function(e,t,r,n){for(var a=65535&e|0,i=e>>>16&65535|0,o=0;0!==r;){r-=o=r>2e3?2e3:r;do{i=i+(a=a+t[n++]|0)|0}while(--o);a%=65521,i%=65521}return a|i<<16|0},adler32_1=adler32,makeTable=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t},crcTable=new Uint32Array(makeTable()),crc32=function(e,t,r,n){var a=crcTable,i=n+r;e^=-1;for(var o=n;o<i;o++)e=e>>>8^a[255&(e^t[o])];return-1^e},crc32_1=crc32,messages={2:\"need dictionary\",1:\"stream end\",0:\"\",\"-1\":\"file error\",\"-2\":\"stream error\",\"-3\":\"data error\",\"-4\":\"insufficient memory\",\"-5\":\"buffer error\",\"-6\":\"incompatible version\"},constants$2={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},_has=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var r=t.shift();if(r){if(\"object\"!==_typeof(r))throw new TypeError(r+\"must be non-object\");for(var n in r)_has(r,n)&&(e[n]=r[n])}}return e},flattenChunks=function(e){for(var t=0,r=0,n=e.length;r<n;r++)t+=e[r].length;for(var a=new Uint8Array(t),i=0,o=0,s=e.length;i<s;i++){var l=e[i];a.set(l,o),o+=l.length}return a},common={assign:assign,flattenChunks:flattenChunks},STR_APPLY_UIA_OK=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){STR_APPLY_UIA_OK=!1}for(var _utf8len=new Uint8Array(256),q=0;q<256;q++)_utf8len[q]=q>=252?6:q>=248?5:q>=240?4:q>=224?3:q>=192?2:1;_utf8len[254]=_utf8len[254]=1;var string2buf=function(e){if(\"function\"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(e);var t,r,n,a,i,o=e.length,s=0;for(a=0;a<o;a++)55296==(64512&(r=e.charCodeAt(a)))&&a+1<o&&56320==(64512&(n=e.charCodeAt(a+1)))&&(r=65536+(r-55296<<10)+(n-56320),a++),s+=r<128?1:r<2048?2:r<65536?3:4;for(t=new Uint8Array(s),i=0,a=0;i<s;a++)55296==(64512&(r=e.charCodeAt(a)))&&a+1<o&&56320==(64512&(n=e.charCodeAt(a+1)))&&(r=65536+(r-55296<<10)+(n-56320),a++),r<128?t[i++]=r:r<2048?(t[i++]=192|r>>>6,t[i++]=128|63&r):r<65536?(t[i++]=224|r>>>12,t[i++]=128|r>>>6&63,t[i++]=128|63&r):(t[i++]=240|r>>>18,t[i++]=128|r>>>12&63,t[i++]=128|r>>>6&63,t[i++]=128|63&r);return t},buf2binstring=function(e,t){if(t<65534&&e.subarray&&STR_APPLY_UIA_OK)return String.fromCharCode.apply(null,e.length===t?e:e.subarray(0,t));for(var r=\"\",n=0;n<t;n++)r+=String.fromCharCode(e[n]);return r},buf2string=function(e,t){var r,n,a=t||e.length;if(\"function\"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(e.subarray(0,t));var i=new Array(2*a);for(n=0,r=0;r<a;){var o=e[r++];if(o<128)i[n++]=o;else{var s=_utf8len[o];if(s>4)i[n++]=65533,r+=s-1;else{for(o&=2===s?31:3===s?15:7;s>1&&r<a;)o=o<<6|63&e[r++],s--;s>1?i[n++]=65533:o<65536?i[n++]=o:(o-=65536,i[n++]=55296|o>>10&1023,i[n++]=56320|1023&o)}}}return buf2binstring(i,n)},utf8border=function(e,t){(t=t||e.length)>e.length&&(t=e.length);for(var r=t-1;r>=0&&128==(192&e[r]);)r--;return r<0||0===r?t:r+_utf8len[e[r]]>t?r:t},strings={string2buf:string2buf,buf2string:buf2string,utf8border:utf8border};function ZStream(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\"\",this.state=null,this.data_type=2,this.adler=0}var zstream=ZStream,BAD$1=30,TYPE$1=12,inffast=function(e,t){var r,n,a,i,o,s,l,f,c,u,d,h,p,m,g,y,_,b,v,w,k,T,E,x,S=e.state;r=e.next_in,E=e.input,n=r+(e.avail_in-5),a=e.next_out,x=e.output,i=a-(t-e.avail_out),o=a+(e.avail_out-257),s=S.dmax,l=S.wsize,f=S.whave,c=S.wnext,u=S.window,d=S.hold,h=S.bits,p=S.lencode,m=S.distcode,g=(1<<S.lenbits)-1,y=(1<<S.distbits)-1;e:do{h<15&&(d+=E[r++]<<h,h+=8,d+=E[r++]<<h,h+=8),_=p[d&g];t:for(;;){if(d>>>=b=_>>>24,h-=b,0===(b=_>>>16&255))x[a++]=65535&_;else{if(!(16&b)){if(0==(64&b)){_=p[(65535&_)+(d&(1<<b)-1)];continue t}if(32&b){S.mode=TYPE$1;break e}e.msg=\"invalid literal/length code\",S.mode=BAD$1;break e}v=65535&_,(b&=15)&&(h<b&&(d+=E[r++]<<h,h+=8),v+=d&(1<<b)-1,d>>>=b,h-=b),h<15&&(d+=E[r++]<<h,h+=8,d+=E[r++]<<h,h+=8),_=m[d&y];r:for(;;){if(d>>>=b=_>>>24,h-=b,!(16&(b=_>>>16&255))){if(0==(64&b)){_=m[(65535&_)+(d&(1<<b)-1)];continue r}e.msg=\"invalid distance code\",S.mode=BAD$1;break e}if(w=65535&_,h<(b&=15)&&(d+=E[r++]<<h,(h+=8)<b&&(d+=E[r++]<<h,h+=8)),(w+=d&(1<<b)-1)>s){e.msg=\"invalid distance too far back\",S.mode=BAD$1;break e}if(d>>>=b,h-=b,w>(b=a-i)){if((b=w-b)>f&&S.sane){e.msg=\"invalid distance too far back\",S.mode=BAD$1;break e}if(k=0,T=u,0===c){if(k+=l-b,b<v){v-=b;do{x[a++]=u[k++]}while(--b);k=a-w,T=x}}else if(c<b){if(k+=l+c-b,(b-=c)<v){v-=b;do{x[a++]=u[k++]}while(--b);if(k=0,c<v){v-=b=c;do{x[a++]=u[k++]}while(--b);k=a-w,T=x}}}else if(k+=c-b,b<v){v-=b;do{x[a++]=u[k++]}while(--b);k=a-w,T=x}for(;v>2;)x[a++]=T[k++],x[a++]=T[k++],x[a++]=T[k++],v-=3;v&&(x[a++]=T[k++],v>1&&(x[a++]=T[k++]))}else{k=a-w;do{x[a++]=x[k++],x[a++]=x[k++],x[a++]=x[k++],v-=3}while(v>2);v&&(x[a++]=x[k++],v>1&&(x[a++]=x[k++]))}break}}break}}while(r<n&&a<o);r-=v=h>>3,d&=(1<<(h-=v<<3))-1,e.next_in=r,e.next_out=a,e.avail_in=r<n?n-r+5:5-(r-n),e.avail_out=a<o?o-a+257:257-(a-o),S.hold=d,S.bits=h},MAXBITS=15,ENOUGH_LENS$1=852,ENOUGH_DISTS$1=592,CODES$1=0,LENS$1=1,DISTS$1=2,lbase=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),lext=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),dbase=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),dext=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),inflate_table=function(e,t,r,n,a,i,o,s){var l,f,c,u,d,h,p,m,g,y=s.bits,_=0,b=0,v=0,w=0,k=0,T=0,E=0,x=0,S=0,D=0,A=null,M=0,I=new Uint16Array(MAXBITS+1),R=new Uint16Array(MAXBITS+1),O=null,C=0;for(_=0;_<=MAXBITS;_++)I[_]=0;for(b=0;b<n;b++)I[t[r+b]]++;for(k=y,w=MAXBITS;w>=1&&0===I[w];w--);if(k>w&&(k=w),0===w)return a[i++]=20971520,a[i++]=20971520,s.bits=1,0;for(v=1;v<w&&0===I[v];v++);for(k<v&&(k=v),x=1,_=1;_<=MAXBITS;_++)if(x<<=1,(x-=I[_])<0)return-1;if(x>0&&(e===CODES$1||1!==w))return-1;for(R[1]=0,_=1;_<MAXBITS;_++)R[_+1]=R[_]+I[_];for(b=0;b<n;b++)0!==t[r+b]&&(o[R[t[r+b]]++]=b);if(e===CODES$1?(A=O=o,h=19):e===LENS$1?(A=lbase,M-=257,O=lext,C-=257,h=256):(A=dbase,O=dext,h=-1),D=0,b=0,_=v,d=i,T=k,E=0,c=-1,u=(S=1<<k)-1,e===LENS$1&&S>ENOUGH_LENS$1||e===DISTS$1&&S>ENOUGH_DISTS$1)return 1;for(;;){p=_-E,o[b]<h?(m=0,g=o[b]):o[b]>h?(m=O[C+o[b]],g=A[M+o[b]]):(m=96,g=0),l=1<<_-E,v=f=1<<T;do{a[d+(D>>E)+(f-=l)]=p<<24|m<<16|g|0}while(0!==f);for(l=1<<_-1;D&l;)l>>=1;if(0!==l?(D&=l-1,D+=l):D=0,b++,0==--I[_]){if(_===w)break;_=t[r+o[b]]}if(_>k&&(D&u)!==c){for(0===E&&(E=k),d+=v,x=1<<(T=_-E);T+E<w&&!((x-=I[T+E])<=0);)T++,x<<=1;if(S+=1<<T,e===LENS$1&&S>ENOUGH_LENS$1||e===DISTS$1&&S>ENOUGH_DISTS$1)return 1;a[c=D&u]=k<<24|T<<16|d-i|0}}return 0!==D&&(a[d+D]=_-E<<24|64<<16|0),s.bits=k,0},inftrees=inflate_table,CODES=0,LENS=1,DISTS=2,Z_FINISH$1=constants$2.Z_FINISH,Z_BLOCK=constants$2.Z_BLOCK,Z_TREES=constants$2.Z_TREES,Z_OK$1=constants$2.Z_OK,Z_STREAM_END$1=constants$2.Z_STREAM_END,Z_NEED_DICT$1=constants$2.Z_NEED_DICT,Z_STREAM_ERROR$1=constants$2.Z_STREAM_ERROR,Z_DATA_ERROR$1=constants$2.Z_DATA_ERROR,Z_MEM_ERROR$1=constants$2.Z_MEM_ERROR,Z_BUF_ERROR=constants$2.Z_BUF_ERROR,Z_DEFLATED=constants$2.Z_DEFLATED,HEAD=1,FLAGS=2,TIME=3,OS=4,EXLEN=5,EXTRA=6,NAME=7,COMMENT=8,HCRC=9,DICTID=10,DICT=11,TYPE=12,TYPEDO=13,STORED=14,COPY_=15,COPY=16,TABLE=17,LENLENS=18,CODELENS=19,LEN_=20,LEN=21,LENEXT=22,DIST=23,DISTEXT=24,MATCH=25,LIT=26,CHECK=27,LENGTH=28,DONE=29,BAD=30,MEM=31,SYNC=32,ENOUGH_LENS=852,ENOUGH_DISTS=592,MAX_WBITS=15,DEF_WBITS=MAX_WBITS,zswap32=function(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)};function InflateState(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}var inflateResetKeep=function(e){if(!e||!e.state)return Z_STREAM_ERROR$1;var t=e.state;return e.total_in=e.total_out=t.total=0,e.msg=\"\",t.wrap&&(e.adler=1&t.wrap),t.mode=HEAD,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(ENOUGH_LENS),t.distcode=t.distdyn=new Int32Array(ENOUGH_DISTS),t.sane=1,t.back=-1,Z_OK$1},inflateReset=function(e){if(!e||!e.state)return Z_STREAM_ERROR$1;var t=e.state;return t.wsize=0,t.whave=0,t.wnext=0,inflateResetKeep(e)},inflateReset2=function(e,t){var r;if(!e||!e.state)return Z_STREAM_ERROR$1;var n=e.state;return t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?Z_STREAM_ERROR$1:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,inflateReset(e))},inflateInit2=function(e,t){if(!e)return Z_STREAM_ERROR$1;var r=new InflateState;e.state=r,r.window=null;var n=inflateReset2(e,t);return n!==Z_OK$1&&(e.state=null),n},inflateInit=function(e){return inflateInit2(e,DEF_WBITS)},virgin=!0,lenfix,distfix,fixedtables=function(e){if(virgin){lenfix=new Int32Array(512),distfix=new Int32Array(32);for(var t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(inftrees(LENS,e.lens,0,288,lenfix,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;inftrees(DISTS,e.lens,0,32,distfix,0,e.work,{bits:5}),virgin=!1}e.lencode=lenfix,e.lenbits=9,e.distcode=distfix,e.distbits=5},updatewindow=function(e,t,r,n){var a,i=e.state;return null===i.window&&(i.wsize=1<<i.wbits,i.wnext=0,i.whave=0,i.window=new Uint8Array(i.wsize)),n>=i.wsize?(i.window.set(t.subarray(r-i.wsize,r),0),i.wnext=0,i.whave=i.wsize):((a=i.wsize-i.wnext)>n&&(a=n),i.window.set(t.subarray(r-n,r-n+a),i.wnext),(n-=a)?(i.window.set(t.subarray(r-n,r),0),i.wnext=n,i.whave=i.wsize):(i.wnext+=a,i.wnext===i.wsize&&(i.wnext=0),i.whave<i.wsize&&(i.whave+=a))),0},inflate$2=function(e,t){var r,n,a,i,o,s,l,f,c,u,d,h,p,m,g,y,_,b,v,w,k,T,E,x,S=0,D=new Uint8Array(4),A=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return Z_STREAM_ERROR$1;(r=e.state).mode===TYPE&&(r.mode=TYPEDO),o=e.next_out,a=e.output,l=e.avail_out,i=e.next_in,n=e.input,s=e.avail_in,f=r.hold,c=r.bits,u=s,d=l,T=Z_OK$1;e:for(;;)switch(r.mode){case HEAD:if(0===r.wrap){r.mode=TYPEDO;break}for(;c<16;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(2&r.wrap&&35615===f){r.check=0,D[0]=255&f,D[1]=f>>>8&255,r.check=crc32_1(r.check,D,2,0),f=0,c=0,r.mode=FLAGS;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&f)<<8)+(f>>8))%31){e.msg=\"incorrect header check\",r.mode=BAD;break}if((15&f)!==Z_DEFLATED){e.msg=\"unknown compression method\",r.mode=BAD;break}if(c-=4,k=8+(15&(f>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){e.msg=\"invalid window size\",r.mode=BAD;break}r.dmax=1<<r.wbits,e.adler=r.check=1,r.mode=512&f?DICTID:TYPE,f=0,c=0;break;case FLAGS:for(;c<16;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(r.flags=f,(255&r.flags)!==Z_DEFLATED){e.msg=\"unknown compression method\",r.mode=BAD;break}if(57344&r.flags){e.msg=\"unknown header flags set\",r.mode=BAD;break}r.head&&(r.head.text=f>>8&1),512&r.flags&&(D[0]=255&f,D[1]=f>>>8&255,r.check=crc32_1(r.check,D,2,0)),f=0,c=0,r.mode=TIME;case TIME:for(;c<32;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}r.head&&(r.head.time=f),512&r.flags&&(D[0]=255&f,D[1]=f>>>8&255,D[2]=f>>>16&255,D[3]=f>>>24&255,r.check=crc32_1(r.check,D,4,0)),f=0,c=0,r.mode=OS;case OS:for(;c<16;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}r.head&&(r.head.xflags=255&f,r.head.os=f>>8),512&r.flags&&(D[0]=255&f,D[1]=f>>>8&255,r.check=crc32_1(r.check,D,2,0)),f=0,c=0,r.mode=EXLEN;case EXLEN:if(1024&r.flags){for(;c<16;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}r.length=f,r.head&&(r.head.extra_len=f),512&r.flags&&(D[0]=255&f,D[1]=f>>>8&255,r.check=crc32_1(r.check,D,2,0)),f=0,c=0}else r.head&&(r.head.extra=null);r.mode=EXTRA;case EXTRA:if(1024&r.flags&&((h=r.length)>s&&(h=s),h&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Uint8Array(r.head.extra_len)),r.head.extra.set(n.subarray(i,i+h),k)),512&r.flags&&(r.check=crc32_1(r.check,n,h,i)),s-=h,i+=h,r.length-=h),r.length))break e;r.length=0,r.mode=NAME;case NAME:if(2048&r.flags){if(0===s)break e;h=0;do{k=n[i+h++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k))}while(k&&h<s);if(512&r.flags&&(r.check=crc32_1(r.check,n,h,i)),s-=h,i+=h,k)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=COMMENT;case COMMENT:if(4096&r.flags){if(0===s)break e;h=0;do{k=n[i+h++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k))}while(k&&h<s);if(512&r.flags&&(r.check=crc32_1(r.check,n,h,i)),s-=h,i+=h,k)break e}else r.head&&(r.head.comment=null);r.mode=HCRC;case HCRC:if(512&r.flags){for(;c<16;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(f!==(65535&r.check)){e.msg=\"header crc mismatch\",r.mode=BAD;break}f=0,c=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=TYPE;break;case DICTID:for(;c<32;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}e.adler=r.check=zswap32(f),f=0,c=0,r.mode=DICT;case DICT:if(0===r.havedict)return e.next_out=o,e.avail_out=l,e.next_in=i,e.avail_in=s,r.hold=f,r.bits=c,Z_NEED_DICT$1;e.adler=r.check=1,r.mode=TYPE;case TYPE:if(t===Z_BLOCK||t===Z_TREES)break e;case TYPEDO:if(r.last){f>>>=7&c,c-=7&c,r.mode=CHECK;break}for(;c<3;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}switch(r.last=1&f,c-=1,3&(f>>>=1)){case 0:r.mode=STORED;break;case 1:if(fixedtables(r),r.mode=LEN_,t===Z_TREES){f>>>=2,c-=2;break e}break;case 2:r.mode=TABLE;break;case 3:e.msg=\"invalid block type\",r.mode=BAD}f>>>=2,c-=2;break;case STORED:for(f>>>=7&c,c-=7&c;c<32;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if((65535&f)!=(f>>>16^65535)){e.msg=\"invalid stored block lengths\",r.mode=BAD;break}if(r.length=65535&f,f=0,c=0,r.mode=COPY_,t===Z_TREES)break e;case COPY_:r.mode=COPY;case COPY:if(h=r.length){if(h>s&&(h=s),h>l&&(h=l),0===h)break e;a.set(n.subarray(i,i+h),o),s-=h,i+=h,l-=h,o+=h,r.length-=h;break}r.mode=TYPE;break;case TABLE:for(;c<14;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(r.nlen=257+(31&f),f>>>=5,c-=5,r.ndist=1+(31&f),f>>>=5,c-=5,r.ncode=4+(15&f),f>>>=4,c-=4,r.nlen>286||r.ndist>30){e.msg=\"too many length or distance symbols\",r.mode=BAD;break}r.have=0,r.mode=LENLENS;case LENLENS:for(;r.have<r.ncode;){for(;c<3;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}r.lens[A[r.have++]]=7&f,f>>>=3,c-=3}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,E={bits:r.lenbits},T=inftrees(CODES,r.lens,0,19,r.lencode,0,r.work,E),r.lenbits=E.bits,T){e.msg=\"invalid code lengths set\",r.mode=BAD;break}r.have=0,r.mode=CODELENS;case CODELENS:for(;r.have<r.nlen+r.ndist;){for(;y=(S=r.lencode[f&(1<<r.lenbits)-1])>>>16&255,_=65535&S,!((g=S>>>24)<=c);){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(_<16)f>>>=g,c-=g,r.lens[r.have++]=_;else{if(16===_){for(x=g+2;c<x;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(f>>>=g,c-=g,0===r.have){e.msg=\"invalid bit length repeat\",r.mode=BAD;break}k=r.lens[r.have-1],h=3+(3&f),f>>>=2,c-=2}else if(17===_){for(x=g+3;c<x;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}c-=g,k=0,h=3+(7&(f>>>=g)),f>>>=3,c-=3}else{for(x=g+7;c<x;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}c-=g,k=0,h=11+(127&(f>>>=g)),f>>>=7,c-=7}if(r.have+h>r.nlen+r.ndist){e.msg=\"invalid bit length repeat\",r.mode=BAD;break}for(;h--;)r.lens[r.have++]=k}}if(r.mode===BAD)break;if(0===r.lens[256]){e.msg=\"invalid code -- missing end-of-block\",r.mode=BAD;break}if(r.lenbits=9,E={bits:r.lenbits},T=inftrees(LENS,r.lens,0,r.nlen,r.lencode,0,r.work,E),r.lenbits=E.bits,T){e.msg=\"invalid literal/lengths set\",r.mode=BAD;break}if(r.distbits=6,r.distcode=r.distdyn,E={bits:r.distbits},T=inftrees(DISTS,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,E),r.distbits=E.bits,T){e.msg=\"invalid distances set\",r.mode=BAD;break}if(r.mode=LEN_,t===Z_TREES)break e;case LEN_:r.mode=LEN;case LEN:if(s>=6&&l>=258){e.next_out=o,e.avail_out=l,e.next_in=i,e.avail_in=s,r.hold=f,r.bits=c,inffast(e,d),o=e.next_out,a=e.output,l=e.avail_out,i=e.next_in,n=e.input,s=e.avail_in,f=r.hold,c=r.bits,r.mode===TYPE&&(r.back=-1);break}for(r.back=0;y=(S=r.lencode[f&(1<<r.lenbits)-1])>>>16&255,_=65535&S,!((g=S>>>24)<=c);){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(y&&0==(240&y)){for(b=g,v=y,w=_;y=(S=r.lencode[w+((f&(1<<b+v)-1)>>b)])>>>16&255,_=65535&S,!(b+(g=S>>>24)<=c);){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}f>>>=b,c-=b,r.back+=b}if(f>>>=g,c-=g,r.back+=g,r.length=_,0===y){r.mode=LIT;break}if(32&y){r.back=-1,r.mode=TYPE;break}if(64&y){e.msg=\"invalid literal/length code\",r.mode=BAD;break}r.extra=15&y,r.mode=LENEXT;case LENEXT:if(r.extra){for(x=r.extra;c<x;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}r.length+=f&(1<<r.extra)-1,f>>>=r.extra,c-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=DIST;case DIST:for(;y=(S=r.distcode[f&(1<<r.distbits)-1])>>>16&255,_=65535&S,!((g=S>>>24)<=c);){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(0==(240&y)){for(b=g,v=y,w=_;y=(S=r.distcode[w+((f&(1<<b+v)-1)>>b)])>>>16&255,_=65535&S,!(b+(g=S>>>24)<=c);){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}f>>>=b,c-=b,r.back+=b}if(f>>>=g,c-=g,r.back+=g,64&y){e.msg=\"invalid distance code\",r.mode=BAD;break}r.offset=_,r.extra=15&y,r.mode=DISTEXT;case DISTEXT:if(r.extra){for(x=r.extra;c<x;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}r.offset+=f&(1<<r.extra)-1,f>>>=r.extra,c-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg=\"invalid distance too far back\",r.mode=BAD;break}r.mode=MATCH;case MATCH:if(0===l)break e;if(h=d-l,r.offset>h){if((h=r.offset-h)>r.whave&&r.sane){e.msg=\"invalid distance too far back\",r.mode=BAD;break}h>r.wnext?(h-=r.wnext,p=r.wsize-h):p=r.wnext-h,h>r.length&&(h=r.length),m=r.window}else m=a,p=o-r.offset,h=r.length;h>l&&(h=l),l-=h,r.length-=h;do{a[o++]=m[p++]}while(--h);0===r.length&&(r.mode=LEN);break;case LIT:if(0===l)break e;a[o++]=r.length,l--,r.mode=LEN;break;case CHECK:if(r.wrap){for(;c<32;){if(0===s)break e;s--,f|=n[i++]<<c,c+=8}if(d-=l,e.total_out+=d,r.total+=d,d&&(e.adler=r.check=r.flags?crc32_1(r.check,a,d,o-d):adler32_1(r.check,a,d,o-d)),d=l,(r.flags?f:zswap32(f))!==r.check){e.msg=\"incorrect data check\",r.mode=BAD;break}f=0,c=0}r.mode=LENGTH;case LENGTH:if(r.wrap&&r.flags){for(;c<32;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(f!==(4294967295&r.total)){e.msg=\"incorrect length check\",r.mode=BAD;break}f=0,c=0}r.mode=DONE;case DONE:T=Z_STREAM_END$1;break e;case BAD:T=Z_DATA_ERROR$1;break e;case MEM:return Z_MEM_ERROR$1;case SYNC:default:return Z_STREAM_ERROR$1}return e.next_out=o,e.avail_out=l,e.next_in=i,e.avail_in=s,r.hold=f,r.bits=c,(r.wsize||d!==e.avail_out&&r.mode<BAD&&(r.mode<CHECK||t!==Z_FINISH$1))&&updatewindow(e,e.output,e.next_out,d-e.avail_out),u-=e.avail_in,d-=e.avail_out,e.total_in+=u,e.total_out+=d,r.total+=d,r.wrap&&d&&(e.adler=r.check=r.flags?crc32_1(r.check,a,d,e.next_out-d):adler32_1(r.check,a,d,e.next_out-d)),e.data_type=r.bits+(r.last?64:0)+(r.mode===TYPE?128:0)+(r.mode===LEN_||r.mode===COPY_?256:0),(0===u&&0===d||t===Z_FINISH$1)&&T===Z_OK$1&&(T=Z_BUF_ERROR),T},inflateEnd=function(e){if(!e||!e.state)return Z_STREAM_ERROR$1;var t=e.state;return t.window&&(t.window=null),e.state=null,Z_OK$1},inflateGetHeader=function(e,t){if(!e||!e.state)return Z_STREAM_ERROR$1;var r=e.state;return 0==(2&r.wrap)?Z_STREAM_ERROR$1:(r.head=t,t.done=!1,Z_OK$1)},inflateSetDictionary=function(e,t){var r,n=t.length;return e&&e.state?0!==(r=e.state).wrap&&r.mode!==DICT?Z_STREAM_ERROR$1:r.mode===DICT&&adler32_1(1,t,n,0)!==r.check?Z_DATA_ERROR$1:updatewindow(e,t,n,n)?(r.mode=MEM,Z_MEM_ERROR$1):(r.havedict=1,Z_OK$1):Z_STREAM_ERROR$1},inflateReset_1=inflateReset,inflateReset2_1=inflateReset2,inflateResetKeep_1=inflateResetKeep,inflateInit_1=inflateInit,inflateInit2_1=inflateInit2,inflate_2$1=inflate$2,inflateEnd_1=inflateEnd,inflateGetHeader_1=inflateGetHeader,inflateSetDictionary_1=inflateSetDictionary,inflateInfo=\"pako inflate (from Nodeca project)\",inflate_1$2={inflateReset:inflateReset_1,inflateReset2:inflateReset2_1,inflateResetKeep:inflateResetKeep_1,inflateInit:inflateInit_1,inflateInit2:inflateInit2_1,inflate:inflate_2$1,inflateEnd:inflateEnd_1,inflateGetHeader:inflateGetHeader_1,inflateSetDictionary:inflateSetDictionary_1,inflateInfo:inflateInfo};function GZheader(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name=\"\",this.comment=\"\",this.hcrc=0,this.done=!1}var gzheader=GZheader,toString=Object.prototype.toString,Z_NO_FLUSH=constants$2.Z_NO_FLUSH,Z_FINISH=constants$2.Z_FINISH,Z_OK=constants$2.Z_OK,Z_STREAM_END=constants$2.Z_STREAM_END,Z_NEED_DICT=constants$2.Z_NEED_DICT,Z_STREAM_ERROR=constants$2.Z_STREAM_ERROR,Z_DATA_ERROR=constants$2.Z_DATA_ERROR,Z_MEM_ERROR=constants$2.Z_MEM_ERROR;function Inflate$1(e){this.options=common.assign({chunkSize:65536,windowBits:15,to:\"\"},e||{});var t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new zstream,this.strm.avail_out=0;var r=inflate_1$2.inflateInit2(this.strm,t.windowBits);if(r!==Z_OK)throw new Error(messages[r]);if(this.header=new gzheader,inflate_1$2.inflateGetHeader(this.strm,this.header),t.dictionary&&(\"string\"==typeof t.dictionary?t.dictionary=strings.string2buf(t.dictionary):\"[object ArrayBuffer]\"===toString.call(t.dictionary)&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(r=inflate_1$2.inflateSetDictionary(this.strm,t.dictionary))!==Z_OK))throw new Error(messages[r])}function inflate$1(e,t){var r=new Inflate$1(t);if(r.push(e),r.err)throw r.msg||messages[r.err];return r.result}function inflateRaw$1(e,t){return(t=t||{}).raw=!0,inflate$1(e,t)}Inflate$1.prototype.push=function(e,t){var r,n,a,i=this.strm,o=this.options.chunkSize,s=this.options.dictionary;if(this.ended)return!1;for(n=t===~~t?t:!0===t?Z_FINISH:Z_NO_FLUSH,\"[object ArrayBuffer]\"===toString.call(e)?i.input=new Uint8Array(e):i.input=e,i.next_in=0,i.avail_in=i.input.length;;){for(0===i.avail_out&&(i.output=new Uint8Array(o),i.next_out=0,i.avail_out=o),(r=inflate_1$2.inflate(i,n))===Z_NEED_DICT&&s&&((r=inflate_1$2.inflateSetDictionary(i,s))===Z_OK?r=inflate_1$2.inflate(i,n):r===Z_DATA_ERROR&&(r=Z_NEED_DICT));i.avail_in>0&&r===Z_STREAM_END&&i.state.wrap>0&&0!==e[i.next_in];)inflate_1$2.inflateReset(i),r=inflate_1$2.inflate(i,n);switch(r){case Z_STREAM_ERROR:case Z_DATA_ERROR:case Z_NEED_DICT:case Z_MEM_ERROR:return this.onEnd(r),this.ended=!0,!1}if(a=i.avail_out,i.next_out&&(0===i.avail_out||r===Z_STREAM_END))if(\"string\"===this.options.to){var l=strings.utf8border(i.output,i.next_out),f=i.next_out-l,c=strings.buf2string(i.output,l);i.next_out=f,i.avail_out=o-f,f&&i.output.set(i.output.subarray(l,l+f),0),this.onData(c)}else this.onData(i.output.length===i.next_out?i.output:i.output.subarray(0,i.next_out));if(r!==Z_OK||0!==a){if(r===Z_STREAM_END)return r=inflate_1$2.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,!0;if(0===i.avail_in)break}}return!0},Inflate$1.prototype.onData=function(e){this.chunks.push(e)},Inflate$1.prototype.onEnd=function(e){e===Z_OK&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=common.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var Inflate_1$1=Inflate$1,inflate_2=inflate$1,inflateRaw_1$1=inflateRaw$1,ungzip$1=inflate$1,constants=constants$2,inflate_1$1={Inflate:Inflate_1$1,inflate:inflate_2,inflateRaw:inflateRaw_1$1,ungzip:ungzip$1,constants:constants},inflate=inflate_1$1.inflate,inflate_1=inflate,DeflateDecoder=function(e){_inherits(r,BaseDecoder);var t=_createSuper(r);function r(){return _classCallCheck(this,r),t.apply(this,arguments)}return _createClass(r,[{key:\"decodeBlock\",value:function(e){return inflate_1(new Uint8Array(e)).buffer}}]),r}(),deflate=Object.freeze({__proto__:null,default:DeflateDecoder}),PackbitsDecoder=function(e){_inherits(r,BaseDecoder);var t=_createSuper(r);function r(){return _classCallCheck(this,r),t.apply(this,arguments)}return _createClass(r,[{key:\"decodeBlock\",value:function(e){for(var t=new DataView(e),r=[],n=0;n<e.byteLength;++n){var a=t.getInt8(n);if(a<0){var i=t.getUint8(n+1);a=-a;for(var o=0;o<=a;++o)r.push(i);n+=1}else{for(var s=0;s<=a;++s)r.push(t.getUint8(n+s+1));n+=a+1}}return new Uint8Array(r).buffer}}]),r}(),packbits=Object.freeze({__proto__:null,default:PackbitsDecoder}),LercDecode={exports:{}},module;module=LercDecode,\n/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\nfunction(){var e,t,r,n,a,i,o,s,l,f,c,u,d,h,p,m,g=(e={defaultNoDataValue:-34027999387901484e22,decode:function(i,o){var s=(o=o||{}).encodedMaskData||null===o.encodedMaskData,l=a(i,o.inputOffset||0,s),f=null!==o.noDataValue?o.noDataValue:e.defaultNoDataValue,c=t(l,o.pixelType||Float32Array,o.encodedMaskData,f,o.returnMask),u={width:l.width,height:l.height,pixelData:c.resultPixels,minValue:c.minValue,maxValue:l.pixels.maxValue,noDataValue:f};return c.resultMask&&(u.maskData=c.resultMask),o.returnEncodedMask&&l.mask&&(u.encodedMaskData=l.mask.bitset?l.mask.bitset:null),o.returnFileInfo&&(u.fileInfo=r(l),o.computeUsedBitDepths&&(u.fileInfo.bitDepths=n(l))),u}},t=function(e,t,r,n,a){var o,s,l,f=0,c=e.pixels.numBlocksX,u=e.pixels.numBlocksY,d=Math.floor(e.width/c),h=Math.floor(e.height/u),p=2*e.maxZError,m=Number.MAX_VALUE;r=r||(e.mask?e.mask.bitset:null),s=new t(e.width*e.height),a&&r&&(l=new Uint8Array(e.width*e.height));for(var g,y,_=new Float32Array(d*h),b=0;b<=u;b++){var v=b!==u?h:e.height%u;if(0!==v)for(var w=0;w<=c;w++){var k=w!==c?d:e.width%c;if(0!==k){var T,E,x,S,D=b*e.width*h+w*d,A=e.width-k,M=e.pixels.blocks[f];if(M.encoding<2?(0===M.encoding?T=M.rawData:(i(M.stuffedData,M.bitsPerPixel,M.numValidPixels,M.offset,p,_,e.pixels.maxValue),T=_),E=0):x=2===M.encoding?0:M.offset,r)for(y=0;y<v;y++){for(7&D&&(S=r[D>>3],S<<=7&D),g=0;g<k;g++)7&D||(S=r[D>>3]),128&S?(l&&(l[D]=1),m=m>(o=M.encoding<2?T[E++]:x)?o:m,s[D++]=o):(l&&(l[D]=0),s[D++]=n),S<<=1;D+=A}else if(M.encoding<2)for(y=0;y<v;y++){for(g=0;g<k;g++)m=m>(o=T[E++])?o:m,s[D++]=o;D+=A}else for(m=m>x?x:m,y=0;y<v;y++){for(g=0;g<k;g++)s[D++]=x;D+=A}if(1===M.encoding&&E!==M.numValidPixels)throw\"Block and Mask do not match\";f++}}}return{resultPixels:s,resultMask:l,minValue:m}},r=function(e){return{fileIdentifierString:e.fileIdentifierString,fileVersion:e.fileVersion,imageType:e.imageType,height:e.height,width:e.width,maxZError:e.maxZError,eofOffset:e.eofOffset,mask:e.mask?{numBlocksX:e.mask.numBlocksX,numBlocksY:e.mask.numBlocksY,numBytes:e.mask.numBytes,maxValue:e.mask.maxValue}:null,pixels:{numBlocksX:e.pixels.numBlocksX,numBlocksY:e.pixels.numBlocksY,numBytes:e.pixels.numBytes,maxValue:e.pixels.maxValue,noDataValue:e.noDataValue}}},n=function(e){for(var t=e.pixels.numBlocksX*e.pixels.numBlocksY,r={},n=0;n<t;n++){var a=e.pixels.blocks[n];0===a.encoding?r.float32=!0:1===a.encoding?r[a.bitsPerPixel]=!0:r[0]=!0}return Object.keys(r)},a=function(e,t,r){var n={},a=new Uint8Array(e,t,10);if(n.fileIdentifierString=String.fromCharCode.apply(null,a),\"CntZImage\"!==n.fileIdentifierString.trim())throw\"Unexpected file identifier string: \"+n.fileIdentifierString;t+=10;var i=new DataView(e,t,24);if(n.fileVersion=i.getInt32(0,!0),n.imageType=i.getInt32(4,!0),n.height=i.getUint32(8,!0),n.width=i.getUint32(12,!0),n.maxZError=i.getFloat64(16,!0),t+=24,!r)if(i=new DataView(e,t,16),n.mask={},n.mask.numBlocksY=i.getUint32(0,!0),n.mask.numBlocksX=i.getUint32(4,!0),n.mask.numBytes=i.getUint32(8,!0),n.mask.maxValue=i.getFloat32(12,!0),t+=16,n.mask.numBytes>0){var o=new Uint8Array(Math.ceil(n.width*n.height/8)),s=(i=new DataView(e,t,n.mask.numBytes)).getInt16(0,!0),l=2,f=0;do{if(s>0)for(;s--;)o[f++]=i.getUint8(l++);else{var c=i.getUint8(l++);for(s=-s;s--;)o[f++]=c}s=i.getInt16(l,!0),l+=2}while(l<n.mask.numBytes);if(-32768!==s||f<o.length)throw\"Unexpected end of mask RLE encoding\";n.mask.bitset=o,t+=n.mask.numBytes}else 0==(n.mask.numBytes|n.mask.numBlocksY|n.mask.maxValue)&&(n.mask.bitset=new Uint8Array(Math.ceil(n.width*n.height/8)));i=new DataView(e,t,16),n.pixels={},n.pixels.numBlocksY=i.getUint32(0,!0),n.pixels.numBlocksX=i.getUint32(4,!0),n.pixels.numBytes=i.getUint32(8,!0),n.pixels.maxValue=i.getFloat32(12,!0),t+=16;var u=n.pixels.numBlocksX,d=n.pixels.numBlocksY,h=u+(n.width%u>0?1:0),p=d+(n.height%d>0?1:0);n.pixels.blocks=new Array(h*p);for(var m=0,g=0;g<p;g++)for(var y=0;y<h;y++){var _=0,b=e.byteLength-t;i=new DataView(e,t,Math.min(10,b));var v={};n.pixels.blocks[m++]=v;var w=i.getUint8(0);if(_++,v.encoding=63&w,v.encoding>3)throw\"Invalid block encoding (\"+v.encoding+\")\";if(2!==v.encoding){if(0!==w&&2!==w){if(w>>=6,v.offsetType=w,2===w)v.offset=i.getInt8(1),_++;else if(1===w)v.offset=i.getInt16(1,!0),_+=2;else{if(0!==w)throw\"Invalid block offset type\";v.offset=i.getFloat32(1,!0),_+=4}if(1===v.encoding)if(w=i.getUint8(_),_++,v.bitsPerPixel=63&w,w>>=6,v.numValidPixelsType=w,2===w)v.numValidPixels=i.getUint8(_),_++;else if(1===w)v.numValidPixels=i.getUint16(_,!0),_+=2;else{if(0!==w)throw\"Invalid valid pixel count type\";v.numValidPixels=i.getUint32(_,!0),_+=4}}var k;if(t+=_,3!==v.encoding)if(0===v.encoding){var T=(n.pixels.numBytes-1)/4;if(T!==Math.floor(T))throw\"uncompressed block has invalid length\";k=new ArrayBuffer(4*T),new Uint8Array(k).set(new Uint8Array(e,t,4*T));var E=new Float32Array(k);v.rawData=E,t+=4*T}else if(1===v.encoding){var x=Math.ceil(v.numValidPixels*v.bitsPerPixel/8),S=Math.ceil(x/4);k=new ArrayBuffer(4*S),new Uint8Array(k).set(new Uint8Array(e,t,x)),v.stuffedData=new Uint32Array(k),t+=x}}else t++}return n.eofOffset=t,n},i=function(e,t,r,n,a,i,o){var s,l,f,c=(1<<t)-1,u=0,d=0,h=Math.ceil((o-n)/a),p=4*e.length-Math.ceil(t*r/8);for(e[e.length-1]<<=8*p,s=0;s<r;s++){if(0===d&&(f=e[u++],d=32),d>=t)l=f>>>d-t&c,d-=t;else{var m=t-d;l=(f&c)<<m&c,l+=(f=e[u++])>>>(d=32-m)}i[s]=l<h?n+l*a:o}return i},e),y=(o=function(e,t,r,n,a,i,o,s){var l,f,c,u,d,h=(1<<r)-1,p=0,m=0,g=4*e.length-Math.ceil(r*n/8);if(e[e.length-1]<<=8*g,a)for(l=0;l<n;l++)0===m&&(c=e[p++],m=32),m>=r?(f=c>>>m-r&h,m-=r):(f=(c&h)<<(u=r-m)&h,f+=(c=e[p++])>>>(m=32-u)),t[l]=a[f];else for(d=Math.ceil((s-i)/o),l=0;l<n;l++)0===m&&(c=e[p++],m=32),m>=r?(f=c>>>m-r&h,m-=r):(f=(c&h)<<(u=r-m)&h,f+=(c=e[p++])>>>(m=32-u)),t[l]=f<d?i+f*o:s},s=function(e,t,r,n,a,i){var o,s=(1<<t)-1,l=0,f=0,c=0,u=0,d=0,h=[],p=4*e.length-Math.ceil(t*r/8);e[e.length-1]<<=8*p;var m=Math.ceil((i-n)/a);for(f=0;f<r;f++)0===u&&(o=e[l++],u=32),u>=t?(d=o>>>u-t&s,u-=t):(d=(o&s)<<(c=t-u)&s,d+=(o=e[l++])>>>(u=32-c)),h[f]=d<m?n+d*a:i;return h.unshift(n),h},l=function(e,t,r,n,a,i,o,s){var l,f,c,u,d=(1<<r)-1,h=0,p=0,m=0;if(a)for(l=0;l<n;l++)0===p&&(c=e[h++],p=32,m=0),p>=r?(f=c>>>m&d,p-=r,m+=r):(f=c>>>m&d,p=32-(u=r-p),f|=((c=e[h++])&(1<<u)-1)<<r-u,m=u),t[l]=a[f];else{var g=Math.ceil((s-i)/o);for(l=0;l<n;l++)0===p&&(c=e[h++],p=32,m=0),p>=r?(f=c>>>m&d,p-=r,m+=r):(f=c>>>m&d,p=32-(u=r-p),f|=((c=e[h++])&(1<<u)-1)<<r-u,m=u),t[l]=f<g?i+f*o:s}return t},f=function(e,t,r,n,a,i){var o,s=(1<<t)-1,l=0,f=0,c=0,u=0,d=0,h=0,p=[],m=Math.ceil((i-n)/a);for(f=0;f<r;f++)0===u&&(o=e[l++],u=32,h=0),u>=t?(d=o>>>h&s,u-=t,h+=t):(d=o>>>h&s,u=32-(c=t-u),d|=((o=e[l++])&(1<<c)-1)<<t-c,h=c),p[f]=d<m?n+d*a:i;return p.unshift(n),p},c=function(e,t,r,n){var a,i,o,s,l=(1<<r)-1,f=0,c=0,u=4*e.length-Math.ceil(r*n/8);for(e[e.length-1]<<=8*u,a=0;a<n;a++)0===c&&(o=e[f++],c=32),c>=r?(i=o>>>c-r&l,c-=r):(i=(o&l)<<(s=r-c)&l,i+=(o=e[f++])>>>(c=32-s)),t[a]=i;return t},u=function(e,t,r,n){var a,i,o,s,l=(1<<r)-1,f=0,c=0,u=0;for(a=0;a<n;a++)0===c&&(o=e[f++],c=32,u=0),c>=r?(i=o>>>u&l,c-=r,u+=r):(i=o>>>u&l,c=32-(s=r-c),i|=((o=e[f++])&(1<<s)-1)<<r-s,u=s),t[a]=i;return t},d={HUFFMAN_LUT_BITS_MAX:12,computeChecksumFletcher32:function(e){for(var t=65535,r=65535,n=e.length,a=Math.floor(n/2),i=0;a;){var o=a>=359?359:a;a-=o;do{t+=e[i++]<<8,r+=t+=e[i++]}while(--o);t=(65535&t)+(t>>>16),r=(65535&r)+(r>>>16)}return 1&n&&(r+=t+=e[i]<<8),((r=(65535&r)+(r>>>16))<<16|(t=(65535&t)+(t>>>16)))>>>0},readHeaderInfo:function(e,t){var r=t.ptr,n=new Uint8Array(e,r,6),a={};if(a.fileIdentifierString=String.fromCharCode.apply(null,n),0!==a.fileIdentifierString.lastIndexOf(\"Lerc2\",0))throw\"Unexpected file identifier string (expect Lerc2 ): \"+a.fileIdentifierString;r+=6;var i,o=new DataView(e,r,8),s=o.getInt32(0,!0);if(a.fileVersion=s,r+=4,s>=3&&(a.checksum=o.getUint32(4,!0),r+=4),o=new DataView(e,r,12),a.height=o.getUint32(0,!0),a.width=o.getUint32(4,!0),r+=8,s>=4?(a.numDims=o.getUint32(8,!0),r+=4):a.numDims=1,o=new DataView(e,r,40),a.numValidPixel=o.getUint32(0,!0),a.microBlockSize=o.getInt32(4,!0),a.blobSize=o.getInt32(8,!0),a.imageType=o.getInt32(12,!0),a.maxZError=o.getFloat64(16,!0),a.zMin=o.getFloat64(24,!0),a.zMax=o.getFloat64(32,!0),r+=40,t.headerInfo=a,t.ptr=r,s>=3&&(i=s>=4?52:48,this.computeChecksumFletcher32(new Uint8Array(e,r-i,a.blobSize-14))!==a.checksum))throw\"Checksum failed.\";return!0},checkMinMaxRanges:function(e,t){var r=t.headerInfo,n=this.getDataTypeArray(r.imageType),a=r.numDims*this.getDataTypeSize(r.imageType),i=this.readSubArray(e,t.ptr,n,a),o=this.readSubArray(e,t.ptr+a,n,a);t.ptr+=2*a;var s,l=!0;for(s=0;s<r.numDims;s++)if(i[s]!==o[s]){l=!1;break}return r.minValues=i,r.maxValues=o,l},readSubArray:function(e,t,r,n){var a;if(r===Uint8Array)a=new Uint8Array(e,t,n);else{var i=new ArrayBuffer(n);new Uint8Array(i).set(new Uint8Array(e,t,n)),a=new r(i)}return a},readMask:function(e,t){var r,n,a=t.ptr,i=t.headerInfo,o=i.width*i.height,s=i.numValidPixel,l=new DataView(e,a,4),f={};if(f.numBytes=l.getUint32(0,!0),a+=4,(0===s||o===s)&&0!==f.numBytes)throw\"invalid mask\";if(0===s)r=new Uint8Array(Math.ceil(o/8)),f.bitset=r,n=new Uint8Array(o),t.pixels.resultMask=n,a+=f.numBytes;else if(f.numBytes>0){r=new Uint8Array(Math.ceil(o/8));var c=(l=new DataView(e,a,f.numBytes)).getInt16(0,!0),u=2,d=0,h=0;do{if(c>0)for(;c--;)r[d++]=l.getUint8(u++);else for(h=l.getUint8(u++),c=-c;c--;)r[d++]=h;c=l.getInt16(u,!0),u+=2}while(u<f.numBytes);if(-32768!==c||d<r.length)throw\"Unexpected end of mask RLE encoding\";n=new Uint8Array(o);var p=0,m=0;for(m=0;m<o;m++)7&m?(p=r[m>>3],p<<=7&m):p=r[m>>3],128&p&&(n[m]=1);t.pixels.resultMask=n,f.bitset=r,a+=f.numBytes}return t.ptr=a,t.mask=f,!0},readDataOneSweep:function(e,t,r,n){var a,i=t.ptr,o=t.headerInfo,s=o.numDims,l=o.width*o.height,f=o.imageType,c=o.numValidPixel*d.getDataTypeSize(f)*s,u=t.pixels.resultMask;if(r===Uint8Array)a=new Uint8Array(e,i,c);else{var h=new ArrayBuffer(c);new Uint8Array(h).set(new Uint8Array(e,i,c)),a=new r(h)}if(a.length===l*s)t.pixels.resultPixels=n?d.swapDimensionOrder(a,l,s,r,!0):a;else{t.pixels.resultPixels=new r(l*s);var p=0,m=0,g=0,y=0;if(s>1){if(n){for(m=0;m<l;m++)if(u[m])for(y=m,g=0;g<s;g++,y+=l)t.pixels.resultPixels[y]=a[p++]}else for(m=0;m<l;m++)if(u[m])for(y=m*s,g=0;g<s;g++)t.pixels.resultPixels[y+g]=a[p++]}else for(m=0;m<l;m++)u[m]&&(t.pixels.resultPixels[m]=a[p++])}return i+=c,t.ptr=i,!0},readHuffmanTree:function(e,t){var r=this.HUFFMAN_LUT_BITS_MAX,n=new DataView(e,t.ptr,16);if(t.ptr+=16,n.getInt32(0,!0)<2)throw\"unsupported Huffman version\";var a=n.getInt32(4,!0),i=n.getInt32(8,!0),o=n.getInt32(12,!0);if(i>=o)return!1;var s=new Uint32Array(o-i);d.decodeBits(e,t,s);var l,f,c,u,p=[];for(l=i;l<o;l++)p[f=l-(l<a?0:a)]={first:s[l-i],second:null};var m=e.byteLength-t.ptr,g=Math.ceil(m/4),y=new ArrayBuffer(4*g);new Uint8Array(y).set(new Uint8Array(e,t.ptr,m));var _,b=new Uint32Array(y),v=0,w=0;for(_=b[0],l=i;l<o;l++)(u=p[f=l-(l<a?0:a)].first)>0&&(p[f].second=_<<v>>>32-u,32-v>=u?32===(v+=u)&&(v=0,_=b[++w]):(v+=u-32,_=b[++w],p[f].second|=_>>>32-v));var k=0,T=0,E=new h;for(l=0;l<p.length;l++)void 0!==p[l]&&(k=Math.max(k,p[l].first));T=k>=r?r:k;var x,S,D,A,M,I=[];for(l=i;l<o;l++)if((u=p[f=l-(l<a?0:a)].first)>0)if(x=[u,f],u<=T)for(S=p[f].second<<T-u,D=1<<T-u,c=0;c<D;c++)I[S|c]=x;else for(S=p[f].second,M=E,A=u-1;A>=0;A--)S>>>A&1?(M.right||(M.right=new h),M=M.right):(M.left||(M.left=new h),M=M.left),0!==A||M.val||(M.val=x[1]);return{decodeLut:I,numBitsLUTQick:T,numBitsLUT:k,tree:E,stuffedData:b,srcPtr:w,bitPos:v}},readHuffman:function(e,t,r,n){var a,i,o,s,l,f,c,u,h,p=t.headerInfo.numDims,m=t.headerInfo.height,g=t.headerInfo.width,y=g*m,_=this.readHuffmanTree(e,t),b=_.decodeLut,v=_.tree,w=_.stuffedData,k=_.srcPtr,T=_.bitPos,E=_.numBitsLUTQick,x=_.numBitsLUT,S=0===t.headerInfo.imageType?128:0,D=t.pixels.resultMask,A=0;T>0&&(k++,T=0);var M,I=w[k],R=1===t.encodeMode,O=new r(y*p),C=O;if(p<2||R){for(M=0;M<p;M++)if(p>1&&(C=new r(O.buffer,y*M,y),A=0),t.headerInfo.numValidPixel===g*m)for(u=0,f=0;f<m;f++)for(c=0;c<g;c++,u++){if(i=0,l=s=I<<T>>>32-E,32-T<E&&(l=s|=w[k+1]>>>64-T-E),b[l])i=b[l][1],T+=b[l][0];else for(l=s=I<<T>>>32-x,32-T<x&&(l=s|=w[k+1]>>>64-T-x),a=v,h=0;h<x;h++)if(!(a=s>>>x-h-1&1?a.right:a.left).left&&!a.right){i=a.val,T=T+h+1;break}T>=32&&(T-=32,I=w[++k]),o=i-S,R?(o+=c>0?A:f>0?C[u-g]:A,o&=255,C[u]=o,A=o):C[u]=o}else for(u=0,f=0;f<m;f++)for(c=0;c<g;c++,u++)if(D[u]){if(i=0,l=s=I<<T>>>32-E,32-T<E&&(l=s|=w[k+1]>>>64-T-E),b[l])i=b[l][1],T+=b[l][0];else for(l=s=I<<T>>>32-x,32-T<x&&(l=s|=w[k+1]>>>64-T-x),a=v,h=0;h<x;h++)if(!(a=s>>>x-h-1&1?a.right:a.left).left&&!a.right){i=a.val,T=T+h+1;break}T>=32&&(T-=32,I=w[++k]),o=i-S,R?(c>0&&D[u-1]?o+=A:f>0&&D[u-g]?o+=C[u-g]:o+=A,o&=255,C[u]=o,A=o):C[u]=o}}else for(u=0,f=0;f<m;f++)for(c=0;c<g;c++)if(u=f*g+c,!D||D[u])for(M=0;M<p;M++,u+=y){if(i=0,l=s=I<<T>>>32-E,32-T<E&&(l=s|=w[k+1]>>>64-T-E),b[l])i=b[l][1],T+=b[l][0];else for(l=s=I<<T>>>32-x,32-T<x&&(l=s|=w[k+1]>>>64-T-x),a=v,h=0;h<x;h++)if(!(a=s>>>x-h-1&1?a.right:a.left).left&&!a.right){i=a.val,T=T+h+1;break}T>=32&&(T-=32,I=w[++k]),o=i-S,C[u]=o}t.ptr=t.ptr+4*(k+1)+(T>0?4:0),t.pixels.resultPixels=O,p>1&&!n&&(t.pixels.resultPixels=d.swapDimensionOrder(O,y,p,r))},decodeBits:function(e,t,r,n,a){var i=t.headerInfo,d=i.fileVersion,h=0,p=e.byteLength-t.ptr>=5?5:e.byteLength-t.ptr,m=new DataView(e,t.ptr,p),g=m.getUint8(0);h++;var y=g>>6,_=0===y?4:3-y,b=(32&g)>0,v=31&g,w=0;if(1===_)w=m.getUint8(h),h++;else if(2===_)w=m.getUint16(h,!0),h+=2;else{if(4!==_)throw\"Invalid valid pixel count type\";w=m.getUint32(h,!0),h+=4}var k,T,E,x,S,D,A,M,I,R=2*i.maxZError,O=i.numDims>1?i.maxValues[a]:i.zMax;if(b){for(t.counter.lut++,M=m.getUint8(h),h++,x=Math.ceil((M-1)*v/8),S=Math.ceil(x/4),T=new ArrayBuffer(4*S),E=new Uint8Array(T),t.ptr+=h,E.set(new Uint8Array(e,t.ptr,x)),A=new Uint32Array(T),t.ptr+=x,I=0;M-1>>>I;)I++;x=Math.ceil(w*I/8),S=Math.ceil(x/4),T=new ArrayBuffer(4*S),(E=new Uint8Array(T)).set(new Uint8Array(e,t.ptr,x)),k=new Uint32Array(T),t.ptr+=x,D=d>=3?f(A,v,M-1,n,R,O):s(A,v,M-1,n,R,O),d>=3?l(k,r,I,w,D):o(k,r,I,w,D)}else t.counter.bitstuffer++,I=v,t.ptr+=h,I>0&&(x=Math.ceil(w*I/8),S=Math.ceil(x/4),T=new ArrayBuffer(4*S),(E=new Uint8Array(T)).set(new Uint8Array(e,t.ptr,x)),k=new Uint32Array(T),t.ptr+=x,d>=3?null==n?u(k,r,I,w):l(k,r,I,w,!1,n,R,O):null==n?c(k,r,I,w):o(k,r,I,w,!1,n,R,O))},readTiles:function(e,t,r,n){var a=t.headerInfo,i=a.width,o=a.height,s=i*o,l=a.microBlockSize,f=a.imageType,c=d.getDataTypeSize(f),u=Math.ceil(i/l),h=Math.ceil(o/l);t.pixels.numBlocksY=h,t.pixels.numBlocksX=u,t.pixels.ptr=0;var p,m,g,y,_,b,v,w,k,T,E=0,x=0,S=0,D=0,A=0,M=0,I=0,R=0,O=0,C=0,P=0,L=0,U=0,B=0,$=0,N=new r(l*l),z=o%l||l,Z=i%l||l,G=a.numDims,j=t.pixels.resultMask,V=t.pixels.resultPixels,F=a.fileVersion>=5?14:15,K=a.zMax;for(S=0;S<h;S++)for(A=S!==h-1?l:z,D=0;D<u;D++)for(C=S*i*l+D*l,P=i-(M=D!==u-1?l:Z),w=0;w<G;w++){if(G>1?(T=V,C=S*i*l+D*l,V=new r(t.pixels.resultPixels.buffer,s*w*c,s),K=a.maxValues[w]):T=null,I=e.byteLength-t.ptr,m={},$=0,R=(p=new DataView(e,t.ptr,Math.min(10,I))).getUint8(0),$++,k=a.fileVersion>=5?4&R:0,O=R>>6&255,(R>>2&F)!=(D*l>>3&F))throw\"integrity issue\";if(k&&0===w)throw\"integrity issue\";if((_=3&R)>3)throw t.ptr+=$,\"Invalid block encoding (\"+_+\")\";if(2!==_)if(0===_){if(k)throw\"integrity issue\";if(t.counter.uncompressed++,t.ptr+=$,L=(L=A*M*c)<(U=e.byteLength-t.ptr)?L:U,g=new ArrayBuffer(L%c==0?L:L+c-L%c),new Uint8Array(g).set(new Uint8Array(e,t.ptr,L)),y=new r(g),B=0,j)for(E=0;E<A;E++){for(x=0;x<M;x++)j[C]&&(V[C]=y[B++]),C++;C+=P}else for(E=0;E<A;E++){for(x=0;x<M;x++)V[C++]=y[B++];C+=P}t.ptr+=B*c}else if(b=d.getDataTypeUsed(k&&f<6?4:f,O),v=d.getOnePixel(m,$,b,p),$+=d.getDataTypeSize(b),3===_)if(t.ptr+=$,t.counter.constantoffset++,j)for(E=0;E<A;E++){for(x=0;x<M;x++)j[C]&&(V[C]=k?Math.min(K,T[C]+v):v),C++;C+=P}else for(E=0;E<A;E++){for(x=0;x<M;x++)V[C]=k?Math.min(K,T[C]+v):v,C++;C+=P}else if(t.ptr+=$,d.decodeBits(e,t,N,v,w),$=0,k)if(j)for(E=0;E<A;E++){for(x=0;x<M;x++)j[C]&&(V[C]=N[$++]+T[C]),C++;C+=P}else for(E=0;E<A;E++){for(x=0;x<M;x++)V[C]=N[$++]+T[C],C++;C+=P}else if(j)for(E=0;E<A;E++){for(x=0;x<M;x++)j[C]&&(V[C]=N[$++]),C++;C+=P}else for(E=0;E<A;E++){for(x=0;x<M;x++)V[C++]=N[$++];C+=P}else{if(k)if(j)for(E=0;E<A;E++)for(x=0;x<M;x++)j[C]&&(V[C]=T[C]),C++;else for(E=0;E<A;E++)for(x=0;x<M;x++)V[C]=T[C],C++;t.counter.constant++,t.ptr+=$}}G>1&&!n&&(t.pixels.resultPixels=d.swapDimensionOrder(t.pixels.resultPixels,s,G,r))},formatFileInfo:function(e){return{fileIdentifierString:e.headerInfo.fileIdentifierString,fileVersion:e.headerInfo.fileVersion,imageType:e.headerInfo.imageType,height:e.headerInfo.height,width:e.headerInfo.width,numValidPixel:e.headerInfo.numValidPixel,microBlockSize:e.headerInfo.microBlockSize,blobSize:e.headerInfo.blobSize,maxZError:e.headerInfo.maxZError,pixelType:d.getPixelType(e.headerInfo.imageType),eofOffset:e.eofOffset,mask:e.mask?{numBytes:e.mask.numBytes}:null,pixels:{numBlocksX:e.pixels.numBlocksX,numBlocksY:e.pixels.numBlocksY,maxValue:e.headerInfo.zMax,minValue:e.headerInfo.zMin,noDataValue:e.noDataValue}}},constructConstantSurface:function(e,t){var r=e.headerInfo.zMax,n=e.headerInfo.zMin,a=e.headerInfo.maxValues,i=e.headerInfo.numDims,o=e.headerInfo.height*e.headerInfo.width,s=0,l=0,f=0,c=e.pixels.resultMask,u=e.pixels.resultPixels;if(c)if(i>1){if(t)for(s=0;s<i;s++)for(f=s*o,r=a[s],l=0;l<o;l++)c[l]&&(u[f+l]=r);else for(l=0;l<o;l++)if(c[l])for(f=l*i,s=0;s<i;s++)u[f+i]=a[s]}else for(l=0;l<o;l++)c[l]&&(u[l]=r);else if(i>1&&n!==r)if(t)for(s=0;s<i;s++)for(f=s*o,r=a[s],l=0;l<o;l++)u[f+l]=r;else for(l=0;l<o;l++)for(f=l*i,s=0;s<i;s++)u[f+s]=a[s];else for(l=0;l<o*i;l++)u[l]=r},getDataTypeArray:function(e){var t;switch(e){case 0:t=Int8Array;break;case 1:t=Uint8Array;break;case 2:t=Int16Array;break;case 3:t=Uint16Array;break;case 4:t=Int32Array;break;case 5:t=Uint32Array;break;case 6:t=Float32Array;break;case 7:t=Float64Array;break;default:t=Float32Array}return t},getPixelType:function(e){var t;switch(e){case 0:t=\"S8\";break;case 1:t=\"U8\";break;case 2:t=\"S16\";break;case 3:t=\"U16\";break;case 4:t=\"S32\";break;case 5:t=\"U32\";break;case 6:t=\"F32\";break;case 7:t=\"F64\";break;default:t=\"F32\"}return t},isValidPixelValue:function(e,t){if(null==t)return!1;var r;switch(e){case 0:r=t>=-128&&t<=127;break;case 1:r=t>=0&&t<=255;break;case 2:r=t>=-32768&&t<=32767;break;case 3:r=t>=0&&t<=65536;break;case 4:r=t>=-2147483648&&t<=2147483647;break;case 5:r=t>=0&&t<=4294967296;break;case 6:r=t>=-34027999387901484e22&&t<=34027999387901484e22;break;case 7:r=t>=-17976931348623157e292&&t<=17976931348623157e292;break;default:r=!1}return r},getDataTypeSize:function(e){var t=0;switch(e){case 0:case 1:t=1;break;case 2:case 3:t=2;break;case 4:case 5:case 6:t=4;break;case 7:t=8;break;default:t=e}return t},getDataTypeUsed:function(e,t){var r=e;switch(e){case 2:case 4:r=e-t;break;case 3:case 5:r=e-2*t;break;case 6:r=0===t?e:1===t?2:1;break;case 7:r=0===t?e:e-2*t+1;break;default:r=e}return r},getOnePixel:function(e,t,r,n){var a=0;switch(r){case 0:a=n.getInt8(t);break;case 1:a=n.getUint8(t);break;case 2:a=n.getInt16(t,!0);break;case 3:a=n.getUint16(t,!0);break;case 4:a=n.getInt32(t,!0);break;case 5:a=n.getUInt32(t,!0);break;case 6:a=n.getFloat32(t,!0);break;case 7:a=n.getFloat64(t,!0);break;default:throw\"the decoder does not understand this pixel type\"}return a},swapDimensionOrder:function(e,t,r,n,a){var i=0,o=0,s=0,l=0,f=e;if(r>1)if(f=new n(t*r),a)for(i=0;i<t;i++)for(l=i,s=0;s<r;s++,l+=t)f[l]=e[o++];else for(i=0;i<t;i++)for(l=i,s=0;s<r;s++,l+=t)f[o++]=e[l];return f}},h=function(e,t,r){this.val=e,this.left=t,this.right=r},{decode:function(e,t){var r=(t=t||{}).noDataValue,n=0,a={};a.ptr=t.inputOffset||0,a.pixels={},d.readHeaderInfo(e,a);var i=a.headerInfo,o=i.fileVersion,s=d.getDataTypeArray(i.imageType);if(o>5)throw\"unsupported lerc version 2.\"+o;d.readMask(e,a),i.numValidPixel===i.width*i.height||a.pixels.resultMask||(a.pixels.resultMask=t.maskData);var l=i.width*i.height;a.pixels.resultPixels=new s(l*i.numDims),a.counter={onesweep:0,uncompressed:0,lut:0,bitstuffer:0,constant:0,constantoffset:0};var f,c=!t.returnPixelInterleavedDims;if(0!==i.numValidPixel)if(i.zMax===i.zMin)d.constructConstantSurface(a,c);else if(o>=4&&d.checkMinMaxRanges(e,a))d.constructConstantSurface(a,c);else{var u=new DataView(e,a.ptr,2),h=u.getUint8(0);if(a.ptr++,h)d.readDataOneSweep(e,a,s,c);else if(o>1&&i.imageType<=1&&Math.abs(i.maxZError-.5)<1e-5){var p=u.getUint8(1);if(a.ptr++,a.encodeMode=p,p>2||o<4&&p>1)throw\"Invalid Huffman flag \"+p;p?d.readHuffman(e,a,s,c):d.readTiles(e,a,s,c)}else d.readTiles(e,a,s,c)}a.eofOffset=a.ptr,t.inputOffset?(f=a.headerInfo.blobSize+t.inputOffset-a.ptr,Math.abs(f)>=1&&(a.eofOffset=t.inputOffset+a.headerInfo.blobSize)):(f=a.headerInfo.blobSize-a.ptr,Math.abs(f)>=1&&(a.eofOffset=a.headerInfo.blobSize));var m={width:i.width,height:i.height,pixelData:a.pixels.resultPixels,minValue:i.zMin,maxValue:i.zMax,validPixelCount:i.numValidPixel,dimCount:i.numDims,dimStats:{minValues:i.minValues,maxValues:i.maxValues},maskData:a.pixels.resultMask};if(a.pixels.resultMask&&d.isValidPixelValue(i.imageType,r)){var g=a.pixels.resultMask;for(n=0;n<l;n++)g[n]||(m.pixelData[n]=r);m.noDataValue=r}return a.noDataValue=r,t.returnFileInfo&&(m.fileInfo=d.formatFileInfo(a)),m},getBandCount:function(e){for(var t=0,r=0,n={ptr:0,pixels:{}};r<e.byteLength-58;)d.readHeaderInfo(e,n),r+=n.headerInfo.blobSize,t++,n.ptr=r;return t}}),_=(p=new ArrayBuffer(4),m=new Uint8Array(p),new Uint32Array(p)[0]=1,1===m[0]),b={decode:function(e,t){if(!_)throw\"Big endian system is not supported.\";var r,n,a=(t=t||{}).inputOffset||0,i=new Uint8Array(e,a,10),o=String.fromCharCode.apply(null,i);if(\"CntZImage\"===o.trim())r=g,n=1;else{if(\"Lerc2\"!==o.substring(0,5))throw\"Unexpected file identifier string: \"+o;r=y,n=2}for(var s,l,f,c,u,d,h=0,p=e.byteLength-10,m=[],b={width:0,height:0,pixels:[],pixelType:t.pixelType,mask:null,statistics:[]},v=0;a<p;){var w=r.decode(e,{inputOffset:a,encodedMaskData:s,maskData:f,returnMask:0===h,returnEncodedMask:0===h,returnFileInfo:!0,returnPixelInterleavedDims:t.returnPixelInterleavedDims,pixelType:t.pixelType||null,noDataValue:t.noDataValue||null});a=w.fileInfo.eofOffset,f=w.maskData,0===h&&(s=w.encodedMaskData,b.width=w.width,b.height=w.height,b.dimCount=w.dimCount||1,b.pixelType=w.pixelType||w.fileInfo.pixelType,b.mask=f),n>1&&(f&&m.push(f),w.fileInfo.mask&&w.fileInfo.mask.numBytes>0&&v++),h++,b.pixels.push(w.pixelData),b.statistics.push({minValue:w.minValue,maxValue:w.maxValue,noDataValue:w.noDataValue,dimStats:w.dimStats})}if(n>1&&v>1){for(d=b.width*b.height,b.bandMasks=m,(f=new Uint8Array(d)).set(m[0]),c=1;c<m.length;c++)for(l=m[c],u=0;u<d;u++)f[u]=f[u]&l[u];b.maskData=f}return b}};module.exports?module.exports=b:this.Lerc=b}();var Lerc=LercDecode.exports,fieldTagNames={315:\"Artist\",258:\"BitsPerSample\",265:\"CellLength\",264:\"CellWidth\",320:\"ColorMap\",259:\"Compression\",33432:\"Copyright\",306:\"DateTime\",338:\"ExtraSamples\",266:\"FillOrder\",289:\"FreeByteCounts\",288:\"FreeOffsets\",291:\"GrayResponseCurve\",290:\"GrayResponseUnit\",316:\"HostComputer\",270:\"ImageDescription\",257:\"ImageLength\",256:\"ImageWidth\",271:\"Make\",281:\"MaxSampleValue\",280:\"MinSampleValue\",272:\"Model\",254:\"NewSubfileType\",274:\"Orientation\",262:\"PhotometricInterpretation\",284:\"PlanarConfiguration\",296:\"ResolutionUnit\",278:\"RowsPerStrip\",277:\"SamplesPerPixel\",305:\"Software\",279:\"StripByteCounts\",273:\"StripOffsets\",255:\"SubfileType\",263:\"Threshholding\",282:\"XResolution\",283:\"YResolution\",326:\"BadFaxLines\",327:\"CleanFaxData\",343:\"ClipPath\",328:\"ConsecutiveBadFaxLines\",433:\"Decode\",434:\"DefaultImageColor\",269:\"DocumentName\",336:\"DotRange\",321:\"HalftoneHints\",346:\"Indexed\",347:\"JPEGTables\",285:\"PageName\",297:\"PageNumber\",317:\"Predictor\",319:\"PrimaryChromaticities\",532:\"ReferenceBlackWhite\",339:\"SampleFormat\",340:\"SMinSampleValue\",341:\"SMaxSampleValue\",559:\"StripRowCounts\",330:\"SubIFDs\",292:\"T4Options\",293:\"T6Options\",325:\"TileByteCounts\",323:\"TileLength\",324:\"TileOffsets\",322:\"TileWidth\",301:\"TransferFunction\",318:\"WhitePoint\",344:\"XClipPathUnits\",286:\"XPosition\",529:\"YCbCrCoefficients\",531:\"YCbCrPositioning\",530:\"YCbCrSubSampling\",345:\"YClipPathUnits\",287:\"YPosition\",37378:\"ApertureValue\",40961:\"ColorSpace\",36868:\"DateTimeDigitized\",36867:\"DateTimeOriginal\",34665:\"Exif IFD\",36864:\"ExifVersion\",33434:\"ExposureTime\",41728:\"FileSource\",37385:\"Flash\",40960:\"FlashpixVersion\",33437:\"FNumber\",42016:\"ImageUniqueID\",37384:\"LightSource\",37500:\"MakerNote\",37377:\"ShutterSpeedValue\",37510:\"UserComment\",33723:\"IPTC\",34675:\"ICC Profile\",700:\"XMP\",42112:\"GDAL_METADATA\",42113:\"GDAL_NODATA\",34377:\"Photoshop\",33550:\"ModelPixelScale\",33922:\"ModelTiepoint\",34264:\"ModelTransformation\",34735:\"GeoKeyDirectory\",34736:\"GeoDoubleParams\",34737:\"GeoAsciiParams\",50674:\"LercParameters\"},fieldTags={};for(var key in fieldTagNames)fieldTagNames.hasOwnProperty(key)&&(fieldTags[fieldTagNames[key]]=parseInt(key,10));fieldTags.BitsPerSample,fieldTags.ExtraSamples,fieldTags.SampleFormat,fieldTags.StripByteCounts,fieldTags.StripOffsets,fieldTags.StripRowCounts,fieldTags.TileByteCounts,fieldTags.TileOffsets,fieldTags.SubIFDs;var fieldTypeNames={1:\"BYTE\",2:\"ASCII\",3:\"SHORT\",4:\"LONG\",5:\"RATIONAL\",6:\"SBYTE\",7:\"UNDEFINED\",8:\"SSHORT\",9:\"SLONG\",10:\"SRATIONAL\",11:\"FLOAT\",12:\"DOUBLE\",13:\"IFD\",16:\"LONG8\",17:\"SLONG8\",18:\"IFD8\"},fieldTypes={};for(var _key in fieldTypeNames)fieldTypeNames.hasOwnProperty(_key)&&(fieldTypes[fieldTypeNames[_key]]=parseInt(_key,10));var LercParameters={Version:0,AddCompression:1},LercAddCompression={None:0,Deflate:1},geoKeyNames={1024:\"GTModelTypeGeoKey\",1025:\"GTRasterTypeGeoKey\",1026:\"GTCitationGeoKey\",2048:\"GeographicTypeGeoKey\",2049:\"GeogCitationGeoKey\",2050:\"GeogGeodeticDatumGeoKey\",2051:\"GeogPrimeMeridianGeoKey\",2052:\"GeogLinearUnitsGeoKey\",2053:\"GeogLinearUnitSizeGeoKey\",2054:\"GeogAngularUnitsGeoKey\",2055:\"GeogAngularUnitSizeGeoKey\",2056:\"GeogEllipsoidGeoKey\",2057:\"GeogSemiMajorAxisGeoKey\",2058:\"GeogSemiMinorAxisGeoKey\",2059:\"GeogInvFlatteningGeoKey\",2060:\"GeogAzimuthUnitsGeoKey\",2061:\"GeogPrimeMeridianLongGeoKey\",2062:\"GeogTOWGS84GeoKey\",3072:\"ProjectedCSTypeGeoKey\",3073:\"PCSCitationGeoKey\",3074:\"ProjectionGeoKey\",3075:\"ProjCoordTransGeoKey\",3076:\"ProjLinearUnitsGeoKey\",3077:\"ProjLinearUnitSizeGeoKey\",3078:\"ProjStdParallel1GeoKey\",3079:\"ProjStdParallel2GeoKey\",3080:\"ProjNatOriginLongGeoKey\",3081:\"ProjNatOriginLatGeoKey\",3082:\"ProjFalseEastingGeoKey\",3083:\"ProjFalseNorthingGeoKey\",3084:\"ProjFalseOriginLongGeoKey\",3085:\"ProjFalseOriginLatGeoKey\",3086:\"ProjFalseOriginEastingGeoKey\",3087:\"ProjFalseOriginNorthingGeoKey\",3088:\"ProjCenterLongGeoKey\",3089:\"ProjCenterLatGeoKey\",3090:\"ProjCenterEastingGeoKey\",3091:\"ProjCenterNorthingGeoKey\",3092:\"ProjScaleAtNatOriginGeoKey\",3093:\"ProjScaleAtCenterGeoKey\",3094:\"ProjAzimuthAngleGeoKey\",3095:\"ProjStraightVertPoleLongGeoKey\",3096:\"ProjRectifiedGridAngleGeoKey\",4096:\"VerticalCSTypeGeoKey\",4097:\"VerticalCitationGeoKey\",4098:\"VerticalDatumGeoKey\",4099:\"VerticalUnitsGeoKey\"},geoKeys={};for(var _key2 in geoKeyNames)geoKeyNames.hasOwnProperty(_key2)&&(geoKeys[geoKeyNames[_key2]]=parseInt(_key2,10));var LercDecoder=function(e){_inherits(r,BaseDecoder);var t=_createSuper(r);function r(e){var n;return _classCallCheck(this,r),(n=t.call(this)).planarConfiguration=void 0!==e.PlanarConfiguration?e.PlanarConfiguration:1,n.samplesPerPixel=void 0!==e.SamplesPerPixel?e.SamplesPerPixel:1,n.addCompression=e.LercParameters[LercParameters.AddCompression],n}return _createClass(r,[{key:\"decodeBlock\",value:function(e){switch(this.addCompression){case LercAddCompression.None:break;case LercAddCompression.Deflate:e=inflate_1(new Uint8Array(e)).buffer;break;default:throw new Error(\"Unsupported LERC additional compression method identifier: \".concat(this.addCompression))}return Lerc.decode(e,{returnPixelInterleavedDims:1===this.planarConfiguration}).pixels[0].buffer}}]),r}(),lerc=Object.freeze({__proto__:null,default:LercDecoder});";
var blob = new Blob([
    source
], {
    type: 'application/javascript'
});
var url = URL.createObjectURL(blob);
function create() {
    return new Worker(url);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"76DwP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/Map
 */ var _compositeJs = require("./renderer/Composite.js");
var _compositeJsDefault = parcelHelpers.interopDefault(_compositeJs);
var _pluggableMapJs = require("./PluggableMap.js");
var _pluggableMapJsDefault = parcelHelpers.interopDefault(_pluggableMapJs);
var _objJs = require("./obj.js");
var _controlJs = require("./control.js");
var _interactionJs = require("./interaction.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'ol/Map';
 *     import View from 'ol/View';
 *     import TileLayer from 'ol/layer/Tile';
 *     import OSM from 'ol/source/OSM';
 *
 *     var map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM()
 *         })
 *       ],
 *       target: 'map'
 *     });
 *
 * The above snippet creates a map using a {@link module:ol/layer/Tile} to
 * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:ol/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:ol/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~Group}
 * is a subclass of {@link module:ol/layer/Base}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @api
 */ var Map1 = function(_super) {
    __extends(Map2, _super);
    /**
     * @param {import("./PluggableMap.js").MapOptions} options Map options.
     */ function Map2(options) {
        var _this = this;
        options = _objJs.assign({
        }, options);
        if (!options.controls) options.controls = _controlJs.defaults();
        if (!options.interactions) options.interactions = _interactionJs.defaults({
            onFocusOnly: true
        });
        _this = _super.call(this, options) || this;
        return _this;
    }
    Map2.prototype.createRenderer = function() {
        return new _compositeJsDefault.default(this);
    };
    return Map2;
}(_pluggableMapJsDefault.default);
exports.default = Map1;

},{"./renderer/Composite.js":"fXChd","./PluggableMap.js":"8N6xR","./obj.js":"g3fPg","./control.js":"liICj","./interaction.js":"kbOE7","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"fXChd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/renderer/Composite
 */ var _mapJs = require("./Map.js");
var _mapJsDefault = parcelHelpers.interopDefault(_mapJs);
var _objectEventTypeJs = require("../ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _eventJs = require("../render/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../render/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _stateJs = require("../source/State.js");
var _stateJsDefault = parcelHelpers.interopDefault(_stateJs);
var _cssJs = require("../css.js");
var _canvasJs = require("../render/canvas.js");
var _layerJs = require("../layer/Layer.js");
var _eventsJs = require("../events.js");
var _domJs = require("../dom.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */ var CompositeMapRenderer1 = function(_super) {
    __extends(CompositeMapRenderer2, _super);
    /**
     * @param {import("../PluggableMap.js").default} map Map.
     */ function CompositeMapRenderer2(map) {
        var _this = _super.call(this, map) || this;
        /**
         * @type {import("../events.js").EventsKey}
         */ _this.fontChangeListenerKey_ = _eventsJs.listen(_canvasJs.checkedFonts, _objectEventTypeJsDefault.default.PROPERTYCHANGE, map.redrawText.bind(map));
        /**
         * @private
         * @type {HTMLDivElement}
         */ _this.element_ = document.createElement('div');
        var style = _this.element_.style;
        style.position = 'absolute';
        style.width = '100%';
        style.height = '100%';
        style.zIndex = '0';
        _this.element_.className = _cssJs.CLASS_UNSELECTABLE + ' ol-layers';
        var container = map.getViewport();
        container.insertBefore(_this.element_, container.firstChild || null);
        /**
         * @private
         * @type {Array<HTMLElement>}
         */ _this.children_ = [];
        /**
         * @private
         * @type {boolean}
         */ _this.renderedVisible_ = true;
        return _this;
    }
    /**
     * @param {import("../render/EventType.js").default} type Event type.
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     */ CompositeMapRenderer2.prototype.dispatchRenderEvent = function(type, frameState) {
        var map = this.getMap();
        if (map.hasListener(type)) {
            var event_1 = new _eventJsDefault.default(type, undefined, frameState);
            map.dispatchEvent(event_1);
        }
    };
    CompositeMapRenderer2.prototype.disposeInternal = function() {
        _eventsJs.unlistenByKey(this.fontChangeListenerKey_);
        this.element_.parentNode.removeChild(this.element_);
        _super.prototype.disposeInternal.call(this);
    };
    /**
     * Render.
     * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
     */ CompositeMapRenderer2.prototype.renderFrame = function(frameState) {
        if (!frameState) {
            if (this.renderedVisible_) {
                this.element_.style.display = 'none';
                this.renderedVisible_ = false;
            }
            return;
        }
        this.calculateMatrices2D(frameState);
        this.dispatchRenderEvent(_eventTypeJsDefault.default.PRECOMPOSE, frameState);
        var layerStatesArray = frameState.layerStatesArray.sort(function(a, b) {
            return a.zIndex - b.zIndex;
        });
        var viewState = frameState.viewState;
        this.children_.length = 0;
        /**
         * @type {Array<import("../layer/BaseVector.js").default>}
         */ var declutterLayers = [];
        var previousElement = null;
        for(var i = 0, ii = layerStatesArray.length; i < ii; ++i){
            var layerState = layerStatesArray[i];
            frameState.layerIndex = i;
            if (!_layerJs.inView(layerState, viewState) || layerState.sourceState != _stateJsDefault.default.READY && layerState.sourceState != _stateJsDefault.default.UNDEFINED) continue;
            var layer = layerState.layer;
            var element = layer.render(frameState, previousElement);
            if (!element) continue;
            if (element !== previousElement) {
                this.children_.push(element);
                previousElement = element;
            }
            if ('getDeclutter' in layer) declutterLayers.push(layer);
        }
        for(var i = declutterLayers.length - 1; i >= 0; --i)declutterLayers[i].renderDeclutter(frameState);
        _domJs.replaceChildren(this.element_, this.children_);
        this.dispatchRenderEvent(_eventTypeJsDefault.default.POSTCOMPOSE, frameState);
        if (!this.renderedVisible_) {
            this.element_.style.display = '';
            this.renderedVisible_ = true;
        }
        this.scheduleExpireIconCache(frameState);
    };
    /**
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {function(import("../layer/Layer.js").default<import("../source/Source").default>, (Uint8ClampedArray|Uint8Array)): T} callback Layer
     *     callback.
     * @param {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @return {T|undefined} Callback result.
     * @template T
     */ CompositeMapRenderer2.prototype.forEachLayerAtPixel = function(pixel, frameState, hitTolerance, callback, layerFilter) {
        var viewState = frameState.viewState;
        var layerStates = frameState.layerStatesArray;
        var numLayers = layerStates.length;
        for(var i = numLayers - 1; i >= 0; --i){
            var layerState = layerStates[i];
            var layer = layerState.layer;
            if (layer.hasRenderer() && _layerJs.inView(layerState, viewState) && layerFilter(layer)) {
                var layerRenderer = layer.getRenderer();
                var data = layerRenderer.getDataAtPixel(pixel, frameState, hitTolerance);
                if (data) {
                    var result = callback(layer, data);
                    if (result) return result;
                }
            }
        }
        return undefined;
    };
    return CompositeMapRenderer2;
}(_mapJsDefault.default);
exports.default = CompositeMapRenderer1;

},{"./Map.js":"hBbei","../ObjectEventType.js":"j6hH6","../render/Event.js":"1IrqP","../render/EventType.js":"6WjvK","../source/State.js":"hpoq1","../css.js":"23c5q","../render/canvas.js":"hMw4S","../layer/Layer.js":"4vI3D","../events.js":"e9Qqr","../dom.js":"akJqt","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hBbei":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/renderer/Map
 */ var _disposableJs = require("../Disposable.js");
var _disposableJsDefault = parcelHelpers.interopDefault(_disposableJs);
var _functionsJs = require("../functions.js");
var _utilJs = require("../util.js");
var _transformJs = require("../transform.js");
var _extentJs = require("../extent.js");
var _iconImageCacheJs = require("../style/IconImageCache.js");
var _layerJs = require("../layer/Layer.js");
var _coordinateJs = require("../coordinate.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef HitMatch
 * @property {import("../Feature.js").FeatureLike} feature Feature.
 * @property {import("../layer/Layer.js").default} layer Layer.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} distanceSq Squared distance.
 * @property {import("./vector.js").FeatureCallback<T>} callback Callback.
 * @template T
 */ /**
 * @abstract
 */ var MapRenderer1 = function(_super) {
    __extends(MapRenderer2, _super);
    /**
     * @param {import("../PluggableMap.js").default} map Map.
     */ function MapRenderer2(map) {
        var _this = _super.call(this) || this;
        /**
         * @private
         * @type {import("../PluggableMap.js").default}
         */ _this.map_ = map;
        return _this;
    }
    /**
     * @abstract
     * @param {import("../render/EventType.js").default} type Event type.
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     */ MapRenderer2.prototype.dispatchRenderEvent = function(type, frameState) {
        _utilJs.abstract();
    };
    /**
     * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
     * @protected
     */ MapRenderer2.prototype.calculateMatrices2D = function(frameState) {
        var viewState = frameState.viewState;
        var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
        var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
        _transformJs.compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
        _transformJs.makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
    };
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {S} thisArg Value to use as `this` when executing `callback`.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
     * @return {T|undefined} Callback result.
     * @template S,T,U
     */ MapRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
        var result;
        var viewState = frameState.viewState;
        /**
         * @param {boolean} managed Managed layer.
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @param {import("../geom/Geometry.js").default} geometry Geometry.
         * @return {T|undefined} Callback result.
         */ function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
            return callback.call(thisArg, feature, managed ? layer : null, geometry);
        }
        var projection = viewState.projection;
        var translatedCoordinate = _coordinateJs.wrapX(coordinate.slice(), projection);
        var offsets = [
            [
                0,
                0
            ]
        ];
        if (projection.canWrapX() && checkWrapped) {
            var projectionExtent = projection.getExtent();
            var worldWidth = _extentJs.getWidth(projectionExtent);
            offsets.push([
                -worldWidth,
                0
            ], [
                worldWidth,
                0
            ]);
        }
        var layerStates = frameState.layerStatesArray;
        var numLayers = layerStates.length;
        var matches = [];
        var tmpCoord = [];
        for(var i = 0; i < offsets.length; i++)for(var j = numLayers - 1; j >= 0; --j){
            var layerState = layerStates[j];
            var layer = layerState.layer;
            if (layer.hasRenderer() && _layerJs.inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
                var layerRenderer = layer.getRenderer();
                var source = layer.getSource();
                if (layerRenderer && source) {
                    var coordinates = source.getWrapX() ? translatedCoordinate : coordinate;
                    var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);
                    tmpCoord[0] = coordinates[0] + offsets[i][0];
                    tmpCoord[1] = coordinates[1] + offsets[i][1];
                    result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, matches);
                }
                if (result) return result;
            }
        }
        if (matches.length === 0) return undefined;
        var order = 1 / matches.length;
        matches.forEach(function(m, i1) {
            return m.distanceSq += i1 * order;
        });
        matches.sort(function(a, b) {
            return a.distanceSq - b.distanceSq;
        });
        matches.some(function(m) {
            return result = m.callback(m.feature, m.layer, m.geometry);
        });
        return result;
    };
    /**
     * @abstract
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {function(import("../layer/Layer.js").default<import("../source/Source").default>, (Uint8ClampedArray|Uint8Array)): T} callback Layer
     *     callback.
     * @param {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @return {T|undefined} Callback result.
     * @template T
     */ MapRenderer2.prototype.forEachLayerAtPixel = function(pixel, frameState, hitTolerance, callback, layerFilter) {
        return _utilJs.abstract();
    };
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
     * @return {boolean} Is there a feature at the given coordinate?
     * @template U
     */ MapRenderer2.prototype.hasFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
        var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, _functionsJs.TRUE, this, layerFilter, thisArg);
        return hasFeature !== undefined;
    };
    /**
     * @return {import("../PluggableMap.js").default} Map.
     */ MapRenderer2.prototype.getMap = function() {
        return this.map_;
    };
    /**
     * Render.
     * @abstract
     * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
     */ MapRenderer2.prototype.renderFrame = function(frameState) {
        _utilJs.abstract();
    };
    /**
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     * @protected
     */ MapRenderer2.prototype.scheduleExpireIconCache = function(frameState) {
        if (_iconImageCacheJs.shared.canExpireCache()) frameState.postRenderFunctions.push(expireIconCache);
    };
    return MapRenderer2;
}(_disposableJsDefault.default);
/**
 * @param {import("../PluggableMap.js").default} map Map.
 * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
 */ function expireIconCache(map, frameState) {
    _iconImageCacheJs.shared.expire();
}
exports.default = MapRenderer1;

},{"../Disposable.js":"b72Yc","../functions.js":"d72zA","../util.js":"9zOhk","../transform.js":"C21tg","../extent.js":"jgUz2","../style/IconImageCache.js":"iLULD","../layer/Layer.js":"4vI3D","../coordinate.js":"cmApa","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"C21tg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */ parcelHelpers.export(exports, "reset", ()=>reset
);
/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */ parcelHelpers.export(exports, "multiply", ()=>multiply
);
/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */ parcelHelpers.export(exports, "set", ()=>set
);
/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */ parcelHelpers.export(exports, "setFromArray", ()=>setFromArray
);
/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */ parcelHelpers.export(exports, "apply", ()=>apply
);
/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * Creates a scale transform.
 * @param {!Transform} target Transform to overwrite.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scale transform.
 */ parcelHelpers.export(exports, "makeScale", ()=>makeScale
);
/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */ parcelHelpers.export(exports, "translate", ()=>translate
);
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */ parcelHelpers.export(exports, "compose", ()=>compose
);
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative). The resulting transform
 * string can be applied as `transform` property of an HTMLElement's style.
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {string} The composite css transform.
 * @api
 */ parcelHelpers.export(exports, "composeCssTransform", ()=>composeCssTransform
);
/**
 * Invert the given transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (source) transform.
 */ parcelHelpers.export(exports, "invert", ()=>invert
);
/**
 * Invert the given transform.
 * @param {!Transform} target Transform to be set as the inverse of
 *     the source transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (target) transform.
 */ parcelHelpers.export(exports, "makeInverse", ()=>makeInverse
);
/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */ parcelHelpers.export(exports, "determinant", ()=>determinant
);
/**
 * A rounded string version of the transform.  This can be used
 * for CSS transforms.
 * @param {!Transform} mat Matrix.
 * @return {string} The transform as a string.
 */ parcelHelpers.export(exports, "toString", ()=>toString
);
/**
 * @module ol/transform
 */ var _hasJs = require("./has.js");
var _assertsJs = require("./asserts.js");
/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 * @api
 */ /**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3Ã—3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */ /**
 * @private
 * @type {Transform}
 */ var tmp_ = new Array(6);
function create() {
    return [
        1,
        0,
        0,
        1,
        0,
        0
    ];
}
function reset(transform) {
    return set(transform, 1, 0, 0, 1, 0, 0);
}
function multiply(transform1, transform2) {
    var a1 = transform1[0];
    var b1 = transform1[1];
    var c1 = transform1[2];
    var d1 = transform1[3];
    var e1 = transform1[4];
    var f1 = transform1[5];
    var a2 = transform2[0];
    var b2 = transform2[1];
    var c2 = transform2[2];
    var d2 = transform2[3];
    var e2 = transform2[4];
    var f2 = transform2[5];
    transform1[0] = a1 * a2 + c1 * b2;
    transform1[1] = b1 * a2 + d1 * b2;
    transform1[2] = a1 * c2 + c1 * d2;
    transform1[3] = b1 * c2 + d1 * d2;
    transform1[4] = a1 * e2 + c1 * f2 + e1;
    transform1[5] = b1 * e2 + d1 * f2 + f1;
    return transform1;
}
function set(transform, a, b, c, d, e, f) {
    transform[0] = a;
    transform[1] = b;
    transform[2] = c;
    transform[3] = d;
    transform[4] = e;
    transform[5] = f;
    return transform;
}
function setFromArray(transform1, transform2) {
    transform1[0] = transform2[0];
    transform1[1] = transform2[1];
    transform1[2] = transform2[2];
    transform1[3] = transform2[3];
    transform1[4] = transform2[4];
    transform1[5] = transform2[5];
    return transform1;
}
function apply(transform, coordinate) {
    var x = coordinate[0];
    var y = coordinate[1];
    coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
    coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
    return coordinate;
}
function rotate(transform, angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}
function scale(transform, x, y) {
    return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}
function makeScale(target, x, y) {
    return set(target, x, 0, 0, y, 0, 0);
}
function translate(transform, dx, dy) {
    return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
    var sin = Math.sin(angle);
    var cos = Math.cos(angle);
    transform[0] = sx * cos;
    transform[1] = sy * sin;
    transform[2] = -sx * sin;
    transform[3] = sy * cos;
    transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
    transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
    return transform;
}
function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
    return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}
function invert(source) {
    return makeInverse(source, source);
}
function makeInverse(target, source) {
    var det = determinant(source);
    _assertsJs.assert(det !== 0, 32); // Transformation matrix cannot be inverted
    var a = source[0];
    var b = source[1];
    var c = source[2];
    var d = source[3];
    var e = source[4];
    var f = source[5];
    target[0] = d / det;
    target[1] = -b / det;
    target[2] = -c / det;
    target[3] = a / det;
    target[4] = (c * f - d * e) / det;
    target[5] = -(a * f - b * e) / det;
    return target;
}
function determinant(mat) {
    return mat[0] * mat[3] - mat[1] * mat[2];
}
/**
 * @type {HTMLElement}
 * @private
 */ var transformStringDiv;
function toString(mat) {
    var transformString = 'matrix(' + mat.join(', ') + ')';
    if (_hasJs.WORKER_OFFSCREEN_CANVAS) return transformString;
    var node = transformStringDiv || (transformStringDiv = document.createElement('div'));
    node.style.transform = transformString;
    return node.style.transform;
}

},{"./has.js":"cdiSc","./asserts.js":"cnrP4","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cdiSc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FIREFOX", ()=>FIREFOX
);
parcelHelpers.export(exports, "SAFARI", ()=>SAFARI
);
parcelHelpers.export(exports, "WEBKIT", ()=>WEBKIT
);
parcelHelpers.export(exports, "MAC", ()=>MAC
);
parcelHelpers.export(exports, "DEVICE_PIXEL_RATIO", ()=>DEVICE_PIXEL_RATIO
);
parcelHelpers.export(exports, "WORKER_OFFSCREEN_CANVAS", ()=>WORKER_OFFSCREEN_CANVAS
);
parcelHelpers.export(exports, "IMAGE_DECODE", ()=>IMAGE_DECODE
);
parcelHelpers.export(exports, "PASSIVE_EVENT_LISTENERS", ()=>PASSIVE_EVENT_LISTENERS
);
/**
 * @module ol/has
 */ var ua = typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined' ? navigator.userAgent.toLowerCase() : '';
var FIREFOX = ua.indexOf('firefox') !== -1;
var SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;
var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;
var MAC = ua.indexOf('macintosh') !== -1;
var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;
var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' && typeof OffscreenCanvas !== 'undefined' && self instanceof WorkerGlobalScope; //eslint-disable-line
var IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;
var PASSIVE_EVENT_LISTENERS = function() {
    var passive = false;
    try {
        var options = Object.defineProperty({
        }, 'passive', {
            get: function() {
                passive = true;
            }
        });
        window.addEventListener('_', null, options);
        window.removeEventListener('_', null, options);
    } catch (error) {
    // passive not supported
    }
    return passive;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"iLULD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shared", ()=>shared
);
/**
 * @module ol/style/IconImageCache
 */ var _colorJs = require("../color.js");
/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.
 */ var IconImageCache = function() {
    function IconImageCache1() {
        /**
         * @type {!Object<string, import("./IconImage.js").default>}
         * @private
         */ this.cache_ = {
        };
        /**
         * @type {number}
         * @private
         */ this.cacheSize_ = 0;
        /**
         * @type {number}
         * @private
         */ this.maxCacheSize_ = 32;
    }
    /**
     * FIXME empty description for jsdoc
     */ IconImageCache1.prototype.clear = function() {
        this.cache_ = {
        };
        this.cacheSize_ = 0;
    };
    /**
     * @return {boolean} Can expire cache.
     */ IconImageCache1.prototype.canExpireCache = function() {
        return this.cacheSize_ > this.maxCacheSize_;
    };
    /**
     * FIXME empty description for jsdoc
     */ IconImageCache1.prototype.expire = function() {
        if (this.canExpireCache()) {
            var i = 0;
            for(var key in this.cache_){
                var iconImage = this.cache_[key];
                if (((i++) & 3) === 0 && !iconImage.hasListener()) {
                    delete this.cache_[key];
                    --this.cacheSize_;
                }
            }
        }
    };
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color} color Color.
     * @return {import("./IconImage.js").default} Icon image.
     */ IconImageCache1.prototype.get = function(src, crossOrigin, color) {
        var key = getKey(src, crossOrigin, color);
        return key in this.cache_ ? this.cache_[key] : null;
    };
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color} color Color.
     * @param {import("./IconImage.js").default} iconImage Icon image.
     */ IconImageCache1.prototype.set = function(src, crossOrigin, color, iconImage) {
        var key = getKey(src, crossOrigin, color);
        this.cache_[key] = iconImage;
        ++this.cacheSize_;
    };
    /**
     * Set the cache size of the icon cache. Default is `32`. Change this value when
     * your map uses more than 32 different icon images and you are not caching icon
     * styles on the application level.
     * @param {number} maxCacheSize Cache max size.
     * @api
     */ IconImageCache1.prototype.setSize = function(maxCacheSize) {
        this.maxCacheSize_ = maxCacheSize;
        this.expire();
    };
    return IconImageCache1;
}();
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../color.js").Color} color Color.
 * @return {string} Cache key.
 */ function getKey(src, crossOrigin, color) {
    var colorString = color ? _colorJs.asString(color) : 'null';
    return crossOrigin + ':' + src + ':' + colorString;
}
exports.default = IconImageCache;
var shared = new IconImageCache();

},{"../color.js":"liKgX","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"liKgX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */ parcelHelpers.export(exports, "asString", ()=>asString
);
parcelHelpers.export(exports, "fromString", ()=>fromString
);
/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */ parcelHelpers.export(exports, "asArray", ()=>asArray
);
/**
 * TODO this function is only used in the test, we probably shouldn't export it
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */ parcelHelpers.export(exports, "normalize", ()=>normalize
);
/**
 * @param {Color} color Color.
 * @return {string} String.
 */ parcelHelpers.export(exports, "toString", ()=>toString
);
/**
 * @param {string} s String.
 * @return {boolean} Whether the string is actually a valid color
 */ parcelHelpers.export(exports, "isStringColor", ()=>isStringColor
);
/**
 * @module ol/color
 */ var _assertsJs = require("./asserts.js");
var _mathJs = require("./math.js");
/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */ /**
 * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */ var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */ var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
function asString(color) {
    if (typeof color === 'string') return color;
    else return toString(color);
}
/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */ function fromNamed(color) {
    var el = document.createElement('div');
    el.style.color = color;
    if (el.style.color !== '') {
        document.body.appendChild(el);
        var rgb = getComputedStyle(el).color;
        document.body.removeChild(el);
        return rgb;
    } else return '';
}
var fromString = function() {
    // We maintain a small cache of parsed strings.  To provide cheap LRU-like
    // semantics, whenever the cache grows too large we simply delete an
    // arbitrary 25% of the entries.
    /**
     * @const
     * @type {number}
     */ var MAX_CACHE_SIZE = 1024;
    /**
     * @type {Object<string, Color>}
     */ var cache = {
    };
    /**
     * @type {number}
     */ var cacheSize = 0;
    return(/**
     * @param {string} s String.
     * @return {Color} Color.
     */ function(s) {
        var color;
        if (cache.hasOwnProperty(s)) color = cache[s];
        else {
            if (cacheSize >= MAX_CACHE_SIZE) {
                var i = 0;
                for(var key in cache)if (((i++) & 3) === 0) {
                    delete cache[key];
                    --cacheSize;
                }
            }
            color = fromStringInternal_(s);
            cache[s] = color;
            ++cacheSize;
        }
        return color;
    });
}();
function asArray(color) {
    if (Array.isArray(color)) return color;
    else return fromString(color);
}
/**
 * @param {string} s String.
 * @private
 * @return {Color} Color.
 */ function fromStringInternal_(s) {
    var r, g, b, a, color;
    if (NAMED_COLOR_RE_.exec(s)) s = fromNamed(s);
    if (HEX_COLOR_RE_.exec(s)) {
        // hex
        var n = s.length - 1; // number of hex digits
        var d = void 0; // number of digits per channel
        if (n <= 4) d = 1;
        else d = 2;
        var hasAlpha = n === 4 || n === 8;
        r = parseInt(s.substr(1 + 0 * d, d), 16);
        g = parseInt(s.substr(1 + 1 * d, d), 16);
        b = parseInt(s.substr(1 + 2 * d, d), 16);
        if (hasAlpha) a = parseInt(s.substr(1 + 3 * d, d), 16);
        else a = 255;
        if (d == 1) {
            r = (r << 4) + r;
            g = (g << 4) + g;
            b = (b << 4) + b;
            if (hasAlpha) a = (a << 4) + a;
        }
        color = [
            r,
            g,
            b,
            a / 255
        ];
    } else if (s.indexOf('rgba(') == 0) {
        // rgba()
        color = s.slice(5, -1).split(',').map(Number);
        normalize(color);
    } else if (s.indexOf('rgb(') == 0) {
        // rgb()
        color = s.slice(4, -1).split(',').map(Number);
        color.push(1);
        normalize(color);
    } else _assertsJs.assert(false, 14); // Invalid color
    return color;
}
function normalize(color) {
    color[0] = _mathJs.clamp(color[0] + 0.5 | 0, 0, 255);
    color[1] = _mathJs.clamp(color[1] + 0.5 | 0, 0, 255);
    color[2] = _mathJs.clamp(color[2] + 0.5 | 0, 0, 255);
    color[3] = _mathJs.clamp(color[3], 0, 1);
    return color;
}
function toString(color) {
    var r = color[0];
    if (r != (r | 0)) r = r + 0.5 | 0;
    var g = color[1];
    if (g != (g | 0)) g = g + 0.5 | 0;
    var b = color[2];
    if (b != (b | 0)) b = b + 0.5 | 0;
    var a = color[3] === undefined ? 1 : color[3];
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}
function isStringColor(s) {
    if (NAMED_COLOR_RE_.test(s)) s = fromNamed(s);
    return HEX_COLOR_RE_.test(s) || s.indexOf('rgba(') === 0 || s.indexOf('rgb(') === 0;
}

},{"./asserts.js":"cnrP4","./math.js":"kI4rE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"4vI3D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Return `true` if the layer is visible and if the provided view state
 * has resolution and zoom levels that are in range of the layer's min/max.
 * @param {State} layerState Layer state.
 * @param {import("../View.js").State} viewState View state.
 * @return {boolean} The layer is visible at the given view state.
 */ parcelHelpers.export(exports, "inView", ()=>inView
);
/**
 * @module ol/layer/Layer
 */ var _baseJs = require("./Base.js");
var _baseJsDefault = parcelHelpers.interopDefault(_baseJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _eventTypeJs1 = require("../render/EventType.js");
var _eventTypeJsDefault1 = parcelHelpers.interopDefault(_eventTypeJs1);
var _stateJs = require("../source/State.js");
var _stateJsDefault = parcelHelpers.interopDefault(_stateJs);
var _assertsJs = require("../asserts.js");
var _objJs = require("../obj.js");
var _eventsJs = require("../events.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {function(import("../PluggableMap.js").FrameState):HTMLElement} RenderFunction
 */ /***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:source', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:source'|
 *     import("../render/EventType").LayerRenderEventTypes, Return>} LayerOnSignature
 */ /**
 * @template {import("../source/Source.js").default} SourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../PluggableMap.js").default} [map] Map.
 * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
 * HTML element. Will overwrite the default rendering for the layer.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @typedef {Object} State
 * @property {import("./Layer.js").default} layer Layer.
 * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
 * @property {import("../source/State.js").default} sourceState SourceState.
 * @property {boolean} visible Visible.
 * @property {boolean} managed Managed.
 * @property {import("../extent.js").Extent} [extent] Extent.
 * @property {number} zIndex ZIndex.
 * @property {number} maxResolution Maximum resolution.
 * @property {number} minResolution Minimum resolution.
 * @property {number} minZoom Minimum zoom.
 * @property {number} maxZoom Maximum zoom.
 */ /**
 * @classdesc
 * Base class from which all layer types are derived. This should only be instantiated
 * in the case where a custom layer is be added to the map with a custom `render` function.
 * Such a function can be specified in the `options` object, and is expected to return an HTML element.
 *
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with {@link import("../PluggableMap.js").default#addLayer map.addLayer()}. Components
 * like {@link module:ol/interaction/Draw~Draw} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * {@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * Please note that for performance reasons several layers might get rendered to
 * the same HTML element, which will cause {@link import("../PluggableMap.js").default#forEachLayerAtPixel map.forEachLayerAtPixel()} to
 * give false positives. To avoid this, apply different `className` properties to the
 * layers at creation time.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 *
 * @template {import("../source/Source.js").default} SourceType
 * @api
 */ var Layer1 = function(_super) {
    __extends(Layer2, _super);
    /**
     * @param {Options<SourceType>} options Layer options.
     */ function Layer2(options) {
        var _this = this;
        var baseOptions = _objJs.assign({
        }, options);
        delete baseOptions.source;
        _this = _super.call(this, baseOptions) || this;
        /***
         * @type {LayerOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {LayerOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {LayerOnSignature<void>}
         */ _this.un;
        /**
         * @private
         * @type {?import("../events.js").EventsKey}
         */ _this.mapPrecomposeKey_ = null;
        /**
         * @private
         * @type {?import("../events.js").EventsKey}
         */ _this.mapRenderKey_ = null;
        /**
         * @private
         * @type {?import("../events.js").EventsKey}
         */ _this.sourceChangeKey_ = null;
        /**
         * @private
         * @type {import("../renderer/Layer.js").default}
         */ _this.renderer_ = null;
        // Overwrite default render method with a custom one
        if (options.render) _this.render = options.render;
        if (options.map) _this.setMap(options.map);
        _this.addChangeListener(_propertyJsDefault.default.SOURCE, _this.handleSourcePropertyChange_);
        var source = options.source ? options.source : null;
        _this.setSource(source);
        return _this;
    }
    /**
     * @param {Array<import("./Layer.js").default>} [opt_array] Array of layers (to be modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */ Layer2.prototype.getLayersArray = function(opt_array) {
        var array = opt_array ? opt_array : [];
        array.push(this);
        return array;
    };
    /**
     * @param {Array<import("./Layer.js").State>} [opt_states] Optional list of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */ Layer2.prototype.getLayerStatesArray = function(opt_states) {
        var states = opt_states ? opt_states : [];
        states.push(this.getLayerState());
        return states;
    };
    /**
     * Get the layer source.
     * @return {SourceType} The layer source (or `null` if not yet set).
     * @observable
     * @api
     */ Layer2.prototype.getSource = function() {
        return(/** @type {SourceType} */ this.get(_propertyJsDefault.default.SOURCE) || null);
    };
    /**
     * @return {import("../source/State.js").default} Source state.
     */ Layer2.prototype.getSourceState = function() {
        var source = this.getSource();
        return !source ? _stateJsDefault.default.UNDEFINED : source.getState();
    };
    /**
     * @private
     */ Layer2.prototype.handleSourceChange_ = function() {
        this.changed();
    };
    /**
     * @private
     */ Layer2.prototype.handleSourcePropertyChange_ = function() {
        if (this.sourceChangeKey_) {
            _eventsJs.unlistenByKey(this.sourceChangeKey_);
            this.sourceChangeKey_ = null;
        }
        var source = this.getSource();
        if (source) this.sourceChangeKey_ = _eventsJs.listen(source, _eventTypeJsDefault.default.CHANGE, this.handleSourceChange_, this);
        this.changed();
    };
    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
     * an array of features.
     */ Layer2.prototype.getFeatures = function(pixel) {
        if (!this.renderer_) return new Promise(function(resolve) {
            return resolve([]);
        });
        return this.renderer_.getFeatures(pixel);
    };
    /**
     * In charge to manage the rendering of the layer. One layer type is
     * bounded with one layer renderer.
     * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target which the renderer may (but need not) use
     * for rendering its content.
     * @return {HTMLElement} The rendered element.
     */ Layer2.prototype.render = function(frameState, target) {
        var layerRenderer = this.getRenderer();
        if (layerRenderer.prepareFrame(frameState)) return layerRenderer.renderFrame(frameState, target);
    };
    /**
     * Sets the layer to be rendered on top of other layers on a map. The map will
     * not manage this layer in its layers collection, and the callback in
     * {@link module:ol/Map~Map#forEachLayerAtPixel} will receive `null` as layer. This
     * is useful for temporary layers. To remove an unmanaged layer from the map,
     * use `#setMap(null)`.
     *
     * To add the layer to a map and have it managed by the map, use
     * {@link module:ol/Map~Map#addLayer} instead.
     * @param {import("../PluggableMap.js").default} map Map.
     * @api
     */ Layer2.prototype.setMap = function(map) {
        if (this.mapPrecomposeKey_) {
            _eventsJs.unlistenByKey(this.mapPrecomposeKey_);
            this.mapPrecomposeKey_ = null;
        }
        if (!map) this.changed();
        if (this.mapRenderKey_) {
            _eventsJs.unlistenByKey(this.mapRenderKey_);
            this.mapRenderKey_ = null;
        }
        if (map) {
            this.mapPrecomposeKey_ = _eventsJs.listen(map, _eventTypeJsDefault1.default.PRECOMPOSE, function(evt) {
                var renderEvent = evt;
                var layerStatesArray = renderEvent.frameState.layerStatesArray;
                var layerState = this.getLayerState(false);
                // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.
                _assertsJs.assert(!layerStatesArray.some(function(arrayLayerState) {
                    return arrayLayerState.layer === layerState.layer;
                }), 67);
                layerStatesArray.push(layerState);
            }, this);
            this.mapRenderKey_ = _eventsJs.listen(this, _eventTypeJsDefault.default.CHANGE, map.render, map);
            this.changed();
        }
    };
    /**
     * Set the layer source.
     * @param {SourceType} source The layer source.
     * @observable
     * @api
     */ Layer2.prototype.setSource = function(source) {
        this.set(_propertyJsDefault.default.SOURCE, source);
    };
    /**
     * Get the renderer for this layer.
     * @return {import("../renderer/Layer.js").default} The layer renderer.
     */ Layer2.prototype.getRenderer = function() {
        if (!this.renderer_) this.renderer_ = this.createRenderer();
        return this.renderer_;
    };
    /**
     * @return {boolean} The layer has a renderer.
     */ Layer2.prototype.hasRenderer = function() {
        return !!this.renderer_;
    };
    /**
     * Create a renderer for this layer.
     * @return {import("../renderer/Layer.js").default} A layer renderer.
     * @protected
     */ Layer2.prototype.createRenderer = function() {
        return null;
    };
    /**
     * Clean up.
     */ Layer2.prototype.disposeInternal = function() {
        if (this.renderer_) {
            this.renderer_.dispose();
            delete this.renderer_;
        }
        this.setSource(null);
        _super.prototype.disposeInternal.call(this);
    };
    return Layer2;
}(_baseJsDefault.default);
function inView(layerState, viewState) {
    if (!layerState.visible) return false;
    var resolution = viewState.resolution;
    if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) return false;
    var zoom = viewState.zoom;
    return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
exports.default = Layer1;

},{"./Base.js":"fS38x","../events/EventType.js":"83vee","./Property.js":"aADT4","../render/EventType.js":"6WjvK","../source/State.js":"hpoq1","../asserts.js":"cnrP4","../obj.js":"g3fPg","../events.js":"e9Qqr","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"fS38x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/layer/Base
 */ var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _utilJs = require("../util.js");
var _assertsJs = require("../asserts.js");
var _objJs = require("../obj.js");
var _mathJs = require("../math.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {import("../ObjectEventType").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|
 *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<BaseLayerObjectEventTypes, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */ var BaseLayer1 = function(_super) {
    __extends(BaseLayer2, _super);
    /**
     * @param {Options} options Layer options.
     */ function BaseLayer2(options) {
        var _this = _super.call(this) || this;
        /***
         * @type {BaseLayerOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {BaseLayerOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {BaseLayerOnSignature<void>}
         */ _this.un;
        /**
         * @type {Object<string, *>}
         */ var properties = _objJs.assign({
        }, options);
        if (typeof options.properties === 'object') {
            delete properties.properties;
            _objJs.assign(properties, options.properties);
        }
        properties[_propertyJsDefault.default.OPACITY] = options.opacity !== undefined ? options.opacity : 1;
        _assertsJs.assert(typeof properties[_propertyJsDefault.default.OPACITY] === 'number', 64); // Layer opacity must be a number
        properties[_propertyJsDefault.default.VISIBLE] = options.visible !== undefined ? options.visible : true;
        properties[_propertyJsDefault.default.Z_INDEX] = options.zIndex;
        properties[_propertyJsDefault.default.MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
        properties[_propertyJsDefault.default.MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;
        properties[_propertyJsDefault.default.MIN_ZOOM] = options.minZoom !== undefined ? options.minZoom : -Infinity;
        properties[_propertyJsDefault.default.MAX_ZOOM] = options.maxZoom !== undefined ? options.maxZoom : Infinity;
        /**
         * @type {string}
         * @private
         */ _this.className_ = properties.className !== undefined ? options.className : 'ol-layer';
        delete properties.className;
        _this.setProperties(properties);
        /**
         * @type {import("./Layer.js").State}
         * @private
         */ _this.state_ = null;
        return _this;
    }
    /**
     * @return {string} CSS class name.
     */ BaseLayer2.prototype.getClassName = function() {
        return this.className_;
    };
    /**
     * This method is not meant to be called by layers or layer renderers because the state
     * is incorrect if the layer is included in a layer group.
     *
     * @param {boolean} [opt_managed] Layer is managed.
     * @return {import("./Layer.js").State} Layer state.
     */ BaseLayer2.prototype.getLayerState = function(opt_managed) {
        /** @type {import("./Layer.js").State} */ var state = this.state_ || {
            layer: this,
            managed: opt_managed === undefined ? true : opt_managed
        };
        var zIndex = this.getZIndex();
        state.opacity = _mathJs.clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
        state.sourceState = this.getSourceState();
        state.visible = this.getVisible();
        state.extent = this.getExtent();
        state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;
        state.maxResolution = this.getMaxResolution();
        state.minResolution = Math.max(this.getMinResolution(), 0);
        state.minZoom = this.getMinZoom();
        state.maxZoom = this.getMaxZoom();
        this.state_ = state;
        return state;
    };
    /**
     * @abstract
     * @param {Array<import("./Layer.js").default>} [opt_array] Array of layers (to be
     *     modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */ BaseLayer2.prototype.getLayersArray = function(opt_array) {
        return _utilJs.abstract();
    };
    /**
     * @abstract
     * @param {Array<import("./Layer.js").State>} [opt_states] Optional list of layer
     *     states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */ BaseLayer2.prototype.getLayerStatesArray = function(opt_states) {
        return _utilJs.abstract();
    };
    /**
     * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
     * will be visible regardless of extent.
     * @return {import("../extent.js").Extent|undefined} The layer extent.
     * @observable
     * @api
     */ BaseLayer2.prototype.getExtent = function() {
        return this.get(_propertyJsDefault.default.EXTENT);
    };
    /**
     * Return the maximum resolution of the layer.
     * @return {number} The maximum resolution of the layer.
     * @observable
     * @api
     */ BaseLayer2.prototype.getMaxResolution = function() {
        return this.get(_propertyJsDefault.default.MAX_RESOLUTION);
    };
    /**
     * Return the minimum resolution of the layer.
     * @return {number} The minimum resolution of the layer.
     * @observable
     * @api
     */ BaseLayer2.prototype.getMinResolution = function() {
        return this.get(_propertyJsDefault.default.MIN_RESOLUTION);
    };
    /**
     * Return the minimum zoom level of the layer.
     * @return {number} The minimum zoom level of the layer.
     * @observable
     * @api
     */ BaseLayer2.prototype.getMinZoom = function() {
        return this.get(_propertyJsDefault.default.MIN_ZOOM);
    };
    /**
     * Return the maximum zoom level of the layer.
     * @return {number} The maximum zoom level of the layer.
     * @observable
     * @api
     */ BaseLayer2.prototype.getMaxZoom = function() {
        return this.get(_propertyJsDefault.default.MAX_ZOOM);
    };
    /**
     * Return the opacity of the layer (between 0 and 1).
     * @return {number} The opacity of the layer.
     * @observable
     * @api
     */ BaseLayer2.prototype.getOpacity = function() {
        return this.get(_propertyJsDefault.default.OPACITY);
    };
    /**
     * @abstract
     * @return {import("../source/State.js").default} Source state.
     */ BaseLayer2.prototype.getSourceState = function() {
        return _utilJs.abstract();
    };
    /**
     * Return the visibility of the layer (`true` or `false`).
     * @return {boolean} The visibility of the layer.
     * @observable
     * @api
     */ BaseLayer2.prototype.getVisible = function() {
        return this.get(_propertyJsDefault.default.VISIBLE);
    };
    /**
     * Return the Z-index of the layer, which is used to order layers before
     * rendering. The default Z-index is 0.
     * @return {number} The Z-index of the layer.
     * @observable
     * @api
     */ BaseLayer2.prototype.getZIndex = function() {
        return this.get(_propertyJsDefault.default.Z_INDEX);
    };
    /**
     * Set the extent at which the layer is visible.  If `undefined`, the layer
     * will be visible at all extents.
     * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
     * @observable
     * @api
     */ BaseLayer2.prototype.setExtent = function(extent) {
        this.set(_propertyJsDefault.default.EXTENT, extent);
    };
    /**
     * Set the maximum resolution at which the layer is visible.
     * @param {number} maxResolution The maximum resolution of the layer.
     * @observable
     * @api
     */ BaseLayer2.prototype.setMaxResolution = function(maxResolution) {
        this.set(_propertyJsDefault.default.MAX_RESOLUTION, maxResolution);
    };
    /**
     * Set the minimum resolution at which the layer is visible.
     * @param {number} minResolution The minimum resolution of the layer.
     * @observable
     * @api
     */ BaseLayer2.prototype.setMinResolution = function(minResolution) {
        this.set(_propertyJsDefault.default.MIN_RESOLUTION, minResolution);
    };
    /**
     * Set the maximum zoom (exclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} maxZoom The maximum zoom of the layer.
     * @observable
     * @api
     */ BaseLayer2.prototype.setMaxZoom = function(maxZoom) {
        this.set(_propertyJsDefault.default.MAX_ZOOM, maxZoom);
    };
    /**
     * Set the minimum zoom (inclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} minZoom The minimum zoom of the layer.
     * @observable
     * @api
     */ BaseLayer2.prototype.setMinZoom = function(minZoom) {
        this.set(_propertyJsDefault.default.MIN_ZOOM, minZoom);
    };
    /**
     * Set the opacity of the layer, allowed values range from 0 to 1.
     * @param {number} opacity The opacity of the layer.
     * @observable
     * @api
     */ BaseLayer2.prototype.setOpacity = function(opacity) {
        _assertsJs.assert(typeof opacity === 'number', 64); // Layer opacity must be a number
        this.set(_propertyJsDefault.default.OPACITY, opacity);
    };
    /**
     * Set the visibility of the layer (`true` or `false`).
     * @param {boolean} visible The visibility of the layer.
     * @observable
     * @api
     */ BaseLayer2.prototype.setVisible = function(visible) {
        this.set(_propertyJsDefault.default.VISIBLE, visible);
    };
    /**
     * Set Z-index of the layer, which is used to order layers before rendering.
     * The default Z-index is 0.
     * @param {number} zindex The z-index of the layer.
     * @observable
     * @api
     */ BaseLayer2.prototype.setZIndex = function(zindex) {
        this.set(_propertyJsDefault.default.Z_INDEX, zindex);
    };
    /**
     * Clean up.
     */ BaseLayer2.prototype.disposeInternal = function() {
        if (this.state_) {
            this.state_.layer = null;
            this.state_ = null;
        }
        _super.prototype.disposeInternal.call(this);
    };
    return BaseLayer2;
}(_objectJsDefault.default);
exports.default = BaseLayer1;

},{"../Object.js":"3roCV","./Property.js":"aADT4","../util.js":"9zOhk","../asserts.js":"cnrP4","../obj.js":"g3fPg","../math.js":"kI4rE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aADT4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    OPACITY: 'opacity',
    VISIBLE: 'visible',
    EXTENT: 'extent',
    Z_INDEX: 'zIndex',
    MAX_RESOLUTION: 'maxResolution',
    MIN_RESOLUTION: 'minResolution',
    MAX_ZOOM: 'maxZoom',
    MIN_ZOOM: 'minZoom',
    SOURCE: 'source'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6WjvK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
     * Triggered before a layer is rendered.
     * @event module:ol/render/Event~RenderEvent#prerender
     * @api
     */ PRERENDER: 'prerender',
    /**
     * Triggered after a layer is rendered.
     * @event module:ol/render/Event~RenderEvent#postrender
     * @api
     */ POSTRENDER: 'postrender',
    /**
     * Triggered before layers are rendered.
     * The event object will not have a `context` set.
     * @event module:ol/render/Event~RenderEvent#precompose
     * @api
     */ PRECOMPOSE: 'precompose',
    /**
     * Triggered after all layers are rendered.
     * The event object will not have a `context` set.
     * @event module:ol/render/Event~RenderEvent#postcompose
     * @api
     */ POSTCOMPOSE: 'postcompose',
    /**
     * Triggered when rendering is complete, i.e. all sources and tiles have
     * finished loading for the current viewport, and all tiles are faded in.
     * The event object will not have a `context` set.
     * @event module:ol/render/Event~RenderEvent#rendercomplete
     * @api
     */ RENDERCOMPLETE: 'rendercomplete'
}; /**
 * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes
 */  /**
 * @typedef {'postrender'|'prerender'} LayerRenderEventTypes
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1IrqP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
/**
 * @module ol/render/Event
 */ var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var RenderEvent1 = function(_super) {
    __extends(RenderEvent2, _super);
    /**
     * @param {import("./EventType.js").default} type Type.
     * @param {import("../transform.js").Transform} [opt_inversePixelTransform] Transform for
     *     CSS pixels to rendered pixels.
     * @param {import("../PluggableMap.js").FrameState} [opt_frameState] Frame state.
     * @param {?CanvasRenderingContext2D} [opt_context] Context.
     */ function RenderEvent2(type, opt_inversePixelTransform, opt_frameState, opt_context) {
        var _this = _super.call(this, type) || this;
        /**
         * Transform from CSS pixels (relative to the top-left corner of the map viewport)
         * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.
         * @type {import("../transform.js").Transform|undefined}
         * @api
         */ _this.inversePixelTransform = opt_inversePixelTransform;
        /**
         * An object representing the current render frame state.
         * @type {import("../PluggableMap.js").FrameState|undefined}
         * @api
         */ _this.frameState = opt_frameState;
        /**
         * Canvas context. Not available when the event is dispatched by the map. Only available
         * when a Canvas renderer is used, null otherwise.
         * @type {CanvasRenderingContext2D|null|undefined}
         * @api
         */ _this.context = opt_context;
        return _this;
    }
    return RenderEvent2;
}(_eventJsDefault.default);
exports.default = RenderEvent1;

},{"../events/Event.js":"7AR9n","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"23c5q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CLASS_HIDDEN", ()=>CLASS_HIDDEN
);
parcelHelpers.export(exports, "CLASS_SELECTABLE", ()=>CLASS_SELECTABLE
);
parcelHelpers.export(exports, "CLASS_UNSELECTABLE", ()=>CLASS_UNSELECTABLE
);
parcelHelpers.export(exports, "CLASS_UNSUPPORTED", ()=>CLASS_UNSUPPORTED
);
parcelHelpers.export(exports, "CLASS_CONTROL", ()=>CLASS_CONTROL
);
parcelHelpers.export(exports, "CLASS_COLLAPSED", ()=>CLASS_COLLAPSED
);
parcelHelpers.export(exports, "getFontParameters", ()=>getFontParameters
);
/**
 * @param {number} opacity Opacity (0..1).
 * @return {string} CSS opacity.
 */ parcelHelpers.export(exports, "cssOpacity", ()=>cssOpacity
);
var CLASS_HIDDEN = 'ol-hidden';
var CLASS_SELECTABLE = 'ol-selectable';
var CLASS_UNSELECTABLE = 'ol-unselectable';
var CLASS_UNSUPPORTED = 'ol-unsupported';
var CLASS_CONTROL = 'ol-control';
var CLASS_COLLAPSED = 'ol-collapsed';
/**
 * From https://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
 * @type {RegExp}
 */ var fontRegEx = new RegExp([
    '^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)',
    '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)',
    '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)',
    '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?',
    '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))',
    '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))',
    '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$', 
].join(''), 'i');
var fontRegExMatchIndex = [
    'style',
    'variant',
    'weight',
    'size',
    'lineHeight',
    'family', 
];
var getFontParameters = function(fontSpec) {
    var match = fontSpec.match(fontRegEx);
    if (!match) return null;
    var style = {
        lineHeight: 'normal',
        size: '1.2em',
        style: 'normal',
        weight: 'normal',
        variant: 'normal'
    };
    for(var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i){
        var value = match[i + 1];
        if (value !== undefined) style[fontRegExMatchIndex[i]] = value;
    }
    style.families = style.family.split(/,\s?/);
    return style;
};
function cssOpacity(opacity) {
    return opacity === 1 ? '' : String(Math.round(opacity * 100) / 100);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hMw4S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultFont", ()=>defaultFont
);
parcelHelpers.export(exports, "defaultFillStyle", ()=>defaultFillStyle
);
parcelHelpers.export(exports, "defaultLineCap", ()=>defaultLineCap
);
parcelHelpers.export(exports, "defaultLineDash", ()=>defaultLineDash
);
parcelHelpers.export(exports, "defaultLineDashOffset", ()=>defaultLineDashOffset
);
parcelHelpers.export(exports, "defaultLineJoin", ()=>defaultLineJoin
);
parcelHelpers.export(exports, "defaultMiterLimit", ()=>defaultMiterLimit
);
parcelHelpers.export(exports, "defaultStrokeStyle", ()=>defaultStrokeStyle
);
parcelHelpers.export(exports, "defaultTextAlign", ()=>defaultTextAlign
);
parcelHelpers.export(exports, "defaultTextBaseline", ()=>defaultTextBaseline
);
parcelHelpers.export(exports, "defaultPadding", ()=>defaultPadding
);
parcelHelpers.export(exports, "defaultLineWidth", ()=>defaultLineWidth
);
parcelHelpers.export(exports, "checkedFonts", ()=>checkedFonts
);
parcelHelpers.export(exports, "labelCache", ()=>labelCache
);
parcelHelpers.export(exports, "textHeights", ()=>textHeights
);
parcelHelpers.export(exports, "registerFont", ()=>registerFont
);
parcelHelpers.export(exports, "measureTextHeight", ()=>measureTextHeight
);
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */ parcelHelpers.export(exports, "measureTextWidth", ()=>measureTextWidth
);
/**
 * Measure text width using a cache.
 * @param {string} font The font.
 * @param {string} text The text to measure.
 * @param {Object<string, number>} cache A lookup of cached widths by text.
 * @return {number} The text width.
 */ parcelHelpers.export(exports, "measureAndCacheTextWidth", ()=>measureAndCacheTextWidth
);
/**
 * @param {string} font Font to use for measuring.
 * @param {Array<string>} lines Lines to measure.
 * @param {Array<number>} widths Array will be populated with the widths of
 * each line.
 * @return {number} Width of the whole text.
 */ parcelHelpers.export(exports, "measureTextWidths", ()=>measureTextWidths
);
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */ parcelHelpers.export(exports, "rotateAtOffset", ()=>rotateAtOffset
);
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {import("../size.js").Size} scale Scale.
 */ parcelHelpers.export(exports, "drawImageOrLabel", ()=>drawImageOrLabel
);
/**
 * @module ol/render/canvas
 */ var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _targetJs = require("../events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _hasJs = require("../has.js");
var _objJs = require("../obj.js");
var _domJs = require("../dom.js");
var _cssJs = require("../css.js");
var defaultFont = '10px sans-serif';
var defaultFillStyle = '#000';
var defaultLineCap = 'round';
var defaultLineDash = [];
var defaultLineDashOffset = 0;
var defaultLineJoin = 'round';
var defaultMiterLimit = 10;
var defaultStrokeStyle = '#000';
var defaultTextAlign = 'center';
var defaultTextBaseline = 'middle';
var defaultPadding = [
    0,
    0,
    0,
    0
];
var defaultLineWidth = 1;
var checkedFonts = new _objectJsDefault.default();
var labelCache = new _targetJsDefault.default();
labelCache.setSize = function() {
    console.warn('labelCache is deprecated.'); //eslint-disable-line
};
/**
 * @type {CanvasRenderingContext2D}
 */ var measureContext = null;
/**
 * @type {string}
 */ var measureFont;
var textHeights = {
};
var registerFont = function() {
    var retries = 100;
    var size = '32px ';
    var referenceFonts = [
        'monospace',
        'serif'
    ];
    var len = referenceFonts.length;
    var text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
    var interval, referenceWidth;
    /**
     * @param {string} fontStyle Css font-style
     * @param {string} fontWeight Css font-weight
     * @param {*} fontFamily Css font-family
     * @return {boolean} Font with style and weight is available
     */ function isAvailable(fontStyle, fontWeight, fontFamily) {
        var available = true;
        for(var i = 0; i < len; ++i){
            var referenceFont = referenceFonts[i];
            referenceWidth = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + referenceFont, text);
            if (fontFamily != referenceFont) {
                var width = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + fontFamily + ',' + referenceFont, text);
                // If width and referenceWidth are the same, then the fallback was used
                // instead of the font we wanted, so the font is not available.
                available = available && width != referenceWidth;
            }
        }
        if (available) return true;
        return false;
    }
    function check() {
        var done = true;
        var fonts = checkedFonts.getKeys();
        for(var i = 0, ii = fonts.length; i < ii; ++i){
            var font = fonts[i];
            if (checkedFonts.get(font) < retries) {
                if (isAvailable.apply(this, font.split('\n'))) {
                    _objJs.clear(textHeights);
                    // Make sure that loaded fonts are picked up by Safari
                    measureContext = null;
                    measureFont = undefined;
                    checkedFonts.set(font, retries);
                } else {
                    checkedFonts.set(font, checkedFonts.get(font) + 1, true);
                    done = false;
                }
            }
        }
        if (done) {
            clearInterval(interval);
            interval = undefined;
        }
    }
    return function(fontSpec) {
        var font = _cssJs.getFontParameters(fontSpec);
        if (!font) return;
        var families = font.families;
        for(var i = 0, ii = families.length; i < ii; ++i){
            var family = families[i];
            var key = font.style + '\n' + font.weight + '\n' + family;
            if (checkedFonts.get(key) === undefined) {
                checkedFonts.set(key, retries, true);
                if (!isAvailable(font.style, font.weight, family)) {
                    checkedFonts.set(key, 0, true);
                    if (interval === undefined) interval = setInterval(check, 32);
                }
            }
        }
    };
}();
var measureTextHeight = function() {
    /**
     * @type {HTMLDivElement}
     */ var measureElement;
    return function(fontSpec) {
        var height = textHeights[fontSpec];
        if (height == undefined) {
            if (_hasJs.WORKER_OFFSCREEN_CANVAS) {
                var font = _cssJs.getFontParameters(fontSpec);
                var metrics = measureText(fontSpec, 'Å½g');
                var lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
                height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
            } else {
                if (!measureElement) {
                    measureElement = document.createElement('div');
                    measureElement.innerHTML = 'M';
                    measureElement.style.minHeight = '0';
                    measureElement.style.maxHeight = 'none';
                    measureElement.style.height = 'auto';
                    measureElement.style.padding = '0';
                    measureElement.style.border = 'none';
                    measureElement.style.position = 'absolute';
                    measureElement.style.display = 'block';
                    measureElement.style.left = '-99999px';
                }
                measureElement.style.font = fontSpec;
                document.body.appendChild(measureElement);
                height = measureElement.offsetHeight;
                document.body.removeChild(measureElement);
            }
            textHeights[fontSpec] = height;
        }
        return height;
    };
}();
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {TextMetrics} Text metrics.
 */ function measureText(font, text) {
    if (!measureContext) measureContext = _domJs.createCanvasContext2D(1, 1);
    if (font != measureFont) {
        measureContext.font = font;
        measureFont = measureContext.font;
    }
    return measureContext.measureText(text);
}
function measureTextWidth(font, text) {
    return measureText(font, text).width;
}
function measureAndCacheTextWidth(font, text, cache) {
    if (text in cache) return cache[text];
    var width = measureTextWidth(font, text);
    cache[text] = width;
    return width;
}
function measureTextWidths(font, lines, widths) {
    var numLines = lines.length;
    var width = 0;
    for(var i = 0; i < numLines; ++i){
        var currentWidth = measureTextWidth(font, lines[i]);
        width = Math.max(width, currentWidth);
        widths.push(currentWidth);
    }
    return width;
}
function rotateAtOffset(context, rotation, offsetX, offsetY) {
    if (rotation !== 0) {
        context.translate(offsetX, offsetY);
        context.rotate(rotation);
        context.translate(-offsetX, -offsetY);
    }
}
function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
    context.save();
    if (opacity !== 1) context.globalAlpha *= opacity;
    if (transform) context.setTransform.apply(context, transform);
    if (/** @type {*} */ labelOrImage.contextInstructions) {
        // label
        context.translate(x, y);
        context.scale(scale[0], scale[1]);
        executeLabelInstructions(labelOrImage, context);
    } else if (scale[0] < 0 || scale[1] < 0) {
        // flipped image
        context.translate(x, y);
        context.scale(scale[0], scale[1]);
        context.drawImage(labelOrImage, originX, originY, w, h, 0, 0, w, h);
    } else // if image not flipped translate and scale can be avoided
    context.drawImage(labelOrImage, originX, originY, w, h, x, y, w * scale[0], h * scale[1]);
    context.restore();
}
/**
 * @param {Label} label Label.
 * @param {CanvasRenderingContext2D} context Context.
 */ function executeLabelInstructions(label, context) {
    var contextInstructions = label.contextInstructions;
    for(var i = 0, ii = contextInstructions.length; i < ii; i += 2)if (Array.isArray(contextInstructions[i + 1])) context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
    else context[contextInstructions[i]] = contextInstructions[i + 1];
}

},{"../Object.js":"3roCV","../events/Target.js":"dj5zz","../has.js":"cdiSc","../obj.js":"g3fPg","../dom.js":"akJqt","../css.js":"23c5q","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"akJqt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/dom
 */ //FIXME Move this function to the canvas module
/**
 * Create an html canvas element and returns its 2d context.
 * @param {number} [opt_width] Canvas width.
 * @param {number} [opt_height] Canvas height.
 * @param {Array<HTMLCanvasElement>} [opt_canvasPool] Canvas pool to take existing canvas from.
 * @param {CanvasRenderingContext2DSettings} [opt_Context2DSettings] CanvasRenderingContext2DSettings
 * @return {CanvasRenderingContext2D} The context.
 */ parcelHelpers.export(exports, "createCanvasContext2D", ()=>createCanvasContext2D
);
/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */ parcelHelpers.export(exports, "outerWidth", ()=>outerWidth
);
/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */ parcelHelpers.export(exports, "outerHeight", ()=>outerHeight
);
/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */ parcelHelpers.export(exports, "replaceNode", ()=>replaceNode
);
/**
 * @param {Node} node The node to remove.
 * @return {Node} The node that was removed or null.
 */ parcelHelpers.export(exports, "removeNode", ()=>removeNode
);
/**
 * @param {Node} node The node to remove the children from.
 */ parcelHelpers.export(exports, "removeChildren", ()=>removeChildren
);
/**
 * Transform the children of a parent node so they match the
 * provided list of children.  This function aims to efficiently
 * remove, add, and reorder child nodes while maintaining a simple
 * implementation (it is not guaranteed to minimize DOM operations).
 * @param {Node} node The parent node whose children need reworking.
 * @param {Array<Node>} children The desired children.
 */ parcelHelpers.export(exports, "replaceChildren", ()=>replaceChildren
);
var _hasJs = require("./has.js");
function createCanvasContext2D(opt_width, opt_height, opt_canvasPool, opt_Context2DSettings) {
    /** @type {HTMLCanvasElement|OffscreenCanvas} */ var canvas;
    if (opt_canvasPool && opt_canvasPool.length) canvas = opt_canvasPool.shift();
    else if (_hasJs.WORKER_OFFSCREEN_CANVAS) canvas = new OffscreenCanvas(opt_width || 300, opt_height || 300);
    else {
        canvas = document.createElement('canvas');
        canvas.style.all = 'unset';
    }
    if (opt_width) canvas.width = opt_width;
    if (opt_height) canvas.height = opt_height;
    //FIXME Allow OffscreenCanvasRenderingContext2D as return type
    return canvas.getContext('2d', opt_Context2DSettings);
}
function outerWidth(element) {
    var width = element.offsetWidth;
    var style = getComputedStyle(element);
    width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
    return width;
}
function outerHeight(element) {
    var height = element.offsetHeight;
    var style = getComputedStyle(element);
    height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
    return height;
}
function replaceNode(newNode, oldNode) {
    var parent = oldNode.parentNode;
    if (parent) parent.replaceChild(newNode, oldNode);
}
function removeNode(node) {
    return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}
function removeChildren(node) {
    while(node.lastChild)node.removeChild(node.lastChild);
}
function replaceChildren(node, children) {
    var oldChildren = node.childNodes;
    for(var i = 0;; ++i){
        var oldChild = oldChildren[i];
        var newChild = children[i];
        // check if our work is done
        if (!oldChild && !newChild) break;
        // check if children match
        if (oldChild === newChild) continue;
        // check if a new child needs to be added
        if (!oldChild) {
            node.appendChild(newChild);
            continue;
        }
        // check if an old child needs to be removed
        if (!newChild) {
            node.removeChild(oldChild);
            --i;
            continue;
        }
        // reorder
        node.insertBefore(newChild, oldChild);
    }
}

},{"./has.js":"cdiSc","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"8N6xR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/PluggableMap
 */ var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _collectionEventTypeJs = require("./CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _groupJs = require("./layer/Group.js");
var _groupJsDefault = parcelHelpers.interopDefault(_groupJs);
var _mapBrowserEventJs = require("./MapBrowserEvent.js");
var _mapBrowserEventJsDefault = parcelHelpers.interopDefault(_mapBrowserEventJs);
var _mapBrowserEventHandlerJs = require("./MapBrowserEventHandler.js");
var _mapBrowserEventHandlerJsDefault = parcelHelpers.interopDefault(_mapBrowserEventHandlerJs);
var _mapBrowserEventTypeJs = require("./MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _mapEventJs = require("./MapEvent.js");
var _mapEventJsDefault = parcelHelpers.interopDefault(_mapEventJs);
var _mapEventTypeJs = require("./MapEventType.js");
var _mapEventTypeJsDefault = parcelHelpers.interopDefault(_mapEventTypeJs);
var _mapPropertyJs = require("./MapProperty.js");
var _mapPropertyJsDefault = parcelHelpers.interopDefault(_mapPropertyJs);
var _objectEventTypeJs = require("./ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _eventTypeJs1 = require("./pointer/EventType.js");
var _eventTypeJsDefault1 = parcelHelpers.interopDefault(_eventTypeJs1);
var _eventTypeJs2 = require("./render/EventType.js");
var _eventTypeJsDefault2 = parcelHelpers.interopDefault(_eventTypeJs2);
var _tileQueueJs = require("./TileQueue.js");
var _tileQueueJsDefault = parcelHelpers.interopDefault(_tileQueueJs);
var _viewJs = require("./View.js");
var _viewJsDefault = parcelHelpers.interopDefault(_viewJs);
var _viewHintJs = require("./ViewHint.js");
var _viewHintJsDefault = parcelHelpers.interopDefault(_viewHintJs);
var _hasJs = require("./has.js");
var _functionsJs = require("./functions.js");
var _transformJs = require("./transform.js");
var _assertsJs = require("./asserts.js");
var _extentJs = require("./extent.js");
var _projJs = require("./proj.js");
var _sizeJs = require("./size.js");
var _eventsJs = require("./events.js");
var _domJs = require("./dom.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 * @typedef {Object} FrameState
 * @property {number} pixelRatio The pixel ratio of the frame.
 * @property {number} time The time when rendering of the frame was requested.
 * @property {import("./View.js").State} viewState The state of the current view.
 * @property {boolean} animate Animate.
 * @property {import("./transform.js").Transform} coordinateToPixelTransform CoordinateToPixelTransform.
 * @property {import("rbush").default} declutterTree DeclutterTree.
 * @property {null|import("./extent.js").Extent} extent Extent.
 * @property {import("./extent.js").Extent} [nextExtent] Next extent during an animation series.
 * @property {number} index Index.
 * @property {Array<import("./layer/Layer.js").State>} layerStatesArray LayerStatesArray.
 * @property {number} layerIndex LayerIndex.
 * @property {import("./transform.js").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.
 * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.
 * @property {import("./size.js").Size} size Size.
 * @property {TileQueue} tileQueue TileQueue.
 * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.
 * @property {Array<number>} viewHints ViewHints.
 * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.
 */ /**
 * @typedef {function(PluggableMap, ?FrameState): any} PostRenderFunction
 */ /**
 * @typedef {Object} AtPixelOptions
 * @property {undefined|function(import("./layer/Layer.js").default<import("./source/Source").default>): boolean} [layerFilter] Layer filter
 * function. The filter function will receive one argument, the
 * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.
 * Only layers which are visible and for which this function returns `true`
 * will be tested for features. By default, all visible layers will be tested.
 * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels
 * inside the radius around the given position will be checked for features.
 * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for for wrapped geometries inside the range of
 *   +/- 1 world width. Works only if a projection is used that can be wrapped.
 */ /**
 * @typedef {Object} MapOptionsInternal
 * @property {Collection<import("./control/Control.js").default>} [controls] Controls.
 * @property {Collection<import("./interaction/Interaction.js").default>} [interactions] Interactions.
 * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.
 * @property {Collection<import("./Overlay.js").default>} overlays Overlays.
 * @property {Object<string, *>} values Values.
 */ /**
 * @typedef {import("./ObjectEventType").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<MapObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *    import("./Observable").OnSignature<import("./MapBrowserEventType").Types, import("./MapBrowserEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./MapEventType").Types, import("./MapEvent").default, Return> &
 *    import("./Observable").OnSignature<import("./render/EventType").MapRenderEventTypes, import("./render/Event").default, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|MapObjectEventTypes|
 *      import("./MapBrowserEventType").Types|import("./MapEventType").Types|
 *      import("./render/EventType").MapRenderEventTypes, Return>} PluggableMapOnSignature
 */ /**
 * Object literal with config options for the map.
 * @typedef {Object} MapOptions
 * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
 * Controls initially added to the map. If not specified,
 * {@link module:ol/control.defaults} is used.
 * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
 * physical pixels and device-independent pixels (dips) on the device.
 * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
 * Interactions that are initially added to the map. If not specified,
 * {@link module:ol/interaction.defaults} is used.
 * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
 * listen to keyboard events on. This determines when the `KeyboardPan` and
 * `KeyboardZoom` interactions trigger. For example, if this option is set to
 * `document` the keyboard interactions will always trigger. If this option is
 * not specified, the element the library listens to keyboard events on is the
 * map target (i.e. the user-provided div for the map). If this is not
 * `document`, the target element needs to be focused for key events to be
 * emitted, requiring that the target element has a `tabindex` attribute.
 * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
 * Layers. If this is not defined, a map with no layers will be rendered. Note
 * that layers are rendered in the order supplied, so if you want, for example,
 * a vector layer to appear on top of a tile layer, it must come after the tile
 * layer.
 * @property {number} [maxTilesLoading=16] Maximum number tiles to load
 * simultaneously.
 * @property {number} [moveTolerance=1] The minimum distance in pixels the
 * cursor must move to be detected as a map move event instead of a click.
 * Increasing this value can make it easier to click on the map.
 * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
 * Overlays initially added to the map. By default, no overlays are added.
 * @property {HTMLElement|string} [target] The container for the map, either the
 * element itself or the `id` of the element. If not specified at construction
 * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
 * rendered. If passed by element, the container can be in a secondary document.
 * @property {View|Promise<import("./View.js").ViewOptions>} [view] The map's view.  No layer sources will be
 * fetched unless this is specified at construction time or through
 * {@link module:ol/Map~Map#setView}.
 */ /**
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires import("./render/Event.js").default#precompose
 * @fires import("./render/Event.js").default#postcompose
 * @fires import("./render/Event.js").default#rendercomplete
 * @api
 */ var PluggableMap1 = function(_super) {
    __extends(PluggableMap2, _super);
    /**
     * @param {MapOptions} options Map options.
     */ function PluggableMap2(options) {
        var _this = _super.call(this) || this;
        /***
         * @type {PluggableMapOnSignature<import("./events").EventsKey>}
         */ _this.on;
        /***
         * @type {PluggableMapOnSignature<import("./events").EventsKey>}
         */ _this.once;
        /***
         * @type {PluggableMapOnSignature<void>}
         */ _this.un;
        var optionsInternal = createOptionsInternal(options);
        /** @private */ _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);
        /**
         * @type {number}
         * @private
         */ _this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;
        /**
         * @private
         * @type {number}
         */ _this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : _hasJs.DEVICE_PIXEL_RATIO;
        /**
         * @private
         * @type {*}
         */ _this.postRenderTimeoutHandle_;
        /**
         * @private
         * @type {number|undefined}
         */ _this.animationDelayKey_;
        /**
         * @private
         */ _this.animationDelay_ = /** @this {PluggableMap} */ (function() {
            this.animationDelayKey_ = undefined;
            this.renderFrame_(Date.now());
        }).bind(_this);
        /**
         * @private
         * @type {import("./transform.js").Transform}
         */ _this.coordinateToPixelTransform_ = _transformJs.create();
        /**
         * @private
         * @type {import("./transform.js").Transform}
         */ _this.pixelToCoordinateTransform_ = _transformJs.create();
        /**
         * @private
         * @type {number}
         */ _this.frameIndex_ = 0;
        /**
         * @private
         * @type {?FrameState}
         */ _this.frameState_ = null;
        /**
         * The extent at the previous 'moveend' event.
         * @private
         * @type {import("./extent.js").Extent}
         */ _this.previousExtent_ = null;
        /**
         * @private
         * @type {?import("./events.js").EventsKey}
         */ _this.viewPropertyListenerKey_ = null;
        /**
         * @private
         * @type {?import("./events.js").EventsKey}
         */ _this.viewChangeListenerKey_ = null;
        /**
         * @private
         * @type {?Array<import("./events.js").EventsKey>}
         */ _this.layerGroupPropertyListenerKeys_ = null;
        /**
         * @private
         * @type {!HTMLElement}
         */ _this.viewport_ = document.createElement('div');
        _this.viewport_.className = 'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');
        _this.viewport_.style.position = 'relative';
        _this.viewport_.style.overflow = 'hidden';
        _this.viewport_.style.width = '100%';
        _this.viewport_.style.height = '100%';
        /**
         * @private
         * @type {!HTMLElement}
         */ _this.overlayContainer_ = document.createElement('div');
        _this.overlayContainer_.style.position = 'absolute';
        _this.overlayContainer_.style.zIndex = '0';
        _this.overlayContainer_.style.width = '100%';
        _this.overlayContainer_.style.height = '100%';
        _this.overlayContainer_.style.pointerEvents = 'none';
        _this.overlayContainer_.className = 'ol-overlaycontainer';
        _this.viewport_.appendChild(_this.overlayContainer_);
        /**
         * @private
         * @type {!HTMLElement}
         */ _this.overlayContainerStopEvent_ = document.createElement('div');
        _this.overlayContainerStopEvent_.style.position = 'absolute';
        _this.overlayContainerStopEvent_.style.zIndex = '0';
        _this.overlayContainerStopEvent_.style.width = '100%';
        _this.overlayContainerStopEvent_.style.height = '100%';
        _this.overlayContainerStopEvent_.style.pointerEvents = 'none';
        _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
        _this.viewport_.appendChild(_this.overlayContainerStopEvent_);
        /**
         * @private
         * @type {MapBrowserEventHandler}
         */ _this.mapBrowserEventHandler_ = null;
        /**
         * @private
         * @type {number}
         */ _this.moveTolerance_ = options.moveTolerance;
        /**
         * @private
         * @type {HTMLElement|Document}
         */ _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
        /**
         * @private
         * @type {?Array<import("./events.js").EventsKey>}
         */ _this.keyHandlerKeys_ = null;
        /**
         * @type {Collection<import("./control/Control.js").default>}
         * @protected
         */ _this.controls = optionsInternal.controls || new _collectionJsDefault.default();
        /**
         * @type {Collection<import("./interaction/Interaction.js").default>}
         * @protected
         */ _this.interactions = optionsInternal.interactions || new _collectionJsDefault.default();
        /**
         * @type {Collection<import("./Overlay.js").default>}
         * @private
         */ _this.overlays_ = optionsInternal.overlays;
        /**
         * A lookup of overlays by id.
         * @private
         * @type {Object<string, import("./Overlay.js").default>}
         */ _this.overlayIdIndex_ = {
        };
        /**
         * @type {import("./renderer/Map.js").default}
         * @private
         */ _this.renderer_ = null;
        /**
         * @type {undefined|function(Event): void}
         * @private
         */ _this.handleResize_;
        /**
         * @private
         * @type {!Array<PostRenderFunction>}
         */ _this.postRenderFunctions_ = [];
        /**
         * @private
         * @type {TileQueue}
         */ _this.tileQueue_ = new _tileQueueJsDefault.default(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));
        _this.addChangeListener(_mapPropertyJsDefault.default.LAYERGROUP, _this.handleLayerGroupChanged_);
        _this.addChangeListener(_mapPropertyJsDefault.default.VIEW, _this.handleViewChanged_);
        _this.addChangeListener(_mapPropertyJsDefault.default.SIZE, _this.handleSizeChanged_);
        _this.addChangeListener(_mapPropertyJsDefault.default.TARGET, _this.handleTargetChanged_);
        // setProperties will trigger the rendering of the map if the map
        // is "defined" already.
        _this.setProperties(optionsInternal.values);
        var map = _this;
        if (options.view && !(options.view instanceof _viewJsDefault.default)) options.view.then(function(viewOptions) {
            map.setView(new _viewJsDefault.default(viewOptions));
        });
        _this.controls.addEventListener(_collectionEventTypeJsDefault.default.ADD, /**
         * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
         */ (function(event) {
            event.element.setMap(this);
        }).bind(_this));
        _this.controls.addEventListener(_collectionEventTypeJsDefault.default.REMOVE, /**
         * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
         */ (function(event) {
            event.element.setMap(null);
        }).bind(_this));
        _this.interactions.addEventListener(_collectionEventTypeJsDefault.default.ADD, /**
         * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
         */ (function(event) {
            event.element.setMap(this);
        }).bind(_this));
        _this.interactions.addEventListener(_collectionEventTypeJsDefault.default.REMOVE, /**
         * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
         */ (function(event) {
            event.element.setMap(null);
        }).bind(_this));
        _this.overlays_.addEventListener(_collectionEventTypeJsDefault.default.ADD, /**
         * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
         */ (function(event) {
            this.addOverlayInternal_(event.element);
        }).bind(_this));
        _this.overlays_.addEventListener(_collectionEventTypeJsDefault.default.REMOVE, /**
         * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
         */ (function(event) {
            var overlay = event.element;
            var id = overlay.getId();
            if (id !== undefined) delete this.overlayIdIndex_[id.toString()];
            event.element.setMap(null);
        }).bind(_this));
        _this.controls.forEach(/**
         * @param {import("./control/Control.js").default} control Control.
         * @this {PluggableMap}
         */ (function(control) {
            control.setMap(this);
        }).bind(_this));
        _this.interactions.forEach(/**
         * @param {import("./interaction/Interaction.js").default} interaction Interaction.
         * @this {PluggableMap}
         */ (function(interaction) {
            interaction.setMap(this);
        }).bind(_this));
        _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));
        return _this;
    }
    /**
     * @abstract
     * @return {import("./renderer/Map.js").default} The map renderer
     */ PluggableMap2.prototype.createRenderer = function() {
        throw new Error('Use a map type that has a createRenderer method');
    };
    /**
     * Add the given control to the map.
     * @param {import("./control/Control.js").default} control Control.
     * @api
     */ PluggableMap2.prototype.addControl = function(control) {
        this.getControls().push(control);
    };
    /**
     * Add the given interaction to the map. If you want to add an interaction
     * at another point of the collection use `getInteraction()` and the methods
     * available on {@link module:ol/Collection~Collection}. This can be used to
     * stop the event propagation from the handleEvent function. The interactions
     * get to handle the events in the reverse order of this collection.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
     * @api
     */ PluggableMap2.prototype.addInteraction = function(interaction) {
        this.getInteractions().push(interaction);
    };
    /**
     * Adds the given layer to the top of this map. If you want to add a layer
     * elsewhere in the stack, use `getLayers()` and the methods available on
     * {@link module:ol/Collection~Collection}.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @api
     */ PluggableMap2.prototype.addLayer = function(layer) {
        var layers = this.getLayerGroup().getLayers();
        layers.push(layer);
    };
    /**
     * Add the given overlay to the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @api
     */ PluggableMap2.prototype.addOverlay = function(overlay) {
        this.getOverlays().push(overlay);
    };
    /**
     * This deals with map's overlay collection changes.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @private
     */ PluggableMap2.prototype.addOverlayInternal_ = function(overlay) {
        var id = overlay.getId();
        if (id !== undefined) this.overlayIdIndex_[id.toString()] = overlay;
        overlay.setMap(this);
    };
    /**
     *
     * Clean up.
     */ PluggableMap2.prototype.disposeInternal = function() {
        this.setTarget(null);
        _super.prototype.disposeInternal.call(this);
    };
    /**
     * Detect features that intersect a pixel on the viewport, and execute a
     * callback with each intersecting feature. Layers included in the detection can
     * be configured through the `layerFilter` option in `opt_options`.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
     *     called with two arguments. The first argument is one
     *     {@link module:ol/Feature feature} or
     *     {@link module:ol/render/Feature render feature} at the pixel, the second is
     *     the {@link module:ol/layer/Layer layer} of the feature and will be null for
     *     unmanaged layers. To stop detection, callback functions can return a
     *     truthy value.
     * @param {AtPixelOptions} [opt_options] Optional options.
     * @return {T|undefined} Callback result, i.e. the return value of last
     * callback execution, or the first truthy callback return value.
     * @template T
     * @api
     */ PluggableMap2.prototype.forEachFeatureAtPixel = function(pixel, callback, opt_options) {
        if (!this.frameState_) return;
        var coordinate = this.getCoordinateFromPixelInternal(pixel);
        opt_options = opt_options !== undefined ? opt_options : {
        };
        var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;
        var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functionsJs.TRUE;
        var checkWrapped = opt_options.checkWrapped !== false;
        return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
    };
    /**
     * Get all features that intersect a pixel on the viewport.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [opt_options] Optional options.
     * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
     * an empty array if none were found.
     * @api
     */ PluggableMap2.prototype.getFeaturesAtPixel = function(pixel, opt_options) {
        var features = [];
        this.forEachFeatureAtPixel(pixel, function(feature) {
            features.push(feature);
        }, opt_options);
        return features;
    };
    /**
     * Detect layers that have a color value at a pixel on the viewport, and
     * execute a callback with each matching layer. Layers included in the
     * detection can be configured through `opt_layerFilter`.
     *
     * Note: this may give false positives unless the map layers have had different `className`
     * properties assigned to them.
     *
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {function(this: S, import("./layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback
     *     Layer callback. This callback will receive two arguments: first is the
     *     {@link module:ol/layer/Layer layer}, second argument is an array representing
     *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
     *     that do not currently support this argument. To stop detection, callback
     *     functions can return a truthy value.
     * @param {AtPixelOptions} [opt_options] Configuration options.
     * @return {T|undefined} Callback result, i.e. the return value of last
     * callback execution, or the first truthy callback return value.
     * @template S,T
     * @api
     */ PluggableMap2.prototype.forEachLayerAtPixel = function(pixel, callback, opt_options) {
        if (!this.frameState_) return;
        var options = opt_options || {
        };
        var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
        var layerFilter = options.layerFilter || _functionsJs.TRUE;
        return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);
    };
    /**
     * Detect if features intersect a pixel on the viewport. Layers included in the
     * detection can be configured through `opt_layerFilter`.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [opt_options] Optional options.
     * @return {boolean} Is there a feature at the given pixel?
     * @api
     */ PluggableMap2.prototype.hasFeatureAtPixel = function(pixel, opt_options) {
        if (!this.frameState_) return false;
        var coordinate = this.getCoordinateFromPixelInternal(pixel);
        opt_options = opt_options !== undefined ? opt_options : {
        };
        var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functionsJs.TRUE;
        var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;
        var checkWrapped = opt_options.checkWrapped !== false;
        return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
    };
    /**
     * Returns the coordinate in user projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     * @api
     */ PluggableMap2.prototype.getEventCoordinate = function(event) {
        return this.getCoordinateFromPixel(this.getEventPixel(event));
    };
    /**
     * Returns the coordinate in view projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     */ PluggableMap2.prototype.getEventCoordinateInternal = function(event) {
        return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
    };
    /**
     * Returns the map pixel position for a browser event relative to the viewport.
     * @param {UIEvent} event Event.
     * @return {import("./pixel.js").Pixel} Pixel.
     * @api
     */ PluggableMap2.prototype.getEventPixel = function(event) {
        var viewportPosition = this.viewport_.getBoundingClientRect();
        var eventPosition = //FIXME Are we really calling this with a TouchEvent anywhere?
        'changedTouches' in event ? /** @type {TouchEvent} */ event.changedTouches[0] : event;
        return [
            eventPosition.clientX - viewportPosition.left,
            eventPosition.clientY - viewportPosition.top, 
        ];
    };
    /**
     * Get the target in which this map is rendered.
     * Note that this returns what is entered as an option or in setTarget:
     * if that was an element, it returns an element; if a string, it returns that.
     * @return {HTMLElement|string|undefined} The Element or id of the Element that the
     *     map is rendered in.
     * @observable
     * @api
     */ PluggableMap2.prototype.getTarget = function() {
        return this.get(_mapPropertyJsDefault.default.TARGET);
    };
    /**
     * Get the DOM element into which this map is rendered. In contrast to
     * `getTarget` this method always return an `Element`, or `null` if the
     * map has no target.
     * @return {HTMLElement} The element that the map is rendered in.
     * @api
     */ PluggableMap2.prototype.getTargetElement = function() {
        var target = this.getTarget();
        if (target !== undefined) return typeof target === 'string' ? document.getElementById(target) : target;
        else return null;
    };
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * user projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     * @api
     */ PluggableMap2.prototype.getCoordinateFromPixel = function(pixel) {
        return _projJs.toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
    };
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * map view projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     */ PluggableMap2.prototype.getCoordinateFromPixelInternal = function(pixel) {
        var frameState = this.frameState_;
        if (!frameState) return null;
        else return _transformJs.apply(frameState.pixelToCoordinateTransform, pixel.slice());
    };
    /**
     * Get the map controls. Modifying this collection changes the controls
     * associated with the map.
     * @return {Collection<import("./control/Control.js").default>} Controls.
     * @api
     */ PluggableMap2.prototype.getControls = function() {
        return this.controls;
    };
    /**
     * Get the map overlays. Modifying this collection changes the overlays
     * associated with the map.
     * @return {Collection<import("./Overlay.js").default>} Overlays.
     * @api
     */ PluggableMap2.prototype.getOverlays = function() {
        return this.overlays_;
    };
    /**
     * Get an overlay by its identifier (the value returned by overlay.getId()).
     * Note that the index treats string and numeric identifiers as the same. So
     * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
     * @param {string|number} id Overlay identifier.
     * @return {import("./Overlay.js").default} Overlay.
     * @api
     */ PluggableMap2.prototype.getOverlayById = function(id) {
        var overlay = this.overlayIdIndex_[id.toString()];
        return overlay !== undefined ? overlay : null;
    };
    /**
     * Get the map interactions. Modifying this collection changes the interactions
     * associated with the map.
     *
     * Interactions are used for e.g. pan, zoom and rotate.
     * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
     * @api
     */ PluggableMap2.prototype.getInteractions = function() {
        return this.interactions;
    };
    /**
     * Get the layergroup associated with this map.
     * @return {LayerGroup} A layer group containing the layers in this map.
     * @observable
     * @api
     */ PluggableMap2.prototype.getLayerGroup = function() {
        return this.get(_mapPropertyJsDefault.default.LAYERGROUP);
    };
    /**
     * Clear any existing layers and add layers to the map.
     * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
     * @api
     */ PluggableMap2.prototype.setLayers = function(layers) {
        var group = this.getLayerGroup();
        if (layers instanceof _collectionJsDefault.default) {
            group.setLayers(layers);
            return;
        }
        var collection = group.getLayers();
        collection.clear();
        collection.extend(layers);
    };
    /**
     * Get the collection of layers associated with this map.
     * @return {!Collection<import("./layer/Base.js").default>} Layers.
     * @api
     */ PluggableMap2.prototype.getLayers = function() {
        var layers = this.getLayerGroup().getLayers();
        return layers;
    };
    /**
     * @return {boolean} Layers have sources that are still loading.
     */ PluggableMap2.prototype.getLoading = function() {
        var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
        for(var i = 0, ii = layerStatesArray.length; i < ii; ++i){
            var layer = layerStatesArray[i].layer;
            var source = /** @type {import("./layer/Layer.js").default} */ layer.getSource();
            if (source && source.loading) return true;
        }
        return false;
    };
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the user
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     * @api
     */ PluggableMap2.prototype.getPixelFromCoordinate = function(coordinate) {
        var viewCoordinate = _projJs.fromUserCoordinate(coordinate, this.getView().getProjection());
        return this.getPixelFromCoordinateInternal(viewCoordinate);
    };
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the map view
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     */ PluggableMap2.prototype.getPixelFromCoordinateInternal = function(coordinate) {
        var frameState = this.frameState_;
        if (!frameState) return null;
        else return _transformJs.apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
    };
    /**
     * Get the map renderer.
     * @return {import("./renderer/Map.js").default} Renderer
     */ PluggableMap2.prototype.getRenderer = function() {
        return this.renderer_;
    };
    /**
     * Get the size of this map.
     * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
     * @observable
     * @api
     */ PluggableMap2.prototype.getSize = function() {
        return this.get(_mapPropertyJsDefault.default.SIZE);
    };
    /**
     * Get the view associated with this map. A view manages properties such as
     * center and resolution.
     * @return {View} The view that controls this map.
     * @observable
     * @api
     */ PluggableMap2.prototype.getView = function() {
        return this.get(_mapPropertyJsDefault.default.VIEW);
    };
    /**
     * Get the element that serves as the map viewport.
     * @return {HTMLElement} Viewport.
     * @api
     */ PluggableMap2.prototype.getViewport = function() {
        return this.viewport_;
    };
    /**
     * Get the element that serves as the container for overlays.  Elements added to
     * this container will let mousedown and touchstart events through to the map,
     * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
     * events.
     * @return {!HTMLElement} The map's overlay container.
     */ PluggableMap2.prototype.getOverlayContainer = function() {
        return this.overlayContainer_;
    };
    /**
     * Get the element that serves as a container for overlays that don't allow
     * event propagation. Elements added to this container won't let mousedown and
     * touchstart events through to the map, so clicks and gestures on an overlay
     * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @return {!HTMLElement} The map's overlay container that stops events.
     */ PluggableMap2.prototype.getOverlayContainerStopEvent = function() {
        return this.overlayContainerStopEvent_;
    };
    /**
     * @return {!Document} The document where the map is displayed.
     */ PluggableMap2.prototype.getOwnerDocument = function() {
        var targetElement = this.getTargetElement();
        return targetElement ? targetElement.ownerDocument : document;
    };
    /**
     * @param {import("./Tile.js").default} tile Tile.
     * @param {string} tileSourceKey Tile source key.
     * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
     * @param {number} tileResolution Tile resolution.
     * @return {number} Tile priority.
     */ PluggableMap2.prototype.getTilePriority = function(tile, tileSourceKey, tileCenter, tileResolution) {
        return _tileQueueJs.getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
    };
    /**
     * @param {UIEvent} browserEvent Browser event.
     * @param {string} [opt_type] Type.
     */ PluggableMap2.prototype.handleBrowserEvent = function(browserEvent, opt_type) {
        var type = opt_type || browserEvent.type;
        var mapBrowserEvent = new _mapBrowserEventJsDefault.default(type, this, browserEvent);
        this.handleMapBrowserEvent(mapBrowserEvent);
    };
    /**
     * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
     */ PluggableMap2.prototype.handleMapBrowserEvent = function(mapBrowserEvent) {
        if (!this.frameState_) // With no view defined, we cannot translate pixels into geographical
        // coordinates so interactions cannot be used.
        return;
        var originalEvent = mapBrowserEvent.originalEvent;
        var eventType = originalEvent.type;
        if (eventType === _eventTypeJsDefault1.default.POINTERDOWN || eventType === _eventTypeJsDefault.default.WHEEL || eventType === _eventTypeJsDefault.default.KEYDOWN) {
            var doc = this.getOwnerDocument();
            var rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
            var target = originalEvent.target;
            if (// Abort if the target is a child of the container for elements whose events are not meant
            // to be handled by map interactions.
            this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
            // It's possible for the target to no longer be in the page if it has been removed in an
            // event listener, this might happen in a Control that recreates it's content based on
            // user interaction either manually or via a render in something like https://reactjs.org/
            !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) return;
        }
        mapBrowserEvent.frameState = this.frameState_;
        if (this.dispatchEvent(mapBrowserEvent) !== false) {
            var interactionsArray = this.getInteractions().getArray().slice();
            for(var i = interactionsArray.length - 1; i >= 0; i--){
                var interaction = interactionsArray[i];
                if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) continue;
                var cont = interaction.handleEvent(mapBrowserEvent);
                if (!cont || mapBrowserEvent.propagationStopped) break;
            }
        }
    };
    /**
     * @protected
     */ PluggableMap2.prototype.handlePostRender = function() {
        var frameState = this.frameState_;
        // Manage the tile queue
        // Image loads are expensive and a limited resource, so try to use them
        // efficiently:
        // * When the view is static we allow a large number of parallel tile loads
        //   to complete the frame as quickly as possible.
        // * When animating or interacting, image loads can cause janks, so we reduce
        //   the maximum number of loads per frame and limit the number of parallel
        //   tile loads to remain reactive to view changes and to reduce the chance of
        //   loading tiles that will quickly disappear from view.
        var tileQueue = this.tileQueue_;
        if (!tileQueue.isEmpty()) {
            var maxTotalLoading = this.maxTilesLoading_;
            var maxNewLoads = maxTotalLoading;
            if (frameState) {
                var hints = frameState.viewHints;
                if (hints[_viewHintJsDefault.default.ANIMATING] || hints[_viewHintJsDefault.default.INTERACTING]) {
                    var lowOnFrameBudget = Date.now() - frameState.time > 8;
                    maxTotalLoading = lowOnFrameBudget ? 0 : 8;
                    maxNewLoads = lowOnFrameBudget ? 0 : 2;
                }
            }
            if (tileQueue.getTilesLoading() < maxTotalLoading) {
                tileQueue.reprioritize(); // FIXME only call if view has changed
                tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
            }
        }
        if (frameState && this.hasListener(_eventTypeJsDefault2.default.RENDERCOMPLETE) && !frameState.animate && !this.tileQueue_.getTilesLoading() && !this.getLoading()) this.renderer_.dispatchRenderEvent(_eventTypeJsDefault2.default.RENDERCOMPLETE, frameState);
        var postRenderFunctions = this.postRenderFunctions_;
        for(var i = 0, ii = postRenderFunctions.length; i < ii; ++i)postRenderFunctions[i](this, frameState);
        postRenderFunctions.length = 0;
    };
    /**
     * @private
     */ PluggableMap2.prototype.handleSizeChanged_ = function() {
        if (this.getView() && !this.getView().getAnimating()) this.getView().resolveConstraints(0);
        this.render();
    };
    /**
     * @private
     */ PluggableMap2.prototype.handleTargetChanged_ = function() {
        // target may be undefined, null, a string or an Element.
        // If it's a string we convert it to an Element before proceeding.
        // If it's not now an Element we remove the viewport from the DOM.
        // If it's an Element we append the viewport element to it.
        var targetElement;
        if (this.getTarget()) targetElement = this.getTargetElement();
        if (this.mapBrowserEventHandler_) {
            for(var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i)_eventsJs.unlistenByKey(this.keyHandlerKeys_[i]);
            this.keyHandlerKeys_ = null;
            this.viewport_.removeEventListener(_eventTypeJsDefault.default.CONTEXTMENU, this.boundHandleBrowserEvent_);
            this.viewport_.removeEventListener(_eventTypeJsDefault.default.WHEEL, this.boundHandleBrowserEvent_);
            if (this.handleResize_ !== undefined) {
                removeEventListener(_eventTypeJsDefault.default.RESIZE, this.handleResize_, false);
                this.handleResize_ = undefined;
            }
            this.mapBrowserEventHandler_.dispose();
            this.mapBrowserEventHandler_ = null;
            _domJs.removeNode(this.viewport_);
        }
        if (!targetElement) {
            if (this.renderer_) {
                clearTimeout(this.postRenderTimeoutHandle_);
                this.postRenderTimeoutHandle_ = undefined;
                this.postRenderFunctions_.length = 0;
                this.renderer_.dispose();
                this.renderer_ = null;
            }
            if (this.animationDelayKey_) {
                cancelAnimationFrame(this.animationDelayKey_);
                this.animationDelayKey_ = undefined;
            }
        } else {
            targetElement.appendChild(this.viewport_);
            if (!this.renderer_) this.renderer_ = this.createRenderer();
            this.mapBrowserEventHandler_ = new _mapBrowserEventHandlerJsDefault.default(this, this.moveTolerance_);
            for(var key in _mapBrowserEventTypeJsDefault.default)this.mapBrowserEventHandler_.addEventListener(_mapBrowserEventTypeJsDefault.default[key], this.handleMapBrowserEvent.bind(this));
            this.viewport_.addEventListener(_eventTypeJsDefault.default.CONTEXTMENU, this.boundHandleBrowserEvent_, false);
            this.viewport_.addEventListener(_eventTypeJsDefault.default.WHEEL, this.boundHandleBrowserEvent_, _hasJs.PASSIVE_EVENT_LISTENERS ? {
                passive: false
            } : false);
            var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
            this.keyHandlerKeys_ = [
                _eventsJs.listen(keyboardEventTarget, _eventTypeJsDefault.default.KEYDOWN, this.handleBrowserEvent, this),
                _eventsJs.listen(keyboardEventTarget, _eventTypeJsDefault.default.KEYPRESS, this.handleBrowserEvent, this), 
            ];
            if (!this.handleResize_) {
                this.handleResize_ = this.updateSize.bind(this);
                window.addEventListener(_eventTypeJsDefault.default.RESIZE, this.handleResize_, false);
            }
        }
        this.updateSize();
    // updateSize calls setSize, so no need to call this.render
    // ourselves here.
    };
    /**
     * @private
     */ PluggableMap2.prototype.handleTileChange_ = function() {
        this.render();
    };
    /**
     * @private
     */ PluggableMap2.prototype.handleViewPropertyChanged_ = function() {
        this.render();
    };
    /**
     * @private
     */ PluggableMap2.prototype.handleViewChanged_ = function() {
        if (this.viewPropertyListenerKey_) {
            _eventsJs.unlistenByKey(this.viewPropertyListenerKey_);
            this.viewPropertyListenerKey_ = null;
        }
        if (this.viewChangeListenerKey_) {
            _eventsJs.unlistenByKey(this.viewChangeListenerKey_);
            this.viewChangeListenerKey_ = null;
        }
        var view = this.getView();
        if (view) {
            this.updateViewportSize_();
            this.viewPropertyListenerKey_ = _eventsJs.listen(view, _objectEventTypeJsDefault.default.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
            this.viewChangeListenerKey_ = _eventsJs.listen(view, _eventTypeJsDefault.default.CHANGE, this.handleViewPropertyChanged_, this);
            view.resolveConstraints(0);
        }
        this.render();
    };
    /**
     * @private
     */ PluggableMap2.prototype.handleLayerGroupChanged_ = function() {
        if (this.layerGroupPropertyListenerKeys_) {
            this.layerGroupPropertyListenerKeys_.forEach(_eventsJs.unlistenByKey);
            this.layerGroupPropertyListenerKeys_ = null;
        }
        var layerGroup = this.getLayerGroup();
        if (layerGroup) this.layerGroupPropertyListenerKeys_ = [
            _eventsJs.listen(layerGroup, _objectEventTypeJsDefault.default.PROPERTYCHANGE, this.render, this),
            _eventsJs.listen(layerGroup, _eventTypeJsDefault.default.CHANGE, this.render, this), 
        ];
        this.render();
    };
    /**
     * @return {boolean} Is rendered.
     */ PluggableMap2.prototype.isRendered = function() {
        return !!this.frameState_;
    };
    /**
     * Requests an immediate render in a synchronous manner.
     * @api
     */ PluggableMap2.prototype.renderSync = function() {
        if (this.animationDelayKey_) cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelay_();
    };
    /**
     * Redraws all text after new fonts have loaded
     */ PluggableMap2.prototype.redrawText = function() {
        var layerStates = this.getLayerGroup().getLayerStatesArray();
        for(var i = 0, ii = layerStates.length; i < ii; ++i){
            var layer = layerStates[i].layer;
            if (layer.hasRenderer()) layer.getRenderer().handleFontsChanged();
        }
    };
    /**
     * Request a map rendering (at the next animation frame).
     * @api
     */ PluggableMap2.prototype.render = function() {
        if (this.renderer_ && this.animationDelayKey_ === undefined) this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    };
    /**
     * Remove the given control from the map.
     * @param {import("./control/Control.js").default} control Control.
     * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
     *     if the control was not found).
     * @api
     */ PluggableMap2.prototype.removeControl = function(control) {
        return this.getControls().remove(control);
    };
    /**
     * Remove the given interaction from the map.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
     * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
     *     undefined if the interaction was not found).
     * @api
     */ PluggableMap2.prototype.removeInteraction = function(interaction) {
        return this.getInteractions().remove(interaction);
    };
    /**
     * Removes the given layer from the map.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
     *     layer was not found).
     * @api
     */ PluggableMap2.prototype.removeLayer = function(layer) {
        var layers = this.getLayerGroup().getLayers();
        return layers.remove(layer);
    };
    /**
     * Remove the given overlay from the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
     *     if the overlay was not found).
     * @api
     */ PluggableMap2.prototype.removeOverlay = function(overlay) {
        return this.getOverlays().remove(overlay);
    };
    /**
     * @param {number} time Time.
     * @private
     */ PluggableMap2.prototype.renderFrame_ = function(time) {
        var _this = this;
        var size = this.getSize();
        var view = this.getView();
        var previousFrameState = this.frameState_;
        /** @type {?FrameState} */ var frameState = null;
        if (size !== undefined && _sizeJs.hasArea(size) && view && view.isDef()) {
            var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
            var viewState = view.getState();
            frameState = {
                animate: false,
                coordinateToPixelTransform: this.coordinateToPixelTransform_,
                declutterTree: null,
                extent: _extentJs.getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),
                index: this.frameIndex_++,
                layerIndex: 0,
                layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
                pixelRatio: this.pixelRatio_,
                pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
                postRenderFunctions: [],
                size: size,
                tileQueue: this.tileQueue_,
                time: time,
                usedTiles: {
                },
                viewState: viewState,
                viewHints: viewHints,
                wantedTiles: {
                }
            };
            if (viewState.nextCenter && viewState.nextResolution) {
                var rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
                frameState.nextExtent = _extentJs.getForViewAndSize(viewState.nextCenter, viewState.nextResolution, rotation, size);
            }
        }
        this.frameState_ = frameState;
        this.renderer_.renderFrame(frameState);
        if (frameState) {
            if (frameState.animate) this.render();
            Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
            if (previousFrameState) {
                var moveStart = !this.previousExtent_ || !_extentJs.isEmpty(this.previousExtent_) && !_extentJs.equals(frameState.extent, this.previousExtent_);
                if (moveStart) {
                    this.dispatchEvent(new _mapEventJsDefault.default(_mapEventTypeJsDefault.default.MOVESTART, this, previousFrameState));
                    this.previousExtent_ = _extentJs.createOrUpdateEmpty(this.previousExtent_);
                }
            }
            var idle = this.previousExtent_ && !frameState.viewHints[_viewHintJsDefault.default.ANIMATING] && !frameState.viewHints[_viewHintJsDefault.default.INTERACTING] && !_extentJs.equals(frameState.extent, this.previousExtent_);
            if (idle) {
                this.dispatchEvent(new _mapEventJsDefault.default(_mapEventTypeJsDefault.default.MOVEEND, this, frameState));
                _extentJs.clone(frameState.extent, this.previousExtent_);
            }
        }
        this.dispatchEvent(new _mapEventJsDefault.default(_mapEventTypeJsDefault.default.POSTRENDER, this, frameState));
        if (!this.postRenderTimeoutHandle_) this.postRenderTimeoutHandle_ = setTimeout(function() {
            _this.postRenderTimeoutHandle_ = undefined;
            _this.handlePostRender();
        }, 0);
    };
    /**
     * Sets the layergroup of this map.
     * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
     * @observable
     * @api
     */ PluggableMap2.prototype.setLayerGroup = function(layerGroup) {
        this.set(_mapPropertyJsDefault.default.LAYERGROUP, layerGroup);
    };
    /**
     * Set the size of this map.
     * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
     * @observable
     * @api
     */ PluggableMap2.prototype.setSize = function(size) {
        this.set(_mapPropertyJsDefault.default.SIZE, size);
    };
    /**
     * Set the target element to render this map into.
     * @param {HTMLElement|string} [target] The Element or id of the Element
     *     that the map is rendered in.
     * @observable
     * @api
     */ PluggableMap2.prototype.setTarget = function(target) {
        this.set(_mapPropertyJsDefault.default.TARGET, target);
    };
    /**
     * Set the view for this map.
     * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
     * It is also possible to pass a promise that resolves to options for constructing a view.  This
     * alternative allows view properties to be resolved by sources or other components that load
     * view-related metadata.
     * @observable
     * @api
     */ PluggableMap2.prototype.setView = function(view) {
        if (!view || view instanceof _viewJsDefault.default) {
            this.set(_mapPropertyJsDefault.default.VIEW, view);
            return;
        }
        this.set(_mapPropertyJsDefault.default.VIEW, new _viewJsDefault.default());
        var map = this;
        view.then(function(viewOptions) {
            map.setView(new _viewJsDefault.default(viewOptions));
        });
    };
    /**
     * Force a recalculation of the map viewport size.  This should be called when
     * third-party code changes the size of the map viewport.
     * @api
     */ PluggableMap2.prototype.updateSize = function() {
        var targetElement = this.getTargetElement();
        var size = undefined;
        if (targetElement) {
            var computedStyle = getComputedStyle(targetElement);
            var width = targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']);
            var height = targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth']);
            if (!isNaN(width) && !isNaN(height)) {
                size = [
                    width,
                    height
                ];
                if (!_sizeJs.hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) // eslint-disable-next-line
                console.warn("No map visible because the map container's width or height are 0.");
            }
        }
        this.setSize(size);
        this.updateViewportSize_();
    };
    /**
     * Recomputes the viewport size and save it on the view object (if any)
     * @private
     */ PluggableMap2.prototype.updateViewportSize_ = function() {
        var view = this.getView();
        if (view) {
            var size = undefined;
            var computedStyle = getComputedStyle(this.viewport_);
            if (computedStyle.width && computedStyle.height) size = [
                parseInt(computedStyle.width, 10),
                parseInt(computedStyle.height, 10), 
            ];
            view.setViewportSize(size);
        }
    };
    return PluggableMap2;
}(_objectJsDefault.default);
/**
 * @param {MapOptions} options Map options.
 * @return {MapOptionsInternal} Internal map options.
 */ function createOptionsInternal(options) {
    /**
     * @type {HTMLElement|Document}
     */ var keyboardEventTarget = null;
    if (options.keyboardEventTarget !== undefined) keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
    /**
     * @type {Object<string, *>}
     */ var values = {
    };
    var layerGroup = options.layers && typeof /** @type {?} */ options.layers.getLayers === 'function' ? options.layers : new _groupJsDefault.default({
        layers: options.layers
    });
    values[_mapPropertyJsDefault.default.LAYERGROUP] = layerGroup;
    values[_mapPropertyJsDefault.default.TARGET] = options.target;
    values[_mapPropertyJsDefault.default.VIEW] = options.view instanceof _viewJsDefault.default ? options.view : new _viewJsDefault.default();
    var controls;
    if (options.controls !== undefined) {
        if (Array.isArray(options.controls)) controls = new _collectionJsDefault.default(options.controls.slice());
        else {
            _assertsJs.assert(typeof /** @type {?} */ options.controls.getArray === 'function', 47); // Expected `controls` to be an array or an `import("./Collection.js").Collection`
            controls = options.controls;
        }
    }
    var interactions;
    if (options.interactions !== undefined) {
        if (Array.isArray(options.interactions)) interactions = new _collectionJsDefault.default(options.interactions.slice());
        else {
            _assertsJs.assert(typeof /** @type {?} */ options.interactions.getArray === 'function', 48); // Expected `interactions` to be an array or an `import("./Collection.js").Collection`
            interactions = options.interactions;
        }
    }
    var overlays;
    if (options.overlays !== undefined) {
        if (Array.isArray(options.overlays)) overlays = new _collectionJsDefault.default(options.overlays.slice());
        else {
            _assertsJs.assert(typeof /** @type {?} */ options.overlays.getArray === 'function', 49); // Expected `overlays` to be an array or an `import("./Collection.js").Collection`
            overlays = options.overlays;
        }
    } else overlays = new _collectionJsDefault.default();
    return {
        controls: controls,
        interactions: interactions,
        keyboardEventTarget: keyboardEventTarget,
        overlays: overlays,
        values: values
    };
}
exports.default = PluggableMap1;

},{"./Object.js":"3roCV","./Collection.js":"d2f3b","./CollectionEventType.js":"jxyhy","./events/EventType.js":"83vee","./layer/Group.js":"gxl7q","./MapBrowserEvent.js":"8kc32","./MapBrowserEventHandler.js":"iN1Ja","./MapBrowserEventType.js":"coXRZ","./MapEvent.js":"7dx8e","./MapEventType.js":"eYKj9","./MapProperty.js":"jNLVu","./ObjectEventType.js":"j6hH6","./pointer/EventType.js":"3XFPg","./render/EventType.js":"6WjvK","./TileQueue.js":"2r09E","./View.js":"9RaqO","./ViewHint.js":"EJUkL","./has.js":"cdiSc","./functions.js":"d72zA","./transform.js":"C21tg","./asserts.js":"cnrP4","./extent.js":"jgUz2","./proj.js":"hmdWM","./size.js":"5PZ8p","./events.js":"e9Qqr","./dom.js":"akJqt","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"d2f3b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CollectionEvent", ()=>CollectionEvent1
);
/**
 * @module ol/Collection
 */ var _assertionErrorJs = require("./AssertionError.js");
var _assertionErrorJsDefault = parcelHelpers.interopDefault(_assertionErrorJs);
var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _collectionEventTypeJs = require("./CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventJs = require("./events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @enum {string}
 * @private
 */ var Property = {
    LENGTH: 'length'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 */ var CollectionEvent1 = function(_super) {
    __extends(CollectionEvent2, _super);
    /**
     * @param {import("./CollectionEventType.js").default} type Type.
     * @param {*} [opt_element] Element.
     * @param {number} [opt_index] The index of the added or removed element.
     */ function CollectionEvent2(type, opt_element, opt_index) {
        var _this = _super.call(this, type) || this;
        /**
         * The element that is added to or removed from the collection.
         * @type {*}
         * @api
         */ _this.element = opt_element;
        /**
         * The index of the added or removed element.
         * @type {number}
         * @api
         */ _this.index = opt_index;
        return _this;
    }
    return CollectionEvent2;
}(_eventJsDefault.default);
/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:length', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").OnSignature<'add'|'remove', CollectionEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types|
 *     'change:length'|'add'|'remove',Return>} CollectionOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */ /**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */ var Collection1 = function(_super) {
    __extends(Collection2, _super);
    /**
     * @param {Array<T>} [opt_array] Array.
     * @param {Options} [opt_options] Collection options.
     */ function Collection2(opt_array, opt_options) {
        var _this = _super.call(this) || this;
        /***
         * @type {CollectionOnSignature<import("./events").EventsKey>}
         */ _this.on;
        /***
         * @type {CollectionOnSignature<import("./events").EventsKey>}
         */ _this.once;
        /***
         * @type {CollectionOnSignature<void>}
         */ _this.un;
        var options = opt_options || {
        };
        /**
         * @private
         * @type {boolean}
         */ _this.unique_ = !!options.unique;
        /**
         * @private
         * @type {!Array<T>}
         */ _this.array_ = opt_array ? opt_array : [];
        if (_this.unique_) for(var i = 0, ii = _this.array_.length; i < ii; ++i)_this.assertUnique_(_this.array_[i], i);
        _this.updateLength_();
        return _this;
    }
    /**
     * Remove all elements from the collection.
     * @api
     */ Collection2.prototype.clear = function() {
        while(this.getLength() > 0)this.pop();
    };
    /**
     * Add elements to the collection.  This pushes each item in the provided array
     * to the end of the collection.
     * @param {!Array<T>} arr Array.
     * @return {Collection<T>} This collection.
     * @api
     */ Collection2.prototype.extend = function(arr) {
        for(var i = 0, ii = arr.length; i < ii; ++i)this.push(arr[i]);
        return this;
    };
    /**
     * Iterate over each element, calling the provided callback.
     * @param {function(T, number, Array<T>): *} f The function to call
     *     for every element. This function takes 3 arguments (the element, the
     *     index and the array). The return value is ignored.
     * @api
     */ Collection2.prototype.forEach = function(f) {
        var array = this.array_;
        for(var i = 0, ii = array.length; i < ii; ++i)f(array[i], i, array);
    };
    /**
     * Get a reference to the underlying Array object. Warning: if the array
     * is mutated, no events will be dispatched by the collection, and the
     * collection's "length" property won't be in sync with the actual length
     * of the array.
     * @return {!Array<T>} Array.
     * @api
     */ Collection2.prototype.getArray = function() {
        return this.array_;
    };
    /**
     * Get the element at the provided index.
     * @param {number} index Index.
     * @return {T} Element.
     * @api
     */ Collection2.prototype.item = function(index) {
        return this.array_[index];
    };
    /**
     * Get the length of this collection.
     * @return {number} The length of the array.
     * @observable
     * @api
     */ Collection2.prototype.getLength = function() {
        return this.get(Property.LENGTH);
    };
    /**
     * Insert an element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */ Collection2.prototype.insertAt = function(index, elem) {
        if (this.unique_) this.assertUnique_(elem);
        this.array_.splice(index, 0, elem);
        this.updateLength_();
        this.dispatchEvent(new CollectionEvent1(_collectionEventTypeJsDefault.default.ADD, elem, index));
    };
    /**
     * Remove the last element of the collection and return it.
     * Return `undefined` if the collection is empty.
     * @return {T|undefined} Element.
     * @api
     */ Collection2.prototype.pop = function() {
        return this.removeAt(this.getLength() - 1);
    };
    /**
     * Insert the provided element at the end of the collection.
     * @param {T} elem Element.
     * @return {number} New length of the collection.
     * @api
     */ Collection2.prototype.push = function(elem) {
        if (this.unique_) this.assertUnique_(elem);
        var n = this.getLength();
        this.insertAt(n, elem);
        return this.getLength();
    };
    /**
     * Remove the first occurrence of an element from the collection.
     * @param {T} elem Element.
     * @return {T|undefined} The removed element or undefined if none found.
     * @api
     */ Collection2.prototype.remove = function(elem) {
        var arr = this.array_;
        for(var i = 0, ii = arr.length; i < ii; ++i){
            if (arr[i] === elem) return this.removeAt(i);
        }
        return undefined;
    };
    /**
     * Remove the element at the provided index and return it.
     * Return `undefined` if the collection does not contain this index.
     * @param {number} index Index.
     * @return {T|undefined} Value.
     * @api
     */ Collection2.prototype.removeAt = function(index) {
        var prev = this.array_[index];
        this.array_.splice(index, 1);
        this.updateLength_();
        this.dispatchEvent(new CollectionEvent1(_collectionEventTypeJsDefault.default.REMOVE, prev, index));
        return prev;
    };
    /**
     * Set the element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */ Collection2.prototype.setAt = function(index, elem) {
        var n = this.getLength();
        if (index < n) {
            if (this.unique_) this.assertUnique_(elem, index);
            var prev = this.array_[index];
            this.array_[index] = elem;
            this.dispatchEvent(new CollectionEvent1(_collectionEventTypeJsDefault.default.REMOVE, prev, index));
            this.dispatchEvent(new CollectionEvent1(_collectionEventTypeJsDefault.default.ADD, elem, index));
        } else {
            for(var j = n; j < index; ++j)this.insertAt(j, undefined);
            this.insertAt(index, elem);
        }
    };
    /**
     * @private
     */ Collection2.prototype.updateLength_ = function() {
        this.set(Property.LENGTH, this.array_.length);
    };
    /**
     * @private
     * @param {T} elem Element.
     * @param {number} [opt_except] Optional index to ignore.
     */ Collection2.prototype.assertUnique_ = function(elem, opt_except) {
        for(var i = 0, ii = this.array_.length; i < ii; ++i){
            if (this.array_[i] === elem && i !== opt_except) throw new _assertionErrorJsDefault.default(58);
        }
    };
    return Collection2;
}(_objectJsDefault.default);
exports.default = Collection1;

},{"./AssertionError.js":"6D6Dt","./Object.js":"3roCV","./CollectionEventType.js":"jxyhy","./events/Event.js":"7AR9n","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jxyhy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
     * Triggered when an item is added to the collection.
     * @event module:ol/Collection.CollectionEvent#add
     * @api
     */ ADD: 'add',
    /**
     * Triggered when an item is removed from the collection.
     * @event module:ol/Collection.CollectionEvent#remove
     * @api
     */ REMOVE: 'remove'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"gxl7q":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/layer/Group
 */ var _baseJs = require("./Base.js");
var _baseJsDefault = parcelHelpers.interopDefault(_baseJs);
var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _collectionEventTypeJs = require("../CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _objectEventTypeJs = require("../ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _stateJs = require("../source/State.js");
var _stateJsDefault = parcelHelpers.interopDefault(_stateJs);
var _assertsJs = require("../asserts.js");
var _objJs = require("../obj.js");
var _extentJs = require("../extent.js");
var _utilJs = require("../util.js");
var _eventsJs = require("../events.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:layers', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:layers', Return>} GroupOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<import("./Base.js").default>|import("../Collection.js").default<import("./Base.js").default>} [layers] Child layers.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @enum {string}
 * @private
 */ var Property = {
    LAYERS: 'layers'
};
/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */ var LayerGroup1 = function(_super) {
    __extends(LayerGroup2, _super);
    /**
     * @param {Options} [opt_options] Layer options.
     */ function LayerGroup2(opt_options) {
        var _this = this;
        var options = opt_options || {
        };
        var baseOptions = _objJs.assign({
        }, options);
        delete baseOptions.layers;
        var layers = options.layers;
        _this = _super.call(this, baseOptions) || this;
        /***
         * @type {GroupOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {GroupOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {GroupOnSignature<void>}
         */ _this.un;
        /**
         * @private
         * @type {Array<import("../events.js").EventsKey>}
         */ _this.layersListenerKeys_ = [];
        /**
         * @private
         * @type {Object<string, Array<import("../events.js").EventsKey>>}
         */ _this.listenerKeys_ = {
        };
        _this.addChangeListener(Property.LAYERS, _this.handleLayersChanged_);
        if (layers) {
            if (Array.isArray(layers)) layers = new _collectionJsDefault.default(layers.slice(), {
                unique: true
            });
            else _assertsJs.assert(typeof /** @type {?} */ layers.getArray === 'function', 43); // Expected `layers` to be an array or a `Collection`
        } else layers = new _collectionJsDefault.default(undefined, {
            unique: true
        });
        _this.setLayers(layers);
        return _this;
    }
    /**
     * @private
     */ LayerGroup2.prototype.handleLayerChange_ = function() {
        this.changed();
    };
    /**
     * @private
     */ LayerGroup2.prototype.handleLayersChanged_ = function() {
        this.layersListenerKeys_.forEach(_eventsJs.unlistenByKey);
        this.layersListenerKeys_.length = 0;
        var layers = this.getLayers();
        this.layersListenerKeys_.push(_eventsJs.listen(layers, _collectionEventTypeJsDefault.default.ADD, this.handleLayersAdd_, this), _eventsJs.listen(layers, _collectionEventTypeJsDefault.default.REMOVE, this.handleLayersRemove_, this));
        for(var id in this.listenerKeys_)this.listenerKeys_[id].forEach(_eventsJs.unlistenByKey);
        _objJs.clear(this.listenerKeys_);
        var layersArray = layers.getArray();
        for(var i = 0, ii = layersArray.length; i < ii; i++){
            var layer = layersArray[i];
            this.listenerKeys_[_utilJs.getUid(layer)] = [
                _eventsJs.listen(layer, _objectEventTypeJsDefault.default.PROPERTYCHANGE, this.handleLayerChange_, this),
                _eventsJs.listen(layer, _eventTypeJsDefault.default.CHANGE, this.handleLayerChange_, this), 
            ];
        }
        this.changed();
    };
    /**
     * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
     * @private
     */ LayerGroup2.prototype.handleLayersAdd_ = function(collectionEvent) {
        var layer = collectionEvent.element;
        this.listenerKeys_[_utilJs.getUid(layer)] = [
            _eventsJs.listen(layer, _objectEventTypeJsDefault.default.PROPERTYCHANGE, this.handleLayerChange_, this),
            _eventsJs.listen(layer, _eventTypeJsDefault.default.CHANGE, this.handleLayerChange_, this), 
        ];
        this.changed();
    };
    /**
     * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
     * @private
     */ LayerGroup2.prototype.handleLayersRemove_ = function(collectionEvent) {
        var layer = collectionEvent.element;
        var key = _utilJs.getUid(layer);
        this.listenerKeys_[key].forEach(_eventsJs.unlistenByKey);
        delete this.listenerKeys_[key];
        this.changed();
    };
    /**
     * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @return {!import("../Collection.js").default<import("./Base.js").default>} Collection of
     *   {@link module:ol/layer/Base layers} that are part of this group.
     * @observable
     * @api
     */ LayerGroup2.prototype.getLayers = function() {
        return this.get(Property.LAYERS);
    };
    /**
     * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @param {!import("../Collection.js").default<import("./Base.js").default>} layers Collection of
     *   {@link module:ol/layer/Base layers} that are part of this group.
     * @observable
     * @api
     */ LayerGroup2.prototype.setLayers = function(layers) {
        this.set(Property.LAYERS, layers);
    };
    /**
     * @param {Array<import("./Layer.js").default>} [opt_array] Array of layers (to be modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */ LayerGroup2.prototype.getLayersArray = function(opt_array) {
        var array = opt_array !== undefined ? opt_array : [];
        this.getLayers().forEach(function(layer) {
            layer.getLayersArray(array);
        });
        return array;
    };
    /**
     * Get the layer states list and use this groups z-index as the default
     * for all layers in this and nested groups, if it is unset at this point.
     * If opt_states is not provided and this group's z-index is undefined
     * 0 is used a the default z-index.
     * @param {Array<import("./Layer.js").State>} [opt_states] Optional list
     * of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */ LayerGroup2.prototype.getLayerStatesArray = function(opt_states) {
        var states = opt_states !== undefined ? opt_states : [];
        var pos = states.length;
        this.getLayers().forEach(function(layer) {
            layer.getLayerStatesArray(states);
        });
        var ownLayerState = this.getLayerState();
        var defaultZIndex = ownLayerState.zIndex;
        if (!opt_states && ownLayerState.zIndex === undefined) defaultZIndex = 0;
        for(var i = pos, ii = states.length; i < ii; i++){
            var layerState = states[i];
            layerState.opacity *= ownLayerState.opacity;
            layerState.visible = layerState.visible && ownLayerState.visible;
            layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
            layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
            layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
            layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
            if (ownLayerState.extent !== undefined) {
                if (layerState.extent !== undefined) layerState.extent = _extentJs.getIntersection(layerState.extent, ownLayerState.extent);
                else layerState.extent = ownLayerState.extent;
            }
            if (layerState.zIndex === undefined) layerState.zIndex = defaultZIndex;
        }
        return states;
    };
    /**
     * @return {import("../source/State.js").default} Source state.
     */ LayerGroup2.prototype.getSourceState = function() {
        return _stateJsDefault.default.READY;
    };
    return LayerGroup2;
}(_baseJsDefault.default);
exports.default = LayerGroup1;

},{"./Base.js":"fS38x","../Collection.js":"d2f3b","../CollectionEventType.js":"jxyhy","../events/EventType.js":"83vee","../ObjectEventType.js":"j6hH6","../source/State.js":"hpoq1","../asserts.js":"cnrP4","../obj.js":"g3fPg","../extent.js":"jgUz2","../util.js":"9zOhk","../events.js":"e9Qqr","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"8kc32":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/MapBrowserEvent
 */ var _mapEventJs = require("./MapEvent.js");
var _mapEventJsDefault = parcelHelpers.interopDefault(_mapEventJs);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map browser event.
 * @template {UIEvent} EVENT
 */ var MapBrowserEvent1 = function(_super) {
    __extends(MapBrowserEvent2, _super);
    /**
     * @param {string} type Event type.
     * @param {import("./PluggableMap.js").default} map Map.
     * @param {EVENT} originalEvent Original event.
     * @param {boolean} [opt_dragging] Is the map currently being dragged?
     * @param {?import("./PluggableMap.js").FrameState} [opt_frameState] Frame state.
     */ function MapBrowserEvent2(type, map, originalEvent, opt_dragging, opt_frameState) {
        var _this = _super.call(this, type, map, opt_frameState) || this;
        /**
         * The original browser event.
         * @const
         * @type {EVENT}
         * @api
         */ _this.originalEvent = originalEvent;
        /**
         * The map pixel relative to the viewport corresponding to the original browser event.
         * @type {?import("./pixel.js").Pixel}
         */ _this.pixel_ = null;
        /**
         * The coordinate in the user projection corresponding to the original browser event.
         * @type {?import("./coordinate.js").Coordinate}
         */ _this.coordinate_ = null;
        /**
         * Indicates if the map is currently being dragged. Only set for
         * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
         *
         * @type {boolean}
         * @api
         */ _this.dragging = opt_dragging !== undefined ? opt_dragging : false;
        return _this;
    }
    Object.defineProperty(MapBrowserEvent2.prototype, "pixel", {
        /**
         * The map pixel relative to the viewport corresponding to the original event.
         * @type {import("./pixel.js").Pixel}
         * @api
         */ get: function() {
            if (!this.pixel_) this.pixel_ = this.map.getEventPixel(this.originalEvent);
            return this.pixel_;
        },
        set: function(pixel) {
            this.pixel_ = pixel;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MapBrowserEvent2.prototype, "coordinate", {
        /**
         * The coordinate corresponding to the original browser event.  This will be in the user
         * projection if one is set.  Otherwise it will be in the view projection.
         * @type {import("./coordinate.js").Coordinate}
         * @api
         */ get: function() {
            if (!this.coordinate_) this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
            return this.coordinate_;
        },
        set: function(coordinate) {
            this.coordinate_ = coordinate;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Prevents the default browser action.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
     * @api
     */ MapBrowserEvent2.prototype.preventDefault = function() {
        _super.prototype.preventDefault.call(this);
        if ('preventDefault' in this.originalEvent) /** @type {UIEvent} */ this.originalEvent.preventDefault();
    };
    /**
     * Prevents further propagation of the current event.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
     * @api
     */ MapBrowserEvent2.prototype.stopPropagation = function() {
        _super.prototype.stopPropagation.call(this);
        if ('stopPropagation' in this.originalEvent) /** @type {UIEvent} */ this.originalEvent.stopPropagation();
    };
    return MapBrowserEvent2;
}(_mapEventJsDefault.default);
exports.default = MapBrowserEvent1;

},{"./MapEvent.js":"7dx8e","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7dx8e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/MapEvent
 */ var _eventJs = require("./events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map event.
 */ var MapEvent1 = function(_super) {
    __extends(MapEvent2, _super);
    /**
     * @param {string} type Event type.
     * @param {import("./PluggableMap.js").default} map Map.
     * @param {?import("./PluggableMap.js").FrameState} [opt_frameState] Frame state.
     */ function MapEvent2(type, map, opt_frameState) {
        var _this = _super.call(this, type) || this;
        /**
         * The map where the event occurred.
         * @type {import("./PluggableMap.js").default}
         * @api
         */ _this.map = map;
        /**
         * The frame state at the time of the event.
         * @type {?import("./PluggableMap.js").FrameState}
         * @api
         */ _this.frameState = opt_frameState !== undefined ? opt_frameState : null;
        return _this;
    }
    return MapEvent2;
}(_eventJsDefault.default);
exports.default = MapEvent1;

},{"./events/Event.js":"7AR9n","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"iN1Ja":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _mapBrowserEventJs = require("./MapBrowserEvent.js");
var _mapBrowserEventJsDefault = parcelHelpers.interopDefault(_mapBrowserEventJs);
var _mapBrowserEventTypeJs = require("./MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _eventTypeJs1 = require("./pointer/EventType.js");
var _eventTypeJsDefault1 = parcelHelpers.interopDefault(_eventTypeJs1);
var _targetJs = require("./events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _hasJs = require("./has.js");
var _functionsJs = require("./functions.js");
var _eventsJs = require("./events.js");
/**
 * @module ol/MapBrowserEventHandler
 */ var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var MapBrowserEventHandler1 = function(_super) {
    __extends(MapBrowserEventHandler2, _super);
    /**
     * @param {import("./PluggableMap.js").default} map The map with the viewport to listen to events on.
     * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
     */ function MapBrowserEventHandler2(map, moveTolerance) {
        var _this = _super.call(this, map) || this;
        /**
         * This is the element that we will listen to the real events on.
         * @type {import("./PluggableMap.js").default}
         * @private
         */ _this.map_ = map;
        /**
         * @type {any}
         * @private
         */ _this.clickTimeoutId_;
        /**
         * Emulate dblclick and singleclick. Will be true when only one pointer is active.
         * @type {boolean}
         */ _this.emulateClicks_ = false;
        /**
         * @type {boolean}
         * @private
         */ _this.dragging_ = false;
        /**
         * @type {!Array<import("./events.js").EventsKey>}
         * @private
         */ _this.dragListenerKeys_ = [];
        /**
         * @type {number}
         * @private
         */ _this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;
        /**
         * The most recent "down" type event (or null if none have occurred).
         * Set on pointerdown.
         * @type {PointerEvent}
         * @private
         */ _this.down_ = null;
        var element = _this.map_.getViewport();
        /**
         * @type {number}
         * @private
         */ _this.activePointers_ = 0;
        /**
         * @type {!Object<number, boolean>}
         * @private
         */ _this.trackedTouches_ = {
        };
        _this.element_ = element;
        /**
         * @type {?import("./events.js").EventsKey}
         * @private
         */ _this.pointerdownListenerKey_ = _eventsJs.listen(element, _eventTypeJsDefault1.default.POINTERDOWN, _this.handlePointerDown_, _this);
        /**
         * @type {PointerEvent}
         * @private
         */ _this.originalPointerMoveEvent_;
        /**
         * @type {?import("./events.js").EventsKey}
         * @private
         */ _this.relayedListenerKey_ = _eventsJs.listen(element, _eventTypeJsDefault1.default.POINTERMOVE, _this.relayEvent_, _this);
        /**
         * @private
         */ _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);
        _this.element_.addEventListener(_eventTypeJsDefault.default.TOUCHMOVE, _this.boundHandleTouchMove_, _hasJs.PASSIVE_EVENT_LISTENERS ? {
            passive: false
        } : false);
        return _this;
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */ MapBrowserEventHandler2.prototype.emulateClick_ = function(pointerEvent) {
        var newEvent = new _mapBrowserEventJsDefault.default(_mapBrowserEventTypeJsDefault.default.CLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
        if (this.clickTimeoutId_ !== undefined) {
            // double-click
            clearTimeout(this.clickTimeoutId_);
            this.clickTimeoutId_ = undefined;
            newEvent = new _mapBrowserEventJsDefault.default(_mapBrowserEventTypeJsDefault.default.DBLCLICK, this.map_, pointerEvent);
            this.dispatchEvent(newEvent);
        } else // click
        this.clickTimeoutId_ = setTimeout(/** @this {MapBrowserEventHandler} */ (function() {
            this.clickTimeoutId_ = undefined;
            var newEvent1 = new _mapBrowserEventJsDefault.default(_mapBrowserEventTypeJsDefault.default.SINGLECLICK, this.map_, pointerEvent);
            this.dispatchEvent(newEvent1);
        }).bind(this), 250);
    };
    /**
     * Keeps track on how many pointers are currently active.
     *
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */ MapBrowserEventHandler2.prototype.updateActivePointers_ = function(pointerEvent) {
        var event = pointerEvent;
        if (event.type == _mapBrowserEventTypeJsDefault.default.POINTERUP || event.type == _mapBrowserEventTypeJsDefault.default.POINTERCANCEL) delete this.trackedTouches_[event.pointerId];
        else if (event.type == _mapBrowserEventTypeJsDefault.default.POINTERDOWN) this.trackedTouches_[event.pointerId] = true;
        this.activePointers_ = Object.keys(this.trackedTouches_).length;
    };
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */ MapBrowserEventHandler2.prototype.handlePointerUp_ = function(pointerEvent) {
        this.updateActivePointers_(pointerEvent);
        var newEvent = new _mapBrowserEventJsDefault.default(_mapBrowserEventTypeJsDefault.default.POINTERUP, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
        // We emulate click events on left mouse button click, touch contact, and pen
        // contact. isMouseActionButton returns true in these cases (evt.button is set
        // to 0).
        // See http://www.w3.org/TR/pointerevents/#button-states
        // We only fire click, singleclick, and doubleclick if nobody has called
        // event.preventDefault().
        if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) this.emulateClick_(this.down_);
        if (this.activePointers_ === 0) {
            this.dragListenerKeys_.forEach(_eventsJs.unlistenByKey);
            this.dragListenerKeys_.length = 0;
            this.dragging_ = false;
            this.down_ = null;
        }
    };
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} If the left mouse button was pressed.
     * @private
     */ MapBrowserEventHandler2.prototype.isMouseActionButton_ = function(pointerEvent) {
        return pointerEvent.button === 0;
    };
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */ MapBrowserEventHandler2.prototype.handlePointerDown_ = function(pointerEvent) {
        this.emulateClicks_ = this.activePointers_ === 0;
        this.updateActivePointers_(pointerEvent);
        var newEvent = new _mapBrowserEventJsDefault.default(_mapBrowserEventTypeJsDefault.default.POINTERDOWN, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
        // Store a copy of the down event
        this.down_ = {
        };
        for(var property in pointerEvent){
            var value = pointerEvent[property];
            this.down_[property] = typeof value === 'function' ? _functionsJs.VOID : value;
        }
        if (this.dragListenerKeys_.length === 0) {
            var doc = this.map_.getOwnerDocument();
            this.dragListenerKeys_.push(_eventsJs.listen(doc, _mapBrowserEventTypeJsDefault.default.POINTERMOVE, this.handlePointerMove_, this), _eventsJs.listen(doc, _mapBrowserEventTypeJsDefault.default.POINTERUP, this.handlePointerUp_, this), /* Note that the listener for `pointercancel is set up on
             * `pointerEventHandler_` and not `documentPointerEventHandler_` like
             * the `pointerup` and `pointermove` listeners.
             *
             * The reason for this is the following: `TouchSource.vacuumTouches_()`
             * issues `pointercancel` events, when there was no `touchend` for a
             * `touchstart`. Now, let's say a first `touchstart` is registered on
             * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
             * But `documentPointerEventHandler_` doesn't know about the first
             * `touchstart`. If there is no `touchend` for the `touchstart`, we can
             * only receive a `touchcancel` from `pointerEventHandler_`, because it is
             * only registered there.
             */ _eventsJs.listen(this.element_, _mapBrowserEventTypeJsDefault.default.POINTERCANCEL, this.handlePointerUp_, this));
            if (this.element_.getRootNode && this.element_.getRootNode() !== doc) this.dragListenerKeys_.push(_eventsJs.listen(this.element_.getRootNode(), _mapBrowserEventTypeJsDefault.default.POINTERUP, this.handlePointerUp_, this));
        }
    };
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */ MapBrowserEventHandler2.prototype.handlePointerMove_ = function(pointerEvent) {
        // Between pointerdown and pointerup, pointermove events are triggered.
        // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
        // moved a significant distance.
        if (this.isMoving_(pointerEvent)) {
            this.dragging_ = true;
            var newEvent = new _mapBrowserEventJsDefault.default(_mapBrowserEventTypeJsDefault.default.POINTERDRAG, this.map_, pointerEvent, this.dragging_);
            this.dispatchEvent(newEvent);
        }
    };
    /**
     * Wrap and relay a pointer event.  Note that this requires that the type
     * string for the MapBrowserEvent matches the PointerEvent type.
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */ MapBrowserEventHandler2.prototype.relayEvent_ = function(pointerEvent) {
        this.originalPointerMoveEvent_ = pointerEvent;
        var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
        this.dispatchEvent(new _mapBrowserEventJsDefault.default(pointerEvent.type, this.map_, pointerEvent, dragging));
    };
    /**
     * Flexible handling of a `touch-action: none` css equivalent: because calling
     * `preventDefault()` on a `pointermove` event does not stop native page scrolling
     * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
     * when an interaction (currently `DragPan` handles the event.
     * @param {TouchEvent} event Event.
     * @private
     */ MapBrowserEventHandler2.prototype.handleTouchMove_ = function(event) {
        // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
        // may not be initialized yet when we get here on a platform without native pointer events.
        var originalEvent = this.originalPointerMoveEvent_;
        if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== 'boolean' || event.cancelable === true)) event.preventDefault();
    };
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} Is moving.
     * @private
     */ MapBrowserEventHandler2.prototype.isMoving_ = function(pointerEvent) {
        return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
    };
    /**
     * Clean up.
     */ MapBrowserEventHandler2.prototype.disposeInternal = function() {
        if (this.relayedListenerKey_) {
            _eventsJs.unlistenByKey(this.relayedListenerKey_);
            this.relayedListenerKey_ = null;
        }
        this.element_.removeEventListener(_eventTypeJsDefault.default.TOUCHMOVE, this.boundHandleTouchMove_);
        if (this.pointerdownListenerKey_) {
            _eventsJs.unlistenByKey(this.pointerdownListenerKey_);
            this.pointerdownListenerKey_ = null;
        }
        this.dragListenerKeys_.forEach(_eventsJs.unlistenByKey);
        this.dragListenerKeys_.length = 0;
        this.element_ = null;
        _super.prototype.disposeInternal.call(this);
    };
    return MapBrowserEventHandler2;
}(_targetJsDefault.default);
exports.default = MapBrowserEventHandler1;

},{"./events/EventType.js":"83vee","./MapBrowserEvent.js":"8kc32","./MapBrowserEventType.js":"coXRZ","./pointer/EventType.js":"3XFPg","./events/Target.js":"dj5zz","./has.js":"cdiSc","./functions.js":"d72zA","./events.js":"e9Qqr","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"coXRZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/MapBrowserEventType
 */ var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
exports.default = {
    /**
     * A true single click with no dragging and no double click. Note that this
     * event is delayed by 250 ms to ensure that it is not a double click.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
     * @api
     */ SINGLECLICK: 'singleclick',
    /**
     * A click with no dragging. A double click will fire two of this.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
     * @api
     */ CLICK: _eventTypeJsDefault.default.CLICK,
    /**
     * A true double click, with no dragging.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
     * @api
     */ DBLCLICK: _eventTypeJsDefault.default.DBLCLICK,
    /**
     * Triggered when a pointer is dragged.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
     * @api
     */ POINTERDRAG: 'pointerdrag',
    /**
     * Triggered when a pointer is moved. Note that on touch devices this is
     * triggered when the map is panned, so is not the same as mousemove.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
     * @api
     */ POINTERMOVE: 'pointermove',
    POINTERDOWN: 'pointerdown',
    POINTERUP: 'pointerup',
    POINTEROVER: 'pointerover',
    POINTEROUT: 'pointerout',
    POINTERENTER: 'pointerenter',
    POINTERLEAVE: 'pointerleave',
    POINTERCANCEL: 'pointercancel'
}; /***
 * @typedef {'singleclick'|'click'|'dblclick'|'pointerdrag'|'pointermove'} Types
 */ 

},{"./events/EventType.js":"83vee","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3XFPg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    POINTERMOVE: 'pointermove',
    POINTERDOWN: 'pointerdown',
    POINTERUP: 'pointerup',
    POINTEROVER: 'pointerover',
    POINTEROUT: 'pointerout',
    POINTERENTER: 'pointerenter',
    POINTERLEAVE: 'pointerleave',
    POINTERCANCEL: 'pointercancel'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eYKj9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
     * Triggered after a map frame is rendered.
     * @event module:ol/MapEvent~MapEvent#postrender
     * @api
     */ POSTRENDER: 'postrender',
    /**
     * Triggered when the map starts moving.
     * @event module:ol/MapEvent~MapEvent#movestart
     * @api
     */ MOVESTART: 'movestart',
    /**
     * Triggered after the map is moved.
     * @event module:ol/MapEvent~MapEvent#moveend
     * @api
     */ MOVEEND: 'moveend'
}; /***
 * @typedef {'postrender'|'movestart'|'moveend'} Types
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jNLVu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    LAYERGROUP: 'layergroup',
    SIZE: 'size',
    TARGET: 'target',
    VIEW: 'view'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"2r09E":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import('./PluggableMap.js').FrameState} frameState Frame state.
 * @param {import("./Tile.js").default} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */ parcelHelpers.export(exports, "getTilePriority", ()=>getTilePriority
);
/**
 * @module ol/TileQueue
 */ var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _priorityQueueJs = require("./structs/PriorityQueue.js");
var _priorityQueueJsDefault = parcelHelpers.interopDefault(_priorityQueueJs);
var _tileStateJs = require("./TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
 */ var TileQueue1 = function(_super) {
    __extends(TileQueue2, _super);
    /**
     * @param {PriorityFunction} tilePriorityFunction Tile priority function.
     * @param {function(): ?} tileChangeCallback Function called on each tile change event.
     */ function TileQueue2(tilePriorityFunction, tileChangeCallback) {
        var _this = _super.call(this, /**
         * @param {Array} element Element.
         * @return {number} Priority.
         */ function(element) {
            return tilePriorityFunction.apply(null, element);
        }, /**
         * @param {Array} element Element.
         * @return {string} Key.
         */ function(element) {
            return(/** @type {import("./Tile.js").default} */ element[0].getKey());
        }) || this;
        /** @private */ _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);
        /**
         * @private
         * @type {function(): ?}
         */ _this.tileChangeCallback_ = tileChangeCallback;
        /**
         * @private
         * @type {number}
         */ _this.tilesLoading_ = 0;
        /**
         * @private
         * @type {!Object<string,boolean>}
         */ _this.tilesLoadingKeys_ = {
        };
        return _this;
    }
    /**
     * @param {Array} element Element.
     * @return {boolean} The element was added to the queue.
     */ TileQueue2.prototype.enqueue = function(element) {
        var added = _super.prototype.enqueue.call(this, element);
        if (added) {
            var tile = element[0];
            tile.addEventListener(_eventTypeJsDefault.default.CHANGE, this.boundHandleTileChange_);
        }
        return added;
    };
    /**
     * @return {number} Number of tiles loading.
     */ TileQueue2.prototype.getTilesLoading = function() {
        return this.tilesLoading_;
    };
    /**
     * @param {import("./events/Event.js").default} event Event.
     * @protected
     */ TileQueue2.prototype.handleTileChange = function(event) {
        var tile = event.target;
        var state = tile.getState();
        if (state === _tileStateJsDefault.default.LOADED || state === _tileStateJsDefault.default.ERROR || state === _tileStateJsDefault.default.EMPTY) {
            tile.removeEventListener(_eventTypeJsDefault.default.CHANGE, this.boundHandleTileChange_);
            var tileKey = tile.getKey();
            if (tileKey in this.tilesLoadingKeys_) {
                delete this.tilesLoadingKeys_[tileKey];
                --this.tilesLoading_;
            }
            this.tileChangeCallback_();
        }
    };
    /**
     * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
     * @param {number} maxNewLoads Maximum number of new tiles to load.
     */ TileQueue2.prototype.loadMoreTiles = function(maxTotalLoading, maxNewLoads) {
        var newLoads = 0;
        var state, tile, tileKey;
        while(this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0){
            tile = this.dequeue()[0];
            tileKey = tile.getKey();
            state = tile.getState();
            if (state === _tileStateJsDefault.default.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
                this.tilesLoadingKeys_[tileKey] = true;
                ++this.tilesLoading_;
                ++newLoads;
                tile.load();
            }
        }
    };
    return TileQueue2;
}(_priorityQueueJsDefault.default);
exports.default = TileQueue1;
function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
    // Filter out tiles at higher zoom levels than the current zoom level, or that
    // are outside the visible extent.
    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) return _priorityQueueJs.DROP;
    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) return _priorityQueueJs.DROP;
    // Prioritize the highest zoom level tiles closest to the focus.
    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
    // Within a zoom level, tiles are prioritized by the distance in pixels between
    // the center of the tile and the center of the viewport.  The factor of 65536
    // means that the prioritization should behave as desired for tiles up to
    // 65536 * Math.log(2) = 45426 pixels from the focus.
    var center = frameState.viewState.center;
    var deltaX = tileCenter[0] - center[0];
    var deltaY = tileCenter[1] - center[1];
    return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}

},{"./events/EventType.js":"83vee","./structs/PriorityQueue.js":"iooGQ","./TileState.js":"eIJIE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"iooGQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DROP", ()=>DROP
);
/**
 * @module ol/structs/PriorityQueue
 */ var _assertsJs = require("../asserts.js");
var _objJs = require("../obj.js");
var DROP = Infinity;
/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See https://github.com/google/closure-library/blob/master/closure/goog/structs/heap.js
 * and https://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */ var PriorityQueue = function() {
    /**
     * @param {function(T): number} priorityFunction Priority function.
     * @param {function(T): string} keyFunction Key function.
     */ function PriorityQueue1(priorityFunction, keyFunction) {
        /**
         * @type {function(T): number}
         * @private
         */ this.priorityFunction_ = priorityFunction;
        /**
         * @type {function(T): string}
         * @private
         */ this.keyFunction_ = keyFunction;
        /**
         * @type {Array<T>}
         * @private
         */ this.elements_ = [];
        /**
         * @type {Array<number>}
         * @private
         */ this.priorities_ = [];
        /**
         * @type {!Object<string, boolean>}
         * @private
         */ this.queuedElements_ = {
        };
    }
    /**
     * FIXME empty description for jsdoc
     */ PriorityQueue1.prototype.clear = function() {
        this.elements_.length = 0;
        this.priorities_.length = 0;
        _objJs.clear(this.queuedElements_);
    };
    /**
     * Remove and return the highest-priority element. O(log N).
     * @return {T} Element.
     */ PriorityQueue1.prototype.dequeue = function() {
        var elements = this.elements_;
        var priorities = this.priorities_;
        var element = elements[0];
        if (elements.length == 1) {
            elements.length = 0;
            priorities.length = 0;
        } else {
            elements[0] = elements.pop();
            priorities[0] = priorities.pop();
            this.siftUp_(0);
        }
        var elementKey = this.keyFunction_(element);
        delete this.queuedElements_[elementKey];
        return element;
    };
    /**
     * Enqueue an element. O(log N).
     * @param {T} element Element.
     * @return {boolean} The element was added to the queue.
     */ PriorityQueue1.prototype.enqueue = function(element) {
        _assertsJs.assert(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue
        var priority = this.priorityFunction_(element);
        if (priority != DROP) {
            this.elements_.push(element);
            this.priorities_.push(priority);
            this.queuedElements_[this.keyFunction_(element)] = true;
            this.siftDown_(0, this.elements_.length - 1);
            return true;
        }
        return false;
    };
    /**
     * @return {number} Count.
     */ PriorityQueue1.prototype.getCount = function() {
        return this.elements_.length;
    };
    /**
     * Gets the index of the left child of the node at the given index.
     * @param {number} index The index of the node to get the left child for.
     * @return {number} The index of the left child.
     * @private
     */ PriorityQueue1.prototype.getLeftChildIndex_ = function(index) {
        return index * 2 + 1;
    };
    /**
     * Gets the index of the right child of the node at the given index.
     * @param {number} index The index of the node to get the right child for.
     * @return {number} The index of the right child.
     * @private
     */ PriorityQueue1.prototype.getRightChildIndex_ = function(index) {
        return index * 2 + 2;
    };
    /**
     * Gets the index of the parent of the node at the given index.
     * @param {number} index The index of the node to get the parent for.
     * @return {number} The index of the parent.
     * @private
     */ PriorityQueue1.prototype.getParentIndex_ = function(index) {
        return index - 1 >> 1;
    };
    /**
     * Make this a heap. O(N).
     * @private
     */ PriorityQueue1.prototype.heapify_ = function() {
        var i;
        for(i = (this.elements_.length >> 1) - 1; i >= 0; i--)this.siftUp_(i);
    };
    /**
     * @return {boolean} Is empty.
     */ PriorityQueue1.prototype.isEmpty = function() {
        return this.elements_.length === 0;
    };
    /**
     * @param {string} key Key.
     * @return {boolean} Is key queued.
     */ PriorityQueue1.prototype.isKeyQueued = function(key) {
        return key in this.queuedElements_;
    };
    /**
     * @param {T} element Element.
     * @return {boolean} Is queued.
     */ PriorityQueue1.prototype.isQueued = function(element) {
        return this.isKeyQueued(this.keyFunction_(element));
    };
    /**
     * @param {number} index The index of the node to move down.
     * @private
     */ PriorityQueue1.prototype.siftUp_ = function(index) {
        var elements = this.elements_;
        var priorities = this.priorities_;
        var count = elements.length;
        var element = elements[index];
        var priority = priorities[index];
        var startIndex = index;
        while(index < count >> 1){
            var lIndex = this.getLeftChildIndex_(index);
            var rIndex = this.getRightChildIndex_(index);
            var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
            elements[index] = elements[smallerChildIndex];
            priorities[index] = priorities[smallerChildIndex];
            index = smallerChildIndex;
        }
        elements[index] = element;
        priorities[index] = priority;
        this.siftDown_(startIndex, index);
    };
    /**
     * @param {number} startIndex The index of the root.
     * @param {number} index The index of the node to move up.
     * @private
     */ PriorityQueue1.prototype.siftDown_ = function(startIndex, index) {
        var elements = this.elements_;
        var priorities = this.priorities_;
        var element = elements[index];
        var priority = priorities[index];
        while(index > startIndex){
            var parentIndex = this.getParentIndex_(index);
            if (priorities[parentIndex] > priority) {
                elements[index] = elements[parentIndex];
                priorities[index] = priorities[parentIndex];
                index = parentIndex;
            } else break;
        }
        elements[index] = element;
        priorities[index] = priority;
    };
    /**
     * FIXME empty description for jsdoc
     */ PriorityQueue1.prototype.reprioritize = function() {
        var priorityFunction = this.priorityFunction_;
        var elements = this.elements_;
        var priorities = this.priorities_;
        var index = 0;
        var n = elements.length;
        var element, i, priority;
        for(i = 0; i < n; ++i){
            element = elements[i];
            priority = priorityFunction(element);
            if (priority == DROP) delete this.queuedElements_[this.keyFunction_(element)];
            else {
                priorities[index] = priority;
                elements[index++] = element;
            }
        }
        elements.length = index;
        priorities.length = index;
        this.heapify_();
    };
    return PriorityQueue1;
}();
exports.default = PriorityQueue;

},{"../asserts.js":"cnrP4","../obj.js":"g3fPg","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9RaqO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {ViewOptions} options View options.
 * @return {import("./centerconstraint.js").Type} The constraint.
 */ parcelHelpers.export(exports, "createCenterConstraint", ()=>createCenterConstraint
);
/**
 * @param {ViewOptions} options View options.
 * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
 *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
 */ parcelHelpers.export(exports, "createResolutionConstraint", ()=>createResolutionConstraint
);
/**
 * @param {ViewOptions} options View options.
 * @return {import("./rotationconstraint.js").Type} Rotation constraint.
 */ parcelHelpers.export(exports, "createRotationConstraint", ()=>createRotationConstraint
);
/**
 * Determine if an animation involves no view change.
 * @param {Animation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */ parcelHelpers.export(exports, "isNoopAnimation", ()=>isNoopAnimation
);
/**
 * @module ol/View
 */ var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _geometryTypeJs = require("./geom/GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _unitsJs = require("./proj/Units.js");
var _unitsJsDefault = parcelHelpers.interopDefault(_unitsJs);
var _viewHintJs = require("./ViewHint.js");
var _viewHintJsDefault = parcelHelpers.interopDefault(_viewHintJs);
var _viewPropertyJs = require("./ViewProperty.js");
var _viewPropertyJsDefault = parcelHelpers.interopDefault(_viewPropertyJs);
var _commonJs = require("./tilegrid/common.js");
var _projJs = require("./proj.js");
var _functionsJs = require("./functions.js");
var _coordinateJs = require("./coordinate.js");
var _assertsJs = require("./asserts.js");
var _objJs = require("./obj.js");
var _centerconstraintJs = require("./centerconstraint.js");
var _mathJs = require("./math.js");
var _resolutionconstraintJs = require("./resolutionconstraint.js");
var _rotationconstraintJs = require("./rotationconstraint.js");
var _easingJs = require("./easing.js");
var _extentJs = require("./extent.js");
var _arrayJs = require("./array.js");
var _polygonJs = require("./geom/Polygon.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {import("./coordinate.js").Coordinate} [sourceCenter] Source center.
 * @property {import("./coordinate.js").Coordinate} [targetCenter] Target center.
 * @property {number} [sourceResolution] Source resolution.
 * @property {number} [targetResolution] Target resolution.
 * @property {number} [sourceRotation] Source rotation.
 * @property {number} [targetRotation] Target rotation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Anchor.
 * @property {number} start Start.
 * @property {number} duration Duration.
 * @property {boolean} complete Complete.
 * @property {function(number):number} easing Easing.
 * @property {function(boolean):void} callback Callback.
 */ /**
 * @typedef {Object} Constraints
 * @property {import("./centerconstraint.js").Type} center Center.
 * @property {import("./resolutionconstraint.js").Type} resolution Resolution.
 * @property {import("./rotationconstraint.js").Type} rotation Rotation.
 */ /**
 * @typedef {Object} FitOptions
 * @property {import("./size.js").Size} [size] The size in pixels of the box to fit
 * the extent into. Default is the current size of the first map in the DOM that
 * uses this view, or `[100, 100]` if no such map is found.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
 * get the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean):void} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */ /**
 * @typedef {Object} ViewOptions
 * @property {import("./coordinate.js").Coordinate} [center] The initial center for
 * the view. If a user projection is not set, the coordinate system for the center is
 * specified with the `projection` option. Layer sources will not be fetched if this
 * is not set, but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {import("./extent.js").Extent} [extent] The extent that constrains the
 * view, in other words, nothing outside of this extent can be visible on the map.
 * @property {boolean} [constrainOnlyCenter=false] If true, the extent
 * constraint will only apply to the view center and not the whole extent.
 * @property {boolean} [smoothExtentConstraint=true] If true, the extent
 * constraint will be applied smoothly, i.e. allow the view to go slightly outside
 * of the given `extent`.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {boolean} [multiWorld=false] If `false` the view is constrained so
 * only one world is visible, and you cannot pan off the edge.  If `true` the map
 * may show multiple worlds at low zoom levels.  Only used if the `projection` is
 * global.  Note that if `extent` is also provided it is given precedence.
 * @property {boolean} [constrainResolution=false] If true, the view will always
 * animate to the closest zoom level after an interaction; false means
 * intermediary zoom levels are allowed.
 * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
 * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
 * the given resolution or zoom bounds.
 * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
 * show the full configured extent. By default, when a view is configured with an
 * extent, users will not be able to zoom out so the viewport exceeds the extent in
 * either dimension. This means the full extent may not be visible if the viewport
 * is taller or wider than the aspect ratio of the configured extent. If
 * showFullExtent is true, the user will be able to zoom out so that the viewport
 * exceeds the height or width of the configured extent, but not both, allowing the
 * full extent to be shown.
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array<number>} [resolutions] Resolutions that determine the
 * zoom levels if specified. The index in the array corresponds to the zoom level,
 * therefore the resolution values have to be in descending order. It also constrains
 * the resolution by the minimum and maximum value. If set the `maxResolution`,
 * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view.
 * @property {number} [zoomFactor=2] The zoom factor used to compute the
 * corresponding resolution.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).
 * If the map viewport is partially covered with other content (overlays) along
 * its edges, this setting allows to shift the center of the viewport away from
 * that content. The order of the values is top, right, bottom, left.
 */ /**
 * @typedef {Object} AnimationOptions
 * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
 * the animation.
 * @property {number} [zoom] The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number} [resolution] The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number} [rotation] The rotation of the view at the end of
 * the animation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:ol/easing.inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */ /**
 * @typedef {Object} State
 * @property {import("./coordinate.js").Coordinate} center Center.
 * @property {import("./proj/Projection.js").default} projection Projection.
 * @property {number} resolution Resolution.
 * @property {import("./coordinate.js").Coordinate} [nextCenter] The next center during an animation series.
 * @property {number} [nextResolution] The next resolution during an animation series.
 * @property {number} [nextRotation] The next rotation during an animation series.
 * @property {number} rotation Rotation.
 * @property {number} zoom Zoom.
 */ /**
 * Default min zoom level for the map view.
 * @type {number}
 */ var DEFAULT_MIN_ZOOM = 0;
/**
 * @typedef {import("./ObjectEventType").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<ViewObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature
 */ /**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * A View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Spherical Mercator (EPSG:3857).
 *
 * ### The view states
 *
 * A View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * The `zoom` state is actually not saved on the view: all computations
 * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
 * methods are available, as well as `getResolutionForZoom` and
 * `getZoomForResolution` to switch from one system to the other.
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view, but any constraint defined in the constructor will
 * be applied along the way.
 *
 * A View object can have a *resolution constraint*, a *rotation constraint*
 * and a *center constraint*.
 *
 * The *resolution constraint* typically restricts min/max values and
 * snaps to specific resolutions. It is determined by the following
 * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
 * If `resolutions` is set, the other three options are ignored. See
 * documentation for each option for more information. By default, the view
 * only has a min/max restriction and allow intermediary zoom levels when
 * pinch-zooming for example.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default rotation is allowed and its value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the view center is not constrained at all.
 *
 * ### Changing the view state
 *
 * It is important to note that `setZoom`, `setResolution`, `setCenter` and
 * `setRotation` are subject to the above mentioned constraints. As such, it
 * may sometimes not be possible to know in advance the resulting state of the
 * View. For example, calling `setResolution(10)` does not guarantee that
 * `getResolution()` will return `10`.
 *
 * A consequence of this is that, when applying a delta on the view state, one
 * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
 * rather than the corresponding setters. This will let view do its internal
 * computations. Besides, the `adjust*` methods also take an `opt_anchor`
 * argument which allows specifying an origin for the transformation.
 *
 * ### Interacting with the view
 *
 * View constraints are usually only applied when the view is *at rest*, meaning that
 * no interaction or animation is ongoing. As such, if the user puts the view in a
 * state that is not equivalent to a constrained one (e.g. rotating the view when
 * the snap angle is 0), an animation will be triggered at the interaction end to
 * put back the view to a stable state;
 *
 * @api
 */ var View1 = function(_super) {
    __extends(View2, _super);
    /**
     * @param {ViewOptions} [opt_options] View options.
     */ function View2(opt_options) {
        var _this = _super.call(this) || this;
        /***
         * @type {ViewOnSignature<import("./events").EventsKey>}
         */ _this.on;
        /***
         * @type {ViewOnSignature<import("./events").EventsKey>}
         */ _this.once;
        /***
         * @type {ViewOnSignature<void>}
         */ _this.un;
        var options = _objJs.assign({
        }, opt_options);
        /**
         * @private
         * @type {Array<number>}
         */ _this.hints_ = [
            0,
            0
        ];
        /**
         * @private
         * @type {Array<Array<Animation>>}
         */ _this.animations_ = [];
        /**
         * @private
         * @type {number|undefined}
         */ _this.updateAnimationKey_;
        /**
         * @private
         * @const
         * @type {import("./proj/Projection.js").default}
         */ _this.projection_ = _projJs.createProjection(options.projection, 'EPSG:3857');
        /**
         * @private
         * @type {import("./size.js").Size}
         */ _this.viewportSize_ = [
            100,
            100
        ];
        /**
         * @private
         * @type {import("./coordinate.js").Coordinate|undefined}
         */ _this.targetCenter_ = null;
        /**
         * @private
         * @type {number|undefined}
         */ _this.targetResolution_;
        /**
         * @private
         * @type {number|undefined}
         */ _this.targetRotation_;
        /**
         * @private
         * @type {import("./coordinate.js").Coordinate}
         */ _this.nextCenter_ = null;
        /**
         * @private
         * @type {number}
         */ _this.nextResolution_;
        /**
         * @private
         * @type {number}
         */ _this.nextRotation_;
        /**
         * @private
         * @type {import("./coordinate.js").Coordinate|undefined}
         */ _this.cancelAnchor_ = undefined;
        if (options.center) options.center = _projJs.fromUserCoordinate(options.center, _this.projection_);
        if (options.extent) options.extent = _projJs.fromUserExtent(options.extent, _this.projection_);
        _this.applyOptions_(options);
        return _this;
    }
    /**
     * Set up the view with the given options.
     * @param {ViewOptions} options View options.
     */ View2.prototype.applyOptions_ = function(options) {
        /**
         * @type {Object<string, *>}
         */ var properties = {
        };
        var resolutionConstraintInfo = createResolutionConstraint(options);
        /**
         * @private
         * @type {number}
         */ this.maxResolution_ = resolutionConstraintInfo.maxResolution;
        /**
         * @private
         * @type {number}
         */ this.minResolution_ = resolutionConstraintInfo.minResolution;
        /**
         * @private
         * @type {number}
         */ this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
        /**
         * @private
         * @type {Array<number>|undefined}
         */ this.resolutions_ = options.resolutions;
        /**
         * @type {Array<number>|undefined}
         * @private
         */ this.padding_ = options.padding;
        /**
         * @private
         * @type {number}
         */ this.minZoom_ = resolutionConstraintInfo.minZoom;
        var centerConstraint = createCenterConstraint(options);
        var resolutionConstraint = resolutionConstraintInfo.constraint;
        var rotationConstraint = createRotationConstraint(options);
        /**
         * @private
         * @type {Constraints}
         */ this.constraints_ = {
            center: centerConstraint,
            resolution: resolutionConstraint,
            rotation: rotationConstraint
        };
        this.setRotation(options.rotation !== undefined ? options.rotation : 0);
        this.setCenterInternal(options.center !== undefined ? options.center : null);
        if (options.resolution !== undefined) this.setResolution(options.resolution);
        else if (options.zoom !== undefined) this.setZoom(options.zoom);
        this.setProperties(properties);
        /**
         * @private
         * @type {ViewOptions}
         */ this.options_ = options;
    };
    Object.defineProperty(View2.prototype, "padding", {
        /**
         * Padding (in css pixels).
         * If the map viewport is partially covered with other content (overlays) along
         * its edges, this setting allows to shift the center of the viewport away from that
         * content. The order of the values in the array is top, right, bottom, left.
         * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
         * @type {Array<number>|undefined}
         * @api
         */ get: function() {
            return this.padding_;
        },
        set: function(padding) {
            var oldPadding = this.padding_;
            this.padding_ = padding;
            var center = this.getCenter();
            if (center) {
                var newPadding = padding || [
                    0,
                    0,
                    0,
                    0
                ];
                oldPadding = oldPadding || [
                    0,
                    0,
                    0,
                    0
                ];
                var resolution = this.getResolution();
                var offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
                var offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
                this.setCenterInternal([
                    center[0] + offsetX,
                    center[1] - offsetY
                ]);
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Get an updated version of the view options used to construct the view.  The
     * current resolution (or zoom), center, and rotation are applied to any stored
     * options.  The provided options can be used to apply new min/max zoom or
     * resolution limits.
     * @param {ViewOptions} newOptions New options to be applied.
     * @return {ViewOptions} New options updated with the current view state.
     */ View2.prototype.getUpdatedOptions_ = function(newOptions) {
        var options = _objJs.assign({
        }, this.options_);
        // preserve resolution (or zoom)
        if (options.resolution !== undefined) options.resolution = this.getResolution();
        else options.zoom = this.getZoom();
        // preserve center
        options.center = this.getCenterInternal();
        // preserve rotation
        options.rotation = this.getRotation();
        return _objJs.assign({
        }, options, newOptions);
    };
    /**
     * Animate the view.  The view's center, zoom (or resolution), and rotation
     * can be animated for smooth transitions between view states.  For example,
     * to animate the view to a new zoom level:
     *
     *     view.animate({zoom: view.getZoom() + 1});
     *
     * By default, the animation lasts one second and uses in-and-out easing.  You
     * can customize this behavior by including `duration` (in milliseconds) and
     * `easing` options (see {@link module:ol/easing}).
     *
     * To chain together multiple animations, call the method with multiple
     * animation objects.  For example, to first zoom and then pan:
     *
     *     view.animate({zoom: 10}, {center: [0, 0]});
     *
     * If you provide a function as the last argument to the animate method, it
     * will get called at the end of an animation series.  The callback will be
     * called with `true` if the animation series completed on its own or `false`
     * if it was cancelled.
     *
     * Animations are cancelled by user interactions (e.g. dragging the map) or by
     * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
     * (or another method that calls one of these).
     *
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
     *     options.  Multiple animations can be run in series by passing multiple
     *     options objects.  To run multiple animations in parallel, call the method
     *     multiple times.  An optional callback can be provided as a final
     *     argument.  The callback will be called with a boolean indicating whether
     *     the animation completed without being cancelled.
     * @api
     */ View2.prototype.animate = function(var_args) {
        if (this.isDef() && !this.getAnimating()) this.resolveConstraints(0);
        var args = new Array(arguments.length);
        for(var i = 0; i < args.length; ++i){
            var options = arguments[i];
            if (options.center) {
                options = _objJs.assign({
                }, options);
                options.center = _projJs.fromUserCoordinate(options.center, this.getProjection());
            }
            if (options.anchor) {
                options = _objJs.assign({
                }, options);
                options.anchor = _projJs.fromUserCoordinate(options.anchor, this.getProjection());
            }
            args[i] = options;
        }
        this.animateInternal.apply(this, args);
    };
    /**
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
     */ View2.prototype.animateInternal = function(var_args) {
        var animationCount = arguments.length;
        var callback;
        if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
            callback = arguments[animationCount - 1];
            --animationCount;
        }
        if (!this.isDef()) {
            // if view properties are not yet set, shortcut to the final state
            var state = arguments[animationCount - 1];
            if (state.center) this.setCenterInternal(state.center);
            if (state.zoom !== undefined) this.setZoom(state.zoom);
            if (state.rotation !== undefined) this.setRotation(state.rotation);
            if (callback) animationCallback(callback, true);
            return;
        }
        var start = Date.now();
        var center = this.targetCenter_.slice();
        var resolution = this.targetResolution_;
        var rotation = this.targetRotation_;
        var series = [];
        for(var i = 0; i < animationCount; ++i){
            var options = arguments[i];
            var animation = {
                start: start,
                complete: false,
                anchor: options.anchor,
                duration: options.duration !== undefined ? options.duration : 1000,
                easing: options.easing || _easingJs.inAndOut,
                callback: callback
            };
            if (options.center) {
                animation.sourceCenter = center;
                animation.targetCenter = options.center.slice();
                center = animation.targetCenter;
            }
            if (options.zoom !== undefined) {
                animation.sourceResolution = resolution;
                animation.targetResolution = this.getResolutionForZoom(options.zoom);
                resolution = animation.targetResolution;
            } else if (options.resolution) {
                animation.sourceResolution = resolution;
                animation.targetResolution = options.resolution;
                resolution = animation.targetResolution;
            }
            if (options.rotation !== undefined) {
                animation.sourceRotation = rotation;
                var delta = _mathJs.modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
                animation.targetRotation = rotation + delta;
                rotation = animation.targetRotation;
            }
            // check if animation is a no-op
            if (isNoopAnimation(animation)) animation.complete = true;
            else start += animation.duration;
            series.push(animation);
        }
        this.animations_.push(series);
        this.setHint(_viewHintJsDefault.default.ANIMATING, 1);
        this.updateAnimations_();
    };
    /**
     * Determine if the view is being animated.
     * @return {boolean} The view is being animated.
     * @api
     */ View2.prototype.getAnimating = function() {
        return this.hints_[_viewHintJsDefault.default.ANIMATING] > 0;
    };
    /**
     * Determine if the user is interacting with the view, such as panning or zooming.
     * @return {boolean} The view is being interacted with.
     * @api
     */ View2.prototype.getInteracting = function() {
        return this.hints_[_viewHintJsDefault.default.INTERACTING] > 0;
    };
    /**
     * Cancel any ongoing animations.
     * @api
     */ View2.prototype.cancelAnimations = function() {
        this.setHint(_viewHintJsDefault.default.ANIMATING, -this.hints_[_viewHintJsDefault.default.ANIMATING]);
        var anchor;
        for(var i = 0, ii = this.animations_.length; i < ii; ++i){
            var series = this.animations_[i];
            if (series[0].callback) animationCallback(series[0].callback, false);
            if (!anchor) for(var j = 0, jj = series.length; j < jj; ++j){
                var animation = series[j];
                if (!animation.complete) {
                    anchor = animation.anchor;
                    break;
                }
            }
        }
        this.animations_.length = 0;
        this.cancelAnchor_ = anchor;
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
    };
    /**
     * Update all animations.
     */ View2.prototype.updateAnimations_ = function() {
        if (this.updateAnimationKey_ !== undefined) {
            cancelAnimationFrame(this.updateAnimationKey_);
            this.updateAnimationKey_ = undefined;
        }
        if (!this.getAnimating()) return;
        var now = Date.now();
        var more = false;
        for(var i = this.animations_.length - 1; i >= 0; --i){
            var series = this.animations_[i];
            var seriesComplete = true;
            for(var j = 0, jj = series.length; j < jj; ++j){
                var animation = series[j];
                if (animation.complete) continue;
                var elapsed = now - animation.start;
                var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
                if (fraction >= 1) {
                    animation.complete = true;
                    fraction = 1;
                } else seriesComplete = false;
                var progress = animation.easing(fraction);
                if (animation.sourceCenter) {
                    var x0 = animation.sourceCenter[0];
                    var y0 = animation.sourceCenter[1];
                    var x1 = animation.targetCenter[0];
                    var y1 = animation.targetCenter[1];
                    this.nextCenter_ = animation.targetCenter;
                    var x = x0 + progress * (x1 - x0);
                    var y = y0 + progress * (y1 - y0);
                    this.targetCenter_ = [
                        x,
                        y
                    ];
                }
                if (animation.sourceResolution && animation.targetResolution) {
                    var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
                    if (animation.anchor) {
                        var size = this.getViewportSize_(this.getRotation());
                        var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
                        this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
                    }
                    this.nextResolution_ = animation.targetResolution;
                    this.targetResolution_ = resolution;
                    this.applyTargetState_(true);
                }
                if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
                    var rotation = progress === 1 ? _mathJs.modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
                    if (animation.anchor) {
                        var constrainedRotation = this.constraints_.rotation(rotation, true);
                        this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
                    }
                    this.nextRotation_ = animation.targetRotation;
                    this.targetRotation_ = rotation;
                }
                this.applyTargetState_(true);
                more = true;
                if (!animation.complete) break;
            }
            if (seriesComplete) {
                this.animations_[i] = null;
                this.setHint(_viewHintJsDefault.default.ANIMATING, -1);
                this.nextCenter_ = null;
                this.nextResolution_ = NaN;
                this.nextRotation_ = NaN;
                var callback = series[0].callback;
                if (callback) animationCallback(callback, true);
            }
        }
        // prune completed series
        this.animations_ = this.animations_.filter(Boolean);
        if (more && this.updateAnimationKey_ === undefined) this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
    };
    /**
     * @param {number} rotation Target rotation.
     * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
     */ View2.prototype.calculateCenterRotate = function(rotation, anchor) {
        var center;
        var currentCenter = this.getCenterInternal();
        if (currentCenter !== undefined) {
            center = [
                currentCenter[0] - anchor[0],
                currentCenter[1] - anchor[1]
            ];
            _coordinateJs.rotate(center, rotation - this.getRotation());
            _coordinateJs.add(center, anchor);
        }
        return center;
    };
    /**
     * @param {number} resolution Target resolution.
     * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
     */ View2.prototype.calculateCenterZoom = function(resolution, anchor) {
        var center;
        var currentCenter = this.getCenterInternal();
        var currentResolution = this.getResolution();
        if (currentCenter !== undefined && currentResolution !== undefined) {
            var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
            var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
            center = [
                x,
                y
            ];
        }
        return center;
    };
    /**
     * Returns the current viewport size.
     * @private
     * @param {number} [opt_rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
     */ View2.prototype.getViewportSize_ = function(opt_rotation) {
        var size = this.viewportSize_;
        if (opt_rotation) {
            var w = size[0];
            var h = size[1];
            return [
                Math.abs(w * Math.cos(opt_rotation)) + Math.abs(h * Math.sin(opt_rotation)),
                Math.abs(w * Math.sin(opt_rotation)) + Math.abs(h * Math.cos(opt_rotation)), 
            ];
        } else return size;
    };
    /**
     * Stores the viewport size on the view. The viewport size is not read every time from the DOM
     * to avoid performance hit and layout reflow.
     * This should be done on map size change.
     * Note: the constraints are not resolved during an animation to avoid stopping it
     * @param {import("./size.js").Size} [opt_size] Viewport size; if undefined, [100, 100] is assumed
     */ View2.prototype.setViewportSize = function(opt_size) {
        this.viewportSize_ = Array.isArray(opt_size) ? opt_size.slice() : [
            100,
            100
        ];
        if (!this.getAnimating()) this.resolveConstraints(0);
    };
    /**
     * Get the view center.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     * @observable
     * @api
     */ View2.prototype.getCenter = function() {
        var center = this.getCenterInternal();
        if (!center) return center;
        return _projJs.toUserCoordinate(center, this.getProjection());
    };
    /**
     * Get the view center without transforming to user projection.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     */ View2.prototype.getCenterInternal = function() {
        return this.get(_viewPropertyJsDefault.default.CENTER);
    };
    /**
     * @return {Constraints} Constraints.
     */ View2.prototype.getConstraints = function() {
        return this.constraints_;
    };
    /**
     * @return {boolean} Resolution constraint is set
     */ View2.prototype.getConstrainResolution = function() {
        return this.options_.constrainResolution;
    };
    /**
     * @param {Array<number>} [opt_hints] Destination array.
     * @return {Array<number>} Hint.
     */ View2.prototype.getHints = function(opt_hints) {
        if (opt_hints !== undefined) {
            opt_hints[0] = this.hints_[0];
            opt_hints[1] = this.hints_[1];
            return opt_hints;
        } else return this.hints_.slice();
    };
    /**
     * Calculate the extent for the current view state and the passed size.
     * The size is the pixel dimensions of the box into which the calculated extent
     * should fit. In most cases you want to get the extent of the entire map,
     * that is `map.getSize()`.
     * @param {import("./size.js").Size} [opt_size] Box pixel size. If not provided, the size
     * of the map that uses this view will be used.
     * @return {import("./extent.js").Extent} Extent.
     * @api
     */ View2.prototype.calculateExtent = function(opt_size) {
        var extent = this.calculateExtentInternal(opt_size);
        return _projJs.toUserExtent(extent, this.getProjection());
    };
    /**
     * @param {import("./size.js").Size} [opt_size] Box pixel size. If not provided,
     * the map's last known viewport size will be used.
     * @return {import("./extent.js").Extent} Extent.
     */ View2.prototype.calculateExtentInternal = function(opt_size) {
        var size = opt_size || this.getViewportSizeMinusPadding_();
        var center = this.getCenterInternal();
        _assertsJs.assert(center, 1); // The view center is not defined
        var resolution = this.getResolution();
        _assertsJs.assert(resolution !== undefined, 2); // The view resolution is not defined
        var rotation = this.getRotation();
        _assertsJs.assert(rotation !== undefined, 3); // The view rotation is not defined
        return _extentJs.getForViewAndSize(center, resolution, rotation, size);
    };
    /**
     * Get the maximum resolution of the view.
     * @return {number} The maximum resolution of the view.
     * @api
     */ View2.prototype.getMaxResolution = function() {
        return this.maxResolution_;
    };
    /**
     * Get the minimum resolution of the view.
     * @return {number} The minimum resolution of the view.
     * @api
     */ View2.prototype.getMinResolution = function() {
        return this.minResolution_;
    };
    /**
     * Get the maximum zoom level for the view.
     * @return {number} The maximum zoom level.
     * @api
     */ View2.prototype.getMaxZoom = function() {
        return this.getZoomForResolution(this.minResolution_);
    };
    /**
     * Set a new maximum zoom level for the view.
     * @param {number} zoom The maximum zoom level.
     * @api
     */ View2.prototype.setMaxZoom = function(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({
            maxZoom: zoom
        }));
    };
    /**
     * Get the minimum zoom level for the view.
     * @return {number} The minimum zoom level.
     * @api
     */ View2.prototype.getMinZoom = function() {
        return this.getZoomForResolution(this.maxResolution_);
    };
    /**
     * Set a new minimum zoom level for the view.
     * @param {number} zoom The minimum zoom level.
     * @api
     */ View2.prototype.setMinZoom = function(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({
            minZoom: zoom
        }));
    };
    /**
     * Set whether the view should allow intermediary zoom levels.
     * @param {boolean} enabled Whether the resolution is constrained.
     * @api
     */ View2.prototype.setConstrainResolution = function(enabled) {
        this.applyOptions_(this.getUpdatedOptions_({
            constrainResolution: enabled
        }));
    };
    /**
     * Get the view projection.
     * @return {import("./proj/Projection.js").default} The projection of the view.
     * @api
     */ View2.prototype.getProjection = function() {
        return this.projection_;
    };
    /**
     * Get the view resolution.
     * @return {number|undefined} The resolution of the view.
     * @observable
     * @api
     */ View2.prototype.getResolution = function() {
        return this.get(_viewPropertyJsDefault.default.RESOLUTION);
    };
    /**
     * Get the resolutions for the view. This returns the array of resolutions
     * passed to the constructor of the View, or undefined if none were given.
     * @return {Array<number>|undefined} The resolutions of the view.
     * @api
     */ View2.prototype.getResolutions = function() {
        return this.resolutions_;
    };
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [opt_size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     * @api
     */ View2.prototype.getResolutionForExtent = function(extent, opt_size) {
        return this.getResolutionForExtentInternal(_projJs.fromUserExtent(extent, this.getProjection()), opt_size);
    };
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [opt_size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     */ View2.prototype.getResolutionForExtentInternal = function(extent, opt_size) {
        var size = opt_size || this.getViewportSizeMinusPadding_();
        var xResolution = _extentJs.getWidth(extent) / size[0];
        var yResolution = _extentJs.getHeight(extent) / size[1];
        return Math.max(xResolution, yResolution);
    };
    /**
     * Return a function that returns a value between 0 and 1 for a
     * resolution. Exponential scaling is assumed.
     * @param {number} [opt_power] Power.
     * @return {function(number): number} Resolution for value function.
     */ View2.prototype.getResolutionForValueFunction = function(opt_power) {
        var power = opt_power || 2;
        var maxResolution = this.getConstrainedResolution(this.maxResolution_);
        var minResolution = this.minResolution_;
        var max = Math.log(maxResolution / minResolution) / Math.log(power);
        return(/**
         * @param {number} value Value.
         * @return {number} Resolution.
         */ function(value) {
            var resolution = maxResolution / Math.pow(power, value * max);
            return resolution;
        });
    };
    /**
     * Get the view rotation.
     * @return {number} The rotation of the view in radians.
     * @observable
     * @api
     */ View2.prototype.getRotation = function() {
        return this.get(_viewPropertyJsDefault.default.ROTATION);
    };
    /**
     * Return a function that returns a resolution for a value between
     * 0 and 1. Exponential scaling is assumed.
     * @param {number} [opt_power] Power.
     * @return {function(number): number} Value for resolution function.
     */ View2.prototype.getValueForResolutionFunction = function(opt_power) {
        var logPower = Math.log(opt_power || 2);
        var maxResolution = this.getConstrainedResolution(this.maxResolution_);
        var minResolution = this.minResolution_;
        var max = Math.log(maxResolution / minResolution) / logPower;
        return(/**
         * @param {number} resolution Resolution.
         * @return {number} Value.
         */ function(resolution) {
            var value = Math.log(maxResolution / resolution) / logPower / max;
            return value;
        });
    };
    /**
     * Returns the size of the viewport minus padding.
     * @private
     * @param {number} [opt_rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size reduced by the padding.
     */ View2.prototype.getViewportSizeMinusPadding_ = function(opt_rotation) {
        var size = this.getViewportSize_(opt_rotation);
        var padding = this.padding_;
        if (padding) size = [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2], 
        ];
        return size;
    };
    /**
     * @return {State} View state.
     */ View2.prototype.getState = function() {
        var projection = this.getProjection();
        var resolution = this.getResolution();
        var rotation = this.getRotation();
        var center = this.getCenterInternal();
        var padding = this.padding_;
        if (padding) {
            var reducedSize = this.getViewportSizeMinusPadding_();
            center = calculateCenterOn(center, this.getViewportSize_(), [
                reducedSize[0] / 2 + padding[3],
                reducedSize[1] / 2 + padding[0]
            ], resolution, rotation);
        }
        return {
            center: center.slice(0),
            projection: projection !== undefined ? projection : null,
            resolution: resolution,
            nextCenter: this.nextCenter_,
            nextResolution: this.nextResolution_,
            nextRotation: this.nextRotation_,
            rotation: rotation,
            zoom: this.getZoom()
        };
    };
    /**
     * Get the current zoom level. This method may return non-integer zoom levels
     * if the view does not constrain the resolution, or if an interaction or
     * animation is underway.
     * @return {number|undefined} Zoom.
     * @api
     */ View2.prototype.getZoom = function() {
        var zoom;
        var resolution = this.getResolution();
        if (resolution !== undefined) zoom = this.getZoomForResolution(resolution);
        return zoom;
    };
    /**
     * Get the zoom level for a resolution.
     * @param {number} resolution The resolution.
     * @return {number|undefined} The zoom level for the provided resolution.
     * @api
     */ View2.prototype.getZoomForResolution = function(resolution) {
        var offset = this.minZoom_ || 0;
        var max, zoomFactor;
        if (this.resolutions_) {
            var nearest = _arrayJs.linearFindNearest(this.resolutions_, resolution, 1);
            offset = nearest;
            max = this.resolutions_[nearest];
            if (nearest == this.resolutions_.length - 1) zoomFactor = 2;
            else zoomFactor = max / this.resolutions_[nearest + 1];
        } else {
            max = this.maxResolution_;
            zoomFactor = this.zoomFactor_;
        }
        return offset + Math.log(max / resolution) / Math.log(zoomFactor);
    };
    /**
     * Get the resolution for a zoom level.
     * @param {number} zoom Zoom level.
     * @return {number} The view resolution for the provided zoom level.
     * @api
     */ View2.prototype.getResolutionForZoom = function(zoom) {
        if (this.resolutions_) {
            if (this.resolutions_.length <= 1) return 0;
            var baseLevel = _mathJs.clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);
            var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
            return this.resolutions_[baseLevel] / Math.pow(zoomFactor, _mathJs.clamp(zoom - baseLevel, 0, 1));
        } else return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
    };
    /**
     * Fit the given geometry or extent based on the given map size and border.
     * The size is pixel dimensions of the box to fit the extent into.
     * In most cases you will want to use the map size, that is `map.getSize()`.
     * Takes care of the map angle.
     * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
     *     extent to fit the view to.
     * @param {FitOptions} [opt_options] Options.
     * @api
     */ View2.prototype.fit = function(geometryOrExtent, opt_options) {
        /** @type {import("./geom/SimpleGeometry.js").default} */ var geometry;
        _assertsJs.assert(Array.isArray(geometryOrExtent) || typeof /** @type {?} */ geometryOrExtent.getSimplifiedGeometry === 'function', 24); // Invalid extent or geometry provided as `geometry`
        if (Array.isArray(geometryOrExtent)) {
            _assertsJs.assert(!_extentJs.isEmpty(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`
            var extent = _projJs.fromUserExtent(geometryOrExtent, this.getProjection());
            geometry = _polygonJs.fromExtent(extent);
        } else if (geometryOrExtent.getType() === _geometryTypeJsDefault.default.CIRCLE) {
            var extent = _projJs.fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());
            geometry = _polygonJs.fromExtent(extent);
            geometry.rotate(this.getRotation(), _extentJs.getCenter(extent));
        } else {
            var userProjection = _projJs.getUserProjection();
            if (userProjection) geometry = geometryOrExtent.clone().transform(userProjection, this.getProjection());
            else geometry = geometryOrExtent;
        }
        this.fitInternal(geometry, opt_options);
    };
    /**
     * Calculate rotated extent
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @return {import("./extent").Extent} The rotated extent for the geometry.
     */ View2.prototype.rotatedExtentForGeometry = function(geometry) {
        var rotation = this.getRotation();
        var cosAngle = Math.cos(rotation);
        var sinAngle = Math.sin(-rotation);
        var coords = geometry.getFlatCoordinates();
        var stride = geometry.getStride();
        var minRotX = Infinity;
        var minRotY = Infinity;
        var maxRotX = -Infinity;
        var maxRotY = -Infinity;
        for(var i = 0, ii = coords.length; i < ii; i += stride){
            var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
            var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
            minRotX = Math.min(minRotX, rotX);
            minRotY = Math.min(minRotY, rotY);
            maxRotX = Math.max(maxRotX, rotX);
            maxRotY = Math.max(maxRotY, rotY);
        }
        return [
            minRotX,
            minRotY,
            maxRotX,
            maxRotY
        ];
    };
    /**
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @param {FitOptions} [opt_options] Options.
     */ View2.prototype.fitInternal = function(geometry, opt_options) {
        var options = opt_options || {
        };
        var size = options.size;
        if (!size) size = this.getViewportSizeMinusPadding_();
        var padding = options.padding !== undefined ? options.padding : [
            0,
            0,
            0,
            0
        ];
        var nearest = options.nearest !== undefined ? options.nearest : false;
        var minResolution;
        if (options.minResolution !== undefined) minResolution = options.minResolution;
        else if (options.maxZoom !== undefined) minResolution = this.getResolutionForZoom(options.maxZoom);
        else minResolution = 0;
        var rotatedExtent = this.rotatedExtentForGeometry(geometry);
        // calculate resolution
        var resolution = this.getResolutionForExtentInternal(rotatedExtent, [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2], 
        ]);
        resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
        resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
        // calculate center
        var rotation = this.getRotation();
        var sinAngle = Math.sin(rotation);
        var cosAngle = Math.cos(rotation);
        var centerRot = _extentJs.getCenter(rotatedExtent);
        centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
        centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
        var centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
        var centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
        var center = this.getConstrainedCenter([
            centerX,
            centerY
        ], resolution);
        var callback = options.callback ? options.callback : _functionsJs.VOID;
        if (options.duration !== undefined) this.animateInternal({
            resolution: resolution,
            center: center,
            duration: options.duration,
            easing: options.easing
        }, callback);
        else {
            this.targetResolution_ = resolution;
            this.targetCenter_ = center;
            this.applyTargetState_(false, true);
            animationCallback(callback, true);
        }
    };
    /**
     * Center on coordinate and view position.
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     * @api
     */ View2.prototype.centerOn = function(coordinate, size, position) {
        this.centerOnInternal(_projJs.fromUserCoordinate(coordinate, this.getProjection()), size, position);
    };
    /**
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     */ View2.prototype.centerOnInternal = function(coordinate, size, position) {
        this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
    };
    /**
     * Calculates the shift between map and viewport center.
     * @param {import("./coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {import("./size.js").Size} size Size.
     * @return {Array<number>|undefined} Center shift.
     */ View2.prototype.calculateCenterShift = function(center, resolution, rotation, size) {
        var centerShift;
        var padding = this.padding_;
        if (padding && center) {
            var reducedSize = this.getViewportSizeMinusPadding_(-rotation);
            var shiftedCenter = calculateCenterOn(center, size, [
                reducedSize[0] / 2 + padding[3],
                reducedSize[1] / 2 + padding[0]
            ], resolution, rotation);
            centerShift = [
                center[0] - shiftedCenter[0],
                center[1] - shiftedCenter[1], 
            ];
        }
        return centerShift;
    };
    /**
     * @return {boolean} Is defined.
     */ View2.prototype.isDef = function() {
        return !!this.getCenterInternal() && this.getResolution() !== undefined;
    };
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     * @api
     */ View2.prototype.adjustCenter = function(deltaCoordinates) {
        var center = _projJs.toUserCoordinate(this.targetCenter_, this.getProjection());
        this.setCenter([
            center[0] + deltaCoordinates[0],
            center[1] + deltaCoordinates[1], 
        ]);
    };
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     */ View2.prototype.adjustCenterInternal = function(deltaCoordinates) {
        var center = this.targetCenter_;
        this.setCenterInternal([
            center[0] + deltaCoordinates[0],
            center[1] + deltaCoordinates[1], 
        ]);
    };
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
     * @api
     */ View2.prototype.adjustResolution = function(ratio, opt_anchor) {
        var anchor = opt_anchor && _projJs.fromUserCoordinate(opt_anchor, this.getProjection());
        this.adjustResolutionInternal(ratio, anchor);
    };
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
     */ View2.prototype.adjustResolutionInternal = function(ratio, opt_anchor) {
        var isMoving = this.getAnimating() || this.getInteracting();
        var size = this.getViewportSize_(this.getRotation());
        var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
        if (opt_anchor) this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);
        this.targetResolution_ *= ratio;
        this.applyTargetState_();
    };
    /**
     * Adds a value to the view zoom level, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom level.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
     * @api
     */ View2.prototype.adjustZoom = function(delta, opt_anchor) {
        this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);
    };
    /**
     * Adds a value to the view rotation, optionally using an anchor. Any rotation
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The rotation center.
     * @api
     */ View2.prototype.adjustRotation = function(delta, opt_anchor) {
        if (opt_anchor) opt_anchor = _projJs.fromUserCoordinate(opt_anchor, this.getProjection());
        this.adjustRotationInternal(delta, opt_anchor);
    };
    /**
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The rotation center.
     */ View2.prototype.adjustRotationInternal = function(delta, opt_anchor) {
        var isMoving = this.getAnimating() || this.getInteracting();
        var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
        if (opt_anchor) this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);
        this.targetRotation_ += delta;
        this.applyTargetState_();
    };
    /**
     * Set the center of the current view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     * @observable
     * @api
     */ View2.prototype.setCenter = function(center) {
        this.setCenterInternal(_projJs.fromUserCoordinate(center, this.getProjection()));
    };
    /**
     * Set the center using the view projection (not the user projection).
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     */ View2.prototype.setCenterInternal = function(center) {
        this.targetCenter_ = center;
        this.applyTargetState_();
    };
    /**
     * @param {import("./ViewHint.js").default} hint Hint.
     * @param {number} delta Delta.
     * @return {number} New value.
     */ View2.prototype.setHint = function(hint, delta) {
        this.hints_[hint] += delta;
        this.changed();
        return this.hints_[hint];
    };
    /**
     * Set the resolution for this view. Any resolution constraint will apply.
     * @param {number|undefined} resolution The resolution of the view.
     * @observable
     * @api
     */ View2.prototype.setResolution = function(resolution) {
        this.targetResolution_ = resolution;
        this.applyTargetState_();
    };
    /**
     * Set the rotation for this view. Any rotation constraint will apply.
     * @param {number} rotation The rotation of the view in radians.
     * @observable
     * @api
     */ View2.prototype.setRotation = function(rotation) {
        this.targetRotation_ = rotation;
        this.applyTargetState_();
    };
    /**
     * Zoom to a specific zoom level. Any resolution constrain will apply.
     * @param {number} zoom Zoom level.
     * @api
     */ View2.prototype.setZoom = function(zoom) {
        this.setResolution(this.getResolutionForZoom(zoom));
    };
    /**
     * Recompute rotation/resolution/center based on target values.
     * Note: we have to compute rotation first, then resolution and center considering that
     * parameters can influence one another in case a view extent constraint is present.
     * @param {boolean} [opt_doNotCancelAnims] Do not cancel animations.
     * @param {boolean} [opt_forceMoving] Apply constraints as if the view is moving.
     * @private
     */ View2.prototype.applyTargetState_ = function(opt_doNotCancelAnims, opt_forceMoving) {
        var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving;
        // compute rotation
        var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
        var size = this.getViewportSize_(newRotation);
        var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
        var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
        if (this.get(_viewPropertyJsDefault.default.ROTATION) !== newRotation) this.set(_viewPropertyJsDefault.default.ROTATION, newRotation);
        if (this.get(_viewPropertyJsDefault.default.RESOLUTION) !== newResolution) this.set(_viewPropertyJsDefault.default.RESOLUTION, newResolution);
        if (!this.get(_viewPropertyJsDefault.default.CENTER) || !_coordinateJs.equals(this.get(_viewPropertyJsDefault.default.CENTER), newCenter)) this.set(_viewPropertyJsDefault.default.CENTER, newCenter);
        if (this.getAnimating() && !opt_doNotCancelAnims) this.cancelAnimations();
        this.cancelAnchor_ = undefined;
    };
    /**
     * If any constraints need to be applied, an animation will be triggered.
     * This is typically done on interaction end.
     * Note: calling this with a duration of 0 will apply the constrained values straight away,
     * without animation.
     * @param {number} [opt_duration] The animation duration in ms.
     * @param {number} [opt_resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
     */ View2.prototype.resolveConstraints = function(opt_duration, opt_resolutionDirection, opt_anchor) {
        var duration = opt_duration !== undefined ? opt_duration : 200;
        var direction = opt_resolutionDirection || 0;
        var newRotation = this.constraints_.rotation(this.targetRotation_);
        var size = this.getViewportSize_(newRotation);
        var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
        var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));
        if (duration === 0 && !this.cancelAnchor_) {
            this.targetResolution_ = newResolution;
            this.targetRotation_ = newRotation;
            this.targetCenter_ = newCenter;
            this.applyTargetState_();
            return;
        }
        var anchor = opt_anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
        this.cancelAnchor_ = undefined;
        if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !_coordinateJs.equals(this.getCenterInternal(), newCenter)) {
            if (this.getAnimating()) this.cancelAnimations();
            this.animateInternal({
                rotation: newRotation,
                center: newCenter,
                resolution: newResolution,
                duration: duration,
                easing: _easingJs.easeOut,
                anchor: anchor
            });
        }
    };
    /**
     * Notify the View that an interaction has started.
     * The view state will be resolved to a stable one if needed
     * (depending on its constraints).
     * @api
     */ View2.prototype.beginInteraction = function() {
        this.resolveConstraints(0);
        this.setHint(_viewHintJsDefault.default.INTERACTING, 1);
    };
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [opt_duration] Animation duration in ms.
     * @param {number} [opt_resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
     * @api
     */ View2.prototype.endInteraction = function(opt_duration, opt_resolutionDirection, opt_anchor) {
        var anchor = opt_anchor && _projJs.fromUserCoordinate(opt_anchor, this.getProjection());
        this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);
    };
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [opt_duration] Animation duration in ms.
     * @param {number} [opt_resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [opt_anchor] The origin of the transformation.
     */ View2.prototype.endInteractionInternal = function(opt_duration, opt_resolutionDirection, opt_anchor) {
        this.setHint(_viewHintJsDefault.default.INTERACTING, -1);
        this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);
    };
    /**
     * Get a valid position for the view center according to the current constraints.
     * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
     * @param {number} [opt_targetResolution] Target resolution. If not supplied, the current one will be used.
     * This is useful to guess a valid center position at a different zoom level.
     * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
     */ View2.prototype.getConstrainedCenter = function(targetCenter, opt_targetResolution) {
        var size = this.getViewportSize_(this.getRotation());
        return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);
    };
    /**
     * Get a valid zoom level according to the current view constraints.
     * @param {number|undefined} targetZoom Target zoom.
     * @param {number} [opt_direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid zoom level.
     */ View2.prototype.getConstrainedZoom = function(targetZoom, opt_direction) {
        var targetRes = this.getResolutionForZoom(targetZoom);
        return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));
    };
    /**
     * Get a valid resolution according to the current view constraints.
     * @param {number|undefined} targetResolution Target resolution.
     * @param {number} [opt_direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid resolution.
     */ View2.prototype.getConstrainedResolution = function(targetResolution, opt_direction) {
        var direction = opt_direction || 0;
        var size = this.getViewportSize_(this.getRotation());
        return this.constraints_.resolution(targetResolution, direction, size);
    };
    return View2;
}(_objectJsDefault.default);
/**
 * @param {Function} callback Callback.
 * @param {*} returnValue Return value.
 */ function animationCallback(callback, returnValue) {
    setTimeout(function() {
        callback(returnValue);
    }, 0);
}
function createCenterConstraint(options) {
    if (options.extent !== undefined) {
        var smooth = options.smoothExtentConstraint !== undefined ? options.smoothExtentConstraint : true;
        return _centerconstraintJs.createExtent(options.extent, options.constrainOnlyCenter, smooth);
    }
    var projection = _projJs.createProjection(options.projection, 'EPSG:3857');
    if (options.multiWorld !== true && projection.isGlobal()) {
        var extent = projection.getExtent().slice();
        extent[0] = -Infinity;
        extent[2] = Infinity;
        return _centerconstraintJs.createExtent(extent, false, false);
    }
    return _centerconstraintJs.none;
}
function createResolutionConstraint(options) {
    var resolutionConstraint;
    var maxResolution;
    var minResolution;
    // TODO: move these to be ol constants
    // see https://github.com/openlayers/openlayers/issues/2076
    var defaultMaxZoom = 28;
    var defaultZoomFactor = 2;
    var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
    var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
    var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
    var multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
    var smooth = options.smoothResolutionConstraint !== undefined ? options.smoothResolutionConstraint : true;
    var showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
    var projection = _projJs.createProjection(options.projection, 'EPSG:3857');
    var projExtent = projection.getExtent();
    var constrainOnlyCenter = options.constrainOnlyCenter;
    var extent = options.extent;
    if (!multiWorld && !extent && projection.isGlobal()) {
        constrainOnlyCenter = false;
        extent = projExtent;
    }
    if (options.resolutions !== undefined) {
        var resolutions = options.resolutions;
        maxResolution = resolutions[minZoom];
        minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
        if (options.constrainResolution) resolutionConstraint = _resolutionconstraintJs.createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
        else resolutionConstraint = _resolutionconstraintJs.createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
        // calculate the default min and max resolution
        var size = !projExtent ? 360 * _projJs.METERS_PER_UNIT[_unitsJsDefault.default.DEGREES] / projection.getMetersPerUnit() : Math.max(_extentJs.getWidth(projExtent), _extentJs.getHeight(projExtent));
        var defaultMaxResolution = size / _commonJs.DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
        var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
        // user provided maxResolution takes precedence
        maxResolution = options.maxResolution;
        if (maxResolution !== undefined) minZoom = 0;
        else maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
        // user provided minResolution takes precedence
        minResolution = options.minResolution;
        if (minResolution === undefined) {
            if (options.maxZoom !== undefined) {
                if (options.maxResolution !== undefined) minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
                else minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
            } else minResolution = defaultMinResolution;
        }
        // given discrete zoom levels, minResolution may be different than provided
        maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
        minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
        if (options.constrainResolution) resolutionConstraint = _resolutionconstraintJs.createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
        else resolutionConstraint = _resolutionconstraintJs.createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
    return {
        constraint: resolutionConstraint,
        maxResolution: maxResolution,
        minResolution: minResolution,
        minZoom: minZoom,
        zoomFactor: zoomFactor
    };
}
function createRotationConstraint(options) {
    var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;
    if (enableRotation) {
        var constrainRotation = options.constrainRotation;
        if (constrainRotation === undefined || constrainRotation === true) return _rotationconstraintJs.createSnapToZero();
        else if (constrainRotation === false) return _rotationconstraintJs.none;
        else if (typeof constrainRotation === 'number') return _rotationconstraintJs.createSnapToN(constrainRotation);
        else return _rotationconstraintJs.none;
    } else return _rotationconstraintJs.disable;
}
function isNoopAnimation(animation) {
    if (animation.sourceCenter && animation.targetCenter) {
        if (!_coordinateJs.equals(animation.sourceCenter, animation.targetCenter)) return false;
    }
    if (animation.sourceResolution !== animation.targetResolution) return false;
    if (animation.sourceRotation !== animation.targetRotation) return false;
    return true;
}
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {import("./size.js").Size} size Box pixel size.
 * @param {import("./pixel.js").Pixel} position Position on the view to center on.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {import("./coordinate.js").Coordinate} Shifted center.
 */ function calculateCenterOn(coordinate, size, position, resolution, rotation) {
    // calculate rotated position
    var cosAngle = Math.cos(-rotation);
    var sinAngle = Math.sin(-rotation);
    var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    rotX += (size[0] / 2 - position[0]) * resolution;
    rotY += (position[1] - size[1] / 2) * resolution;
    // go back to original angle
    sinAngle = -sinAngle; // go back to original rotation
    var centerX = rotX * cosAngle - rotY * sinAngle;
    var centerY = rotY * cosAngle + rotX * sinAngle;
    return [
        centerX,
        centerY
    ];
}
exports.default = View1;

},{"./Object.js":"3roCV","./geom/GeometryType.js":"3sRlw","./proj/Units.js":"g2gaW","./ViewHint.js":"EJUkL","./ViewProperty.js":"d8El4","./tilegrid/common.js":"euoxp","./proj.js":"hmdWM","./functions.js":"d72zA","./coordinate.js":"cmApa","./asserts.js":"cnrP4","./obj.js":"g3fPg","./centerconstraint.js":"l9Gcm","./math.js":"kI4rE","./resolutionconstraint.js":"kpQUH","./rotationconstraint.js":"5he2A","./easing.js":"BpZIl","./extent.js":"jgUz2","./array.js":"jKNP0","./geom/Polygon.js":"hoOc8","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"EJUkL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    ANIMATING: 0,
    INTERACTING: 1
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"d8El4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    CENTER: 'center',
    RESOLUTION: 'resolution',
    ROTATION: 'rotation'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"l9Gcm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=, Array<number>=): (import("./coordinate.js").Coordinate|undefined)} Type
 */ /**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
 * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
 * (only during interaction and animation).
 * @return {Type} The constraint.
 */ parcelHelpers.export(exports, "createExtent", ()=>createExtent
);
/**
 * @param {import("./coordinate.js").Coordinate} [center] Center.
 * @return {import("./coordinate.js").Coordinate|undefined} Center.
 */ parcelHelpers.export(exports, "none", ()=>none
);
/**
 * @module ol/centerconstraint
 */ var _mathJs = require("./math.js");
function createExtent(extent, onlyCenter, smooth) {
    return(/**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [opt_centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */ function(center, resolution, size, opt_isMoving, opt_centerShift) {
        if (center) {
            var viewWidth = onlyCenter ? 0 : size[0] * resolution;
            var viewHeight = onlyCenter ? 0 : size[1] * resolution;
            var shiftX = opt_centerShift ? opt_centerShift[0] : 0;
            var shiftY = opt_centerShift ? opt_centerShift[1] : 0;
            var minX = extent[0] + viewWidth / 2 + shiftX;
            var maxX = extent[2] - viewWidth / 2 + shiftX;
            var minY = extent[1] + viewHeight / 2 + shiftY;
            var maxY = extent[3] - viewHeight / 2 + shiftY;
            // note: when zooming out of bounds, min and max values for x and y may
            // end up inverted (min > max); this has to be accounted for
            if (minX > maxX) {
                minX = (maxX + minX) / 2;
                maxX = minX;
            }
            if (minY > maxY) {
                minY = (maxY + minY) / 2;
                maxY = minY;
            }
            var x = _mathJs.clamp(center[0], minX, maxX);
            var y = _mathJs.clamp(center[1], minY, maxY);
            var ratio = 30 * resolution;
            // during an interaction, allow some overscroll
            if (opt_isMoving && smooth) {
                x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
                y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
            }
            return [
                x,
                y
            ];
        } else return undefined;
    });
}
function none(center) {
    return center;
}

},{"./math.js":"kI4rE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kpQUH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} resolutions Resolutions.
 * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [opt_maxExtent] Maximum allowed extent.
 * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */ parcelHelpers.export(exports, "createSnapToResolutions", ()=>createSnapToResolutions
);
/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number} [opt_minResolution] Minimum resolution.
 * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [opt_maxExtent] Maximum allowed extent.
 * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */ parcelHelpers.export(exports, "createSnapToPower", ()=>createSnapToPower
);
/**
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @param {boolean} [opt_smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent} [opt_maxExtent] Maximum allowed extent.
 * @param {boolean} [opt_showFullExtent] If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */ parcelHelpers.export(exports, "createMinMaxResolution", ()=>createMinMaxResolution
);
/**
 * @module ol/resolutionconstraint
 */ var _mathJs = require("./math.js");
var _extentJs = require("./extent.js");
var _arrayJs = require("./array.js");
/**
 * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
 */ /**
 * Returns a modified resolution taking into account the viewport size and maximum
 * allowed extent.
 * @param {number} resolution Resolution
 * @param {import("./extent.js").Extent} maxExtent Maximum allowed extent.
 * @param {import("./size.js").Size} viewportSize Viewport size.
 * @param {boolean} showFullExtent Whether to show the full extent.
 * @return {number} Capped resolution.
 */ function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
    var xResolution = _extentJs.getWidth(maxExtent) / viewportSize[0];
    var yResolution = _extentJs.getHeight(maxExtent) / viewportSize[1];
    if (showFullExtent) return Math.min(resolution, Math.max(xResolution, yResolution));
    return Math.min(resolution, Math.min(xResolution, yResolution));
}
/**
 * Returns a modified resolution to be between maxResolution and minResolution while
 * still allowing the value to be slightly out of bounds.
 * Note: the computation is based on the logarithm function (ln):
 *  - at 1, ln(x) is 0
 *  - above 1, ln(x) keeps increasing but at a much slower pace than x
 * The final result is clamped to prevent getting too far away from bounds.
 * @param {number} resolution Resolution.
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @return {number} Smoothed resolution.
 */ function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
    var result = Math.min(resolution, maxResolution);
    var ratio = 50;
    result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
    if (minResolution) {
        result = Math.max(result, minResolution);
        result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
    }
    return _mathJs.clamp(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {
    return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */ function(resolution, direction, size, opt_isMoving) {
        if (resolution !== undefined) {
            var maxResolution = resolutions[0];
            var minResolution = resolutions[resolutions.length - 1];
            var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
            // during interacting or animating, allow intermediary values
            if (opt_isMoving) {
                var smooth = opt_smooth !== undefined ? opt_smooth : true;
                if (!smooth) return _mathJs.clamp(resolution, minResolution, cappedMaxRes);
                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
            }
            var capped = Math.min(cappedMaxRes, resolution);
            var z = Math.floor(_arrayJs.linearFindNearest(resolutions, capped, direction));
            if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) return resolutions[z + 1];
            return resolutions[z];
        } else return undefined;
    });
}
function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
    return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */ function(resolution, direction, size, opt_isMoving) {
        if (resolution !== undefined) {
            var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
            var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0;
            // during interacting or animating, allow intermediary values
            if (opt_isMoving) {
                var smooth = opt_smooth !== undefined ? opt_smooth : true;
                if (!smooth) return _mathJs.clamp(resolution, minResolution, cappedMaxRes);
                return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
            }
            var tolerance = 0.000000001;
            var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
            var offset = -direction * (0.5 - tolerance) + 0.5;
            var capped = Math.min(cappedMaxRes, resolution);
            var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
            var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
            var newResolution = maxResolution / Math.pow(power, zoomLevel);
            return _mathJs.clamp(newResolution, minResolution, cappedMaxRes);
        } else return undefined;
    });
}
function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
    return(/**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */ function(resolution, direction, size, opt_isMoving) {
        if (resolution !== undefined) {
            var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
            var smooth = opt_smooth !== undefined ? opt_smooth : true;
            if (!smooth || !opt_isMoving) return _mathJs.clamp(resolution, minResolution, cappedMaxRes);
            return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        } else return undefined;
    });
}

},{"./math.js":"kI4rE","./extent.js":"jgUz2","./array.js":"jKNP0","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5he2A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
 */ /**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */ parcelHelpers.export(exports, "disable", ()=>disable
);
/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */ parcelHelpers.export(exports, "none", ()=>none
);
/**
 * @param {number} n N.
 * @return {Type} Rotation constraint.
 */ parcelHelpers.export(exports, "createSnapToN", ()=>createSnapToN
);
/**
 * @param {number} [opt_tolerance] Tolerance.
 * @return {Type} Rotation constraint.
 */ parcelHelpers.export(exports, "createSnapToZero", ()=>createSnapToZero
);
/**
 * @module ol/rotationconstraint
 */ var _mathJs = require("./math.js");
function disable(rotation) {
    if (rotation !== undefined) return 0;
    else return undefined;
}
function none(rotation) {
    if (rotation !== undefined) return rotation;
    else return undefined;
}
function createSnapToN(n) {
    var theta = 2 * Math.PI / n;
    return(/**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */ function(rotation, opt_isMoving) {
        if (opt_isMoving) return rotation;
        if (rotation !== undefined) {
            rotation = Math.floor(rotation / theta + 0.5) * theta;
            return rotation;
        } else return undefined;
    });
}
function createSnapToZero(opt_tolerance) {
    var tolerance = opt_tolerance || _mathJs.toRadians(5);
    return(/**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [opt_isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */ function(rotation, opt_isMoving) {
        if (opt_isMoving) return rotation;
        if (rotation !== undefined) {
            if (Math.abs(rotation) <= tolerance) return 0;
            else return rotation;
        } else return undefined;
    });
}

},{"./math.js":"kI4rE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hoOc8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices in meters.
 * @param {number} [opt_n] Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number} [opt_sphereRadius] Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {Polygon} The "circular" polygon.
 * @api
 */ parcelHelpers.export(exports, "circular", ()=>circular
);
/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {import("../extent.js").Extent} extent The extent.
 * @return {Polygon} The polygon.
 * @api
 */ parcelHelpers.export(exports, "fromExtent", ()=>fromExtent
);
/**
 * Create a regular polygon from a circle.
 * @param {import("./Circle.js").default} circle Circle geometry.
 * @param {number} [opt_sides] Number of sides of the polygon. Default is 32.
 * @param {number} [opt_angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 * @return {Polygon} Polygon geometry.
 * @api
 */ parcelHelpers.export(exports, "fromCircle", ()=>fromCircle
);
/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {Polygon} polygon Polygon geometry.
 * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number} [opt_angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 */ parcelHelpers.export(exports, "makeRegular", ()=>makeRegular
);
/**
 * @module ol/geom/Polygon
 */ var _geometryLayoutJs = require("./GeometryLayout.js");
var _geometryLayoutJsDefault = parcelHelpers.interopDefault(_geometryLayoutJs);
var _geometryTypeJs = require("./GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _linearRingJs = require("./LinearRing.js");
var _linearRingJsDefault = parcelHelpers.interopDefault(_linearRingJs);
var _pointJs = require("./Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _arrayJs = require("../array.js");
var _interiorpointJs = require("./flat/interiorpoint.js");
var _inflateJs = require("./flat/inflate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
var _orientJs = require("./flat/orient.js");
var _areaJs = require("./flat/area.js");
var _containsJs = require("./flat/contains.js");
var _mathJs = require("../math.js");
var _simplifyJs = require("./flat/simplify.js");
var _sphereJs = require("../sphere.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */ var Polygon1 = function(_super) {
    __extends(Polygon2, _super);
    /**
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
     *     Array of linear rings that define the polygon. The first linear ring of the
     *     array defines the outer-boundary or surface of the polygon. Each subsequent
     *     linear ring defines a hole in the surface of the polygon. A linear ring is
     *     an array of vertices' coordinates where the first coordinate and the last are
     *     equivalent. (For internal use, flat coordinates in combination with
     *     `opt_layout` and `opt_ends` are also accepted.)
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @param {Array<number>} [opt_ends] Ends (for internal use with flat coordinates).
     */ function Polygon2(coordinates, opt_layout, opt_ends) {
        var _this = _super.call(this) || this;
        /**
         * @type {Array<number>}
         * @private
         */ _this.ends_ = [];
        /**
         * @private
         * @type {number}
         */ _this.flatInteriorPointRevision_ = -1;
        /**
         * @private
         * @type {import("../coordinate.js").Coordinate}
         */ _this.flatInteriorPoint_ = null;
        /**
         * @private
         * @type {number}
         */ _this.maxDelta_ = -1;
        /**
         * @private
         * @type {number}
         */ _this.maxDeltaRevision_ = -1;
        /**
         * @private
         * @type {number}
         */ _this.orientedRevision_ = -1;
        /**
         * @private
         * @type {Array<number>}
         */ _this.orientedFlatCoordinates_ = null;
        if (opt_layout !== undefined && opt_ends) {
            _this.setFlatCoordinates(opt_layout, coordinates);
            _this.ends_ = opt_ends;
        } else _this.setCoordinates(coordinates, opt_layout);
        return _this;
    }
    /**
     * Append the passed linear ring to this polygon.
     * @param {LinearRing} linearRing Linear ring.
     * @api
     */ Polygon2.prototype.appendLinearRing = function(linearRing) {
        if (!this.flatCoordinates) this.flatCoordinates = linearRing.getFlatCoordinates().slice();
        else _arrayJs.extend(this.flatCoordinates, linearRing.getFlatCoordinates());
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
    };
    /**
     * Make a complete copy of the geometry.
     * @return {!Polygon} Clone.
     * @api
     */ Polygon2.prototype.clone = function() {
        var polygon = new Polygon2(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
        polygon.applyProperties(this);
        return polygon;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */ Polygon2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < _extentJs.closestSquaredDistanceXY(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt(_closestJs.arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return _closestJs.assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */ Polygon2.prototype.containsXY = function(x, y) {
        return _containsJs.linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
    };
    /**
     * Return the area of the polygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */ Polygon2.prototype.getArea = function() {
        return _areaJs.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
    };
    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for polygons.
     *
     * @param {boolean} [opt_right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     */ Polygon2.prototype.getCoordinates = function(opt_right) {
        var flatCoordinates;
        if (opt_right !== undefined) {
            flatCoordinates = this.getOrientedFlatCoordinates().slice();
            _orientJs.orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);
        } else flatCoordinates = this.flatCoordinates;
        return _inflateJs.inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
    };
    /**
     * @return {Array<number>} Ends.
     */ Polygon2.prototype.getEnds = function() {
        return this.ends_;
    };
    /**
     * @return {Array<number>} Interior point.
     */ Polygon2.prototype.getFlatInteriorPoint = function() {
        if (this.flatInteriorPointRevision_ != this.getRevision()) {
            var flatCenter = _extentJs.getCenter(this.getExtent());
            this.flatInteriorPoint_ = _interiorpointJs.getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
            this.flatInteriorPointRevision_ = this.getRevision();
        }
        return this.flatInteriorPoint_;
    };
    /**
     * Return an interior point of the polygon.
     * @return {Point} Interior point as XYM coordinate, where M is the
     * length of the horizontal intersection that the point belongs to.
     * @api
     */ Polygon2.prototype.getInteriorPoint = function() {
        return new _pointJsDefault.default(this.getFlatInteriorPoint(), _geometryLayoutJsDefault.default.XYM);
    };
    /**
     * Return the number of rings of the polygon,  this includes the exterior
     * ring and any interior rings.
     *
     * @return {number} Number of rings.
     * @api
     */ Polygon2.prototype.getLinearRingCount = function() {
        return this.ends_.length;
    };
    /**
     * Return the Nth linear ring of the polygon geometry. Return `null` if the
     * given index is out of range.
     * The exterior linear ring is available at index `0` and the interior rings
     * at index `1` and beyond.
     *
     * @param {number} index Index.
     * @return {LinearRing} Linear ring.
     * @api
     */ Polygon2.prototype.getLinearRing = function(index) {
        if (index < 0 || this.ends_.length <= index) return null;
        return new _linearRingJsDefault.default(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
    };
    /**
     * Return the linear rings of the polygon.
     * @return {Array<LinearRing>} Linear rings.
     * @api
     */ Polygon2.prototype.getLinearRings = function() {
        var layout = this.layout;
        var flatCoordinates = this.flatCoordinates;
        var ends = this.ends_;
        var linearRings = [];
        var offset = 0;
        for(var i = 0, ii = ends.length; i < ii; ++i){
            var end = ends[i];
            var linearRing = new _linearRingJsDefault.default(flatCoordinates.slice(offset, end), layout);
            linearRings.push(linearRing);
            offset = end;
        }
        return linearRings;
    };
    /**
     * @return {Array<number>} Oriented flat coordinates.
     */ Polygon2.prototype.getOrientedFlatCoordinates = function() {
        if (this.orientedRevision_ != this.getRevision()) {
            var flatCoordinates = this.flatCoordinates;
            if (_orientJs.linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) this.orientedFlatCoordinates_ = flatCoordinates;
            else {
                this.orientedFlatCoordinates_ = flatCoordinates.slice();
                this.orientedFlatCoordinates_.length = _orientJs.orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
            }
            this.orientedRevision_ = this.getRevision();
        }
        return this.orientedFlatCoordinates_;
    };
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Polygon} Simplified Polygon.
     * @protected
     */ Polygon2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        var simplifiedEnds = [];
        simplifiedFlatCoordinates.length = _simplifyJs.quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
        return new Polygon2(simplifiedFlatCoordinates, _geometryLayoutJsDefault.default.XY, simplifiedEnds);
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */ Polygon2.prototype.getType = function() {
        return _geometryTypeJsDefault.default.POLYGON;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */ Polygon2.prototype.intersectsExtent = function(extent) {
        return _intersectsextentJs.intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
    };
    /**
     * Set the coordinates of the polygon.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @api
     */ Polygon2.prototype.setCoordinates = function(coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 2);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        var ends = _deflateJs.deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
    };
    return Polygon2;
}(_simpleGeometryJsDefault.default);
exports.default = Polygon1;
function circular(center, radius, opt_n, opt_sphereRadius) {
    var n = opt_n ? opt_n : 32;
    /** @type {Array<number>} */ var flatCoordinates = [];
    for(var i = 0; i < n; ++i)_arrayJs.extend(flatCoordinates, _sphereJs.offset(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));
    flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
    return new Polygon1(flatCoordinates, _geometryLayoutJsDefault.default.XY, [
        flatCoordinates.length, 
    ]);
}
function fromExtent(extent) {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var flatCoordinates = [
        minX,
        minY,
        minX,
        maxY,
        maxX,
        maxY,
        maxX,
        minY,
        minX,
        minY, 
    ];
    return new Polygon1(flatCoordinates, _geometryLayoutJsDefault.default.XY, [
        flatCoordinates.length, 
    ]);
}
function fromCircle(circle, opt_sides, opt_angle) {
    var sides = opt_sides ? opt_sides : 32;
    var stride = circle.getStride();
    var layout = circle.getLayout();
    var center = circle.getCenter();
    var arrayLength = stride * (sides + 1);
    var flatCoordinates = new Array(arrayLength);
    for(var i = 0; i < arrayLength; i += stride){
        flatCoordinates[i] = 0;
        flatCoordinates[i + 1] = 0;
        for(var j = 2; j < stride; j++)flatCoordinates[i + j] = center[j];
    }
    var ends = [
        flatCoordinates.length
    ];
    var polygon = new Polygon1(flatCoordinates, layout, ends);
    makeRegular(polygon, center, circle.getRadius(), opt_angle);
    return polygon;
}
function makeRegular(polygon, center, radius, opt_angle) {
    var flatCoordinates = polygon.getFlatCoordinates();
    var stride = polygon.getStride();
    var sides = flatCoordinates.length / stride - 1;
    var startAngle = opt_angle ? opt_angle : 0;
    for(var i = 0; i <= sides; ++i){
        var offset = i * stride;
        var angle = startAngle + _mathJs.modulo(i, sides) * 2 * Math.PI / sides;
        flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
        flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
    }
    polygon.changed();
}

},{"./GeometryLayout.js":"ajlbX","./GeometryType.js":"3sRlw","./LinearRing.js":"9Sp1K","./Point.js":"4ReTD","./SimpleGeometry.js":"4jyQo","./flat/closest.js":"2YhxK","../extent.js":"jgUz2","./flat/deflate.js":"gFAia","../array.js":"jKNP0","./flat/interiorpoint.js":"kXs0P","./flat/inflate.js":"9BPwr","./flat/intersectsextent.js":"jv50N","./flat/orient.js":"TP5fs","./flat/area.js":"kSE5y","./flat/contains.js":"hPmbJ","../math.js":"kI4rE","./flat/simplify.js":"7GCEm","../sphere.js":"d26nZ","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"ajlbX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    XY: 'XY',
    XYZ: 'XYZ',
    XYM: 'XYM',
    XYZM: 'XYZM'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9Sp1K":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/LinearRing
 */ var _geometryLayoutJs = require("./GeometryLayout.js");
var _geometryLayoutJsDefault = parcelHelpers.interopDefault(_geometryLayoutJs);
var _geometryTypeJs = require("./GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _simplifyJs = require("./flat/simplify.js");
var _inflateJs = require("./flat/inflate.js");
var _areaJs = require("./flat/area.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */ var LinearRing1 = function(_super) {
    __extends(LinearRing2, _super);
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     */ function LinearRing2(coordinates, opt_layout) {
        var _this = _super.call(this) || this;
        /**
         * @private
         * @type {number}
         */ _this.maxDelta_ = -1;
        /**
         * @private
         * @type {number}
         */ _this.maxDeltaRevision_ = -1;
        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) _this.setFlatCoordinates(opt_layout, coordinates);
        else _this.setCoordinates(coordinates, opt_layout);
        return _this;
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!LinearRing} Clone.
     * @api
     */ LinearRing2.prototype.clone = function() {
        return new LinearRing2(this.flatCoordinates.slice(), this.layout);
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */ LinearRing2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < _extentJs.closestSquaredDistanceXY(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt(_closestJs.maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return _closestJs.assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    };
    /**
     * Return the area of the linear ring on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */ LinearRing2.prototype.getArea = function() {
        return _areaJs.linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    };
    /**
     * Return the coordinates of the linear ring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     */ LinearRing2.prototype.getCoordinates = function() {
        return _inflateJs.inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    };
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LinearRing} Simplified LinearRing.
     * @protected
     */ LinearRing2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = _simplifyJs.douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        return new LinearRing2(simplifiedFlatCoordinates, _geometryLayoutJsDefault.default.XY);
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */ LinearRing2.prototype.getType = function() {
        return _geometryTypeJsDefault.default.LINEAR_RING;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */ LinearRing2.prototype.intersectsExtent = function(extent) {
        return false;
    };
    /**
     * Set the coordinates of the linear ring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @api
     */ LinearRing2.prototype.setCoordinates = function(coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 1);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = _deflateJs.deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    };
    return LinearRing2;
}(_simpleGeometryJsDefault.default);
exports.default = LinearRing1;

},{"./GeometryLayout.js":"ajlbX","./GeometryType.js":"3sRlw","./SimpleGeometry.js":"4jyQo","./flat/closest.js":"2YhxK","../extent.js":"jgUz2","./flat/deflate.js":"gFAia","./flat/simplify.js":"7GCEm","./flat/inflate.js":"9BPwr","./flat/area.js":"kSE5y","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"4jyQo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import("./GeometryLayout.js").default} layout Layout.
 * @return {number} Stride.
 */ parcelHelpers.export(exports, "getStrideForLayout", ()=>getStrideForLayout
);
/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */ parcelHelpers.export(exports, "transformGeom2D", ()=>transformGeom2D
);
/**
 * @module ol/geom/SimpleGeometry
 */ var _geometryJs = require("./Geometry.js");
var _geometryJsDefault = parcelHelpers.interopDefault(_geometryJs);
var _geometryLayoutJs = require("./GeometryLayout.js");
var _geometryLayoutJsDefault = parcelHelpers.interopDefault(_geometryLayoutJs);
var _utilJs = require("../util.js");
var _extentJs = require("../extent.js");
var _transformJs = require("./flat/transform.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */ var SimpleGeometry1 = function(_super) {
    __extends(SimpleGeometry2, _super);
    function SimpleGeometry2() {
        var _this = _super.call(this) || this;
        /**
         * @protected
         * @type {import("./GeometryLayout.js").default}
         */ _this.layout = _geometryLayoutJsDefault.default.XY;
        /**
         * @protected
         * @type {number}
         */ _this.stride = 2;
        /**
         * @protected
         * @type {Array<number>}
         */ _this.flatCoordinates = null;
        return _this;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */ SimpleGeometry2.prototype.computeExtent = function(extent) {
        return _extentJs.createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
    };
    /**
     * @abstract
     * @return {Array<*>} Coordinates.
     */ SimpleGeometry2.prototype.getCoordinates = function() {
        return _utilJs.abstract();
    };
    /**
     * Return the first coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} First coordinate.
     * @api
     */ SimpleGeometry2.prototype.getFirstCoordinate = function() {
        return this.flatCoordinates.slice(0, this.stride);
    };
    /**
     * @return {Array<number>} Flat coordinates.
     */ SimpleGeometry2.prototype.getFlatCoordinates = function() {
        return this.flatCoordinates;
    };
    /**
     * Return the last coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} Last point.
     * @api
     */ SimpleGeometry2.prototype.getLastCoordinate = function() {
        return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
    };
    /**
     * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.
     * @return {import("./GeometryLayout.js").default} Layout.
     * @api
     */ SimpleGeometry2.prototype.getLayout = function() {
        return this.layout;
    };
    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     */ SimpleGeometry2.prototype.getSimplifiedGeometry = function(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
            this.simplifiedGeometryMaxMinSquaredTolerance = 0;
            this.simplifiedGeometryRevision = this.getRevision();
        }
        // If squaredTolerance is negative or if we know that simplification will not
        // have any effect then just return this.
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) return this;
        var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
        var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
        if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) return simplifiedGeometry;
        else {
            // Simplification did not actually remove any coordinates.  We now know
            // that any calls to getSimplifiedGeometry with a squaredTolerance less
            // than or equal to the current squaredTolerance will also not have any
            // effect.  This allows us to short circuit simplification (saving CPU
            // cycles) and prevents the cache of simplified geometries from filling
            // up with useless identical copies of this geometry (saving memory).
            this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
            return this;
        }
    };
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     * @protected
     */ SimpleGeometry2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
        return this;
    };
    /**
     * @return {number} Stride.
     */ SimpleGeometry2.prototype.getStride = function() {
        return this.stride;
    };
    /**
     * @param {import("./GeometryLayout.js").default} layout Layout.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     */ SimpleGeometry2.prototype.setFlatCoordinates = function(layout, flatCoordinates) {
        this.stride = getStrideForLayout(layout);
        this.layout = layout;
        this.flatCoordinates = flatCoordinates;
    };
    /**
     * @abstract
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     */ SimpleGeometry2.prototype.setCoordinates = function(coordinates, opt_layout) {
        _utilJs.abstract();
    };
    /**
     * @param {import("./GeometryLayout.js").default|undefined} layout Layout.
     * @param {Array<*>} coordinates Coordinates.
     * @param {number} nesting Nesting.
     * @protected
     */ SimpleGeometry2.prototype.setLayout = function(layout, coordinates, nesting) {
        /** @type {number} */ var stride;
        if (layout) stride = getStrideForLayout(layout);
        else {
            for(var i = 0; i < nesting; ++i)if (coordinates.length === 0) {
                this.layout = _geometryLayoutJsDefault.default.XY;
                this.stride = 2;
                return;
            } else coordinates = coordinates[0];
            stride = coordinates.length;
            layout = getLayoutForStride(stride);
        }
        this.layout = layout;
        this.stride = stride;
    };
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     * @api
     */ SimpleGeometry2.prototype.applyTransform = function(transformFn) {
        if (this.flatCoordinates) {
            transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
            this.changed();
        }
    };
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in counter-clockwise radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */ SimpleGeometry2.prototype.rotate = function(angle, anchor) {
        var flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
            var stride = this.getStride();
            _transformJs.rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
            this.changed();
        }
    };
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [opt_anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */ SimpleGeometry2.prototype.scale = function(sx, opt_sy, opt_anchor) {
        var sy = opt_sy;
        if (sy === undefined) sy = sx;
        var anchor = opt_anchor;
        if (!anchor) anchor = _extentJs.getCenter(this.getExtent());
        var flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
            var stride = this.getStride();
            _transformJs.scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
            this.changed();
        }
    };
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */ SimpleGeometry2.prototype.translate = function(deltaX, deltaY) {
        var flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
            var stride = this.getStride();
            _transformJs.translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
            this.changed();
        }
    };
    return SimpleGeometry2;
}(_geometryJsDefault.default);
/**
 * @param {number} stride Stride.
 * @return {import("./GeometryLayout.js").default} layout Layout.
 */ function getLayoutForStride(stride) {
    var layout;
    if (stride == 2) layout = _geometryLayoutJsDefault.default.XY;
    else if (stride == 3) layout = _geometryLayoutJsDefault.default.XYZ;
    else if (stride == 4) layout = _geometryLayoutJsDefault.default.XYZM;
    return layout;
}
function getStrideForLayout(layout) {
    var stride;
    if (layout == _geometryLayoutJsDefault.default.XY) stride = 2;
    else if (layout == _geometryLayoutJsDefault.default.XYZ || layout == _geometryLayoutJsDefault.default.XYM) stride = 3;
    else if (layout == _geometryLayoutJsDefault.default.XYZM) stride = 4;
    return stride;
}
function transformGeom2D(simpleGeometry, transform, opt_dest) {
    var flatCoordinates = simpleGeometry.getFlatCoordinates();
    if (!flatCoordinates) return null;
    else {
        var stride = simpleGeometry.getStride();
        return _transformJs.transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);
    }
}
exports.default = SimpleGeometry1;

},{"./Geometry.js":"luMos","./GeometryLayout.js":"ajlbX","../util.js":"9zOhk","../extent.js":"jgUz2","./flat/transform.js":"eZ5a1","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"luMos":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/Geometry
 */ var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _unitsJs = require("../proj/Units.js");
var _unitsJsDefault = parcelHelpers.interopDefault(_unitsJs);
var _utilJs = require("../util.js");
var _transformJs = require("../transform.js");
var _extentJs = require("../extent.js");
var _projJs = require("../proj.js");
var _functionsJs = require("../functions.js");
var _transformJs1 = require("./flat/transform.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @type {import("../transform.js").Transform}
 */ var tmpTransform = _transformJs.create();
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */ var Geometry1 = function(_super) {
    __extends(Geometry2, _super);
    function Geometry2() {
        var _this = _super.call(this) || this;
        /**
         * @private
         * @type {import("../extent.js").Extent}
         */ _this.extent_ = _extentJs.createEmpty();
        /**
         * @private
         * @type {number}
         */ _this.extentRevision_ = -1;
        /**
         * @protected
         * @type {number}
         */ _this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        /**
         * @protected
         * @type {number}
         */ _this.simplifiedGeometryRevision = 0;
        /**
         * Get a transformed and simplified version of the geometry.
         * @abstract
         * @param {number} revision The geometry revision.
         * @param {number} squaredTolerance Squared tolerance.
         * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
         * @return {Geometry} Simplified geometry.
         */ _this.simplifyTransformedInternal = _functionsJs.memoizeOne(function(revision, squaredTolerance, opt_transform) {
            if (!opt_transform) return this.getSimplifiedGeometry(squaredTolerance);
            var clone = this.clone();
            clone.applyTransform(opt_transform);
            return clone.getSimplifiedGeometry(squaredTolerance);
        });
        return _this;
    }
    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */ Geometry2.prototype.simplifyTransformed = function(squaredTolerance, opt_transform) {
        return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);
    };
    /**
     * Make a complete copy of the geometry.
     * @abstract
     * @return {!Geometry} Clone.
     */ Geometry2.prototype.clone = function() {
        return _utilJs.abstract();
    };
    /**
     * @abstract
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */ Geometry2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
        return _utilJs.abstract();
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */ Geometry2.prototype.containsXY = function(x, y) {
        var coord = this.getClosestPoint([
            x,
            y
        ]);
        return coord[0] === x && coord[1] === y;
    };
    /**
     * Return the closest point of the geometry to the passed point as
     * {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} point Point.
     * @param {import("../coordinate.js").Coordinate} [opt_closestPoint] Closest point.
     * @return {import("../coordinate.js").Coordinate} Closest point.
     * @api
     */ Geometry2.prototype.getClosestPoint = function(point, opt_closestPoint) {
        var closestPoint = opt_closestPoint ? opt_closestPoint : [
            NaN,
            NaN
        ];
        this.closestPointXY(point[0], point[1], closestPoint, Infinity);
        return closestPoint;
    };
    /**
     * Returns true if this geometry includes the specified coordinate. If the
     * coordinate is on the boundary of the geometry, returns false.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains coordinate.
     * @api
     */ Geometry2.prototype.intersectsCoordinate = function(coordinate) {
        return this.containsXY(coordinate[0], coordinate[1]);
    };
    /**
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */ Geometry2.prototype.computeExtent = function(extent) {
        return _utilJs.abstract();
    };
    /**
     * Get the extent of the geometry.
     * @param {import("../extent.js").Extent} [opt_extent] Extent.
     * @return {import("../extent.js").Extent} extent Extent.
     * @api
     */ Geometry2.prototype.getExtent = function(opt_extent) {
        if (this.extentRevision_ != this.getRevision()) {
            var extent = this.computeExtent(this.extent_);
            if (isNaN(extent[0]) || isNaN(extent[1])) _extentJs.createOrUpdateEmpty(extent);
            this.extentRevision_ = this.getRevision();
        }
        return _extentJs.returnOrUpdate(this.extent_, opt_extent);
    };
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} angle Rotation angle in radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */ Geometry2.prototype.rotate = function(angle, anchor) {
        _utilJs.abstract();
    };
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [opt_anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */ Geometry2.prototype.scale = function(sx, opt_sy, opt_anchor) {
        _utilJs.abstract();
    };
    /**
     * Create a simplified version of this geometry.  For linestrings, this uses
     * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
     * algorithm.  For polygons, a quantization-based
     * simplification is used to preserve topology.
     * @param {number} tolerance The tolerance distance for simplification.
     * @return {Geometry} A new, simplified version of the original geometry.
     * @api
     */ Geometry2.prototype.simplify = function(tolerance) {
        return this.getSimplifiedGeometry(tolerance * tolerance);
    };
    /**
     * Create a simplified version of this geometry using the Douglas Peucker
     * algorithm.
     * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Geometry} Simplified geometry.
     */ Geometry2.prototype.getSimplifiedGeometry = function(squaredTolerance) {
        return _utilJs.abstract();
    };
    /**
     * Get the type of this geometry.
     * @abstract
     * @return {import("./GeometryType.js").default} Geometry type.
     */ Geometry2.prototype.getType = function() {
        return _utilJs.abstract();
    };
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @abstract
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     */ Geometry2.prototype.applyTransform = function(transformFn) {
        _utilJs.abstract();
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     */ Geometry2.prototype.intersectsExtent = function(extent) {
        return _utilJs.abstract();
    };
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @abstract
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */ Geometry2.prototype.translate = function(deltaX, deltaY) {
        _utilJs.abstract();
    };
    /**
     * Transform each coordinate of the geometry from one coordinate reference
     * system to another. The geometry is modified in place.
     * For example, a line will be transformed to a line and a circle to a circle.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     *
     * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @return {Geometry} This geometry.  Note that original geometry is
     *     modified in place.
     * @api
     */ Geometry2.prototype.transform = function(source, destination) {
        /** @type {import("../proj/Projection.js").default} */ var sourceProj = _projJs.get(source);
        var transformFn = sourceProj.getUnits() == _unitsJsDefault.default.TILE_PIXELS ? function(inCoordinates, outCoordinates, stride) {
            var pixelExtent = sourceProj.getExtent();
            var projectedExtent = sourceProj.getWorldExtent();
            var scale = _extentJs.getHeight(projectedExtent) / _extentJs.getHeight(pixelExtent);
            _transformJs.compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
            _transformJs1.transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
            return _projJs.getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);
        } : _projJs.getTransform(sourceProj, destination);
        this.applyTransform(transformFn);
        return this;
    };
    return Geometry2;
}(_objectJsDefault.default);
exports.default = Geometry1;

},{"../Object.js":"3roCV","../proj/Units.js":"g2gaW","../util.js":"9zOhk","../transform.js":"C21tg","../extent.js":"jgUz2","../proj.js":"hmdWM","../functions.js":"d72zA","./flat/transform.js":"eZ5a1","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eZ5a1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/flat/transform
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ parcelHelpers.export(exports, "transform2D", ()=>transform2D
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ parcelHelpers.export(exports, "rotate", ()=>rotate
);
/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ parcelHelpers.export(exports, "scale", ()=>scale
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */ parcelHelpers.export(exports, "translate", ()=>translate
);
function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {
    var dest = opt_dest ? opt_dest : [];
    var i = 0;
    for(var j = offset; j < end; j += stride){
        var x = flatCoordinates[j];
        var y = flatCoordinates[j + 1];
        dest[i++] = transform[0] * x + transform[2] * y + transform[4];
        dest[i++] = transform[1] * x + transform[3] * y + transform[5];
    }
    if (opt_dest && dest.length != i) dest.length = i;
    return dest;
}
function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
    var dest = opt_dest ? opt_dest : [];
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    var anchorX = anchor[0];
    var anchorY = anchor[1];
    var i = 0;
    for(var j = offset; j < end; j += stride){
        var deltaX = flatCoordinates[j] - anchorX;
        var deltaY = flatCoordinates[j + 1] - anchorY;
        dest[i++] = anchorX + deltaX * cos - deltaY * sin;
        dest[i++] = anchorY + deltaX * sin + deltaY * cos;
        for(var k = j + 2; k < j + stride; ++k)dest[i++] = flatCoordinates[k];
    }
    if (opt_dest && dest.length != i) dest.length = i;
    return dest;
}
function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
    var dest = opt_dest ? opt_dest : [];
    var anchorX = anchor[0];
    var anchorY = anchor[1];
    var i = 0;
    for(var j = offset; j < end; j += stride){
        var deltaX = flatCoordinates[j] - anchorX;
        var deltaY = flatCoordinates[j + 1] - anchorY;
        dest[i++] = anchorX + sx * deltaX;
        dest[i++] = anchorY + sy * deltaY;
        for(var k = j + 2; k < j + stride; ++k)dest[i++] = flatCoordinates[k];
    }
    if (opt_dest && dest.length != i) dest.length = i;
    return dest;
}
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
    var dest = opt_dest ? opt_dest : [];
    var i = 0;
    for(var j = offset; j < end; j += stride){
        dest[i++] = flatCoordinates[j] + deltaX;
        dest[i++] = flatCoordinates[j + 1] + deltaY;
        for(var k = j + 2; k < j + stride; ++k)dest[i++] = flatCoordinates[k];
    }
    if (opt_dest && dest.length != i) dest.length = i;
    return dest;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"2YhxK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */ parcelHelpers.export(exports, "maxSquaredDelta", ()=>maxSquaredDelta
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */ parcelHelpers.export(exports, "arrayMaxSquaredDelta", ()=>arrayMaxSquaredDelta
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */ parcelHelpers.export(exports, "multiArrayMaxSquaredDelta", ()=>multiArrayMaxSquaredDelta
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [opt_tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */ parcelHelpers.export(exports, "assignClosestPoint", ()=>assignClosestPoint
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [opt_tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */ parcelHelpers.export(exports, "assignClosestArrayPoint", ()=>assignClosestArrayPoint
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [opt_tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */ parcelHelpers.export(exports, "assignClosestMultiArrayPoint", ()=>assignClosestMultiArrayPoint
);
/**
 * @module ol/geom/flat/closest
 */ var _mathJs = require("../../math.js");
/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 */ function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
    var x1 = flatCoordinates[offset1];
    var y1 = flatCoordinates[offset1 + 1];
    var dx = flatCoordinates[offset2] - x1;
    var dy = flatCoordinates[offset2 + 1] - y1;
    var offset;
    if (dx === 0 && dy === 0) offset = offset1;
    else {
        var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
        if (t > 1) offset = offset2;
        else if (t > 0) {
            for(var i = 0; i < stride; ++i)closestPoint[i] = _mathJs.lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
            closestPoint.length = stride;
            return;
        } else offset = offset1;
    }
    for(var i = 0; i < stride; ++i)closestPoint[i] = flatCoordinates[offset + i];
    closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    for(offset += stride; offset < end; offset += stride){
        var x2 = flatCoordinates[offset];
        var y2 = flatCoordinates[offset + 1];
        var squaredDelta = _mathJs.squaredDistance(x1, y1, x2, y2);
        if (squaredDelta > max) max = squaredDelta;
        x1 = x2;
        y1 = y2;
    }
    return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
    for(var i = 0, ii = ends.length; i < ii; ++i){
        var end = ends[i];
        max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
        offset = end;
    }
    return max;
}
function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
    for(var i = 0, ii = endss.length; i < ii; ++i){
        var ends = endss[i];
        max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
        offset = ends[ends.length - 1];
    }
    return max;
}
function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
    if (offset == end) return minSquaredDistance;
    var i, squaredDistance;
    if (maxDelta === 0) {
        // All points are identical, so just test the first point.
        squaredDistance = _mathJs.squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
        if (squaredDistance < minSquaredDistance) {
            for(i = 0; i < stride; ++i)closestPoint[i] = flatCoordinates[offset + i];
            closestPoint.length = stride;
            return squaredDistance;
        } else return minSquaredDistance;
    }
    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [
        NaN,
        NaN
    ];
    var index = offset + stride;
    while(index < end){
        assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
        squaredDistance = _mathJs.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
        if (squaredDistance < minSquaredDistance) {
            minSquaredDistance = squaredDistance;
            for(i = 0; i < stride; ++i)closestPoint[i] = tmpPoint[i];
            closestPoint.length = stride;
            index += stride;
        } else // Skip ahead multiple points, because we know that all the skipped
        // points cannot be any closer than the closest point we have found so
        // far.  We know this because we know how close the current point is, how
        // close the closest point we have found so far is, and the maximum
        // distance between consecutive points.  For example, if we're currently
        // at distance 10, the best we've found so far is 3, and that the maximum
        // distance between consecutive points is 2, then we'll need to skip at
        // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
        // finding a closer point.  We use Math.max(..., 1) to ensure that we
        // always advance at least one point, to avoid an infinite loop.
        index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
    if (isRing) {
        // Check the closing segment.
        assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
        squaredDistance = _mathJs.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
        if (squaredDistance < minSquaredDistance) {
            minSquaredDistance = squaredDistance;
            for(i = 0; i < stride; ++i)closestPoint[i] = tmpPoint[i];
            closestPoint.length = stride;
        }
    }
    return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [
        NaN,
        NaN
    ];
    for(var i = 0, ii = ends.length; i < ii; ++i){
        var end = ends[i];
        minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
        offset = end;
    }
    return minSquaredDistance;
}
function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
    var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [
        NaN,
        NaN
    ];
    for(var i = 0, ii = endss.length; i < ii; ++i){
        var ends = endss[i];
        minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
        offset = ends[ends.length - 1];
    }
    return minSquaredDistance;
}

},{"../../math.js":"kI4rE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"gFAia":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/flat/deflate
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */ parcelHelpers.export(exports, "deflateCoordinate", ()=>deflateCoordinate
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */ parcelHelpers.export(exports, "deflateCoordinates", ()=>deflateCoordinates
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>} [opt_ends] Ends.
 * @return {Array<number>} Ends.
 */ parcelHelpers.export(exports, "deflateCoordinatesArray", ()=>deflateCoordinatesArray
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>} [opt_endss] Endss.
 * @return {Array<Array<number>>} Endss.
 */ parcelHelpers.export(exports, "deflateMultiCoordinatesArray", ()=>deflateMultiCoordinatesArray
);
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
    for(var i = 0, ii = coordinate.length; i < ii; ++i)flatCoordinates[offset++] = coordinate[i];
    return offset;
}
function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
    for(var i = 0, ii = coordinates.length; i < ii; ++i){
        var coordinate = coordinates[i];
        for(var j = 0; j < stride; ++j)flatCoordinates[offset++] = coordinate[j];
    }
    return offset;
}
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
    var ends = opt_ends ? opt_ends : [];
    var i = 0;
    for(var j = 0, jj = coordinatess.length; j < jj; ++j){
        var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
        ends[i++] = end;
        offset = end;
    }
    ends.length = i;
    return ends;
}
function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
    var endss = opt_endss ? opt_endss : [];
    var i = 0;
    for(var j = 0, jj = coordinatesss.length; j < jj; ++j){
        var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
        endss[i++] = ends;
        offset = ends[ends.length - 1];
    }
    endss.length = i;
    return endss;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7GCEm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>} [opt_simplifiedFlatCoordinates] Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */ parcelHelpers.export(exports, "simplifyLineString", ()=>simplifyLineString
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "douglasPeucker", ()=>douglasPeucker
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "douglasPeuckerArray", ()=>douglasPeuckerArray
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "douglasPeuckerMultiArray", ()=>douglasPeuckerMultiArray
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "radialDistance", ()=>radialDistance
);
/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */ parcelHelpers.export(exports, "snap", ()=>snap
);
/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "quantize", ()=>quantize
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "quantizeArray", ()=>quantizeArray
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */ parcelHelpers.export(exports, "quantizeMultiArray", ()=>quantizeMultiArray
);
/**
 * @module ol/geom/flat/simplify
 */ // Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
var _mathJs = require("../../math.js");
function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {
    var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ? opt_simplifiedFlatCoordinates : [];
    if (!highQuality) {
        end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        flatCoordinates = simplifiedFlatCoordinates;
        offset = 0;
        stride = 2;
    }
    simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return simplifiedFlatCoordinates;
}
function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    var n = (end - offset) / stride;
    if (n < 3) {
        for(; offset < end; offset += stride){
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
        }
        return simplifiedOffset;
    }
    /** @type {Array<number>} */ var markers = new Array(n);
    markers[0] = 1;
    markers[n - 1] = 1;
    /** @type {Array<number>} */ var stack = [
        offset,
        end - stride
    ];
    var index = 0;
    while(stack.length > 0){
        var last = stack.pop();
        var first = stack.pop();
        var maxSquaredDistance = 0;
        var x1 = flatCoordinates[first];
        var y1 = flatCoordinates[first + 1];
        var x2 = flatCoordinates[last];
        var y2 = flatCoordinates[last + 1];
        for(var i = first + stride; i < last; i += stride){
            var x = flatCoordinates[i];
            var y = flatCoordinates[i + 1];
            var squaredDistance_1 = _mathJs.squaredSegmentDistance(x, y, x1, y1, x2, y2);
            if (squaredDistance_1 > maxSquaredDistance) {
                index = i;
                maxSquaredDistance = squaredDistance_1;
            }
        }
        if (maxSquaredDistance > squaredTolerance) {
            markers[(index - offset) / stride] = 1;
            if (first + stride < index) stack.push(first, index);
            if (index + stride < last) stack.push(index, last);
        }
    }
    for(var i = 0; i < n; ++i)if (markers[i]) {
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
    return simplifiedOffset;
}
function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for(var i = 0, ii = ends.length; i < ii; ++i){
        var end = ends[i];
        simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
        simplifiedEnds.push(simplifiedOffset);
        offset = end;
    }
    return simplifiedOffset;
}
function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
    for(var i = 0, ii = endss.length; i < ii; ++i){
        var ends = endss[i];
        var simplifiedEnds = [];
        simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
        simplifiedEndss.push(simplifiedEnds);
        offset = ends[ends.length - 1];
    }
    return simplifiedOffset;
}
function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    if (end <= offset + stride) {
        // zero or one point, no simplification possible, so copy and return
        for(; offset < end; offset += stride){
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
            simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
        }
        return simplifiedOffset;
    }
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    // copy first point
    simplifiedFlatCoordinates[simplifiedOffset++] = x1;
    simplifiedFlatCoordinates[simplifiedOffset++] = y1;
    var x2 = x1;
    var y2 = y1;
    for(offset += stride; offset < end; offset += stride){
        x2 = flatCoordinates[offset];
        y2 = flatCoordinates[offset + 1];
        if (_mathJs.squaredDistance(x1, y1, x2, y2) > squaredTolerance) {
            // copy point at offset
            simplifiedFlatCoordinates[simplifiedOffset++] = x2;
            simplifiedFlatCoordinates[simplifiedOffset++] = y2;
            x1 = x2;
            y1 = y2;
        }
    }
    if (x2 != x1 || y2 != y1) {
        // copy last point
        simplifiedFlatCoordinates[simplifiedOffset++] = x2;
        simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    }
    return simplifiedOffset;
}
function snap(value, tolerance) {
    return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    // do nothing if the line is empty
    if (offset == end) return simplifiedOffset;
    // snap the first coordinate (P1)
    var x1 = snap(flatCoordinates[offset], tolerance);
    var y1 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    // add the first coordinate to the output
    simplifiedFlatCoordinates[simplifiedOffset++] = x1;
    simplifiedFlatCoordinates[simplifiedOffset++] = y1;
    // find the next coordinate that does not snap to the same value as the first
    // coordinate (P2)
    var x2, y2;
    do {
        x2 = snap(flatCoordinates[offset], tolerance);
        y2 = snap(flatCoordinates[offset + 1], tolerance);
        offset += stride;
        if (offset == end) {
            // all coordinates snap to the same value, the line collapses to a point
            // push the last snapped value anyway to ensure that the output contains
            // at least two points
            // FIXME should we really return at least two points anyway?
            simplifiedFlatCoordinates[simplifiedOffset++] = x2;
            simplifiedFlatCoordinates[simplifiedOffset++] = y2;
            return simplifiedOffset;
        }
    }while (x2 == x1 && y2 == y1)
    while(offset < end){
        // snap the next coordinate (P3)
        var x3 = snap(flatCoordinates[offset], tolerance);
        var y3 = snap(flatCoordinates[offset + 1], tolerance);
        offset += stride;
        // skip P3 if it is equal to P2
        if (x3 == x2 && y3 == y2) continue;
        // calculate the delta between P1 and P2
        var dx1 = x2 - x1;
        var dy1 = y2 - y1;
        // calculate the delta between P3 and P1
        var dx2 = x3 - x1;
        var dy2 = y3 - y1;
        // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
        // P1 in the same direction then P2 is on the straight line between P1 and
        // P3
        if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
            // discard P2 and set P2 = P3
            x2 = x3;
            y2 = y3;
            continue;
        }
        // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
        // between P3 and P1 or on the opposite half of the line to P2.  add P2,
        // and continue with P1 = P2 and P2 = P3
        simplifiedFlatCoordinates[simplifiedOffset++] = x2;
        simplifiedFlatCoordinates[simplifiedOffset++] = y2;
        x1 = x2;
        y1 = y2;
        x2 = x3;
        y2 = y3;
    }
    // add the last point (P2)
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for(var i = 0, ii = ends.length; i < ii; ++i){
        var end = ends[i];
        simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
        simplifiedEnds.push(simplifiedOffset);
        offset = end;
    }
    return simplifiedOffset;
}
function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
    for(var i = 0, ii = endss.length; i < ii; ++i){
        var ends = endss[i];
        var simplifiedEnds = [];
        simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
        simplifiedEndss.push(simplifiedEnds);
        offset = ends[ends.length - 1];
    }
    return simplifiedOffset;
}

},{"../../math.js":"kI4rE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9BPwr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/flat/inflate
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>} [opt_coordinates] Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */ parcelHelpers.export(exports, "inflateCoordinates", ()=>inflateCoordinates
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} [opt_coordinatess] Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */ parcelHelpers.export(exports, "inflateCoordinatesArray", ()=>inflateCoordinatesArray
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} [opt_coordinatesss]
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */ parcelHelpers.export(exports, "inflateMultiCoordinatesArray", ()=>inflateMultiCoordinatesArray
);
function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
    var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
    var i = 0;
    for(var j = offset; j < end; j += stride)coordinates[i++] = flatCoordinates.slice(j, j + stride);
    coordinates.length = i;
    return coordinates;
}
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
    var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
    var i = 0;
    for(var j = 0, jj = ends.length; j < jj; ++j){
        var end = ends[j];
        coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
        offset = end;
    }
    coordinatess.length = i;
    return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
    var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
    var i = 0;
    for(var j = 0, jj = endss.length; j < jj; ++j){
        var ends = endss[j];
        coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
        offset = ends[ends.length - 1];
    }
    coordinatesss.length = i;
    return coordinatesss;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kSE5y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/flat/area
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */ parcelHelpers.export(exports, "linearRing", ()=>linearRing
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */ parcelHelpers.export(exports, "linearRings", ()=>linearRings
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */ parcelHelpers.export(exports, "linearRingss", ()=>linearRingss
);
function linearRing(flatCoordinates, offset, end, stride) {
    var twiceArea = 0;
    var x1 = flatCoordinates[end - stride];
    var y1 = flatCoordinates[end - stride + 1];
    for(; offset < end; offset += stride){
        var x2 = flatCoordinates[offset];
        var y2 = flatCoordinates[offset + 1];
        twiceArea += y1 * x2 - x1 * y2;
        x1 = x2;
        y1 = y2;
    }
    return twiceArea / 2;
}
function linearRings(flatCoordinates, offset, ends, stride) {
    var area = 0;
    for(var i = 0, ii = ends.length; i < ii; ++i){
        var end = ends[i];
        area += linearRing(flatCoordinates, offset, end, stride);
        offset = end;
    }
    return area;
}
function linearRingss(flatCoordinates, offset, endss, stride) {
    var area = 0;
    for(var i = 0, ii = endss.length; i < ii; ++i){
        var ends = endss[i];
        area += linearRings(flatCoordinates, offset, ends, stride);
        offset = ends[ends.length - 1];
    }
    return area;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"4ReTD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/Point
 */ var _geometryTypeJs = require("./GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _mathJs = require("../math.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */ var Point1 = function(_super) {
    __extends(Point2, _super);
    /**
     * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     */ function Point2(coordinates, opt_layout) {
        var _this = _super.call(this) || this;
        _this.setCoordinates(coordinates, opt_layout);
        return _this;
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Point} Clone.
     * @api
     */ Point2.prototype.clone = function() {
        var point = new Point2(this.flatCoordinates.slice(), this.layout);
        point.applyProperties(this);
        return point;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */ Point2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
        var flatCoordinates = this.flatCoordinates;
        var squaredDistance = _mathJs.squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);
        if (squaredDistance < minSquaredDistance) {
            var stride = this.stride;
            for(var i = 0; i < stride; ++i)closestPoint[i] = flatCoordinates[i];
            closestPoint.length = stride;
            return squaredDistance;
        } else return minSquaredDistance;
    };
    /**
     * Return the coordinate of the point.
     * @return {import("../coordinate.js").Coordinate} Coordinates.
     * @api
     */ Point2.prototype.getCoordinates = function() {
        return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
    };
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */ Point2.prototype.computeExtent = function(extent) {
        return _extentJs.createOrUpdateFromCoordinate(this.flatCoordinates, extent);
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */ Point2.prototype.getType = function() {
        return _geometryTypeJsDefault.default.POINT;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */ Point2.prototype.intersectsExtent = function(extent) {
        return _extentJs.containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
    };
    /**
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @api
     */ Point2.prototype.setCoordinates = function(coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 0);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = _deflateJs.deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    };
    return Point2;
}(_simpleGeometryJsDefault.default);
exports.default = Point1;

},{"./GeometryType.js":"3sRlw","./SimpleGeometry.js":"4jyQo","../extent.js":"jgUz2","./flat/deflate.js":"gFAia","../math.js":"kI4rE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kXs0P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>} [opt_dest] Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */ parcelHelpers.export(exports, "getInteriorPointOfArray", ()=>getInteriorPointOfArray
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */ parcelHelpers.export(exports, "getInteriorPointsOfMultiArray", ()=>getInteriorPointsOfMultiArray
);
/**
 * @module ol/geom/flat/interiorpoint
 */ var _containsJs = require("./contains.js");
var _arrayJs = require("../../array.js");
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
    var i, ii, x, x1, x2, y1, y2;
    var y = flatCenters[flatCentersOffset + 1];
    /** @type {Array<number>} */ var intersections = [];
    // Calculate intersections with the horizontal line
    for(var r = 0, rr = ends.length; r < rr; ++r){
        var end = ends[r];
        x1 = flatCoordinates[end - stride];
        y1 = flatCoordinates[end - stride + 1];
        for(i = offset; i < end; i += stride){
            x2 = flatCoordinates[i];
            y2 = flatCoordinates[i + 1];
            if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
                x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
                intersections.push(x);
            }
            x1 = x2;
            y1 = y2;
        }
    }
    // Find the longest segment of the horizontal line that has its center point
    // inside the linear ring.
    var pointX = NaN;
    var maxSegmentLength = -Infinity;
    intersections.sort(_arrayJs.numberSafeCompareFunction);
    x1 = intersections[0];
    for(i = 1, ii = intersections.length; i < ii; ++i){
        x2 = intersections[i];
        var segmentLength = Math.abs(x2 - x1);
        if (segmentLength > maxSegmentLength) {
            x = (x1 + x2) / 2;
            if (_containsJs.linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
                pointX = x;
                maxSegmentLength = segmentLength;
            }
        }
        x1 = x2;
    }
    if (isNaN(pointX)) // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
    if (opt_dest) {
        opt_dest.push(pointX, y, maxSegmentLength);
        return opt_dest;
    } else return [
        pointX,
        y,
        maxSegmentLength
    ];
}
function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
    var interiorPoints = [];
    for(var i = 0, ii = endss.length; i < ii; ++i){
        var ends = endss[i];
        interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
        offset = ends[ends.length - 1];
    }
    return interiorPoints;
}

},{"./contains.js":"hPmbJ","../../array.js":"jKNP0","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hPmbJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */ parcelHelpers.export(exports, "linearRingContainsExtent", ()=>linearRingContainsExtent
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */ parcelHelpers.export(exports, "linearRingContainsXY", ()=>linearRingContainsXY
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */ parcelHelpers.export(exports, "linearRingsContainsXY", ()=>linearRingsContainsXY
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */ parcelHelpers.export(exports, "linearRingssContainsXY", ()=>linearRingssContainsXY
);
/**
 * @module ol/geom/flat/contains
 */ var _extentJs = require("../../extent.js");
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
    var outside = _extentJs.forEachCorner(extent, /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */ function(coordinate) {
        return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
    });
    return !outside;
}
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
    // https://geomalgorithms.com/a03-_inclusion.html
    // Copyright 2000 softSurfer, 2012 Dan Sunday
    // This code may be freely used and modified for any purpose
    // providing that this copyright notice is included with it.
    // SoftSurfer makes no warranty for this code, and cannot be held
    // liable for any real or imagined damage resulting from its use.
    // Users of this code must verify correctness for their application.
    var wn = 0;
    var x1 = flatCoordinates[end - stride];
    var y1 = flatCoordinates[end - stride + 1];
    for(; offset < end; offset += stride){
        var x2 = flatCoordinates[offset];
        var y2 = flatCoordinates[offset + 1];
        if (y1 <= y) {
            if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) wn++;
        } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) wn--;
        x1 = x2;
        y1 = y2;
    }
    return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
    if (ends.length === 0) return false;
    if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) return false;
    for(var i = 1, ii = ends.length; i < ii; ++i){
        if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) return false;
    }
    return true;
}
function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
    if (endss.length === 0) return false;
    for(var i = 0, ii = endss.length; i < ii; ++i){
        var ends = endss[i];
        if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) return true;
        offset = ends[ends.length - 1];
    }
    return false;
}

},{"../../extent.js":"jgUz2","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jv50N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLineString", ()=>intersectsLineString
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLineStringArray", ()=>intersectsLineStringArray
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLinearRing", ()=>intersectsLinearRing
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLinearRingArray", ()=>intersectsLinearRingArray
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */ parcelHelpers.export(exports, "intersectsLinearRingMultiArray", ()=>intersectsLinearRingMultiArray
);
/**
 * @module ol/geom/flat/intersectsextent
 */ var _extentJs = require("../../extent.js");
var _segmentsJs = require("./segments.js");
var _containsJs = require("./contains.js");
function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
    var coordinatesExtent = _extentJs.extendFlatCoordinates(_extentJs.createEmpty(), flatCoordinates, offset, end, stride);
    if (!_extentJs.intersects(extent, coordinatesExtent)) return false;
    if (_extentJs.containsExtent(extent, coordinatesExtent)) return true;
    if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) return true;
    if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) return true;
    return _segmentsJs.forEach(flatCoordinates, offset, end, stride, /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */ function(point1, point2) {
        return _extentJs.intersectsSegment(extent, point1, point2);
    });
}
function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
    for(var i = 0, ii = ends.length; i < ii; ++i){
        if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) return true;
        offset = ends[i];
    }
    return false;
}
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
    if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) return true;
    if (_containsJs.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) return true;
    if (_containsJs.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) return true;
    if (_containsJs.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) return true;
    if (_containsJs.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) return true;
    return false;
}
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
    if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) return false;
    if (ends.length === 1) return true;
    for(var i = 1, ii = ends.length; i < ii; ++i)if (_containsJs.linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
        if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) return false;
    }
    return true;
}
function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
    for(var i = 0, ii = endss.length; i < ii; ++i){
        var ends = endss[i];
        if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) return true;
        offset = ends[ends.length - 1];
    }
    return false;
}

},{"../../extent.js":"jgUz2","./segments.js":"54KdJ","./contains.js":"hPmbJ","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"54KdJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/flat/segments
 */ /**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @return {T|boolean} Value.
 * @template T
 */ parcelHelpers.export(exports, "forEach", ()=>forEach
);
function forEach(flatCoordinates, offset, end, stride, callback) {
    var ret;
    offset += stride;
    for(; offset < end; offset += stride){
        ret = callback(flatCoordinates.slice(offset - stride, offset), flatCoordinates.slice(offset, offset + stride));
        if (ret) return ret;
    }
    return false;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"TP5fs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
 * coordinate origin? For a coordinate system with a top-left coordinate origin,
 * the ring's orientation is clockwise when this function returns false.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */ parcelHelpers.export(exports, "linearRingIsClockwise", ()=>linearRingIsClockwise
);
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [opt_right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */ parcelHelpers.export(exports, "linearRingsAreOriented", ()=>linearRingsAreOriented
);
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [opt_right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */ parcelHelpers.export(exports, "linearRingssAreOriented", ()=>linearRingssAreOriented
);
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean} [opt_right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */ parcelHelpers.export(exports, "orientLinearRings", ()=>orientLinearRings
);
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [opt_right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */ parcelHelpers.export(exports, "orientLinearRingsArray", ()=>orientLinearRingsArray
);
/**
 * @module ol/geom/flat/orient
 */ var _reverseJs = require("./reverse.js");
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
    // https://stackoverflow.com/q/1165647/clockwise-method#1165943
    // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp
    var edge = 0;
    var x1 = flatCoordinates[end - stride];
    var y1 = flatCoordinates[end - stride + 1];
    for(; offset < end; offset += stride){
        var x2 = flatCoordinates[offset];
        var y2 = flatCoordinates[offset + 1];
        edge += (x2 - x1) * (y2 + y1);
        x1 = x2;
        y1 = y2;
    }
    return edge === 0 ? undefined : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {
    var right = opt_right !== undefined ? opt_right : false;
    for(var i = 0, ii = ends.length; i < ii; ++i){
        var end = ends[i];
        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
        if (i === 0) {
            if (right && isClockwise || !right && !isClockwise) return false;
        } else {
            if (right && !isClockwise || !right && isClockwise) return false;
        }
        offset = end;
    }
    return true;
}
function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {
    for(var i = 0, ii = endss.length; i < ii; ++i){
        var ends = endss[i];
        if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) return false;
        if (ends.length) offset = ends[ends.length - 1];
    }
    return true;
}
function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
    var right = opt_right !== undefined ? opt_right : false;
    for(var i = 0, ii = ends.length; i < ii; ++i){
        var end = ends[i];
        var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
        var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
        if (reverse) _reverseJs.coordinates(flatCoordinates, offset, end, stride);
        offset = end;
    }
    return offset;
}
function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {
    for(var i = 0, ii = endss.length; i < ii; ++i)offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
    return offset;
}

},{"./reverse.js":"4lLLP","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"4lLLP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/flat/reverse
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */ parcelHelpers.export(exports, "coordinates", ()=>coordinates
);
function coordinates(flatCoordinates, offset, end, stride) {
    while(offset < end - stride){
        for(var i = 0; i < stride; ++i){
            var tmp = flatCoordinates[offset + i];
            flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
            flatCoordinates[end - stride + i] = tmp;
        }
        offset += stride;
        end -= stride;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"liICj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Attribution", ()=>_attributionJsDefault.default
);
parcelHelpers.export(exports, "Control", ()=>_controlJsDefault.default
);
parcelHelpers.export(exports, "FullScreen", ()=>_fullScreenJsDefault.default
);
parcelHelpers.export(exports, "MousePosition", ()=>_mousePositionJsDefault.default
);
parcelHelpers.export(exports, "OverviewMap", ()=>_overviewMapJsDefault.default
);
parcelHelpers.export(exports, "Rotate", ()=>_rotateJsDefault.default
);
parcelHelpers.export(exports, "ScaleLine", ()=>_scaleLineJsDefault.default
);
parcelHelpers.export(exports, "Zoom", ()=>_zoomJsDefault.default
);
parcelHelpers.export(exports, "ZoomSlider", ()=>_zoomSliderJsDefault.default
);
parcelHelpers.export(exports, "ZoomToExtent", ()=>_zoomToExtentJsDefault.default
);
/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [attribution=true] Include
 * {@link module:ol/control/Attribution~Attribution}.
 * @property {import("./control/Attribution.js").Options} [attributionOptions]
 * Options for {@link module:ol/control/Attribution~Attribution}.
 * @property {boolean} [rotate=true] Include
 * {@link module:ol/control/Rotate~Rotate}.
 * @property {import("./control/Rotate.js").Options} [rotateOptions] Options
 * for {@link module:ol/control/Rotate~Rotate}.
 * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
 * @property {import("./control/Zoom.js").Options} [zoomOptions] Options for
 * {@link module:ol/control/Zoom~Zoom}.
 * @api
 */ /**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link module:ol/control/Zoom~Zoom}
 * * {@link module:ol/control/Rotate~Rotate}
 * * {@link module:ol/control/Attribution~Attribution}
 *
 * @param {DefaultsOptions} [opt_options]
 * Defaults options.
 * @return {Collection<import("./control/Control.js").default>}
 * Controls.
 * @api
 */ parcelHelpers.export(exports, "defaults", ()=>defaults
);
/**
 * @module ol/control
 */ var _attributionJs = require("./control/Attribution.js");
var _attributionJsDefault = parcelHelpers.interopDefault(_attributionJs);
var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _rotateJs = require("./control/Rotate.js");
var _rotateJsDefault = parcelHelpers.interopDefault(_rotateJs);
var _zoomJs = require("./control/Zoom.js");
var _zoomJsDefault = parcelHelpers.interopDefault(_zoomJs);
var _controlJs = require("./control/Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _fullScreenJs = require("./control/FullScreen.js");
var _fullScreenJsDefault = parcelHelpers.interopDefault(_fullScreenJs);
var _mousePositionJs = require("./control/MousePosition.js");
var _mousePositionJsDefault = parcelHelpers.interopDefault(_mousePositionJs);
var _overviewMapJs = require("./control/OverviewMap.js");
var _overviewMapJsDefault = parcelHelpers.interopDefault(_overviewMapJs);
var _scaleLineJs = require("./control/ScaleLine.js");
var _scaleLineJsDefault = parcelHelpers.interopDefault(_scaleLineJs);
var _zoomSliderJs = require("./control/ZoomSlider.js");
var _zoomSliderJsDefault = parcelHelpers.interopDefault(_zoomSliderJs);
var _zoomToExtentJs = require("./control/ZoomToExtent.js");
var _zoomToExtentJsDefault = parcelHelpers.interopDefault(_zoomToExtentJs);
function defaults(opt_options) {
    var options = opt_options ? opt_options : {
    };
    var controls = new _collectionJsDefault.default();
    var zoomControl = options.zoom !== undefined ? options.zoom : true;
    if (zoomControl) controls.push(new _zoomJsDefault.default(options.zoomOptions));
    var rotateControl = options.rotate !== undefined ? options.rotate : true;
    if (rotateControl) controls.push(new _rotateJsDefault.default(options.rotateOptions));
    var attributionControl = options.attribution !== undefined ? options.attribution : true;
    if (attributionControl) controls.push(new _attributionJsDefault.default(options.attributionOptions));
    return controls;
}

},{"./control/Attribution.js":"bf8cb","./Collection.js":"d2f3b","./control/Rotate.js":"7J8YD","./control/Zoom.js":"cYIPi","./control/Control.js":"RgF2j","./control/FullScreen.js":"gQI3M","./control/MousePosition.js":"1hb7Z","./control/OverviewMap.js":"3IDuZ","./control/ScaleLine.js":"cV9kw","./control/ZoomSlider.js":"htfq9","./control/ZoomToExtent.js":"idah2","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bf8cb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/control/Attribution
 */ var _controlJs = require("./Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _cssJs = require("../css.js");
var _arrayJs = require("../array.js");
var _layerJs = require("../layer/Layer.js");
var _domJs = require("../dom.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible] Specify if attributions can
 * be collapsed. If not specified, sources control this behavior with their
 * `attributionsCollapsible` setting.
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [expandClassName=className + '-expand'] CSS class name for the
 * collapsed attributions button.
 * @property {string|HTMLElement} [collapseLabel='â€º'] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the
 * expanded attributions button.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 */ /**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */ var Attribution1 = function(_super) {
    __extends(Attribution2, _super);
    /**
     * @param {Options} [opt_options] Attribution options.
     */ function Attribution2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        _this = _super.call(this, {
            element: document.createElement('div'),
            render: options.render,
            target: options.target
        }) || this;
        /**
         * @private
         * @type {HTMLElement}
         */ _this.ulElement_ = document.createElement('ul');
        /**
         * @private
         * @type {boolean}
         */ _this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
        /**
         * @private
         * @type {boolean}
         */ _this.userCollapsed_ = _this.collapsed_;
        /**
         * @private
         * @type {boolean}
         */ _this.overrideCollapsible_ = options.collapsible !== undefined;
        /**
         * @private
         * @type {boolean}
         */ _this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;
        if (!_this.collapsible_) _this.collapsed_ = false;
        var className = options.className !== undefined ? options.className : 'ol-attribution';
        var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
        var expandClassName = options.expandClassName !== undefined ? options.expandClassName : className + '-expand';
        var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u203A';
        var collapseClassName = options.collapseClassName !== undefined ? options.collapseClassName : className + '-collpase';
        if (typeof collapseLabel === 'string') {
            /**
             * @private
             * @type {HTMLElement}
             */ _this.collapseLabel_ = document.createElement('span');
            _this.collapseLabel_.textContent = collapseLabel;
            _this.collapseLabel_.className = collapseClassName;
        } else _this.collapseLabel_ = collapseLabel;
        var label = options.label !== undefined ? options.label : 'i';
        if (typeof label === 'string') {
            /**
             * @private
             * @type {HTMLElement}
             */ _this.label_ = document.createElement('span');
            _this.label_.textContent = label;
            _this.label_.className = expandClassName;
        } else _this.label_ = label;
        var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
        /**
         * @private
         * @type {HTMLElement}
         */ _this.toggleButton_ = document.createElement('button');
        _this.toggleButton_.setAttribute('type', 'button');
        _this.toggleButton_.setAttribute('aria-expanded', String(!_this.collapsed_));
        _this.toggleButton_.title = tipLabel;
        _this.toggleButton_.appendChild(activeLabel);
        _this.toggleButton_.addEventListener(_eventTypeJsDefault.default.CLICK, _this.handleClick_.bind(_this), false);
        var cssClasses = className + ' ' + _cssJs.CLASS_UNSELECTABLE + ' ' + _cssJs.CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? ' ' + _cssJs.CLASS_COLLAPSED : '') + (_this.collapsible_ ? '' : ' ol-uncollapsible');
        var element = _this.element;
        element.className = cssClasses;
        element.appendChild(_this.toggleButton_);
        element.appendChild(_this.ulElement_);
        /**
         * A list of currently rendered resolutions.
         * @type {Array<string>}
         * @private
         */ _this.renderedAttributions_ = [];
        /**
         * @private
         * @type {boolean}
         */ _this.renderedVisible_ = true;
        return _this;
    }
    /**
     * Collect a list of visible attributions and set the collapsible state.
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     * @return {Array<string>} Attributions.
     * @private
     */ Attribution2.prototype.collectSourceAttributions_ = function(frameState) {
        /**
         * Used to determine if an attribution already exists.
         * @type {!Object<string, boolean>}
         */ var lookup = {
        };
        /**
         * A list of visible attributions.
         * @type {Array<string>}
         */ var visibleAttributions = [];
        var collapsible = true;
        var layerStatesArray = frameState.layerStatesArray;
        for(var i = 0, ii = layerStatesArray.length; i < ii; ++i){
            var layerState = layerStatesArray[i];
            if (!_layerJs.inView(layerState, frameState.viewState)) continue;
            var source = /** @type {import("../layer/Layer.js").default} */ layerState.layer.getSource();
            if (!source) continue;
            var attributionGetter = source.getAttributions();
            if (!attributionGetter) continue;
            var attributions = attributionGetter(frameState);
            if (!attributions) continue;
            collapsible = collapsible && source.getAttributionsCollapsible() !== false;
            if (Array.isArray(attributions)) {
                for(var j = 0, jj = attributions.length; j < jj; ++j)if (!(attributions[j] in lookup)) {
                    visibleAttributions.push(attributions[j]);
                    lookup[attributions[j]] = true;
                }
            } else if (!(attributions in lookup)) {
                visibleAttributions.push(attributions);
                lookup[attributions] = true;
            }
        }
        if (!this.overrideCollapsible_) this.setCollapsible(collapsible);
        return visibleAttributions;
    };
    /**
     * @private
     * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
     */ Attribution2.prototype.updateElement_ = function(frameState) {
        if (!frameState) {
            if (this.renderedVisible_) {
                this.element.style.display = 'none';
                this.renderedVisible_ = false;
            }
            return;
        }
        var attributions = this.collectSourceAttributions_(frameState);
        var visible = attributions.length > 0;
        if (this.renderedVisible_ != visible) {
            this.element.style.display = visible ? '' : 'none';
            this.renderedVisible_ = visible;
        }
        if (_arrayJs.equals(attributions, this.renderedAttributions_)) return;
        _domJs.removeChildren(this.ulElement_);
        // append the attributions
        for(var i = 0, ii = attributions.length; i < ii; ++i){
            var element = document.createElement('li');
            element.innerHTML = attributions[i];
            this.ulElement_.appendChild(element);
        }
        this.renderedAttributions_ = attributions;
    };
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */ Attribution2.prototype.handleClick_ = function(event) {
        event.preventDefault();
        this.handleToggle_();
        this.userCollapsed_ = this.collapsed_;
    };
    /**
     * @private
     */ Attribution2.prototype.handleToggle_ = function() {
        this.element.classList.toggle(_cssJs.CLASS_COLLAPSED);
        if (this.collapsed_) _domJs.replaceNode(this.collapseLabel_, this.label_);
        else _domJs.replaceNode(this.label_, this.collapseLabel_);
        this.collapsed_ = !this.collapsed_;
        this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));
    };
    /**
     * Return `true` if the attribution is collapsible, `false` otherwise.
     * @return {boolean} True if the widget is collapsible.
     * @api
     */ Attribution2.prototype.getCollapsible = function() {
        return this.collapsible_;
    };
    /**
     * Set whether the attribution should be collapsible.
     * @param {boolean} collapsible True if the widget is collapsible.
     * @api
     */ Attribution2.prototype.setCollapsible = function(collapsible) {
        if (this.collapsible_ === collapsible) return;
        this.collapsible_ = collapsible;
        this.element.classList.toggle('ol-uncollapsible');
        if (this.userCollapsed_) this.handleToggle_();
    };
    /**
     * Collapse or expand the attribution according to the passed parameter. Will
     * not do anything if the attribution isn't collapsible or if the current
     * collapsed state is already the one requested.
     * @param {boolean} collapsed True if the widget is collapsed.
     * @api
     */ Attribution2.prototype.setCollapsed = function(collapsed) {
        this.userCollapsed_ = collapsed;
        if (!this.collapsible_ || this.collapsed_ === collapsed) return;
        this.handleToggle_();
    };
    /**
     * Return `true` when the attribution is currently collapsed or `false`
     * otherwise.
     * @return {boolean} True if the widget is collapsed.
     * @api
     */ Attribution2.prototype.getCollapsed = function() {
        return this.collapsed_;
    };
    /**
     * Update the attribution element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */ Attribution2.prototype.render = function(mapEvent) {
        this.updateElement_(mapEvent.frameState);
    };
    return Attribution2;
}(_controlJsDefault.default);
exports.default = Attribution1;

},{"./Control.js":"RgF2j","../events/EventType.js":"83vee","../css.js":"23c5q","../array.js":"jKNP0","../layer/Layer.js":"4vI3D","../dom.js":"akJqt","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"RgF2j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/control/Control
 */ var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _mapEventTypeJs = require("../MapEventType.js");
var _mapEventTypeJsDefault = parcelHelpers.interopDefault(_mapEventTypeJs);
var _functionsJs = require("../functions.js");
var _eventsJs = require("../events.js");
var _domJs = require("../dom.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */ /**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * var myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */ var Control1 = function(_super) {
    __extends(Control2, _super);
    /**
     * @param {Options} options Control options.
     */ function Control2(options) {
        var _this = _super.call(this) || this;
        var element = options.element;
        if (element && !options.target && !element.style.pointerEvents) element.style.pointerEvents = 'auto';
        /**
         * @protected
         * @type {HTMLElement}
         */ _this.element = element ? element : null;
        /**
         * @private
         * @type {HTMLElement}
         */ _this.target_ = null;
        /**
         * @private
         * @type {import("../PluggableMap.js").default}
         */ _this.map_ = null;
        /**
         * @protected
         * @type {!Array<import("../events.js").EventsKey>}
         */ _this.listenerKeys = [];
        if (options.render) _this.render = options.render;
        if (options.target) _this.setTarget(options.target);
        return _this;
    }
    /**
     * Clean up.
     */ Control2.prototype.disposeInternal = function() {
        _domJs.removeNode(this.element);
        _super.prototype.disposeInternal.call(this);
    };
    /**
     * Get the map associated with this control.
     * @return {import("../PluggableMap.js").default|undefined} Map.
     * @api
     */ Control2.prototype.getMap = function() {
        return this.map_;
    };
    /**
     * Remove the control from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default} [map] Map.
     * @api
     */ Control2.prototype.setMap = function(map) {
        if (this.map_) _domJs.removeNode(this.element);
        for(var i = 0, ii = this.listenerKeys.length; i < ii; ++i)_eventsJs.unlistenByKey(this.listenerKeys[i]);
        this.listenerKeys.length = 0;
        this.map_ = map;
        if (this.map_) {
            var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
            target.appendChild(this.element);
            if (this.render !== _functionsJs.VOID) this.listenerKeys.push(_eventsJs.listen(map, _mapEventTypeJsDefault.default.POSTRENDER, this.render, this));
            map.render();
        }
    };
    /**
     * Renders the control.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @api
     */ Control2.prototype.render = function(mapEvent) {
    };
    /**
     * This function is used to set a target element for the control. It has no
     * effect if it is called after the control has been added to the map (i.e.
     * after `setMap` is called on the control). If no `target` is set in the
     * options passed to the control constructor and if `setTarget` is not called
     * then the control is added to the map's overlay container.
     * @param {HTMLElement|string} target Target.
     * @api
     */ Control2.prototype.setTarget = function(target) {
        this.target_ = typeof target === 'string' ? document.getElementById(target) : target;
    };
    return Control2;
}(_objectJsDefault.default);
exports.default = Control1;

},{"../Object.js":"3roCV","../MapEventType.js":"eYKj9","../functions.js":"d72zA","../events.js":"e9Qqr","../dom.js":"akJqt","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7J8YD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/control/Rotate
 */ var _controlJs = require("./Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _cssJs = require("../css.js");
var _easingJs = require("../easing.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-rotate'] CSS class name.
 * @property {string|HTMLElement} [label='â‡§'] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function():void} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */ /**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */ var Rotate1 = function(_super) {
    __extends(Rotate2, _super);
    /**
     * @param {Options} [opt_options] Rotate options.
     */ function Rotate2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        _this = _super.call(this, {
            element: document.createElement('div'),
            render: options.render,
            target: options.target
        }) || this;
        var className = options.className !== undefined ? options.className : 'ol-rotate';
        var label = options.label !== undefined ? options.label : '\u21E7';
        var compassClassName = options.compassClassName !== undefined ? options.compassClassName : 'ol-compass';
        /**
         * @type {HTMLElement}
         * @private
         */ _this.label_ = null;
        if (typeof label === 'string') {
            _this.label_ = document.createElement('span');
            _this.label_.className = compassClassName;
            _this.label_.textContent = label;
        } else {
            _this.label_ = label;
            _this.label_.classList.add(compassClassName);
        }
        var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
        var button = document.createElement('button');
        button.className = className + '-reset';
        button.setAttribute('type', 'button');
        button.title = tipLabel;
        button.appendChild(_this.label_);
        button.addEventListener(_eventTypeJsDefault.default.CLICK, _this.handleClick_.bind(_this), false);
        var cssClasses = className + ' ' + _cssJs.CLASS_UNSELECTABLE + ' ' + _cssJs.CLASS_CONTROL;
        var element = _this.element;
        element.className = cssClasses;
        element.appendChild(button);
        _this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;
        /**
         * @type {number}
         * @private
         */ _this.duration_ = options.duration !== undefined ? options.duration : 250;
        /**
         * @type {boolean}
         * @private
         */ _this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
        /**
         * @private
         * @type {number|undefined}
         */ _this.rotation_ = undefined;
        if (_this.autoHide_) _this.element.classList.add(_cssJs.CLASS_HIDDEN);
        return _this;
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */ Rotate2.prototype.handleClick_ = function(event) {
        event.preventDefault();
        if (this.callResetNorth_ !== undefined) this.callResetNorth_();
        else this.resetNorth_();
    };
    /**
     * @private
     */ Rotate2.prototype.resetNorth_ = function() {
        var map = this.getMap();
        var view = map.getView();
        if (!view) // the map does not have a view, so we can't act
        // upon it
        return;
        var rotation = view.getRotation();
        if (rotation !== undefined) {
            if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) view.animate({
                rotation: 0,
                duration: this.duration_,
                easing: _easingJs.easeOut
            });
            else view.setRotation(0);
        }
    };
    /**
     * Update the rotate control element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */ Rotate2.prototype.render = function(mapEvent) {
        var frameState = mapEvent.frameState;
        if (!frameState) return;
        var rotation = frameState.viewState.rotation;
        if (rotation != this.rotation_) {
            var transform = 'rotate(' + rotation + 'rad)';
            if (this.autoHide_) {
                var contains = this.element.classList.contains(_cssJs.CLASS_HIDDEN);
                if (!contains && rotation === 0) this.element.classList.add(_cssJs.CLASS_HIDDEN);
                else if (contains && rotation !== 0) this.element.classList.remove(_cssJs.CLASS_HIDDEN);
            }
            this.label_.style.transform = transform;
        }
        this.rotation_ = rotation;
    };
    return Rotate2;
}(_controlJsDefault.default);
exports.default = Rotate1;

},{"./Control.js":"RgF2j","../events/EventType.js":"83vee","../css.js":"23c5q","../easing.js":"BpZIl","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cYIPi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/control/Zoom
 */ var _controlJs = require("./Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _cssJs = require("../css.js");
var _easingJs = require("../easing.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='ol-zoom'] CSS class name.
 * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.
 * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel='â€“'] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */ /**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */ var Zoom1 = function(_super) {
    __extends(Zoom2, _super);
    /**
     * @param {Options} [opt_options] Zoom options.
     */ function Zoom2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        _this = _super.call(this, {
            element: document.createElement('div'),
            target: options.target
        }) || this;
        var className = options.className !== undefined ? options.className : 'ol-zoom';
        var delta = options.delta !== undefined ? options.delta : 1;
        var zoomInClassName = options.zoomInClassName !== undefined ? options.zoomInClassName : className + '-in';
        var zoomOutClassName = options.zoomOutClassName !== undefined ? options.zoomOutClassName : className + '-out';
        var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
        var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2013';
        var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
        var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out';
        var inElement = document.createElement('button');
        inElement.className = zoomInClassName;
        inElement.setAttribute('type', 'button');
        inElement.title = zoomInTipLabel;
        inElement.appendChild(typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel);
        inElement.addEventListener(_eventTypeJsDefault.default.CLICK, _this.handleClick_.bind(_this, delta), false);
        var outElement = document.createElement('button');
        outElement.className = zoomOutClassName;
        outElement.setAttribute('type', 'button');
        outElement.title = zoomOutTipLabel;
        outElement.appendChild(typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
        outElement.addEventListener(_eventTypeJsDefault.default.CLICK, _this.handleClick_.bind(_this, -delta), false);
        var cssClasses = className + ' ' + _cssJs.CLASS_UNSELECTABLE + ' ' + _cssJs.CLASS_CONTROL;
        var element = _this.element;
        element.className = cssClasses;
        element.appendChild(inElement);
        element.appendChild(outElement);
        /**
         * @type {number}
         * @private
         */ _this.duration_ = options.duration !== undefined ? options.duration : 250;
        return _this;
    }
    /**
     * @param {number} delta Zoom delta.
     * @param {MouseEvent} event The event to handle
     * @private
     */ Zoom2.prototype.handleClick_ = function(delta, event) {
        event.preventDefault();
        this.zoomByDelta_(delta);
    };
    /**
     * @param {number} delta Zoom delta.
     * @private
     */ Zoom2.prototype.zoomByDelta_ = function(delta) {
        var map = this.getMap();
        var view = map.getView();
        if (!view) // the map does not have a view, so we can't act
        // upon it
        return;
        var currentZoom = view.getZoom();
        if (currentZoom !== undefined) {
            var newZoom = view.getConstrainedZoom(currentZoom + delta);
            if (this.duration_ > 0) {
                if (view.getAnimating()) view.cancelAnimations();
                view.animate({
                    zoom: newZoom,
                    duration: this.duration_,
                    easing: _easingJs.easeOut
                });
            } else view.setZoom(newZoom);
        }
    };
    return Zoom2;
}(_controlJsDefault.default);
exports.default = Zoom1;

},{"./Control.js":"RgF2j","../events/EventType.js":"83vee","../css.js":"23c5q","../easing.js":"BpZIl","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"gQI3M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/control/FullScreen
 */ var _controlJs = require("./Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _cssJs = require("../css.js");
var _eventsJs = require("../events.js");
var _domJs = require("../dom.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var events = [
    'fullscreenchange',
    'webkitfullscreenchange',
    'MSFullscreenChange', 
];
/**
 * @enum {string}
 */ var FullScreenEventType = {
    /**
     * Triggered after the map entered fullscreen.
     * @event FullScreenEventType#enterfullscreen
     * @api
     */ ENTERFULLSCREEN: 'enterfullscreen',
    /**
     * Triggered after the map leave fullscreen.
     * @event FullScreenEventType#leavefullscreen
     * @api
     */ LEAVEFULLSCREEN: 'leavefullscreen'
};
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes|
 *     'enterfullscreen'|'leavefullscreen', import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|
 *     'enterfullscreen'|'leavefullscreen'|import("../ObjectEventType").Types, Return>} FullScreenOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {string} [className='ol-full-screen'] CSS class name.
 * @property {string|Text} [label='\u2922'] Text label to use for the button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|Text} [labelActive='\u00d7'] Text label to use for the
 * button when full-screen is active.
 * @property {string} [activeClassName=className + '-true'] CSS class name for the button
 * when full-screen is active.
 * @property {string} [inactiveClassName=className + '-false'] CSS class name for the button
 * when full-screen is inactive.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Toggle full-screen'] Text label to use for the button tip.
 * @property {boolean} [keys=false] Full keyboard access.
 * @property {HTMLElement|string} [target] Specify a target if you want the
 * control to be rendered outside of the map's viewport.
 * @property {HTMLElement|string} [source] The element to be displayed
 * fullscreen. When not provided, the element containing the map viewport will
 * be displayed fullscreen.
 */ /**
 * @classdesc
 * Provides a button that when clicked fills up the full screen with the map.
 * The full screen source element is by default the element containing the map viewport unless
 * overridden by providing the `source` option. In which case, the dom
 * element introduced using this parameter will be displayed in full screen.
 *
 * When in full screen mode, a close button is shown to exit full screen mode.
 * The [Fullscreen API](https://www.w3.org/TR/fullscreen/) is used to
 * toggle the map in full screen mode.
 *
 * @fires FullScreenEventType#enterfullscreen
 * @fires FullScreenEventType#leavefullscreen
 * @api
 */ var FullScreen1 = function(_super) {
    __extends(FullScreen2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function FullScreen2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        _this = _super.call(this, {
            element: document.createElement('div'),
            target: options.target
        }) || this;
        /***
         * @type {FullScreenOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {FullScreenOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {FullScreenOnSignature<void>}
         */ _this.un;
        /**
         * @private
         * @type {string}
         */ _this.cssClassName_ = options.className !== undefined ? options.className : 'ol-full-screen';
        /**
         * @private
         * @type {Array<string>}
         */ _this.activeClassName_ = options.activeClassName !== undefined ? options.activeClassName.split(' ') : [
            _this.cssClassName_ + '-true'
        ];
        /**
         * @private
         * @type {Array<string>}
         */ _this.inactiveClassName_ = options.inactiveClassName !== undefined ? options.inactiveClassName.split(' ') : [
            _this.cssClassName_ + '-false'
        ];
        var label = options.label !== undefined ? options.label : '\u2922';
        /**
         * @private
         * @type {Text}
         */ _this.labelNode_ = typeof label === 'string' ? document.createTextNode(label) : label;
        var labelActive = options.labelActive !== undefined ? options.labelActive : '\u00d7';
        /**
         * @private
         * @type {Text}
         */ _this.labelActiveNode_ = typeof labelActive === 'string' ? document.createTextNode(labelActive) : labelActive;
        /**
         * @private
         * @type {HTMLElement}
         */ _this.button_ = document.createElement('button');
        var tipLabel = options.tipLabel ? options.tipLabel : 'Toggle full-screen';
        _this.setClassName_(_this.button_, isFullScreen());
        _this.button_.setAttribute('type', 'button');
        _this.button_.title = tipLabel;
        _this.button_.appendChild(_this.labelNode_);
        _this.button_.addEventListener(_eventTypeJsDefault.default.CLICK, _this.handleClick_.bind(_this), false);
        var cssClasses = _this.cssClassName_ + ' ' + _cssJs.CLASS_UNSELECTABLE + ' ' + _cssJs.CLASS_CONTROL + ' ' + (!isFullScreenSupported() ? _cssJs.CLASS_UNSUPPORTED : '');
        var element = _this.element;
        element.className = cssClasses;
        element.appendChild(_this.button_);
        /**
         * @private
         * @type {boolean}
         */ _this.keys_ = options.keys !== undefined ? options.keys : false;
        /**
         * @private
         * @type {HTMLElement|string|undefined}
         */ _this.source_ = options.source;
        return _this;
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */ FullScreen2.prototype.handleClick_ = function(event) {
        event.preventDefault();
        this.handleFullScreen_();
    };
    /**
     * @private
     */ FullScreen2.prototype.handleFullScreen_ = function() {
        if (!isFullScreenSupported()) return;
        var map = this.getMap();
        if (!map) return;
        if (isFullScreen()) exitFullScreen();
        else {
            var element = void 0;
            if (this.source_) element = typeof this.source_ === 'string' ? document.getElementById(this.source_) : this.source_;
            else element = map.getTargetElement();
            if (this.keys_) requestFullScreenWithKeys(element);
            else requestFullScreen(element);
        }
    };
    /**
     * @private
     */ FullScreen2.prototype.handleFullScreenChange_ = function() {
        var map = this.getMap();
        if (isFullScreen()) {
            this.setClassName_(this.button_, true);
            _domJs.replaceNode(this.labelActiveNode_, this.labelNode_);
            this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);
        } else {
            this.setClassName_(this.button_, false);
            _domJs.replaceNode(this.labelNode_, this.labelActiveNode_);
            this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);
        }
        if (map) map.updateSize();
    };
    /**
     * @param {HTMLElement} element Target element
     * @param {boolean} fullscreen True if fullscreen class name should be active
     * @private
     */ FullScreen2.prototype.setClassName_ = function(element, fullscreen) {
        var _a, _b, _c;
        var activeClassName = this.activeClassName_;
        var inactiveClassName = this.inactiveClassName_;
        var nextClassName = fullscreen ? activeClassName : inactiveClassName;
        (_a = element.classList).remove.apply(_a, activeClassName);
        (_b = element.classList).remove.apply(_b, inactiveClassName);
        (_c = element.classList).add.apply(_c, nextClassName);
    };
    /**
     * Remove the control from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default} map Map.
     * @api
     */ FullScreen2.prototype.setMap = function(map) {
        _super.prototype.setMap.call(this, map);
        if (map) for(var i = 0, ii = events.length; i < ii; ++i)this.listenerKeys.push(_eventsJs.listen(document, events[i], this.handleFullScreenChange_, this));
    };
    return FullScreen2;
}(_controlJsDefault.default);
/**
 * @return {boolean} Fullscreen is supported by the current platform.
 */ function isFullScreenSupported() {
    var body = document.body;
    return !!(body['webkitRequestFullscreen'] || body['msRequestFullscreen'] && document['msFullscreenEnabled'] || body.requestFullscreen && document.fullscreenEnabled);
}
/**
 * @return {boolean} Element is currently in fullscreen.
 */ function isFullScreen() {
    return !!(document['webkitIsFullScreen'] || document['msFullscreenElement'] || document.fullscreenElement);
}
/**
 * Request to fullscreen an element.
 * @param {HTMLElement} element Element to request fullscreen
 */ function requestFullScreen(element) {
    if (element.requestFullscreen) element.requestFullscreen();
    else if (element['msRequestFullscreen']) element['msRequestFullscreen']();
    else if (element['webkitRequestFullscreen']) element['webkitRequestFullscreen']();
}
/**
 * Request to fullscreen an element with keyboard input.
 * @param {HTMLElement} element Element to request fullscreen
 */ function requestFullScreenWithKeys(element) {
    if (element['webkitRequestFullscreen']) element['webkitRequestFullscreen']();
    else requestFullScreen(element);
}
/**
 * Exit fullscreen.
 */ function exitFullScreen() {
    if (document.exitFullscreen) document.exitFullscreen();
    else if (document['msExitFullscreen']) document['msExitFullscreen']();
    else if (document['webkitExitFullscreen']) document['webkitExitFullscreen']();
}
exports.default = FullScreen1;

},{"./Control.js":"RgF2j","../events/EventType.js":"83vee","../css.js":"23c5q","../events.js":"e9Qqr","../dom.js":"akJqt","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1hb7Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _controlJs = require("./Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _eventTypeJs = require("../pointer/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _projJs = require("../proj.js");
var _eventsJs = require("../events.js");
/**
 * @module ol/control/MousePosition
 */ var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @type {string}
 */ var PROJECTION = 'projection';
/**
 * @type {string}
 */ var COORDINATE_FORMAT = 'coordinateFormat';
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:coordinateFormat'|'change:projection', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:coordinateFormat'|'change:projection', Return>} MousePositionOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {string} [className='ol-mouse-position'] CSS class name.
 * @property {import("../coordinate.js").CoordinateFormat} [coordinateFormat] Coordinate format.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the
 * control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want the
 * control to be rendered outside of the map's viewport.
 * @property {string|boolean} [placeholder] Markup to show when the mouse position is not
 * available (e.g. when the pointer leaves the map viewport).  By default, a non-breaking space
 * is rendered when the mouse leaves the viewport.  To render something else, provide a string
 * to be used as the text content (e.g. 'no position' or '' for an empty string).  Set the placeholder
 * to `false` to retain the last position when the mouse leaves the viewport.  In a future release, this
 * will be the default behavior.
 * @property {string} [undefinedHTML='&#160;'] This option is deprecated.  Use the `placeholder` option instead.
 */ /**
 * @classdesc
 * A control to show the 2D coordinates of the mouse cursor. By default, these
 * are in the view projection, but can be in any supported projection.
 * By default the control is shown in the top right corner of the map, but this
 * can be changed by using the css selector `.ol-mouse-position`.
 *
 * On touch devices, which usually do not have a mouse cursor, the coordinates
 * of the currently touched position are shown.
 *
 * @api
 */ var MousePosition1 = function(_super) {
    __extends(MousePosition2, _super);
    /**
     * @param {Options} [opt_options] Mouse position options.
     */ function MousePosition2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        var element = document.createElement('div');
        element.className = options.className !== undefined ? options.className : 'ol-mouse-position';
        _this = _super.call(this, {
            element: element,
            render: options.render,
            target: options.target
        }) || this;
        /***
         * @type {MousePositionOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {MousePositionOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {MousePositionOnSignature<void>}
         */ _this.un;
        _this.addChangeListener(PROJECTION, _this.handleProjectionChanged_);
        if (options.coordinateFormat) _this.setCoordinateFormat(options.coordinateFormat);
        if (options.projection) _this.setProjection(options.projection);
        /**
         * Change this to `false` when removing the deprecated `undefinedHTML` option.
         * @type {boolean}
         */ var renderOnMouseOut = true;
        /**
         * @type {string}
         */ var placeholder = '&#160;';
        if ('undefinedHTML' in options) {
            // deprecated behavior
            if (options.undefinedHTML !== undefined) placeholder = options.undefinedHTML;
            renderOnMouseOut = !!placeholder;
        } else if ('placeholder' in options) {
            if (options.placeholder === false) renderOnMouseOut = false;
            else placeholder = String(options.placeholder);
        }
        /**
         * @private
         * @type {string}
         */ _this.placeholder_ = placeholder;
        /**
         * @private
         * @type {boolean}
         */ _this.renderOnMouseOut_ = renderOnMouseOut;
        /**
         * @private
         * @type {string}
         */ _this.renderedHTML_ = element.innerHTML;
        /**
         * @private
         * @type {?import("../proj/Projection.js").default}
         */ _this.mapProjection_ = null;
        /**
         * @private
         * @type {?import("../proj.js").TransformFunction}
         */ _this.transform_ = null;
        return _this;
    }
    /**
     * @private
     */ MousePosition2.prototype.handleProjectionChanged_ = function() {
        this.transform_ = null;
    };
    /**
     * Return the coordinate format type used to render the current position or
     * undefined.
     * @return {import("../coordinate.js").CoordinateFormat|undefined} The format to render the current
     *     position in.
     * @observable
     * @api
     */ MousePosition2.prototype.getCoordinateFormat = function() {
        return this.get(COORDINATE_FORMAT);
    };
    /**
     * Return the projection that is used to report the mouse position.
     * @return {import("../proj/Projection.js").default|undefined} The projection to report mouse
     *     position in.
     * @observable
     * @api
     */ MousePosition2.prototype.getProjection = function() {
        return this.get(PROJECTION);
    };
    /**
     * @param {MouseEvent} event Browser event.
     * @protected
     */ MousePosition2.prototype.handleMouseMove = function(event) {
        var map = this.getMap();
        this.updateHTML_(map.getEventPixel(event));
    };
    /**
     * @param {Event} event Browser event.
     * @protected
     */ MousePosition2.prototype.handleMouseOut = function(event) {
        this.updateHTML_(null);
    };
    /**
     * Remove the control from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default} map Map.
     * @api
     */ MousePosition2.prototype.setMap = function(map) {
        _super.prototype.setMap.call(this, map);
        if (map) {
            var viewport = map.getViewport();
            this.listenerKeys.push(_eventsJs.listen(viewport, _eventTypeJsDefault.default.POINTERMOVE, this.handleMouseMove, this));
            if (this.renderOnMouseOut_) this.listenerKeys.push(_eventsJs.listen(viewport, _eventTypeJsDefault.default.POINTEROUT, this.handleMouseOut, this));
            this.updateHTML_(null);
        }
    };
    /**
     * Set the coordinate format type used to render the current position.
     * @param {import("../coordinate.js").CoordinateFormat} format The format to render the current
     *     position in.
     * @observable
     * @api
     */ MousePosition2.prototype.setCoordinateFormat = function(format) {
        this.set(COORDINATE_FORMAT, format);
    };
    /**
     * Set the projection that is used to report the mouse position.
     * @param {import("../proj.js").ProjectionLike} projection The projection to report mouse
     *     position in.
     * @observable
     * @api
     */ MousePosition2.prototype.setProjection = function(projection) {
        this.set(PROJECTION, _projJs.get(projection));
    };
    /**
     * @param {?import("../pixel.js").Pixel} pixel Pixel.
     * @private
     */ MousePosition2.prototype.updateHTML_ = function(pixel) {
        var html = this.placeholder_;
        if (pixel && this.mapProjection_) {
            if (!this.transform_) {
                var projection = this.getProjection();
                if (projection) this.transform_ = _projJs.getTransformFromProjections(this.mapProjection_, projection);
                else this.transform_ = _projJs.identityTransform;
            }
            var map = this.getMap();
            var coordinate = map.getCoordinateFromPixelInternal(pixel);
            if (coordinate) {
                var userProjection = _projJs.getUserProjection();
                if (userProjection) this.transform_ = _projJs.getTransformFromProjections(this.mapProjection_, userProjection);
                this.transform_(coordinate, coordinate);
                var coordinateFormat = this.getCoordinateFormat();
                if (coordinateFormat) html = coordinateFormat(coordinate);
                else html = coordinate.toString();
            }
        }
        if (!this.renderedHTML_ || html !== this.renderedHTML_) {
            this.element.innerHTML = html;
            this.renderedHTML_ = html;
        }
    };
    /**
     * Update the projection. Rendering of the coordinates is done in
     * `handleMouseMove` and `handleMouseUp`.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */ MousePosition2.prototype.render = function(mapEvent) {
        var frameState = mapEvent.frameState;
        if (!frameState) this.mapProjection_ = null;
        else if (this.mapProjection_ != frameState.viewState.projection) {
            this.mapProjection_ = frameState.viewState.projection;
            this.transform_ = null;
        }
    };
    return MousePosition2;
}(_controlJsDefault.default);
exports.default = MousePosition1;

},{"./Control.js":"RgF2j","../pointer/EventType.js":"3XFPg","../proj.js":"hmdWM","../events.js":"e9Qqr","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3IDuZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/control/OverviewMap
 */ var _compositeJs = require("../renderer/Composite.js");
var _compositeJsDefault = parcelHelpers.interopDefault(_compositeJs);
var _controlJs = require("./Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _mapEventTypeJs = require("../MapEventType.js");
var _mapEventTypeJsDefault = parcelHelpers.interopDefault(_mapEventTypeJs);
var _mapPropertyJs = require("../MapProperty.js");
var _mapPropertyJsDefault = parcelHelpers.interopDefault(_mapPropertyJs);
var _objectEventTypeJs = require("../ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _overlayJs = require("../Overlay.js");
var _overlayJsDefault = parcelHelpers.interopDefault(_overlayJs);
var _overlayPositioningJs = require("../OverlayPositioning.js");
var _overlayPositioningJsDefault = parcelHelpers.interopDefault(_overlayPositioningJs);
var _pluggableMapJs = require("../PluggableMap.js");
var _pluggableMapJsDefault = parcelHelpers.interopDefault(_pluggableMapJs);
var _viewJs = require("../View.js");
var _viewJsDefault = parcelHelpers.interopDefault(_viewJs);
var _viewPropertyJs = require("../ViewProperty.js");
var _viewPropertyJsDefault = parcelHelpers.interopDefault(_viewPropertyJs);
var _cssJs = require("../css.js");
var _extentJs = require("../extent.js");
var _eventsJs = require("../events.js");
var _polygonJs = require("../geom/Polygon.js");
var _domJs = require("../dom.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * Maximum width and/or height extent ratio that determines when the overview
 * map should be zoomed out.
 * @type {number}
 */ var MAX_RATIO = 0.75;
/**
 * Minimum width and/or height extent ratio that determines when the overview
 * map should be zoomed in.
 * @type {number}
 */ var MIN_RATIO = 0.1;
var ControlledMap1 = function(_super) {
    __extends(ControlledMap2, _super);
    function ControlledMap2() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ControlledMap2.prototype.createRenderer = function() {
        return new _compositeJsDefault.default(this);
    };
    return ControlledMap2;
}(_pluggableMapJsDefault.default);
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-overviewmap'] CSS class name.
 * @property {boolean} [collapsed=true] Whether the control should start collapsed or not (expanded).
 * @property {string|HTMLElement} [collapseLabel='â€¹'] Text label to use for the
 * expanded overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {boolean} [collapsible=true] Whether the control can be collapsed or not.
 * @property {string|HTMLElement} [label='â€º'] Text label to use for the collapsed
 * overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {Array<import("../layer/Layer.js").default>|import("../Collection.js").default<import("../layer/Layer.js").default>} [layers]
 * Layers for the overview map.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {boolean} [rotateWithView=false] Whether the control view should rotate with the main map view.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {string} [tipLabel='Overview map'] Text label to use for the button tip.
 * @property {View} [view] Custom view for the overview map (should use same projection as main map). If not provided,
 * a default view with the same projection as the main map will be used.
 */ /**
 * Create a new control with a map acting as an overview map for another
 * defined map.
 *
 * @api
 */ var OverviewMap1 = function(_super) {
    __extends(OverviewMap2, _super);
    /**
     * @param {Options} [opt_options] OverviewMap options.
     */ function OverviewMap2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        _this = _super.call(this, {
            element: document.createElement('div'),
            render: options.render,
            target: options.target
        }) || this;
        /**
         * @private
         */ _this.boundHandleRotationChanged_ = _this.handleRotationChanged_.bind(_this);
        /**
         * @type {boolean}
         * @private
         */ _this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
        /**
         * @private
         * @type {boolean}
         */ _this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;
        if (!_this.collapsible_) _this.collapsed_ = false;
        /**
         * @private
         * @type {boolean}
         */ _this.rotateWithView_ = options.rotateWithView !== undefined ? options.rotateWithView : false;
        /**
         * @private
         * @type {import("../extent.js").Extent|undefined}
         */ _this.viewExtent_ = undefined;
        var className = options.className !== undefined ? options.className : 'ol-overviewmap';
        var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Overview map';
        var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u2039';
        if (typeof collapseLabel === 'string') {
            /**
             * @private
             * @type {HTMLElement}
             */ _this.collapseLabel_ = document.createElement('span');
            _this.collapseLabel_.textContent = collapseLabel;
        } else _this.collapseLabel_ = collapseLabel;
        var label = options.label !== undefined ? options.label : '\u203A';
        if (typeof label === 'string') {
            /**
             * @private
             * @type {HTMLElement}
             */ _this.label_ = document.createElement('span');
            _this.label_.textContent = label;
        } else _this.label_ = label;
        var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
        var button = document.createElement('button');
        button.setAttribute('type', 'button');
        button.title = tipLabel;
        button.appendChild(activeLabel);
        button.addEventListener(_eventTypeJsDefault.default.CLICK, _this.handleClick_.bind(_this), false);
        /**
         * @type {HTMLElement}
         * @private
         */ _this.ovmapDiv_ = document.createElement('div');
        _this.ovmapDiv_.className = 'ol-overviewmap-map';
        /**
         * Explicitly given view to be used instead of a view derived from the main map.
         * @type {View}
         * @private
         */ _this.view_ = options.view;
        /**
         * @type {ControlledMap}
         * @private
         */ _this.ovmap_ = new ControlledMap1({
            view: options.view
        });
        var ovmap = _this.ovmap_;
        if (options.layers) options.layers.forEach(function(layer) {
            ovmap.addLayer(layer);
        });
        var box = document.createElement('div');
        box.className = 'ol-overviewmap-box';
        box.style.boxSizing = 'border-box';
        /**
         * @type {import("../Overlay.js").default}
         * @private
         */ _this.boxOverlay_ = new _overlayJsDefault.default({
            position: [
                0,
                0
            ],
            positioning: _overlayPositioningJsDefault.default.CENTER_CENTER,
            element: box
        });
        _this.ovmap_.addOverlay(_this.boxOverlay_);
        var cssClasses = className + ' ' + _cssJs.CLASS_UNSELECTABLE + ' ' + _cssJs.CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? ' ' + _cssJs.CLASS_COLLAPSED : '') + (_this.collapsible_ ? '' : ' ol-uncollapsible');
        var element = _this.element;
        element.className = cssClasses;
        element.appendChild(_this.ovmapDiv_);
        element.appendChild(button);
        /* Interactive map */ var scope = _this;
        var overlay = _this.boxOverlay_;
        var overlayBox = _this.boxOverlay_.getElement();
        /* Functions definition */ var computeDesiredMousePosition = function(mousePosition) {
            return {
                clientX: mousePosition.clientX,
                clientY: mousePosition.clientY
            };
        };
        var move = function(event) {
            var position = computeDesiredMousePosition(event);
            var coordinates = ovmap.getEventCoordinateInternal(position);
            overlay.setPosition(coordinates);
        };
        var endMoving = function(event) {
            var coordinates = ovmap.getEventCoordinateInternal(event);
            scope.getMap().getView().setCenterInternal(coordinates);
            window.removeEventListener('mousemove', move);
            window.removeEventListener('mouseup', endMoving);
        };
        /* Binding */ overlayBox.addEventListener('mousedown', function() {
            window.addEventListener('mousemove', move);
            window.addEventListener('mouseup', endMoving);
        });
        return _this;
    }
    /**
     * Remove the control from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default} map Map.
     * @api
     */ OverviewMap2.prototype.setMap = function(map) {
        var oldMap = this.getMap();
        if (map === oldMap) return;
        if (oldMap) {
            var oldView = oldMap.getView();
            if (oldView) this.unbindView_(oldView);
            this.ovmap_.setTarget(null);
        }
        _super.prototype.setMap.call(this, map);
        if (map) {
            this.ovmap_.setTarget(this.ovmapDiv_);
            this.listenerKeys.push(_eventsJs.listen(map, _objectEventTypeJsDefault.default.PROPERTYCHANGE, this.handleMapPropertyChange_, this));
            var view = map.getView();
            if (view) {
                this.bindView_(view);
                if (view.isDef()) {
                    this.ovmap_.updateSize();
                    this.resetExtent_();
                }
            }
            if (!this.ovmap_.isRendered()) this.updateBoxAfterOvmapIsRendered_();
        }
    };
    /**
     * Handle map property changes.  This only deals with changes to the map's view.
     * @param {import("../Object.js").ObjectEvent} event The propertychange event.
     * @private
     */ OverviewMap2.prototype.handleMapPropertyChange_ = function(event) {
        if (event.key === _mapPropertyJsDefault.default.VIEW) {
            var oldView = event.oldValue;
            if (oldView) this.unbindView_(oldView);
            var newView = this.getMap().getView();
            this.bindView_(newView);
        } else if (!this.ovmap_.isRendered() && (event.key === _mapPropertyJsDefault.default.TARGET || event.key === _mapPropertyJsDefault.default.SIZE)) this.ovmap_.updateSize();
    };
    /**
     * Register listeners for view property changes.
     * @param {import("../View.js").default} view The view.
     * @private
     */ OverviewMap2.prototype.bindView_ = function(view) {
        if (!this.view_) {
            // Unless an explicit view definition was given, derive default from whatever main map uses.
            var newView = new _viewJsDefault.default({
                projection: view.getProjection()
            });
            this.ovmap_.setView(newView);
        }
        view.addChangeListener(_viewPropertyJsDefault.default.ROTATION, this.boundHandleRotationChanged_);
        // Sync once with the new view
        this.handleRotationChanged_();
    };
    /**
     * Unregister listeners for view property changes.
     * @param {import("../View.js").default} view The view.
     * @private
     */ OverviewMap2.prototype.unbindView_ = function(view) {
        view.removeChangeListener(_viewPropertyJsDefault.default.ROTATION, this.boundHandleRotationChanged_);
    };
    /**
     * Handle rotation changes to the main map.
     * @private
     */ OverviewMap2.prototype.handleRotationChanged_ = function() {
        if (this.rotateWithView_) this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
    };
    /**
     * Reset the overview map extent if the box size (width or
     * height) is less than the size of the overview map size times minRatio
     * or is greater than the size of the overview size times maxRatio.
     *
     * If the map extent was not reset, the box size can fits in the defined
     * ratio sizes. This method then checks if is contained inside the overview
     * map current extent. If not, recenter the overview map to the current
     * main map center location.
     * @private
     */ OverviewMap2.prototype.validateExtent_ = function() {
        var map = this.getMap();
        var ovmap = this.ovmap_;
        if (!map.isRendered() || !ovmap.isRendered()) return;
        var mapSize = map.getSize();
        var view = map.getView();
        var extent = view.calculateExtentInternal(mapSize);
        if (this.viewExtent_ && _extentJs.equals(extent, this.viewExtent_)) // repeats of the same extent may indicate constraint conflicts leading to an endless cycle
        return;
        this.viewExtent_ = extent;
        var ovmapSize = ovmap.getSize();
        var ovview = ovmap.getView();
        var ovextent = ovview.calculateExtentInternal(ovmapSize);
        var topLeftPixel = ovmap.getPixelFromCoordinateInternal(_extentJs.getTopLeft(extent));
        var bottomRightPixel = ovmap.getPixelFromCoordinateInternal(_extentJs.getBottomRight(extent));
        var boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);
        var boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);
        var ovmapWidth = ovmapSize[0];
        var ovmapHeight = ovmapSize[1];
        if (boxWidth < ovmapWidth * MIN_RATIO || boxHeight < ovmapHeight * MIN_RATIO || boxWidth > ovmapWidth * MAX_RATIO || boxHeight > ovmapHeight * MAX_RATIO) this.resetExtent_();
        else if (!_extentJs.containsExtent(ovextent, extent)) this.recenter_();
    };
    /**
     * Reset the overview map extent to half calculated min and max ratio times
     * the extent of the main map.
     * @private
     */ OverviewMap2.prototype.resetExtent_ = function() {
        if (MAX_RATIO === 0 || MIN_RATIO === 0) return;
        var map = this.getMap();
        var ovmap = this.ovmap_;
        var mapSize = map.getSize();
        var view = map.getView();
        var extent = view.calculateExtentInternal(mapSize);
        var ovview = ovmap.getView();
        // get how many times the current map overview could hold different
        // box sizes using the min and max ratio, pick the step in the middle used
        // to calculate the extent from the main map to set it to the overview map,
        var steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;
        var ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);
        _extentJs.scaleFromCenter(extent, ratio);
        ovview.fitInternal(_polygonJs.fromExtent(extent));
    };
    /**
     * Set the center of the overview map to the map center without changing its
     * resolution.
     * @private
     */ OverviewMap2.prototype.recenter_ = function() {
        var map = this.getMap();
        var ovmap = this.ovmap_;
        var view = map.getView();
        var ovview = ovmap.getView();
        ovview.setCenterInternal(view.getCenterInternal());
    };
    /**
     * Update the box using the main map extent
     * @private
     */ OverviewMap2.prototype.updateBox_ = function() {
        var map = this.getMap();
        var ovmap = this.ovmap_;
        if (!map.isRendered() || !ovmap.isRendered()) return;
        var mapSize = map.getSize();
        var view = map.getView();
        var ovview = ovmap.getView();
        var rotation = this.rotateWithView_ ? 0 : -view.getRotation();
        var overlay = this.boxOverlay_;
        var box = this.boxOverlay_.getElement();
        var center = view.getCenterInternal();
        var resolution = view.getResolution();
        var ovresolution = ovview.getResolution();
        var width = mapSize[0] * resolution / ovresolution;
        var height = mapSize[1] * resolution / ovresolution;
        // set position using center coordinates
        overlay.setPosition(center);
        // set box size calculated from map extent size and overview map resolution
        if (box) {
            box.style.width = width + 'px';
            box.style.height = height + 'px';
            var transform = 'rotate(' + rotation + 'rad)';
            box.style.transform = transform;
        }
    };
    /**
     * @private
     */ OverviewMap2.prototype.updateBoxAfterOvmapIsRendered_ = function() {
        if (this.ovmapPostrenderKey_) return;
        this.ovmapPostrenderKey_ = _eventsJs.listenOnce(this.ovmap_, _mapEventTypeJsDefault.default.POSTRENDER, function(event) {
            delete this.ovmapPostrenderKey_;
            this.updateBox_();
        }, this);
    };
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */ OverviewMap2.prototype.handleClick_ = function(event) {
        event.preventDefault();
        this.handleToggle_();
    };
    /**
     * @private
     */ OverviewMap2.prototype.handleToggle_ = function() {
        this.element.classList.toggle(_cssJs.CLASS_COLLAPSED);
        if (this.collapsed_) _domJs.replaceNode(this.collapseLabel_, this.label_);
        else _domJs.replaceNode(this.label_, this.collapseLabel_);
        this.collapsed_ = !this.collapsed_;
        // manage overview map if it had not been rendered before and control
        // is expanded
        var ovmap = this.ovmap_;
        if (!this.collapsed_) {
            if (ovmap.isRendered()) {
                this.viewExtent_ = undefined;
                ovmap.render();
                return;
            }
            ovmap.updateSize();
            this.resetExtent_();
            this.updateBoxAfterOvmapIsRendered_();
        }
    };
    /**
     * Return `true` if the overview map is collapsible, `false` otherwise.
     * @return {boolean} True if the widget is collapsible.
     * @api
     */ OverviewMap2.prototype.getCollapsible = function() {
        return this.collapsible_;
    };
    /**
     * Set whether the overview map should be collapsible.
     * @param {boolean} collapsible True if the widget is collapsible.
     * @api
     */ OverviewMap2.prototype.setCollapsible = function(collapsible) {
        if (this.collapsible_ === collapsible) return;
        this.collapsible_ = collapsible;
        this.element.classList.toggle('ol-uncollapsible');
        if (!collapsible && this.collapsed_) this.handleToggle_();
    };
    /**
     * Collapse or expand the overview map according to the passed parameter. Will
     * not do anything if the overview map isn't collapsible or if the current
     * collapsed state is already the one requested.
     * @param {boolean} collapsed True if the widget is collapsed.
     * @api
     */ OverviewMap2.prototype.setCollapsed = function(collapsed) {
        if (!this.collapsible_ || this.collapsed_ === collapsed) return;
        this.handleToggle_();
    };
    /**
     * Determine if the overview map is collapsed.
     * @return {boolean} The overview map is collapsed.
     * @api
     */ OverviewMap2.prototype.getCollapsed = function() {
        return this.collapsed_;
    };
    /**
     * Return `true` if the overview map view can rotate, `false` otherwise.
     * @return {boolean} True if the control view can rotate.
     * @api
     */ OverviewMap2.prototype.getRotateWithView = function() {
        return this.rotateWithView_;
    };
    /**
     * Set whether the overview map view should rotate with the main map view.
     * @param {boolean} rotateWithView True if the control view should rotate.
     * @api
     */ OverviewMap2.prototype.setRotateWithView = function(rotateWithView) {
        if (this.rotateWithView_ === rotateWithView) return;
        this.rotateWithView_ = rotateWithView;
        if (this.getMap().getView().getRotation() !== 0) {
            if (this.rotateWithView_) this.handleRotationChanged_();
            else this.ovmap_.getView().setRotation(0);
            this.viewExtent_ = undefined;
            this.validateExtent_();
            this.updateBox_();
        }
    };
    /**
     * Return the overview map.
     * @return {import("../PluggableMap.js").default} Overview map.
     * @api
     */ OverviewMap2.prototype.getOverviewMap = function() {
        return this.ovmap_;
    };
    /**
     * Update the overview map element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */ OverviewMap2.prototype.render = function(mapEvent) {
        this.validateExtent_();
        this.updateBox_();
    };
    return OverviewMap2;
}(_controlJsDefault.default);
exports.default = OverviewMap1;

},{"../renderer/Composite.js":"fXChd","./Control.js":"RgF2j","../events/EventType.js":"83vee","../MapEventType.js":"eYKj9","../MapProperty.js":"jNLVu","../ObjectEventType.js":"j6hH6","../Overlay.js":"hLIXu","../OverlayPositioning.js":"gd92r","../PluggableMap.js":"8N6xR","../View.js":"9RaqO","../ViewProperty.js":"d8El4","../css.js":"23c5q","../extent.js":"jgUz2","../events.js":"e9Qqr","../geom/Polygon.js":"hoOc8","../dom.js":"akJqt","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hLIXu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/Overlay
 */ var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _mapEventTypeJs = require("./MapEventType.js");
var _mapEventTypeJsDefault = parcelHelpers.interopDefault(_mapEventTypeJs);
var _overlayPositioningJs = require("./OverlayPositioning.js");
var _overlayPositioningJsDefault = parcelHelpers.interopDefault(_overlayPositioningJs);
var _cssJs = require("./css.js");
var _extentJs = require("./extent.js");
var _eventsJs = require("./events.js");
var _domJs = require("./dom.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {number|string} [id] Set the overlay id. The overlay id can be used
 * with the {@link module:ol/Map~Map#getOverlayById} method.
 * @property {HTMLElement} [element] The overlay element.
 * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning
 * the overlay. The first element in the
 * array is the horizontal offset. A positive value shifts the overlay right.
 * The second element in the array is the vertical offset. A positive value
 * shifts the overlay down.
 * @property {import("./coordinate.js").Coordinate} [position] The overlay position
 * in map projection.
 * @property {import("./OverlayPositioning.js").default} [positioning='top-left'] Defines how
 * the overlay is actually positioned with respect to its `position` property.
 * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, and `'top-right'`.
 * @property {boolean} [stopEvent=true] Whether event propagation to the map
 * viewport should be stopped. If `true` the overlay is placed in the same
 * container as that of the controls (CSS class name
 * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container
 * with CSS class name specified by the `className` property.
 * @property {boolean} [insertFirst=true] Whether the overlay is inserted first
 * in the overlay container, or appended. If the overlay is placed in the same
 * container as that of the controls (see the `stopEvent` option) you will
 * probably set `insertFirst` to `true` so the overlay is displayed below the
 * controls.
 * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling
 * `setPosition`, so that the overlay is entirely visible in the current viewport?
 * If `true` (deprecated), then `autoPanAnimation` and `autoPanMargin` will be
 * used to determine the panning parameters; if an object is supplied then other
 * parameters are ignored.
 * @property {PanOptions} [autoPanAnimation] The animation options used to pan
 * the overlay into view. This animation is only used when `autoPan` is enabled.
 * A `duration` and `easing` may be provided to customize the animation.
 * Deprecated and ignored if `autoPan` is supplied as an object.
 * @property {number} [autoPanMargin=20] The margin (in pixels) between the
 * overlay and the borders of the map when autopanning. Deprecated and ignored
 * if `autoPan` is supplied as an object.
 * @property {PanIntoViewOptions} [autoPanOptions] The options to use for the
 * autoPan. This is only used when `autoPan` is enabled and has preference over
 * the individual `autoPanMargin` and `autoPanOptions`.
 * @property {string} [className='ol-overlay-container ol-selectable'] CSS class
 * name.
 */ /**
 * @typedef {Object} PanOptions
 * @property {number} [duration=1000] The duration of the animation in
 * milliseconds.
 * @property {function(number):number} [easing] The easing function to use. Can
 * be one from {@link module:ol/easing} or a custom function.
 * Default is {@link module:ol/easing.inAndOut}.
 */ /**
 * @typedef {Object} PanIntoViewOptions
 * @property {PanOptions} [animation={}] The animation parameters for the pan
 * @property {number} [margin=20] The margin (in pixels) between the
 * overlay and the borders of the map when panning into view.
 */ /**
 * @enum {string}
 * @protected
 */ var Property = {
    ELEMENT: 'element',
    MAP: 'map',
    OFFSET: 'offset',
    POSITION: 'position',
    POSITIONING: 'positioning'
};
/**
 * @typedef {import("./ObjectEventType").Types|'change:element'|'change:map'|'change:offset'|'change:position'|
 *   'change:positioning'} OverlayObjectEventTypes
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<OverlayObjectEventTypes, import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|OverlayObjectEventTypes, Return>} OverlayOnSignature
 */ /**
 * @classdesc
 * An element to be displayed over the map and attached to a single map
 * location.  Like {@link module:ol/control/Control~Control}, Overlays are
 * visible widgets. Unlike Controls, they are not in a fixed position on the
 * screen, but are tied to a geographical coordinate, so panning the map will
 * move an Overlay but not a Control.
 *
 * Example:
 *
 *     import Overlay from 'ol/Overlay';
 *
 *     var popup = new Overlay({
 *       element: document.getElementById('popup')
 *     });
 *     popup.setPosition(coordinate);
 *     map.addOverlay(popup);
 *
 * @api
 */ var Overlay1 = function(_super) {
    __extends(Overlay2, _super);
    /**
     * @param {Options} options Overlay options.
     */ function Overlay2(options) {
        var _this = _super.call(this) || this;
        /***
         * @type {OverlayOnSignature<import("./events").EventsKey>}
         */ _this.on;
        /***
         * @type {OverlayOnSignature<import("./events").EventsKey>}
         */ _this.once;
        /***
         * @type {OverlayOnSignature<void>}
         */ _this.un;
        /**
         * @protected
         * @type {Options}
         */ _this.options = options;
        /**
         * @protected
         * @type {number|string|undefined}
         */ _this.id = options.id;
        /**
         * @protected
         * @type {boolean}
         */ _this.insertFirst = options.insertFirst !== undefined ? options.insertFirst : true;
        /**
         * @protected
         * @type {boolean}
         */ _this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;
        /**
         * @protected
         * @type {HTMLElement}
         */ _this.element = document.createElement('div');
        _this.element.className = options.className !== undefined ? options.className : 'ol-overlay-container ' + _cssJs.CLASS_SELECTABLE;
        _this.element.style.position = 'absolute';
        _this.element.style.pointerEvents = 'auto';
        var autoPan = options.autoPan;
        if (autoPan && 'object' !== typeof autoPan) autoPan = {
            animation: options.autoPanAnimation,
            margin: options.autoPanMargin
        };
        /**
         * @protected
         * @type {PanIntoViewOptions|false}
         */ _this.autoPan = /** @type {PanIntoViewOptions} */ autoPan || false;
        /**
         * @protected
         * @type {{transform_: string,
         *         visible: boolean}}
         */ _this.rendered = {
            transform_: '',
            visible: true
        };
        /**
         * @protected
         * @type {?import("./events.js").EventsKey}
         */ _this.mapPostrenderListenerKey = null;
        _this.addChangeListener(Property.ELEMENT, _this.handleElementChanged);
        _this.addChangeListener(Property.MAP, _this.handleMapChanged);
        _this.addChangeListener(Property.OFFSET, _this.handleOffsetChanged);
        _this.addChangeListener(Property.POSITION, _this.handlePositionChanged);
        _this.addChangeListener(Property.POSITIONING, _this.handlePositioningChanged);
        if (options.element !== undefined) _this.setElement(options.element);
        _this.setOffset(options.offset !== undefined ? options.offset : [
            0,
            0
        ]);
        _this.setPositioning(options.positioning !== undefined ? options.positioning : _overlayPositioningJsDefault.default.TOP_LEFT);
        if (options.position !== undefined) _this.setPosition(options.position);
        return _this;
    }
    /**
     * Get the DOM element of this overlay.
     * @return {HTMLElement|undefined} The Element containing the overlay.
     * @observable
     * @api
     */ Overlay2.prototype.getElement = function() {
        return this.get(Property.ELEMENT);
    };
    /**
     * Get the overlay identifier which is set on constructor.
     * @return {number|string|undefined} Id.
     * @api
     */ Overlay2.prototype.getId = function() {
        return this.id;
    };
    /**
     * Get the map associated with this overlay.
     * @return {import("./PluggableMap.js").default|undefined} The map that the
     * overlay is part of.
     * @observable
     * @api
     */ Overlay2.prototype.getMap = function() {
        return this.get(Property.MAP);
    };
    /**
     * Get the offset of this overlay.
     * @return {Array<number>} The offset.
     * @observable
     * @api
     */ Overlay2.prototype.getOffset = function() {
        return this.get(Property.OFFSET);
    };
    /**
     * Get the current position of this overlay.
     * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
     *     anchored at.
     * @observable
     * @api
     */ Overlay2.prototype.getPosition = function() {
        return this.get(Property.POSITION);
    };
    /**
     * Get the current positioning of this overlay.
     * @return {import("./OverlayPositioning.js").default} How the overlay is positioned
     *     relative to its point on the map.
     * @observable
     * @api
     */ Overlay2.prototype.getPositioning = function() {
        return this.get(Property.POSITIONING);
    };
    /**
     * @protected
     */ Overlay2.prototype.handleElementChanged = function() {
        _domJs.removeChildren(this.element);
        var element = this.getElement();
        if (element) this.element.appendChild(element);
    };
    /**
     * @protected
     */ Overlay2.prototype.handleMapChanged = function() {
        if (this.mapPostrenderListenerKey) {
            _domJs.removeNode(this.element);
            _eventsJs.unlistenByKey(this.mapPostrenderListenerKey);
            this.mapPostrenderListenerKey = null;
        }
        var map = this.getMap();
        if (map) {
            this.mapPostrenderListenerKey = _eventsJs.listen(map, _mapEventTypeJsDefault.default.POSTRENDER, this.render, this);
            this.updatePixelPosition();
            var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();
            if (this.insertFirst) container.insertBefore(this.element, container.childNodes[0] || null);
            else container.appendChild(this.element);
            this.performAutoPan();
        }
    };
    /**
     * @protected
     */ Overlay2.prototype.render = function() {
        this.updatePixelPosition();
    };
    /**
     * @protected
     */ Overlay2.prototype.handleOffsetChanged = function() {
        this.updatePixelPosition();
    };
    /**
     * @protected
     */ Overlay2.prototype.handlePositionChanged = function() {
        this.updatePixelPosition();
        this.performAutoPan();
    };
    /**
     * @protected
     */ Overlay2.prototype.handlePositioningChanged = function() {
        this.updatePixelPosition();
    };
    /**
     * Set the DOM element to be associated with this overlay.
     * @param {HTMLElement|undefined} element The Element containing the overlay.
     * @observable
     * @api
     */ Overlay2.prototype.setElement = function(element) {
        this.set(Property.ELEMENT, element);
    };
    /**
     * Set the map to be associated with this overlay.
     * @param {import("./PluggableMap.js").default|undefined} map The map that the
     * overlay is part of.
     * @observable
     * @api
     */ Overlay2.prototype.setMap = function(map) {
        this.set(Property.MAP, map);
    };
    /**
     * Set the offset for this overlay.
     * @param {Array<number>} offset Offset.
     * @observable
     * @api
     */ Overlay2.prototype.setOffset = function(offset) {
        this.set(Property.OFFSET, offset);
    };
    /**
     * Set the position for this overlay. If the position is `undefined` the
     * overlay is hidden.
     * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
     *     is anchored at.
     * @observable
     * @api
     */ Overlay2.prototype.setPosition = function(position) {
        this.set(Property.POSITION, position);
    };
    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary) using the configured autoPan parameters
     * @protected
     */ Overlay2.prototype.performAutoPan = function() {
        if (this.autoPan) this.panIntoView(this.autoPan);
    };
    /**
     * Pan the map so that the overlay is entirely visible in the current viewport
     * (if necessary).
     * @param {PanIntoViewOptions} [opt_panIntoViewOptions] Options for the pan action
     * @api
     */ Overlay2.prototype.panIntoView = function(opt_panIntoViewOptions) {
        var map = this.getMap();
        if (!map || !map.getTargetElement() || !this.get(Property.POSITION)) return;
        var mapRect = this.getRect(map.getTargetElement(), map.getSize());
        var element = this.getElement();
        var overlayRect = this.getRect(element, [
            _domJs.outerWidth(element),
            _domJs.outerHeight(element), 
        ]);
        var panIntoViewOptions = opt_panIntoViewOptions || {
        };
        var myMargin = panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;
        if (!_extentJs.containsExtent(mapRect, overlayRect)) {
            // the overlay is not completely inside the viewport, so pan the map
            var offsetLeft = overlayRect[0] - mapRect[0];
            var offsetRight = mapRect[2] - overlayRect[2];
            var offsetTop = overlayRect[1] - mapRect[1];
            var offsetBottom = mapRect[3] - overlayRect[3];
            var delta = [
                0,
                0
            ];
            if (offsetLeft < 0) // move map to the left
            delta[0] = offsetLeft - myMargin;
            else if (offsetRight < 0) // move map to the right
            delta[0] = Math.abs(offsetRight) + myMargin;
            if (offsetTop < 0) // move map up
            delta[1] = offsetTop - myMargin;
            else if (offsetBottom < 0) // move map down
            delta[1] = Math.abs(offsetBottom) + myMargin;
            if (delta[0] !== 0 || delta[1] !== 0) {
                var center = map.getView().getCenterInternal();
                var centerPx = map.getPixelFromCoordinateInternal(center);
                if (!centerPx) return;
                var newCenterPx = [
                    centerPx[0] + delta[0],
                    centerPx[1] + delta[1]
                ];
                var panOptions = panIntoViewOptions.animation || {
                };
                map.getView().animateInternal({
                    center: map.getCoordinateFromPixelInternal(newCenterPx),
                    duration: panOptions.duration,
                    easing: panOptions.easing
                });
            }
        }
    };
    /**
     * Get the extent of an element relative to the document
     * @param {HTMLElement} element The element.
     * @param {import("./size.js").Size} size The size of the element.
     * @return {import("./extent.js").Extent} The extent.
     * @protected
     */ Overlay2.prototype.getRect = function(element, size) {
        var box = element.getBoundingClientRect();
        var offsetX = box.left + window.pageXOffset;
        var offsetY = box.top + window.pageYOffset;
        return [
            offsetX,
            offsetY,
            offsetX + size[0],
            offsetY + size[1]
        ];
    };
    /**
     * Set the positioning for this overlay.
     * @param {import("./OverlayPositioning.js").default} positioning how the overlay is
     *     positioned relative to its point on the map.
     * @observable
     * @api
     */ Overlay2.prototype.setPositioning = function(positioning) {
        this.set(Property.POSITIONING, positioning);
    };
    /**
     * Modify the visibility of the element.
     * @param {boolean} visible Element visibility.
     * @protected
     */ Overlay2.prototype.setVisible = function(visible) {
        if (this.rendered.visible !== visible) {
            this.element.style.display = visible ? '' : 'none';
            this.rendered.visible = visible;
        }
    };
    /**
     * Update pixel position.
     * @protected
     */ Overlay2.prototype.updatePixelPosition = function() {
        var map = this.getMap();
        var position = this.getPosition();
        if (!map || !map.isRendered() || !position) {
            this.setVisible(false);
            return;
        }
        var pixel = map.getPixelFromCoordinate(position);
        var mapSize = map.getSize();
        this.updateRenderedPosition(pixel, mapSize);
    };
    /**
     * @param {import("./pixel.js").Pixel} pixel The pixel location.
     * @param {import("./size.js").Size|undefined} mapSize The map size.
     * @protected
     */ Overlay2.prototype.updateRenderedPosition = function(pixel, mapSize) {
        var style = this.element.style;
        var offset = this.getOffset();
        var positioning = this.getPositioning();
        this.setVisible(true);
        var x = Math.round(pixel[0] + offset[0]) + 'px';
        var y = Math.round(pixel[1] + offset[1]) + 'px';
        var posX = '0%';
        var posY = '0%';
        if (positioning == _overlayPositioningJsDefault.default.BOTTOM_RIGHT || positioning == _overlayPositioningJsDefault.default.CENTER_RIGHT || positioning == _overlayPositioningJsDefault.default.TOP_RIGHT) posX = '-100%';
        else if (positioning == _overlayPositioningJsDefault.default.BOTTOM_CENTER || positioning == _overlayPositioningJsDefault.default.CENTER_CENTER || positioning == _overlayPositioningJsDefault.default.TOP_CENTER) posX = '-50%';
        if (positioning == _overlayPositioningJsDefault.default.BOTTOM_LEFT || positioning == _overlayPositioningJsDefault.default.BOTTOM_CENTER || positioning == _overlayPositioningJsDefault.default.BOTTOM_RIGHT) posY = '-100%';
        else if (positioning == _overlayPositioningJsDefault.default.CENTER_LEFT || positioning == _overlayPositioningJsDefault.default.CENTER_CENTER || positioning == _overlayPositioningJsDefault.default.CENTER_RIGHT) posY = '-50%';
        var transform = "translate(" + posX + ", " + posY + ") translate(" + x + ", " + y + ")";
        if (this.rendered.transform_ != transform) {
            this.rendered.transform_ = transform;
            style.transform = transform;
            // @ts-ignore IE9
            style.msTransform = transform;
        }
    };
    /**
     * returns the options this Overlay has been created with
     * @return {Options} overlay options
     */ Overlay2.prototype.getOptions = function() {
        return this.options;
    };
    return Overlay2;
}(_objectJsDefault.default);
exports.default = Overlay1;

},{"./Object.js":"3roCV","./MapEventType.js":"eYKj9","./OverlayPositioning.js":"gd92r","./css.js":"23c5q","./extent.js":"jgUz2","./events.js":"e9Qqr","./dom.js":"akJqt","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"gd92r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    BOTTOM_LEFT: 'bottom-left',
    BOTTOM_CENTER: 'bottom-center',
    BOTTOM_RIGHT: 'bottom-right',
    CENTER_LEFT: 'center-left',
    CENTER_CENTER: 'center-center',
    CENTER_RIGHT: 'center-right',
    TOP_LEFT: 'top-left',
    TOP_CENTER: 'top-center',
    TOP_RIGHT: 'top-right'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cV9kw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Units", ()=>Units
);
/**
 * @module ol/control/ScaleLine
 */ var _controlJs = require("./Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _unitsJs = require("../proj/Units.js");
var _unitsJsDefault = parcelHelpers.interopDefault(_unitsJs);
var _cssJs = require("../css.js");
var _projJs = require("../proj.js");
var _assertsJs = require("../asserts.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @type {string}
 */ var UNITS_PROP = 'units';
var Units = {
    DEGREES: 'degrees',
    IMPERIAL: 'imperial',
    NAUTICAL: 'nautical',
    METRIC: 'metric',
    US: 'us'
};
/**
 * @const
 * @type {Array<number>}
 */ var LEADING_DIGITS = [
    1,
    2,
    5
];
/**
 * @const
 * @type {number}
 */ var DEFAULT_DPI = 25.4 / 0.28;
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:units', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types
 *     |'change:units', Return>} ScaleLineOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {string} [className='ol-scale-line'] CSS Class name.
 * @property {number} [minWidth=64] Minimum width in pixels at the OGC default dpi. The width will be
 * adjusted to match the dpi used.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {import("./ScaleLine.js").Units|string} [units='metric'] Units.
 * @property {boolean} [bar=false] Render scalebars instead of a line.
 * @property {number} [steps=4] Number of steps the scalebar should use. Use even numbers
 * for best results. Only applies when `bar` is `true`.
 * @property {boolean} [text=false] Render the text scale above of the scalebar. Only applies
 * when `bar` is `true`.
 * @property {number|undefined} [dpi=undefined] dpi of output device such as printer. Only applies
 * when `bar` is `true`. If undefined the OGC default screen pixel size of 0.28mm will be assumed.
 */ /**
 * @classdesc
 * A control displaying rough y-axis distances, calculated for the center of the
 * viewport. For conformal projections (e.g. EPSG:3857, the default view
 * projection in OpenLayers), the scale is valid for all directions.
 * No scale line will be shown when the y-axis distance of a pixel at the
 * viewport center cannot be calculated in the view projection.
 * By default the scale line will show in the bottom left portion of the map,
 * but this can be changed by using the css selector `.ol-scale-line`.
 * When specifying `bar` as `true`, a scalebar will be rendered instead
 * of a scaleline.
 *
 * @api
 */ var ScaleLine1 = function(_super) {
    __extends(ScaleLine2, _super);
    /**
     * @param {Options} [opt_options] Scale line options.
     */ function ScaleLine2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        var className = options.className !== undefined ? options.className : options.bar ? 'ol-scale-bar' : 'ol-scale-line';
        _this = _super.call(this, {
            element: document.createElement('div'),
            render: options.render,
            target: options.target
        }) || this;
        /***
         * @type {ScaleLineOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {ScaleLineOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {ScaleLineOnSignature<void>}
         */ _this.un;
        /**
         * @private
         * @type {HTMLElement}
         */ _this.innerElement_ = document.createElement('div');
        _this.innerElement_.className = className + '-inner';
        _this.element.className = className + ' ' + _cssJs.CLASS_UNSELECTABLE;
        _this.element.appendChild(_this.innerElement_);
        /**
         * @private
         * @type {?import("../View.js").State}
         */ _this.viewState_ = null;
        /**
         * @private
         * @type {number}
         */ _this.minWidth_ = options.minWidth !== undefined ? options.minWidth : 64;
        /**
         * @private
         * @type {boolean}
         */ _this.renderedVisible_ = false;
        /**
         * @private
         * @type {number|undefined}
         */ _this.renderedWidth_ = undefined;
        /**
         * @private
         * @type {string}
         */ _this.renderedHTML_ = '';
        _this.addChangeListener(UNITS_PROP, _this.handleUnitsChanged_);
        _this.setUnits(options.units || Units.METRIC);
        /**
         * @private
         * @type {boolean}
         */ _this.scaleBar_ = options.bar || false;
        /**
         * @private
         * @type {number}
         */ _this.scaleBarSteps_ = options.steps || 4;
        /**
         * @private
         * @type {boolean}
         */ _this.scaleBarText_ = options.text || false;
        /**
         * @private
         * @type {number|undefined}
         */ _this.dpi_ = options.dpi || undefined;
        return _this;
    }
    /**
     * Return the units to use in the scale line.
     * @return {import("./ScaleLine.js").Units} The units
     * to use in the scale line.
     * @observable
     * @api
     */ ScaleLine2.prototype.getUnits = function() {
        return this.get(UNITS_PROP);
    };
    /**
     * @private
     */ ScaleLine2.prototype.handleUnitsChanged_ = function() {
        this.updateElement_();
    };
    /**
     * Set the units to use in the scale line.
     * @param {import("./ScaleLine.js").Units} units The units to use in the scale line.
     * @observable
     * @api
     */ ScaleLine2.prototype.setUnits = function(units) {
        this.set(UNITS_PROP, units);
    };
    /**
     * Specify the dpi of output device such as printer.
     * @param {number|undefined} dpi The dpi of output device.
     * @api
     */ ScaleLine2.prototype.setDpi = function(dpi) {
        this.dpi_ = dpi;
    };
    /**
     * @private
     */ ScaleLine2.prototype.updateElement_ = function() {
        var viewState = this.viewState_;
        if (!viewState) {
            if (this.renderedVisible_) {
                this.element.style.display = 'none';
                this.renderedVisible_ = false;
            }
            return;
        }
        var center = viewState.center;
        var projection = viewState.projection;
        var units = this.getUnits();
        var pointResolutionUnits = units == Units.DEGREES ? _unitsJsDefault.default.DEGREES : _unitsJsDefault.default.METERS;
        var pointResolution = _projJs.getPointResolution(projection, viewState.resolution, center, pointResolutionUnits);
        var minWidth = this.minWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI;
        var nominalCount = minWidth * pointResolution;
        var suffix = '';
        if (units == Units.DEGREES) {
            var metersPerDegree = _projJs.METERS_PER_UNIT[_unitsJsDefault.default.DEGREES];
            nominalCount *= metersPerDegree;
            if (nominalCount < metersPerDegree / 60) {
                suffix = '\u2033'; // seconds
                pointResolution *= 3600;
            } else if (nominalCount < metersPerDegree) {
                suffix = '\u2032'; // minutes
                pointResolution *= 60;
            } else suffix = '\u00b0'; // degrees
        } else if (units == Units.IMPERIAL) {
            if (nominalCount < 0.9144) {
                suffix = 'in';
                pointResolution /= 0.0254;
            } else if (nominalCount < 1609.344) {
                suffix = 'ft';
                pointResolution /= 0.3048;
            } else {
                suffix = 'mi';
                pointResolution /= 1609.344;
            }
        } else if (units == Units.NAUTICAL) {
            pointResolution /= 1852;
            suffix = 'nm';
        } else if (units == Units.METRIC) {
            if (nominalCount < 0.001) {
                suffix = 'Î¼m';
                pointResolution *= 1000000;
            } else if (nominalCount < 1) {
                suffix = 'mm';
                pointResolution *= 1000;
            } else if (nominalCount < 1000) suffix = 'm';
            else {
                suffix = 'km';
                pointResolution /= 1000;
            }
        } else if (units == Units.US) {
            if (nominalCount < 0.9144) {
                suffix = 'in';
                pointResolution *= 39.37;
            } else if (nominalCount < 1609.344) {
                suffix = 'ft';
                pointResolution /= 0.30480061;
            } else {
                suffix = 'mi';
                pointResolution /= 1609.3472;
            }
        } else _assertsJs.assert(false, 33); // Invalid units
        var i = 3 * Math.floor(Math.log(minWidth * pointResolution) / Math.log(10));
        var count, width, decimalCount;
        while(true){
            decimalCount = Math.floor(i / 3);
            var decimal = Math.pow(10, decimalCount);
            count = LEADING_DIGITS[(i % 3 + 3) % 3] * decimal;
            width = Math.round(count / pointResolution);
            if (isNaN(width)) {
                this.element.style.display = 'none';
                this.renderedVisible_ = false;
                return;
            } else if (width >= minWidth) break;
            ++i;
        }
        var html;
        if (this.scaleBar_) html = this.createScaleBar(width, count, suffix);
        else html = count.toFixed(decimalCount < 0 ? -decimalCount : 0) + ' ' + suffix;
        if (this.renderedHTML_ != html) {
            this.innerElement_.innerHTML = html;
            this.renderedHTML_ = html;
        }
        if (this.renderedWidth_ != width) {
            this.innerElement_.style.width = width + 'px';
            this.renderedWidth_ = width;
        }
        if (!this.renderedVisible_) {
            this.element.style.display = '';
            this.renderedVisible_ = true;
        }
    };
    /**
     * @private
     * @param {number} width The current width of the scalebar.
     * @param {number} scale The current scale.
     * @param {string} suffix The suffix to append to the scale text.
     * @return {string} The stringified HTML of the scalebar.
     */ ScaleLine2.prototype.createScaleBar = function(width, scale, suffix) {
        var mapScale = '1 : ' + Math.round(this.getScaleForResolution()).toLocaleString();
        var scaleSteps = [];
        var stepWidth = width / this.scaleBarSteps_;
        var backgroundColor = '#ffffff';
        for(var i = 0; i < this.scaleBarSteps_; i++){
            if (i === 0) // create the first marker at position 0
            scaleSteps.push(this.createMarker('absolute', i));
            scaleSteps.push("<div><div class=\"ol-scale-singlebar\" style=\"width: " + stepWidth + 'px;' + 'background-color: ' + backgroundColor + ';"' + '>' + '</div>' + this.createMarker('relative', i) + (i % 2 === 0 || this.scaleBarSteps_ === 2 ? this.createStepText(i, width, false, scale, suffix) : '') + '</div>');
            if (i === this.scaleBarSteps_ - 1) scaleSteps.push(this.createStepText(i + 1, width, true, scale, suffix));
            // switch colors of steps between black and white
            if (backgroundColor === '#ffffff') backgroundColor = '#000000';
            else backgroundColor = '#ffffff';
        }
        var scaleBarText;
        if (this.scaleBarText_) scaleBarText = "<div class=\"ol-scale-text\" style=\"width: " + width + 'px;">' + mapScale + '</div>';
        else scaleBarText = '';
        var container = "<div style=\"display: flex;\">" + scaleBarText + scaleSteps.join('') + '</div>';
        return container;
    };
    /**
     * Creates a marker at given position
     * @param {string} position The position, absolute or relative
     * @param {number} i The iterator
     * @return {string} The stringified div containing the marker
     */ ScaleLine2.prototype.createMarker = function(position, i) {
        var top = position === 'absolute' ? 3 : -10;
        return "<div class=\"ol-scale-step-marker\" style=\"position: " + position + ';' + 'top: ' + top + 'px;"' + '></div>';
    };
    /**
     * Creates the label for a marker marker at given position
     * @param {number} i The iterator
     * @param {number} width The width the scalebar will currently use
     * @param {boolean} isLast Flag indicating if we add the last step text
     * @param {number} scale The current scale for the whole scalebar
     * @param {string} suffix The suffix for the scale
     * @return {string} The stringified div containing the step text
     */ ScaleLine2.prototype.createStepText = function(i, width, isLast, scale, suffix) {
        var length = i === 0 ? 0 : Math.round(scale / this.scaleBarSteps_ * i * 100) / 100;
        var lengthString = length + (i === 0 ? '' : ' ' + suffix);
        var margin = i === 0 ? -3 : width / this.scaleBarSteps_ * -1;
        var minWidth = i === 0 ? 0 : width / this.scaleBarSteps_ * 2;
        return "<div class=\"ol-scale-step-text\" style=\"margin-left: " + margin + 'px;' + 'text-align: ' + (i === 0 ? 'left' : 'center') + '; ' + 'min-width: ' + minWidth + 'px;' + 'left: ' + (isLast ? width + 'px' : 'unset') + ';"' + '>' + lengthString + '</div>';
    };
    /**
     * Returns the appropriate scale for the given resolution and units.
     * @return {number} The appropriate scale.
     */ ScaleLine2.prototype.getScaleForResolution = function() {
        var resolution = _projJs.getPointResolution(this.viewState_.projection, this.viewState_.resolution, this.viewState_.center);
        var dpi = this.dpi_ || DEFAULT_DPI;
        var mpu = this.viewState_.projection.getMetersPerUnit();
        var inchesPerMeter = 1000 / 25.4;
        return parseFloat(resolution.toString()) * mpu * inchesPerMeter * dpi;
    };
    /**
     * Update the scale line element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */ ScaleLine2.prototype.render = function(mapEvent) {
        var frameState = mapEvent.frameState;
        if (!frameState) this.viewState_ = null;
        else this.viewState_ = frameState.viewState;
        this.updateElement_();
    };
    return ScaleLine2;
}(_controlJsDefault.default);
exports.default = ScaleLine1;

},{"./Control.js":"RgF2j","../proj/Units.js":"g2gaW","../css.js":"23c5q","../proj.js":"hmdWM","../asserts.js":"cnrP4","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"htfq9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _controlJs = require("./Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _eventTypeJs1 = require("../pointer/EventType.js");
var _eventTypeJsDefault1 = parcelHelpers.interopDefault(_eventTypeJs1);
var _cssJs = require("../css.js");
var _mathJs = require("../math.js");
var _easingJs = require("../easing.js");
var _eventsJs = require("../events.js");
var _eventJs = require("../events/Event.js");
/**
 * @module ol/control/ZoomSlider
 */ var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * The enum for available directions.
 *
 * @enum {number}
 */ var Direction = {
    VERTICAL: 0,
    HORIZONTAL: 1
};
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-zoomslider'] CSS class name.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 */ /**
 * @classdesc
 * A slider type of control for zooming.
 *
 * Example:
 *
 *     map.addControl(new ZoomSlider());
 *
 * @api
 */ var ZoomSlider1 = function(_super) {
    __extends(ZoomSlider2, _super);
    /**
     * @param {Options} [opt_options] Zoom slider options.
     */ function ZoomSlider2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        _this = _super.call(this, {
            element: document.createElement('div'),
            render: options.render
        }) || this;
        /**
         * @type {!Array<import("../events.js").EventsKey>}
         * @private
         */ _this.dragListenerKeys_ = [];
        /**
         * Will hold the current resolution of the view.
         *
         * @type {number|undefined}
         * @private
         */ _this.currentResolution_ = undefined;
        /**
         * The direction of the slider. Will be determined from actual display of the
         * container and defaults to Direction.VERTICAL.
         *
         * @type {Direction}
         * @private
         */ _this.direction_ = Direction.VERTICAL;
        /**
         * @type {boolean}
         * @private
         */ _this.dragging_;
        /**
         * @type {number}
         * @private
         */ _this.heightLimit_ = 0;
        /**
         * @type {number}
         * @private
         */ _this.widthLimit_ = 0;
        /**
         * @type {number|undefined}
         * @private
         */ _this.startX_;
        /**
         * @type {number|undefined}
         * @private
         */ _this.startY_;
        /**
         * The calculated thumb size (border box plus margins).  Set when initSlider_
         * is called.
         * @type {import("../size.js").Size}
         * @private
         */ _this.thumbSize_ = null;
        /**
         * Whether the slider is initialized.
         * @type {boolean}
         * @private
         */ _this.sliderInitialized_ = false;
        /**
         * @type {number}
         * @private
         */ _this.duration_ = options.duration !== undefined ? options.duration : 200;
        var className = options.className !== undefined ? options.className : 'ol-zoomslider';
        var thumbElement = document.createElement('button');
        thumbElement.setAttribute('type', 'button');
        thumbElement.className = className + '-thumb ' + _cssJs.CLASS_UNSELECTABLE;
        var containerElement = _this.element;
        containerElement.className = className + ' ' + _cssJs.CLASS_UNSELECTABLE + ' ' + _cssJs.CLASS_CONTROL;
        containerElement.appendChild(thumbElement);
        containerElement.addEventListener(_eventTypeJsDefault1.default.POINTERDOWN, _this.handleDraggerStart_.bind(_this), false);
        containerElement.addEventListener(_eventTypeJsDefault1.default.POINTERMOVE, _this.handleDraggerDrag_.bind(_this), false);
        containerElement.addEventListener(_eventTypeJsDefault1.default.POINTERUP, _this.handleDraggerEnd_.bind(_this), false);
        containerElement.addEventListener(_eventTypeJsDefault.default.CLICK, _this.handleContainerClick_.bind(_this), false);
        thumbElement.addEventListener(_eventTypeJsDefault.default.CLICK, _eventJs.stopPropagation, false);
        return _this;
    }
    /**
     * Remove the control from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default} map Map.
     * @api
     */ ZoomSlider2.prototype.setMap = function(map) {
        _super.prototype.setMap.call(this, map);
        if (map) map.render();
    };
    /**
     * Initializes the slider element. This will determine and set this controls
     * direction_ and also constrain the dragging of the thumb to always be within
     * the bounds of the container.
     *
     * @return {boolean} Initialization successful
     * @private
     */ ZoomSlider2.prototype.initSlider_ = function() {
        var container = this.element;
        var containerWidth = container.offsetWidth;
        var containerHeight = container.offsetHeight;
        if (containerWidth === 0 && containerHeight === 0) return this.sliderInitialized_ = false;
        var containerStyle = getComputedStyle(container);
        containerWidth -= parseFloat(containerStyle['paddingRight']) + parseFloat(containerStyle['paddingLeft']);
        containerHeight -= parseFloat(containerStyle['paddingTop']) + parseFloat(containerStyle['paddingBottom']);
        var thumb = container.firstElementChild;
        var thumbStyle = getComputedStyle(thumb);
        var thumbWidth = thumb.offsetWidth + parseFloat(thumbStyle['marginRight']) + parseFloat(thumbStyle['marginLeft']);
        var thumbHeight = thumb.offsetHeight + parseFloat(thumbStyle['marginTop']) + parseFloat(thumbStyle['marginBottom']);
        this.thumbSize_ = [
            thumbWidth,
            thumbHeight
        ];
        if (containerWidth > containerHeight) {
            this.direction_ = Direction.HORIZONTAL;
            this.widthLimit_ = containerWidth - thumbWidth;
        } else {
            this.direction_ = Direction.VERTICAL;
            this.heightLimit_ = containerHeight - thumbHeight;
        }
        return this.sliderInitialized_ = true;
    };
    /**
     * @param {PointerEvent} event The browser event to handle.
     * @private
     */ ZoomSlider2.prototype.handleContainerClick_ = function(event) {
        var view = this.getMap().getView();
        var relativePosition = this.getRelativePosition_(event.offsetX - this.thumbSize_[0] / 2, event.offsetY - this.thumbSize_[1] / 2);
        var resolution = this.getResolutionForPosition_(relativePosition);
        var zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));
        view.animateInternal({
            zoom: zoom,
            duration: this.duration_,
            easing: _easingJs.easeOut
        });
    };
    /**
     * Handle dragger start events.
     * @param {PointerEvent} event The drag event.
     * @private
     */ ZoomSlider2.prototype.handleDraggerStart_ = function(event) {
        if (!this.dragging_ && event.target === this.element.firstElementChild) {
            var element = this.element.firstElementChild;
            this.getMap().getView().beginInteraction();
            this.startX_ = event.clientX - parseFloat(element.style.left);
            this.startY_ = event.clientY - parseFloat(element.style.top);
            this.dragging_ = true;
            if (this.dragListenerKeys_.length === 0) {
                var drag = this.handleDraggerDrag_;
                var end = this.handleDraggerEnd_;
                var doc = this.getMap().getOwnerDocument();
                this.dragListenerKeys_.push(_eventsJs.listen(doc, _eventTypeJsDefault1.default.POINTERMOVE, drag, this), _eventsJs.listen(doc, _eventTypeJsDefault1.default.POINTERUP, end, this));
            }
        }
    };
    /**
     * Handle dragger drag events.
     *
     * @param {PointerEvent} event The drag event.
     * @private
     */ ZoomSlider2.prototype.handleDraggerDrag_ = function(event) {
        if (this.dragging_) {
            var deltaX = event.clientX - this.startX_;
            var deltaY = event.clientY - this.startY_;
            var relativePosition = this.getRelativePosition_(deltaX, deltaY);
            this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
            this.getMap().getView().setResolution(this.currentResolution_);
        }
    };
    /**
     * Handle dragger end events.
     * @param {PointerEvent} event The drag event.
     * @private
     */ ZoomSlider2.prototype.handleDraggerEnd_ = function(event) {
        if (this.dragging_) {
            var view = this.getMap().getView();
            view.endInteraction();
            this.dragging_ = false;
            this.startX_ = undefined;
            this.startY_ = undefined;
            this.dragListenerKeys_.forEach(_eventsJs.unlistenByKey);
            this.dragListenerKeys_.length = 0;
        }
    };
    /**
     * Positions the thumb inside its container according to the given resolution.
     *
     * @param {number} res The res.
     * @private
     */ ZoomSlider2.prototype.setThumbPosition_ = function(res) {
        var position = this.getPositionForResolution_(res);
        var thumb = this.element.firstElementChild;
        if (this.direction_ == Direction.HORIZONTAL) thumb.style.left = this.widthLimit_ * position + 'px';
        else thumb.style.top = this.heightLimit_ * position + 'px';
    };
    /**
     * Calculates the relative position of the thumb given x and y offsets.  The
     * relative position scales from 0 to 1.  The x and y offsets are assumed to be
     * in pixel units within the dragger limits.
     *
     * @param {number} x Pixel position relative to the left of the slider.
     * @param {number} y Pixel position relative to the top of the slider.
     * @return {number} The relative position of the thumb.
     * @private
     */ ZoomSlider2.prototype.getRelativePosition_ = function(x, y) {
        var amount;
        if (this.direction_ === Direction.HORIZONTAL) amount = x / this.widthLimit_;
        else amount = y / this.heightLimit_;
        return _mathJs.clamp(amount, 0, 1);
    };
    /**
     * Calculates the corresponding resolution of the thumb given its relative
     * position (where 0 is the minimum and 1 is the maximum).
     *
     * @param {number} position The relative position of the thumb.
     * @return {number} The corresponding resolution.
     * @private
     */ ZoomSlider2.prototype.getResolutionForPosition_ = function(position) {
        var fn = this.getMap().getView().getResolutionForValueFunction();
        return fn(1 - position);
    };
    /**
     * Determines the relative position of the slider for the given resolution.  A
     * relative position of 0 corresponds to the minimum view resolution.  A
     * relative position of 1 corresponds to the maximum view resolution.
     *
     * @param {number} res The resolution.
     * @return {number} The relative position value (between 0 and 1).
     * @private
     */ ZoomSlider2.prototype.getPositionForResolution_ = function(res) {
        var fn = this.getMap().getView().getValueForResolutionFunction();
        return _mathJs.clamp(1 - fn(res), 0, 1);
    };
    /**
     * Update the zoomslider element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */ ZoomSlider2.prototype.render = function(mapEvent) {
        if (!mapEvent.frameState) return;
        if (!this.sliderInitialized_ && !this.initSlider_()) return;
        var res = mapEvent.frameState.viewState.resolution;
        this.currentResolution_ = res;
        this.setThumbPosition_(res);
    };
    return ZoomSlider2;
}(_controlJsDefault.default);
exports.default = ZoomSlider1;

},{"./Control.js":"RgF2j","../events/EventType.js":"83vee","../pointer/EventType.js":"3XFPg","../css.js":"23c5q","../math.js":"kI4rE","../easing.js":"BpZIl","../events.js":"e9Qqr","../events/Event.js":"7AR9n","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"idah2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/control/ZoomToExtent
 */ var _controlJs = require("./Control.js");
var _controlJsDefault = parcelHelpers.interopDefault(_controlJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _cssJs = require("../css.js");
var _polygonJs = require("../geom/Polygon.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-zoom-extent'] Class name.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {string|HTMLElement} [label='E'] Text label to use for the button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Fit to extent'] Text label to use for the button tip.
 * @property {import("../extent.js").Extent} [extent] The extent to zoom to. If undefined the validity
 * extent of the view projection is used.
 */ /**
 * @classdesc
 * A button control which, when pressed, changes the map view to a specific
 * extent. To style this control use the css selector `.ol-zoom-extent`.
 *
 * @api
 */ var ZoomToExtent1 = function(_super) {
    __extends(ZoomToExtent2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function ZoomToExtent2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        _this = _super.call(this, {
            element: document.createElement('div'),
            target: options.target
        }) || this;
        /**
         * @type {?import("../extent.js").Extent}
         * @protected
         */ _this.extent = options.extent ? options.extent : null;
        var className = options.className !== undefined ? options.className : 'ol-zoom-extent';
        var label = options.label !== undefined ? options.label : 'E';
        var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Fit to extent';
        var button = document.createElement('button');
        button.setAttribute('type', 'button');
        button.title = tipLabel;
        button.appendChild(typeof label === 'string' ? document.createTextNode(label) : label);
        button.addEventListener(_eventTypeJsDefault.default.CLICK, _this.handleClick_.bind(_this), false);
        var cssClasses = className + ' ' + _cssJs.CLASS_UNSELECTABLE + ' ' + _cssJs.CLASS_CONTROL;
        var element = _this.element;
        element.className = cssClasses;
        element.appendChild(button);
        return _this;
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */ ZoomToExtent2.prototype.handleClick_ = function(event) {
        event.preventDefault();
        this.handleZoomToExtent();
    };
    /**
     * @protected
     */ ZoomToExtent2.prototype.handleZoomToExtent = function() {
        var map = this.getMap();
        var view = map.getView();
        var extent = !this.extent ? view.getProjection().getExtent() : this.extent;
        view.fitInternal(_polygonJs.fromExtent(extent));
    };
    return ZoomToExtent2;
}(_controlJsDefault.default);
exports.default = ZoomToExtent1;

},{"./Control.js":"RgF2j","../events/EventType.js":"83vee","../css.js":"23c5q","../geom/Polygon.js":"hoOc8","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kbOE7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DoubleClickZoom", ()=>_doubleClickZoomJsDefault.default
);
parcelHelpers.export(exports, "DragAndDrop", ()=>_dragAndDropJsDefault.default
);
parcelHelpers.export(exports, "DragBox", ()=>_dragBoxJsDefault.default
);
parcelHelpers.export(exports, "DragPan", ()=>_dragPanJsDefault.default
);
parcelHelpers.export(exports, "DragRotate", ()=>_dragRotateJsDefault.default
);
parcelHelpers.export(exports, "DragRotateAndZoom", ()=>_dragRotateAndZoomJsDefault.default
);
parcelHelpers.export(exports, "DragZoom", ()=>_dragZoomJsDefault.default
);
parcelHelpers.export(exports, "Draw", ()=>_drawJsDefault.default
);
parcelHelpers.export(exports, "Extent", ()=>_extentJsDefault.default
);
parcelHelpers.export(exports, "Interaction", ()=>_interactionJsDefault.default
);
parcelHelpers.export(exports, "KeyboardPan", ()=>_keyboardPanJsDefault.default
);
parcelHelpers.export(exports, "KeyboardZoom", ()=>_keyboardZoomJsDefault.default
);
parcelHelpers.export(exports, "Modify", ()=>_modifyJsDefault.default
);
parcelHelpers.export(exports, "MouseWheelZoom", ()=>_mouseWheelZoomJsDefault.default
);
parcelHelpers.export(exports, "PinchRotate", ()=>_pinchRotateJsDefault.default
);
parcelHelpers.export(exports, "PinchZoom", ()=>_pinchZoomJsDefault.default
);
parcelHelpers.export(exports, "Pointer", ()=>_pointerJsDefault.default
);
parcelHelpers.export(exports, "Select", ()=>_selectJsDefault.default
);
parcelHelpers.export(exports, "Snap", ()=>_snapJsDefault.default
);
parcelHelpers.export(exports, "Translate", ()=>_translateJsDefault.default
);
/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
 * desired.
 * @property {boolean} [onFocusOnly=false] Interact only when the map has the
 * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
 * useful when page scroll is desired for maps that do not have the browser's
 * focus.
 * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
 * desired.
 * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
 * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
 * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
 * @property {boolean} [dragPan=true] Whether drag pan is desired.
 * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
 * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
 * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
 * @property {number} [zoomDuration] Duration of the zoom animation in
 * milliseconds.
 */ /**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link module:ol/interaction/Interaction} instances and insert
 * them into a {@link module:ol/Collection} in the order you want
 * before creating your {@link module:ol/Map~Map} instance. Changing the order can
 * be of interest if the event propagation needs to be stopped at a point.
 * The default set of interactions, in sequence, is:
 * * {@link module:ol/interaction/DragRotate~DragRotate}
 * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
 * * {@link module:ol/interaction/DragPan~DragPan}
 * * {@link module:ol/interaction/PinchRotate~PinchRotate}
 * * {@link module:ol/interaction/PinchZoom~PinchZoom}
 * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
 * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
 * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
 * * {@link module:ol/interaction/DragZoom~DragZoom}
 *
 * @param {DefaultsOptions} [opt_options] Defaults options.
 * @return {import("./Collection.js").default<import("./interaction/Interaction.js").default>}
 * A collection of interactions to be used with the {@link module:ol/Map~Map}
 * constructor's `interactions` option.
 * @api
 */ parcelHelpers.export(exports, "defaults", ()=>defaults
);
/**
 * @module ol/interaction
 */ var _collectionJs = require("./Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _doubleClickZoomJs = require("./interaction/DoubleClickZoom.js");
var _doubleClickZoomJsDefault = parcelHelpers.interopDefault(_doubleClickZoomJs);
var _dragPanJs = require("./interaction/DragPan.js");
var _dragPanJsDefault = parcelHelpers.interopDefault(_dragPanJs);
var _dragRotateJs = require("./interaction/DragRotate.js");
var _dragRotateJsDefault = parcelHelpers.interopDefault(_dragRotateJs);
var _dragZoomJs = require("./interaction/DragZoom.js");
var _dragZoomJsDefault = parcelHelpers.interopDefault(_dragZoomJs);
var _keyboardPanJs = require("./interaction/KeyboardPan.js");
var _keyboardPanJsDefault = parcelHelpers.interopDefault(_keyboardPanJs);
var _keyboardZoomJs = require("./interaction/KeyboardZoom.js");
var _keyboardZoomJsDefault = parcelHelpers.interopDefault(_keyboardZoomJs);
var _kineticJs = require("./Kinetic.js");
var _kineticJsDefault = parcelHelpers.interopDefault(_kineticJs);
var _mouseWheelZoomJs = require("./interaction/MouseWheelZoom.js");
var _mouseWheelZoomJsDefault = parcelHelpers.interopDefault(_mouseWheelZoomJs);
var _pinchRotateJs = require("./interaction/PinchRotate.js");
var _pinchRotateJsDefault = parcelHelpers.interopDefault(_pinchRotateJs);
var _pinchZoomJs = require("./interaction/PinchZoom.js");
var _pinchZoomJsDefault = parcelHelpers.interopDefault(_pinchZoomJs);
var _dragAndDropJs = require("./interaction/DragAndDrop.js");
var _dragAndDropJsDefault = parcelHelpers.interopDefault(_dragAndDropJs);
var _dragBoxJs = require("./interaction/DragBox.js");
var _dragBoxJsDefault = parcelHelpers.interopDefault(_dragBoxJs);
var _dragRotateAndZoomJs = require("./interaction/DragRotateAndZoom.js");
var _dragRotateAndZoomJsDefault = parcelHelpers.interopDefault(_dragRotateAndZoomJs);
var _drawJs = require("./interaction/Draw.js");
var _drawJsDefault = parcelHelpers.interopDefault(_drawJs);
var _extentJs = require("./interaction/Extent.js");
var _extentJsDefault = parcelHelpers.interopDefault(_extentJs);
var _interactionJs = require("./interaction/Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _modifyJs = require("./interaction/Modify.js");
var _modifyJsDefault = parcelHelpers.interopDefault(_modifyJs);
var _pointerJs = require("./interaction/Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _selectJs = require("./interaction/Select.js");
var _selectJsDefault = parcelHelpers.interopDefault(_selectJs);
var _snapJs = require("./interaction/Snap.js");
var _snapJsDefault = parcelHelpers.interopDefault(_snapJs);
var _translateJs = require("./interaction/Translate.js");
var _translateJsDefault = parcelHelpers.interopDefault(_translateJs);
function defaults(opt_options) {
    var options = opt_options ? opt_options : {
    };
    var interactions = new _collectionJsDefault.default();
    var kinetic = new _kineticJsDefault.default(-0.005, 0.05, 100);
    var altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;
    if (altShiftDragRotate) interactions.push(new _dragRotateJsDefault.default());
    var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;
    if (doubleClickZoom) interactions.push(new _doubleClickZoomJsDefault.default({
        delta: options.zoomDelta,
        duration: options.zoomDuration
    }));
    var dragPan = options.dragPan !== undefined ? options.dragPan : true;
    if (dragPan) interactions.push(new _dragPanJsDefault.default({
        onFocusOnly: options.onFocusOnly,
        kinetic: kinetic
    }));
    var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;
    if (pinchRotate) interactions.push(new _pinchRotateJsDefault.default());
    var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
    if (pinchZoom) interactions.push(new _pinchZoomJsDefault.default({
        duration: options.zoomDuration
    }));
    var keyboard = options.keyboard !== undefined ? options.keyboard : true;
    if (keyboard) {
        interactions.push(new _keyboardPanJsDefault.default());
        interactions.push(new _keyboardZoomJsDefault.default({
            delta: options.zoomDelta,
            duration: options.zoomDuration
        }));
    }
    var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;
    if (mouseWheelZoom) interactions.push(new _mouseWheelZoomJsDefault.default({
        onFocusOnly: options.onFocusOnly,
        duration: options.zoomDuration
    }));
    var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;
    if (shiftDragZoom) interactions.push(new _dragZoomJsDefault.default({
        duration: options.zoomDuration
    }));
    return interactions;
}

},{"./Collection.js":"d2f3b","./interaction/DoubleClickZoom.js":"e47hF","./interaction/DragPan.js":"6I3mF","./interaction/DragRotate.js":"c9bvr","./interaction/DragZoom.js":"3pnTn","./interaction/KeyboardPan.js":"5egeF","./interaction/KeyboardZoom.js":"aicI4","./Kinetic.js":"aUIXw","./interaction/MouseWheelZoom.js":"1x9fR","./interaction/PinchRotate.js":"7uL1t","./interaction/PinchZoom.js":"adA2u","./interaction/DragAndDrop.js":"h1Dmo","./interaction/DragBox.js":"hSIti","./interaction/DragRotateAndZoom.js":"erzzu","./interaction/Draw.js":"1tafX","./interaction/Extent.js":"lfwwe","./interaction/Interaction.js":"dRzfo","./interaction/Modify.js":"5MUrp","./interaction/Pointer.js":"iatpc","./interaction/Select.js":"bMXNv","./interaction/Snap.js":"7zWYD","./interaction/Translate.js":"kfbdg","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"e47hF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/interaction/DoubleClickZoom
 */ var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */ /**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */ var DoubleClickZoom1 = function(_super) {
    __extends(DoubleClickZoom2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function DoubleClickZoom2(opt_options) {
        var _this = _super.call(this) || this;
        var options = opt_options ? opt_options : {
        };
        /**
         * @private
         * @type {number}
         */ _this.delta_ = options.delta ? options.delta : 1;
        /**
         * @private
         * @type {number}
         */ _this.duration_ = options.duration !== undefined ? options.duration : 250;
        return _this;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a
     * doubleclick) and eventually zooms the map.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     */ DoubleClickZoom2.prototype.handleEvent = function(mapBrowserEvent) {
        var stopEvent = false;
        if (mapBrowserEvent.type == _mapBrowserEventTypeJsDefault.default.DBLCLICK) {
            var browserEvent = mapBrowserEvent.originalEvent;
            var map = mapBrowserEvent.map;
            var anchor = mapBrowserEvent.coordinate;
            var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
            var view = map.getView();
            _interactionJs.zoomByDelta(view, delta, anchor, this.duration_);
            browserEvent.preventDefault();
            stopEvent = true;
        }
        return !stopEvent;
    };
    return DoubleClickZoom2;
}(_interactionJsDefault.default);
exports.default = DoubleClickZoom1;

},{"./Interaction.js":"dRzfo","../MapBrowserEventType.js":"coXRZ","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"dRzfo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import("../View.js").default} view View.
 * @param {import("../coordinate.js").Coordinate} delta Delta.
 * @param {number} [opt_duration] Duration.
 */ parcelHelpers.export(exports, "pan", ()=>pan
);
/**
 * @param {import("../View.js").default} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {import("../coordinate.js").Coordinate} [opt_anchor] Anchor coordinate in the user projection.
 * @param {number} [opt_duration] Duration.
 */ parcelHelpers.export(exports, "zoomByDelta", ()=>zoomByDelta
);
/**
 * @module ol/interaction/Interaction
 */ var _objectJs = require("../Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _easingJs = require("../easing.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active', Return>} InteractionOnSignature
 */ /**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return). The interactions
 * are traversed in reverse order of the interactions collection of the map.
 */ /**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */ var Interaction1 = function(_super) {
    __extends(Interaction2, _super);
    /**
     * @param {InteractionOptions} [opt_options] Options.
     */ function Interaction2(opt_options) {
        var _this = _super.call(this) || this;
        /***
         * @type {InteractionOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {InteractionOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {InteractionOnSignature<void>}
         */ _this.un;
        if (opt_options && opt_options.handleEvent) _this.handleEvent = opt_options.handleEvent;
        /**
         * @private
         * @type {import("../PluggableMap.js").default}
         */ _this.map_ = null;
        _this.setActive(true);
        return _this;
    }
    /**
     * Return whether the interaction is currently active.
     * @return {boolean} `true` if the interaction is active, `false` otherwise.
     * @observable
     * @api
     */ Interaction2.prototype.getActive = function() {
        return this.get(_propertyJsDefault.default.ACTIVE);
    };
    /**
     * Get the map associated with this interaction.
     * @return {import("../PluggableMap.js").default} Map.
     * @api
     */ Interaction2.prototype.getMap = function() {
        return this.map_;
    };
    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event}.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */ Interaction2.prototype.handleEvent = function(mapBrowserEvent) {
        return true;
    };
    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     */ Interaction2.prototype.setActive = function(active) {
        this.set(_propertyJsDefault.default.ACTIVE, active);
    };
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default} map Map.
     */ Interaction2.prototype.setMap = function(map) {
        this.map_ = map;
    };
    return Interaction2;
}(_objectJsDefault.default);
function pan(view, delta, opt_duration) {
    var currentCenter = view.getCenterInternal();
    if (currentCenter) {
        var center = [
            currentCenter[0] + delta[0],
            currentCenter[1] + delta[1]
        ];
        view.animateInternal({
            duration: opt_duration !== undefined ? opt_duration : 250,
            easing: _easingJs.linear,
            center: view.getConstrainedCenter(center)
        });
    }
}
function zoomByDelta(view, delta, opt_anchor, opt_duration) {
    var currentZoom = view.getZoom();
    if (currentZoom === undefined) return;
    var newZoom = view.getConstrainedZoom(currentZoom + delta);
    var newResolution = view.getResolutionForZoom(newZoom);
    if (view.getAnimating()) view.cancelAnimations();
    view.animate({
        resolution: newResolution,
        anchor: opt_anchor,
        duration: opt_duration !== undefined ? opt_duration : 250,
        easing: _easingJs.easeOut
    });
}
exports.default = Interaction1;

},{"../Object.js":"3roCV","./Property.js":"jZl7a","../easing.js":"BpZIl","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jZl7a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    ACTIVE: 'active'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6I3mF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/interaction/DragPan
 */ var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _functionsJs = require("../functions.js");
var _conditionJs = require("../events/condition.js");
var _easingJs = require("../easing.js");
var _coordinateJs = require("../coordinate.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
 */ /**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */ var DragPan1 = function(_super) {
    __extends(DragPan2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function DragPan2(opt_options) {
        var _this = _super.call(this, {
            stopDown: _functionsJs.FALSE
        }) || this;
        var options = opt_options ? opt_options : {
        };
        /**
         * @private
         * @type {import("../Kinetic.js").default|undefined}
         */ _this.kinetic_ = options.kinetic;
        /**
         * @type {import("../pixel.js").Pixel}
         */ _this.lastCentroid = null;
        /**
         * @type {number}
         */ _this.lastPointersCount_;
        /**
         * @type {boolean}
         */ _this.panning_ = false;
        var condition = options.condition ? options.condition : _conditionJs.all(_conditionJs.noModifierKeys, _conditionJs.primaryAction);
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.condition_ = options.onFocusOnly ? _conditionJs.all(_conditionJs.focusWithTabindex, condition) : condition;
        /**
         * @private
         * @type {boolean}
         */ _this.noKinetic_ = false;
        return _this;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */ DragPan2.prototype.handleDragEvent = function(mapBrowserEvent) {
        if (!this.panning_) {
            this.panning_ = true;
            this.getMap().getView().beginInteraction();
        }
        var targetPointers = this.targetPointers;
        var centroid = _pointerJs.centroid(targetPointers);
        if (targetPointers.length == this.lastPointersCount_) {
            if (this.kinetic_) this.kinetic_.update(centroid[0], centroid[1]);
            if (this.lastCentroid) {
                var delta = [
                    this.lastCentroid[0] - centroid[0],
                    centroid[1] - this.lastCentroid[1], 
                ];
                var map = mapBrowserEvent.map;
                var view = map.getView();
                _coordinateJs.scale(delta, view.getResolution());
                _coordinateJs.rotate(delta, view.getRotation());
                view.adjustCenterInternal(delta);
            }
        } else if (this.kinetic_) // reset so we don't overestimate the kinetic energy after
        // after one finger down, tiny drag, second finger down
        this.kinetic_.begin();
        this.lastCentroid = centroid;
        this.lastPointersCount_ = targetPointers.length;
        mapBrowserEvent.originalEvent.preventDefault();
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */ DragPan2.prototype.handleUpEvent = function(mapBrowserEvent) {
        var map = mapBrowserEvent.map;
        var view = map.getView();
        if (this.targetPointers.length === 0) {
            if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
                var distance = this.kinetic_.getDistance();
                var angle = this.kinetic_.getAngle();
                var center = view.getCenterInternal();
                var centerpx = map.getPixelFromCoordinateInternal(center);
                var dest = map.getCoordinateFromPixelInternal([
                    centerpx[0] - distance * Math.cos(angle),
                    centerpx[1] - distance * Math.sin(angle), 
                ]);
                view.animateInternal({
                    center: view.getConstrainedCenter(dest),
                    duration: 500,
                    easing: _easingJs.easeOut
                });
            }
            if (this.panning_) {
                this.panning_ = false;
                view.endInteraction();
            }
            return false;
        } else {
            if (this.kinetic_) // reset so we don't overestimate the kinetic energy after
            // after one finger up, tiny drag, second finger up
            this.kinetic_.begin();
            this.lastCentroid = null;
            return true;
        }
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */ DragPan2.prototype.handleDownEvent = function(mapBrowserEvent) {
        if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
            var map = mapBrowserEvent.map;
            var view = map.getView();
            this.lastCentroid = null;
            // stop any current animation
            if (view.getAnimating()) view.cancelAnimations();
            if (this.kinetic_) this.kinetic_.begin();
            // No kinetic as soon as more than one pointer on the screen is
            // detected. This is to prevent nasty pans after pinch.
            this.noKinetic_ = this.targetPointers.length > 1;
            return true;
        } else return false;
    };
    return DragPan2;
}(_pointerJsDefault.default);
exports.default = DragPan1;

},{"./Pointer.js":"iatpc","../functions.js":"d72zA","../events/condition.js":"eCqyb","../easing.js":"BpZIl","../coordinate.js":"cmApa","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"iatpc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<PointerEvent>} pointerEvents List of events.
 * @return {import("../pixel.js").Pixel} Centroid pixel.
 */ parcelHelpers.export(exports, "centroid", ()=>centroid
);
/**
 * @module ol/interaction/Pointer
 */ var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _objJs = require("../obj.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events.
 * This functions is also called during a drag sequence, so during a drag
 * sequence both the `handleDragEvent` function and this function are called.
 * If `handleDownEvent` is defined and it returns true this function will not
 * be called during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */ /**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */ var PointerInteraction1 = function(_super) {
    __extends(PointerInteraction2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function PointerInteraction2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        _this = _super.call(this, options) || this;
        if (options.handleDownEvent) _this.handleDownEvent = options.handleDownEvent;
        if (options.handleDragEvent) _this.handleDragEvent = options.handleDragEvent;
        if (options.handleMoveEvent) _this.handleMoveEvent = options.handleMoveEvent;
        if (options.handleUpEvent) _this.handleUpEvent = options.handleUpEvent;
        if (options.stopDown) _this.stopDown = options.stopDown;
        /**
         * @type {boolean}
         * @protected
         */ _this.handlingDownUpSequence = false;
        /**
         * @type {!Object<string, PointerEvent>}
         * @private
         */ _this.trackedPointers_ = {
        };
        /**
         * @type {Array<PointerEvent>}
         * @protected
         */ _this.targetPointers = [];
        return _this;
    }
    /**
     * Returns the current number of pointers involved in the interaction,
     * e.g. `2` when two fingers are used.
     * @return {number} The number of pointers.
     * @api
     */ PointerInteraction2.prototype.getPointerCount = function() {
        return this.targetPointers.length;
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */ PointerInteraction2.prototype.handleDownEvent = function(mapBrowserEvent) {
        return false;
    };
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */ PointerInteraction2.prototype.handleDragEvent = function(mapBrowserEvent) {
    };
    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} and may call into
     * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
     * detected.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */ PointerInteraction2.prototype.handleEvent = function(mapBrowserEvent) {
        if (!mapBrowserEvent.originalEvent) return true;
        var stopEvent = false;
        this.updateTrackedPointers_(mapBrowserEvent);
        if (this.handlingDownUpSequence) {
            if (mapBrowserEvent.type == _mapBrowserEventTypeJsDefault.default.POINTERDRAG) {
                this.handleDragEvent(mapBrowserEvent);
                // prevent page scrolling during dragging
                mapBrowserEvent.originalEvent.preventDefault();
            } else if (mapBrowserEvent.type == _mapBrowserEventTypeJsDefault.default.POINTERUP) {
                var handledUp = this.handleUpEvent(mapBrowserEvent);
                this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
            }
        } else {
            if (mapBrowserEvent.type == _mapBrowserEventTypeJsDefault.default.POINTERDOWN) {
                var handled = this.handleDownEvent(mapBrowserEvent);
                this.handlingDownUpSequence = handled;
                stopEvent = this.stopDown(handled);
            } else if (mapBrowserEvent.type == _mapBrowserEventTypeJsDefault.default.POINTERMOVE) this.handleMoveEvent(mapBrowserEvent);
        }
        return !stopEvent;
    };
    /**
     * Handle pointer move events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */ PointerInteraction2.prototype.handleMoveEvent = function(mapBrowserEvent) {
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */ PointerInteraction2.prototype.handleUpEvent = function(mapBrowserEvent) {
        return false;
    };
    /**
     * This function is used to determine if "down" events should be propagated
     * to other interactions or should be stopped.
     * @param {boolean} handled Was the event handled by the interaction?
     * @return {boolean} Should the `down` event be stopped?
     */ PointerInteraction2.prototype.stopDown = function(handled) {
        return handled;
    };
    /**
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @private
     */ PointerInteraction2.prototype.updateTrackedPointers_ = function(mapBrowserEvent) {
        if (isPointerDraggingEvent(mapBrowserEvent)) {
            var event_1 = mapBrowserEvent.originalEvent;
            var id = event_1.pointerId.toString();
            if (mapBrowserEvent.type == _mapBrowserEventTypeJsDefault.default.POINTERUP) delete this.trackedPointers_[id];
            else if (mapBrowserEvent.type == _mapBrowserEventTypeJsDefault.default.POINTERDOWN) this.trackedPointers_[id] = event_1;
            else if (id in this.trackedPointers_) // update only when there was a pointerdown event for this pointer
            this.trackedPointers_[id] = event_1;
            this.targetPointers = _objJs.getValues(this.trackedPointers_);
        }
    };
    return PointerInteraction2;
}(_interactionJsDefault.default);
function centroid(pointerEvents) {
    var length = pointerEvents.length;
    var clientX = 0;
    var clientY = 0;
    for(var i = 0; i < length; i++){
        clientX += pointerEvents[i].clientX;
        clientY += pointerEvents[i].clientY;
    }
    return [
        clientX / length,
        clientY / length
    ];
}
/**
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
 * @return {boolean} Whether the event is a pointerdown, pointerdrag
 *     or pointerup event.
 */ function isPointerDraggingEvent(mapBrowserEvent) {
    var type = mapBrowserEvent.type;
    return type === _mapBrowserEventTypeJsDefault.default.POINTERDOWN || type === _mapBrowserEventTypeJsDefault.default.POINTERDRAG || type === _mapBrowserEventTypeJsDefault.default.POINTERUP;
}
exports.default = PointerInteraction1;

},{"./Interaction.js":"dRzfo","../MapBrowserEventType.js":"coXRZ","../obj.js":"g3fPg","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eCqyb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A function that takes an {@link module:ol/MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
 */ /**
 * Creates a condition function that passes when all provided conditions pass.
 * @param {...Condition} var_args Conditions to check.
 * @return {Condition} Condition function.
 */ parcelHelpers.export(exports, "all", ()=>all
);
parcelHelpers.export(exports, "altKeyOnly", ()=>altKeyOnly
);
parcelHelpers.export(exports, "altShiftKeysOnly", ()=>altShiftKeysOnly
);
parcelHelpers.export(exports, "focus", ()=>focus
);
parcelHelpers.export(exports, "focusWithTabindex", ()=>focusWithTabindex
);
parcelHelpers.export(exports, "always", ()=>always
);
parcelHelpers.export(exports, "click", ()=>click
);
parcelHelpers.export(exports, "mouseActionButton", ()=>mouseActionButton
);
parcelHelpers.export(exports, "never", ()=>never
);
parcelHelpers.export(exports, "pointerMove", ()=>pointerMove
);
parcelHelpers.export(exports, "singleClick", ()=>singleClick
);
parcelHelpers.export(exports, "doubleClick", ()=>doubleClick
);
parcelHelpers.export(exports, "noModifierKeys", ()=>noModifierKeys
);
parcelHelpers.export(exports, "platformModifierKeyOnly", ()=>platformModifierKeyOnly
);
parcelHelpers.export(exports, "shiftKeyOnly", ()=>shiftKeyOnly
);
parcelHelpers.export(exports, "targetNotEditable", ()=>targetNotEditable
);
parcelHelpers.export(exports, "mouseOnly", ()=>mouseOnly
);
parcelHelpers.export(exports, "touchOnly", ()=>touchOnly
);
parcelHelpers.export(exports, "penOnly", ()=>penOnly
);
parcelHelpers.export(exports, "primaryAction", ()=>primaryAction
);
/**
 * @module ol/events/condition
 */ var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _functionsJs = require("../functions.js");
var _hasJs = require("../has.js");
var _assertsJs = require("../asserts.js");
function all(var_args) {
    var conditions = arguments;
    /**
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @return {boolean} All conditions passed.
     */ return function(event) {
        var pass = true;
        for(var i = 0, ii = conditions.length; i < ii; ++i){
            pass = pass && conditions[i](event);
            if (!pass) break;
        }
        return pass;
    };
}
var altKeyOnly = function(mapBrowserEvent) {
    var originalEvent = mapBrowserEvent.originalEvent;
    return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var altShiftKeysOnly = function(mapBrowserEvent) {
    var originalEvent = mapBrowserEvent.originalEvent;
    return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var focus = function(event) {
    return event.target.getTargetElement().contains(document.activeElement);
};
var focusWithTabindex = function(event) {
    return event.map.getTargetElement().hasAttribute('tabindex') ? focus(event) : true;
};
var always = _functionsJs.TRUE;
var click = function(mapBrowserEvent) {
    return mapBrowserEvent.type == _mapBrowserEventTypeJsDefault.default.CLICK;
};
var mouseActionButton = function(mapBrowserEvent) {
    var originalEvent = mapBrowserEvent.originalEvent;
    return originalEvent.button == 0 && !(_hasJs.WEBKIT && _hasJs.MAC && originalEvent.ctrlKey);
};
var never = _functionsJs.FALSE;
var pointerMove = function(mapBrowserEvent) {
    return mapBrowserEvent.type == 'pointermove';
};
var singleClick = function(mapBrowserEvent) {
    return mapBrowserEvent.type == _mapBrowserEventTypeJsDefault.default.SINGLECLICK;
};
var doubleClick = function(mapBrowserEvent) {
    return mapBrowserEvent.type == _mapBrowserEventTypeJsDefault.default.DBLCLICK;
};
var noModifierKeys = function(mapBrowserEvent) {
    var originalEvent = mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var platformModifierKeyOnly = function(mapBrowserEvent) {
    var originalEvent = mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && (_hasJs.MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var shiftKeyOnly = function(mapBrowserEvent) {
    var originalEvent = mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var targetNotEditable = function(mapBrowserEvent) {
    var originalEvent = mapBrowserEvent.originalEvent;
    var tagName = /** @type {Element} */ originalEvent.target.tagName;
    return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';
};
var mouseOnly = function(mapBrowserEvent) {
    var pointerEvent = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    _assertsJs.assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvent.pointerType == 'mouse';
};
var touchOnly = function(mapBrowserEvent) {
    var pointerEvt = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    _assertsJs.assert(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvt.pointerType === 'touch';
};
var penOnly = function(mapBrowserEvent) {
    var pointerEvt = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    _assertsJs.assert(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
    return pointerEvt.pointerType === 'pen';
};
var primaryAction = function(mapBrowserEvent) {
    var pointerEvent = /** @type {import("../MapBrowserEvent").default} */ mapBrowserEvent.originalEvent;
    _assertsJs.assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
    return pointerEvent.isPrimary && pointerEvent.button === 0;
};

},{"../MapBrowserEventType.js":"coXRZ","../functions.js":"d72zA","../has.js":"cdiSc","../asserts.js":"cnrP4","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"c9bvr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/interaction/DragRotate
 */ var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _functionsJs = require("../functions.js");
var _conditionJs = require("../events/condition.js");
var _rotationconstraintJs = require("../rotationconstraint.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an
 * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */ /**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */ var DragRotate1 = function(_super) {
    __extends(DragRotate2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function DragRotate2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        _this = _super.call(this, {
            stopDown: _functionsJs.FALSE
        }) || this;
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.condition_ = options.condition ? options.condition : _conditionJs.altShiftKeysOnly;
        /**
         * @private
         * @type {number|undefined}
         */ _this.lastAngle_ = undefined;
        /**
         * @private
         * @type {number}
         */ _this.duration_ = options.duration !== undefined ? options.duration : 250;
        return _this;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */ DragRotate2.prototype.handleDragEvent = function(mapBrowserEvent) {
        if (!_conditionJs.mouseOnly(mapBrowserEvent)) return;
        var map = mapBrowserEvent.map;
        var view = map.getView();
        if (view.getConstraints().rotation === _rotationconstraintJs.disable) return;
        var size = map.getSize();
        var offset = mapBrowserEvent.pixel;
        var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
        if (this.lastAngle_ !== undefined) {
            var delta = theta - this.lastAngle_;
            view.adjustRotationInternal(-delta);
        }
        this.lastAngle_ = theta;
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */ DragRotate2.prototype.handleUpEvent = function(mapBrowserEvent) {
        if (!_conditionJs.mouseOnly(mapBrowserEvent)) return true;
        var map = mapBrowserEvent.map;
        var view = map.getView();
        view.endInteraction(this.duration_);
        return false;
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */ DragRotate2.prototype.handleDownEvent = function(mapBrowserEvent) {
        if (!_conditionJs.mouseOnly(mapBrowserEvent)) return false;
        if (_conditionJs.mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
            var map = mapBrowserEvent.map;
            map.getView().beginInteraction();
            this.lastAngle_ = undefined;
            return true;
        } else return false;
    };
    return DragRotate2;
}(_pointerJsDefault.default);
exports.default = DragRotate1;

},{"./Pointer.js":"iatpc","../functions.js":"d72zA","../events/condition.js":"eCqyb","../rotationconstraint.js":"5he2A","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3pnTn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/interaction/DragZoom
 */ var _dragBoxJs = require("./DragBox.js");
var _dragBoxJsDefault = parcelHelpers.interopDefault(_dragBoxJs);
var _easingJs = require("../easing.js");
var _conditionJs = require("../events/condition.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragzoom'] CSS class name for styling the
 * box.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
 * `boxEndCondition` function.
 */ /**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */ var DragZoom1 = function(_super) {
    __extends(DragZoom2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function DragZoom2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        var condition = options.condition ? options.condition : _conditionJs.shiftKeyOnly;
        _this = _super.call(this, {
            condition: condition,
            className: options.className || 'ol-dragzoom',
            minArea: options.minArea
        }) || this;
        /**
         * @private
         * @type {number}
         */ _this.duration_ = options.duration !== undefined ? options.duration : 200;
        /**
         * @private
         * @type {boolean}
         */ _this.out_ = options.out !== undefined ? options.out : false;
        return _this;
    }
    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     */ DragZoom2.prototype.onBoxEnd = function(event) {
        var map = this.getMap();
        var view = map.getView();
        var geometry = this.getGeometry();
        if (this.out_) {
            var rotatedExtent = view.rotatedExtentForGeometry(geometry);
            var resolution = view.getResolutionForExtentInternal(rotatedExtent);
            var factor = view.getResolution() / resolution;
            geometry = geometry.clone();
            geometry.scale(factor * factor);
        }
        view.fitInternal(geometry, {
            duration: this.duration_,
            easing: _easingJs.easeOut
        });
    };
    return DragZoom2;
}(_dragBoxJsDefault.default);
exports.default = DragZoom1;

},{"./DragBox.js":"hSIti","../easing.js":"BpZIl","../events/condition.js":"eCqyb","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hSIti":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DragBoxEvent", ()=>DragBoxEvent1
);
/**
 * @module ol/interaction/DragBox
 */ // FIXME draw drag box
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _boxJs = require("../render/Box.js");
var _boxJsDefault = parcelHelpers.interopDefault(_boxJs);
var _conditionJs = require("../events/condition.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * A function that takes a {@link module:ol/MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
 */ /**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link ol/events/condition~mouseActionButton}.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
 * `boxEndCondition` function.
 * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
 * Default is `true` if the area of the box is bigger than the `minArea` option.
 * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
 * before `boxend` is fired.
 */ /**
 * @enum {string}
 */ var DragBoxEventType = {
    /**
     * Triggered upon drag box start.
     * @event DragBoxEvent#boxstart
     * @api
     */ BOXSTART: 'boxstart',
    /**
     * Triggered on drag when box is active.
     * @event DragBoxEvent#boxdrag
     * @api
     */ BOXDRAG: 'boxdrag',
    /**
     * Triggered upon drag box end.
     * @event DragBoxEvent#boxend
     * @api
     */ BOXEND: 'boxend',
    /**
     * Triggered upon drag box canceled.
     * @event DragBoxEvent#boxcancel
     * @api
     */ BOXCANCEL: 'boxcancel'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
 * this type.
 */ var DragBoxEvent1 = function(_super) {
    __extends(DragBoxEvent2, _super);
    /**
     * @param {string} type The event type.
     * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
     */ function DragBoxEvent2(type, coordinate, mapBrowserEvent) {
        var _this = _super.call(this, type) || this;
        /**
         * The coordinate of the drag event.
         * @const
         * @type {import("../coordinate.js").Coordinate}
         * @api
         */ _this.coordinate = coordinate;
        /**
         * @const
         * @type {import("../MapBrowserEvent.js").default}
         * @api
         */ _this.mapBrowserEvent = mapBrowserEvent;
        return _this;
    }
    return DragBoxEvent2;
}(_eventJsDefault.default);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature
 */ /**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:ol/interaction/DragZoom~DragZoom} and
 * {@link module:ol/interaction/DragRotateAndZoom}).
 *
 * @fires DragBoxEvent
 * @api
 */ var DragBox1 = function(_super) {
    __extends(DragBox2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function DragBox2(opt_options) {
        var _this = _super.call(this) || this;
        /***
         * @type {DragBoxOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {DragBoxOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {DragBoxOnSignature<void>}
         */ _this.un;
        var options = opt_options ? opt_options : {
        };
        /**
         * @type {import("../render/Box.js").default}
         * @private
         */ _this.box_ = new _boxJsDefault.default(options.className || 'ol-dragbox');
        /**
         * @type {number}
         * @private
         */ _this.minArea_ = options.minArea !== undefined ? options.minArea : 64;
        if (options.onBoxEnd) _this.onBoxEnd = options.onBoxEnd;
        /**
         * @type {import("../pixel.js").Pixel}
         * @private
         */ _this.startPixel_ = null;
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.condition_ = options.condition ? options.condition : _conditionJs.mouseActionButton;
        /**
         * @private
         * @type {EndCondition}
         */ _this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _this.defaultBoxEndCondition;
        return _this;
    }
    /**
     * The default condition for determining whether the boxend event
     * should fire.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
     *     leading to the box end.
     * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
     * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
     * @return {boolean} Whether or not the boxend condition should be fired.
     */ DragBox2.prototype.defaultBoxEndCondition = function(mapBrowserEvent, startPixel, endPixel) {
        var width = endPixel[0] - startPixel[0];
        var height = endPixel[1] - startPixel[1];
        return width * width + height * height >= this.minArea_;
    };
    /**
     * Returns geometry of last drawn box.
     * @return {import("../geom/Polygon.js").default} Geometry.
     * @api
     */ DragBox2.prototype.getGeometry = function() {
        return this.box_.getGeometry();
    };
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */ DragBox2.prototype.handleDragEvent = function(mapBrowserEvent) {
        this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
        this.dispatchEvent(new DragBoxEvent1(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */ DragBox2.prototype.handleUpEvent = function(mapBrowserEvent) {
        this.box_.setMap(null);
        var completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);
        if (completeBox) this.onBoxEnd(mapBrowserEvent);
        this.dispatchEvent(new DragBoxEvent1(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
        return false;
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */ DragBox2.prototype.handleDownEvent = function(mapBrowserEvent) {
        if (this.condition_(mapBrowserEvent)) {
            this.startPixel_ = mapBrowserEvent.pixel;
            this.box_.setMap(mapBrowserEvent.map);
            this.box_.setPixels(this.startPixel_, this.startPixel_);
            this.dispatchEvent(new DragBoxEvent1(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
            return true;
        } else return false;
    };
    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     */ DragBox2.prototype.onBoxEnd = function(event) {
    };
    return DragBox2;
}(_pointerJsDefault.default);
exports.default = DragBox1;

},{"../events/Event.js":"7AR9n","./Pointer.js":"iatpc","../render/Box.js":"37tJS","../events/condition.js":"eCqyb","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"37tJS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _disposableJs = require("../Disposable.js");
var _disposableJsDefault = parcelHelpers.interopDefault(_disposableJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
/**
 * @module ol/render/Box
 */ var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var RenderBox1 = function(_super) {
    __extends(RenderBox2, _super);
    /**
     * @param {string} className CSS class name.
     */ function RenderBox2(className) {
        var _this = _super.call(this) || this;
        /**
         * @type {import("../geom/Polygon.js").default}
         * @private
         */ _this.geometry_ = null;
        /**
         * @type {HTMLDivElement}
         * @private
         */ _this.element_ = document.createElement('div');
        _this.element_.style.position = 'absolute';
        _this.element_.style.pointerEvents = 'auto';
        _this.element_.className = 'ol-box ' + className;
        /**
         * @private
         * @type {import("../PluggableMap.js").default}
         */ _this.map_ = null;
        /**
         * @private
         * @type {import("../pixel.js").Pixel}
         */ _this.startPixel_ = null;
        /**
         * @private
         * @type {import("../pixel.js").Pixel}
         */ _this.endPixel_ = null;
        return _this;
    }
    /**
     * Clean up.
     */ RenderBox2.prototype.disposeInternal = function() {
        this.setMap(null);
    };
    /**
     * @private
     */ RenderBox2.prototype.render_ = function() {
        var startPixel = this.startPixel_;
        var endPixel = this.endPixel_;
        var px = 'px';
        var style = this.element_.style;
        style.left = Math.min(startPixel[0], endPixel[0]) + px;
        style.top = Math.min(startPixel[1], endPixel[1]) + px;
        style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
        style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
    };
    /**
     * @param {import("../PluggableMap.js").default} map Map.
     */ RenderBox2.prototype.setMap = function(map) {
        if (this.map_) {
            this.map_.getOverlayContainer().removeChild(this.element_);
            var style = this.element_.style;
            style.left = 'inherit';
            style.top = 'inherit';
            style.width = 'inherit';
            style.height = 'inherit';
        }
        this.map_ = map;
        if (this.map_) this.map_.getOverlayContainer().appendChild(this.element_);
    };
    /**
     * @param {import("../pixel.js").Pixel} startPixel Start pixel.
     * @param {import("../pixel.js").Pixel} endPixel End pixel.
     */ RenderBox2.prototype.setPixels = function(startPixel, endPixel) {
        this.startPixel_ = startPixel;
        this.endPixel_ = endPixel;
        this.createOrUpdateGeometry();
        this.render_();
    };
    /**
     * Creates or updates the cached geometry.
     */ RenderBox2.prototype.createOrUpdateGeometry = function() {
        var startPixel = this.startPixel_;
        var endPixel = this.endPixel_;
        var pixels = [
            startPixel,
            [
                startPixel[0],
                endPixel[1]
            ],
            endPixel,
            [
                endPixel[0],
                startPixel[1]
            ], 
        ];
        var coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);
        // close the polygon
        coordinates[4] = coordinates[0].slice();
        if (!this.geometry_) this.geometry_ = new _polygonJsDefault.default([
            coordinates
        ]);
        else this.geometry_.setCoordinates([
            coordinates
        ]);
    };
    /**
     * @return {import("../geom/Polygon.js").default} Geometry.
     */ RenderBox2.prototype.getGeometry = function() {
        return this.geometry_;
    };
    return RenderBox2;
}(_disposableJsDefault.default);
exports.default = RenderBox1;

},{"../Disposable.js":"b72Yc","../geom/Polygon.js":"hoOc8","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5egeF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/interaction/KeyboardPan
 */ var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _keyCodeJs = require("../events/KeyCode.js");
var _keyCodeJsDefault = parcelHelpers.interopDefault(_keyCodeJs);
var _conditionJs = require("../events/condition.js");
var _coordinateJs = require("../coordinate.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.noModifierKeys} and
 * {@link module:ol/events/condition.targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */ /**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */ var KeyboardPan1 = function(_super) {
    __extends(KeyboardPan2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function KeyboardPan2(opt_options) {
        var _this = _super.call(this) || this;
        var options = opt_options || {
        };
        /**
         * @private
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
         * @return {boolean} Combined condition result.
         */ _this.defaultCondition_ = function(mapBrowserEvent) {
            return _conditionJs.noModifierKeys(mapBrowserEvent) && _conditionJs.targetNotEditable(mapBrowserEvent);
        };
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.condition_ = options.condition !== undefined ? options.condition : _this.defaultCondition_;
        /**
         * @private
         * @type {number}
         */ _this.duration_ = options.duration !== undefined ? options.duration : 100;
        /**
         * @private
         * @type {number}
         */ _this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;
        return _this;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides the direction to pan to (if an arrow key was
     * pressed).
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @this {KeyboardPan}
     */ KeyboardPan2.prototype.handleEvent = function(mapBrowserEvent) {
        var stopEvent = false;
        if (mapBrowserEvent.type == _eventTypeJsDefault.default.KEYDOWN) {
            var keyEvent = mapBrowserEvent.originalEvent;
            var keyCode = keyEvent.keyCode;
            if (this.condition_(mapBrowserEvent) && (keyCode == _keyCodeJsDefault.default.DOWN || keyCode == _keyCodeJsDefault.default.LEFT || keyCode == _keyCodeJsDefault.default.RIGHT || keyCode == _keyCodeJsDefault.default.UP)) {
                var map = mapBrowserEvent.map;
                var view = map.getView();
                var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
                var deltaX = 0, deltaY = 0;
                if (keyCode == _keyCodeJsDefault.default.DOWN) deltaY = -mapUnitsDelta;
                else if (keyCode == _keyCodeJsDefault.default.LEFT) deltaX = -mapUnitsDelta;
                else if (keyCode == _keyCodeJsDefault.default.RIGHT) deltaX = mapUnitsDelta;
                else deltaY = mapUnitsDelta;
                var delta = [
                    deltaX,
                    deltaY
                ];
                _coordinateJs.rotate(delta, view.getRotation());
                _interactionJs.pan(view, delta, this.duration_);
                keyEvent.preventDefault();
                stopEvent = true;
            }
        }
        return !stopEvent;
    };
    return KeyboardPan2;
}(_interactionJsDefault.default);
exports.default = KeyboardPan1;

},{"../events/EventType.js":"83vee","./Interaction.js":"dRzfo","../events/KeyCode.js":"dRk72","../events/condition.js":"eCqyb","../coordinate.js":"cmApa","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"dRk72":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aicI4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/interaction/KeyboardZoom
 */ var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _conditionJs = require("../events/condition.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.targetNotEditable}.
 * @property {number} [delta=1] The zoom level delta on each key press.
 */ /**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */ var KeyboardZoom1 = function(_super) {
    __extends(KeyboardZoom2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function KeyboardZoom2(opt_options) {
        var _this = _super.call(this) || this;
        var options = opt_options ? opt_options : {
        };
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.condition_ = options.condition ? options.condition : _conditionJs.targetNotEditable;
        /**
         * @private
         * @type {number}
         */ _this.delta_ = options.delta ? options.delta : 1;
        /**
         * @private
         * @type {number}
         */ _this.duration_ = options.duration !== undefined ? options.duration : 100;
        return _this;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
     * key pressed was '+' or '-').
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @this {KeyboardZoom}
     */ KeyboardZoom2.prototype.handleEvent = function(mapBrowserEvent) {
        var stopEvent = false;
        if (mapBrowserEvent.type == _eventTypeJsDefault.default.KEYDOWN || mapBrowserEvent.type == _eventTypeJsDefault.default.KEYPRESS) {
            var keyEvent = mapBrowserEvent.originalEvent;
            var charCode = keyEvent.charCode;
            if (this.condition_(mapBrowserEvent) && (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
                var map = mapBrowserEvent.map;
                var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;
                var view = map.getView();
                _interactionJs.zoomByDelta(view, delta, undefined, this.duration_);
                keyEvent.preventDefault();
                stopEvent = true;
            }
        }
        return !stopEvent;
    };
    return KeyboardZoom2;
}(_interactionJsDefault.default);
exports.default = KeyboardZoom1;

},{"../events/EventType.js":"83vee","./Interaction.js":"dRzfo","../events/condition.js":"eCqyb","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"aUIXw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/Kinetic
 */ /**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */ var Kinetic = function() {
    /**
     * @param {number} decay Rate of decay (must be negative).
     * @param {number} minVelocity Minimum velocity (pixels/millisecond).
     * @param {number} delay Delay to consider to calculate the kinetic
     *     initial values (milliseconds).
     */ function Kinetic1(decay, minVelocity, delay) {
        /**
         * @private
         * @type {number}
         */ this.decay_ = decay;
        /**
         * @private
         * @type {number}
         */ this.minVelocity_ = minVelocity;
        /**
         * @private
         * @type {number}
         */ this.delay_ = delay;
        /**
         * @private
         * @type {Array<number>}
         */ this.points_ = [];
        /**
         * @private
         * @type {number}
         */ this.angle_ = 0;
        /**
         * @private
         * @type {number}
         */ this.initialVelocity_ = 0;
    }
    /**
     * FIXME empty description for jsdoc
     */ Kinetic1.prototype.begin = function() {
        this.points_.length = 0;
        this.angle_ = 0;
        this.initialVelocity_ = 0;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     */ Kinetic1.prototype.update = function(x, y) {
        this.points_.push(x, y, Date.now());
    };
    /**
     * @return {boolean} Whether we should do kinetic animation.
     */ Kinetic1.prototype.end = function() {
        if (this.points_.length < 6) // at least 2 points are required (i.e. there must be at least 6 elements
        // in the array)
        return false;
        var delay = Date.now() - this.delay_;
        var lastIndex = this.points_.length - 3;
        if (this.points_[lastIndex + 2] < delay) // the last tracked point is too old, which means that the user stopped
        // panning before releasing the map
        return false;
        // get the first point which still falls into the delay time
        var firstIndex = lastIndex - 3;
        while(firstIndex > 0 && this.points_[firstIndex + 2] > delay)firstIndex -= 3;
        var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
        // we don't want a duration of 0 (divide by zero)
        // we also make sure the user panned for a duration of at least one frame
        // (1/60s) to compute sane displacement values
        if (duration < 1000 / 60) return false;
        var dx = this.points_[lastIndex] - this.points_[firstIndex];
        var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
        this.angle_ = Math.atan2(dy, dx);
        this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
        return this.initialVelocity_ > this.minVelocity_;
    };
    /**
     * @return {number} Total distance travelled (pixels).
     */ Kinetic1.prototype.getDistance = function() {
        return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
    };
    /**
     * @return {number} Angle of the kinetic panning animation (radians).
     */ Kinetic1.prototype.getAngle = function() {
        return this.angle_;
    };
    return Kinetic1;
}();
exports.default = Kinetic;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1x9fR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Mode", ()=>Mode
);
/**
 * @module ol/interaction/MouseWheelZoom
 */ var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _hasJs = require("../has.js");
var _conditionJs = require("../events/condition.js");
var _mathJs = require("../math.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var Mode = {
    TRACKPAD: 'trackpad',
    WHEEL: 'wheel'
};
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition.always}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {number} [maxDelta=1] Maximum mouse wheel delta.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
 * event will always animate to the closest zoom level after an interaction;
 * false means intermediary zoom levels are allowed.
 */ /**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */ var MouseWheelZoom1 = function(_super) {
    __extends(MouseWheelZoom2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function MouseWheelZoom2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        _this = _super.call(this, options) || this;
        /**
         * @private
         * @type {number}
         */ _this.totalDelta_ = 0;
        /**
         * @private
         * @type {number}
         */ _this.lastDelta_ = 0;
        /**
         * @private
         * @type {number}
         */ _this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;
        /**
         * @private
         * @type {number}
         */ _this.duration_ = options.duration !== undefined ? options.duration : 250;
        /**
         * @private
         * @type {number}
         */ _this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
        /**
         * @private
         * @type {boolean}
         */ _this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;
        /**
         * @private
         * @type {boolean}
         */ _this.constrainResolution_ = options.constrainResolution !== undefined ? options.constrainResolution : false;
        var condition = options.condition ? options.condition : _conditionJs.always;
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.condition_ = options.onFocusOnly ? _conditionJs.all(_conditionJs.focusWithTabindex, condition) : condition;
        /**
         * @private
         * @type {?import("../coordinate.js").Coordinate}
         */ _this.lastAnchor_ = null;
        /**
         * @private
         * @type {number|undefined}
         */ _this.startTime_ = undefined;
        /**
         * @private
         * @type {?}
         */ _this.timeoutId_;
        /**
         * @private
         * @type {Mode|undefined}
         */ _this.mode_ = undefined;
        /**
         * Trackpad events separated by this delay will be considered separate
         * interactions.
         * @type {number}
         */ _this.trackpadEventGap_ = 400;
        /**
         * @type {?}
         */ _this.trackpadTimeoutId_;
        /**
         * The number of delta values per zoom level
         * @private
         * @type {number}
         */ _this.deltaPerZoom_ = 300;
        return _this;
    }
    /**
     * @private
     */ MouseWheelZoom2.prototype.endInteraction_ = function() {
        this.trackpadTimeoutId_ = undefined;
        var view = this.getMap().getView();
        view.endInteraction(undefined, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
    };
    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
     * zooms the map.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     */ MouseWheelZoom2.prototype.handleEvent = function(mapBrowserEvent) {
        if (!this.condition_(mapBrowserEvent)) return true;
        var type = mapBrowserEvent.type;
        if (type !== _eventTypeJsDefault.default.WHEEL) return true;
        var map = mapBrowserEvent.map;
        var wheelEvent = mapBrowserEvent.originalEvent;
        wheelEvent.preventDefault();
        if (this.useAnchor_) this.lastAnchor_ = mapBrowserEvent.coordinate;
        // Delta normalisation inspired by
        // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
        var delta;
        if (mapBrowserEvent.type == _eventTypeJsDefault.default.WHEEL) {
            delta = wheelEvent.deltaY;
            if (_hasJs.FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) delta /= _hasJs.DEVICE_PIXEL_RATIO;
            if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) delta *= 40;
        }
        if (delta === 0) return false;
        else this.lastDelta_ = delta;
        var now = Date.now();
        if (this.startTime_ === undefined) this.startTime_ = now;
        if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) this.mode_ = Math.abs(delta) < 4 ? Mode.TRACKPAD : Mode.WHEEL;
        var view = map.getView();
        if (this.mode_ === Mode.TRACKPAD && !(view.getConstrainResolution() || this.constrainResolution_)) {
            if (this.trackpadTimeoutId_) clearTimeout(this.trackpadTimeoutId_);
            else {
                if (view.getAnimating()) view.cancelAnimations();
                view.beginInteraction();
            }
            this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
            view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
            this.startTime_ = now;
            return false;
        }
        this.totalDelta_ += delta;
        var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
        clearTimeout(this.timeoutId_);
        this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
        return false;
    };
    /**
     * @private
     * @param {import("../PluggableMap.js").default} map Map.
     */ MouseWheelZoom2.prototype.handleWheelZoom_ = function(map) {
        var view = map.getView();
        if (view.getAnimating()) view.cancelAnimations();
        var delta = -_mathJs.clamp(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
        if (view.getConstrainResolution() || this.constrainResolution_) // view has a zoom constraint, zoom by 1
        delta = delta ? delta > 0 ? 1 : -1 : 0;
        _interactionJs.zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
        this.mode_ = undefined;
        this.totalDelta_ = 0;
        this.lastAnchor_ = null;
        this.startTime_ = undefined;
        this.timeoutId_ = undefined;
    };
    /**
     * Enable or disable using the mouse's location as an anchor when zooming
     * @param {boolean} useAnchor true to zoom to the mouse's location, false
     * to zoom to the center of the map
     * @api
     */ MouseWheelZoom2.prototype.setMouseAnchor = function(useAnchor) {
        this.useAnchor_ = useAnchor;
        if (!useAnchor) this.lastAnchor_ = null;
    };
    return MouseWheelZoom2;
}(_interactionJsDefault.default);
exports.default = MouseWheelZoom1;

},{"../events/EventType.js":"83vee","./Interaction.js":"dRzfo","../has.js":"cdiSc","../events/condition.js":"eCqyb","../math.js":"kI4rE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7uL1t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/interaction/PinchRotate
 */ var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _functionsJs = require("../functions.js");
var _rotationconstraintJs = require("../rotationconstraint.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */ /**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */ var PinchRotate1 = function(_super) {
    __extends(PinchRotate2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function PinchRotate2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        var pointerOptions = options;
        if (!pointerOptions.stopDown) pointerOptions.stopDown = _functionsJs.FALSE;
        _this = _super.call(this, pointerOptions) || this;
        /**
         * @private
         * @type {import("../coordinate.js").Coordinate}
         */ _this.anchor_ = null;
        /**
         * @private
         * @type {number|undefined}
         */ _this.lastAngle_ = undefined;
        /**
         * @private
         * @type {boolean}
         */ _this.rotating_ = false;
        /**
         * @private
         * @type {number}
         */ _this.rotationDelta_ = 0;
        /**
         * @private
         * @type {number}
         */ _this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
        /**
         * @private
         * @type {number}
         */ _this.duration_ = options.duration !== undefined ? options.duration : 250;
        return _this;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */ PinchRotate2.prototype.handleDragEvent = function(mapBrowserEvent) {
        var rotationDelta = 0;
        var touch0 = this.targetPointers[0];
        var touch1 = this.targetPointers[1];
        // angle between touches
        var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
        if (this.lastAngle_ !== undefined) {
            var delta = angle - this.lastAngle_;
            this.rotationDelta_ += delta;
            if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) this.rotating_ = true;
            rotationDelta = delta;
        }
        this.lastAngle_ = angle;
        var map = mapBrowserEvent.map;
        var view = map.getView();
        if (view.getConstraints().rotation === _rotationconstraintJs.disable) return;
        // rotate anchor point.
        // FIXME: should be the intersection point between the lines:
        //     touch0,touch1 and previousTouch0,previousTouch1
        var viewportPosition = map.getViewport().getBoundingClientRect();
        var centroid = _pointerJs.centroid(this.targetPointers);
        centroid[0] -= viewportPosition.left;
        centroid[1] -= viewportPosition.top;
        this.anchor_ = map.getCoordinateFromPixelInternal(centroid);
        // rotate
        if (this.rotating_) {
            map.render();
            view.adjustRotationInternal(rotationDelta, this.anchor_);
        }
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */ PinchRotate2.prototype.handleUpEvent = function(mapBrowserEvent) {
        if (this.targetPointers.length < 2) {
            var map = mapBrowserEvent.map;
            var view = map.getView();
            view.endInteraction(this.duration_);
            return false;
        } else return true;
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */ PinchRotate2.prototype.handleDownEvent = function(mapBrowserEvent) {
        if (this.targetPointers.length >= 2) {
            var map = mapBrowserEvent.map;
            this.anchor_ = null;
            this.lastAngle_ = undefined;
            this.rotating_ = false;
            this.rotationDelta_ = 0;
            if (!this.handlingDownUpSequence) map.getView().beginInteraction();
            return true;
        } else return false;
    };
    return PinchRotate2;
}(_pointerJsDefault.default);
exports.default = PinchRotate1;

},{"./Pointer.js":"iatpc","../functions.js":"d72zA","../rotationconstraint.js":"5he2A","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"adA2u":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/interaction/PinchZoom
 */ var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _functionsJs = require("../functions.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 */ /**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */ var PinchZoom1 = function(_super) {
    __extends(PinchZoom2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function PinchZoom2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        var pointerOptions = options;
        if (!pointerOptions.stopDown) pointerOptions.stopDown = _functionsJs.FALSE;
        _this = _super.call(this, pointerOptions) || this;
        /**
         * @private
         * @type {import("../coordinate.js").Coordinate}
         */ _this.anchor_ = null;
        /**
         * @private
         * @type {number}
         */ _this.duration_ = options.duration !== undefined ? options.duration : 400;
        /**
         * @private
         * @type {number|undefined}
         */ _this.lastDistance_ = undefined;
        /**
         * @private
         * @type {number}
         */ _this.lastScaleDelta_ = 1;
        return _this;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */ PinchZoom2.prototype.handleDragEvent = function(mapBrowserEvent) {
        var scaleDelta = 1;
        var touch0 = this.targetPointers[0];
        var touch1 = this.targetPointers[1];
        var dx = touch0.clientX - touch1.clientX;
        var dy = touch0.clientY - touch1.clientY;
        // distance between touches
        var distance = Math.sqrt(dx * dx + dy * dy);
        if (this.lastDistance_ !== undefined) scaleDelta = this.lastDistance_ / distance;
        this.lastDistance_ = distance;
        var map = mapBrowserEvent.map;
        var view = map.getView();
        if (scaleDelta != 1) this.lastScaleDelta_ = scaleDelta;
        // scale anchor point.
        var viewportPosition = map.getViewport().getBoundingClientRect();
        var centroid = _pointerJs.centroid(this.targetPointers);
        centroid[0] -= viewportPosition.left;
        centroid[1] -= viewportPosition.top;
        this.anchor_ = map.getCoordinateFromPixelInternal(centroid);
        // scale, bypass the resolution constraint
        map.render();
        view.adjustResolutionInternal(scaleDelta, this.anchor_);
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */ PinchZoom2.prototype.handleUpEvent = function(mapBrowserEvent) {
        if (this.targetPointers.length < 2) {
            var map = mapBrowserEvent.map;
            var view = map.getView();
            var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
            view.endInteraction(this.duration_, direction);
            return false;
        } else return true;
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */ PinchZoom2.prototype.handleDownEvent = function(mapBrowserEvent) {
        if (this.targetPointers.length >= 2) {
            var map = mapBrowserEvent.map;
            this.anchor_ = null;
            this.lastDistance_ = undefined;
            this.lastScaleDelta_ = 1;
            if (!this.handlingDownUpSequence) map.getView().beginInteraction();
            return true;
        } else return false;
    };
    return PinchZoom2;
}(_pointerJsDefault.default);
exports.default = PinchZoom1;

},{"./Pointer.js":"iatpc","../functions.js":"d72zA","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"h1Dmo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DragAndDropEvent", ()=>DragAndDropEvent1
);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _formatTypeJs = require("../format/FormatType.js");
var _formatTypeJsDefault = parcelHelpers.interopDefault(_formatTypeJs);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _functionsJs = require("../functions.js");
var _projJs = require("../proj.js");
var _eventsJs = require("../events.js");
/**
 * @module ol/interaction/DragAndDrop
 */ // FIXME should handle all geo-referenced data, not just vector data
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {Array<typeof import("../format/Feature.js").default|import("../format/Feature.js").default>} [formatConstructors] Format constructors
 * (and/or formats pre-constructed with options).
 * @property {import("../source/Vector.js").default} [source] Optional vector source where features will be added.  If a source is provided
 * all existing features will be removed and new features will be added when
 * they are dropped on the target.  If you want to add features to a vector
 * source without removing the existing features (append only), instead of
 * providing the source option listen for the "addfeatures" event.
 * @property {import("../proj.js").ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.
 * @property {HTMLElement} [target] The element that is used as the drop target, default is the viewport element.
 */ /**
 * @enum {string}
 */ var DragAndDropEventType = {
    /**
     * Triggered when features are added
     * @event DragAndDropEvent#addfeatures
     * @api
     */ ADD_FEATURES: 'addfeatures'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances
 * of this type.
 */ var DragAndDropEvent1 = function(_super) {
    __extends(DragAndDropEvent2, _super);
    /**
     * @param {DragAndDropEventType} type Type.
     * @param {File} file File.
     * @param {Array<import("../Feature.js").default>} [opt_features] Features.
     * @param {import("../proj/Projection.js").default} [opt_projection] Projection.
     */ function DragAndDropEvent2(type, file, opt_features, opt_projection) {
        var _this = _super.call(this, type) || this;
        /**
         * The features parsed from dropped data.
         * @type {Array<import("../Feature.js").FeatureLike>|undefined}
         * @api
         */ _this.features = opt_features;
        /**
         * The dropped file.
         * @type {File}
         * @api
         */ _this.file = file;
        /**
         * The feature projection.
         * @type {import("../proj/Projection.js").default|undefined}
         * @api
         */ _this.projection = opt_projection;
        return _this;
    }
    return DragAndDropEvent2;
}(_eventJsDefault.default);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'addfeatures', DragAndDropEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'addfeatures', Return>} DragAndDropOnSignature
 */ /**
 * @classdesc
 * Handles input of vector data by drag and drop.
 *
 * Note that the DragAndDrop interaction uses the TextDecoder() constructor if the supplied
 * combinnation of formats read both text string and ArrayBuffer sources. Older browsers such
 * as IE which do not support this will need a TextDecoder polyfill to be loaded before use.
 *
 * @api
 *
 * @fires DragAndDropEvent
 */ var DragAndDrop1 = function(_super) {
    __extends(DragAndDrop2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function DragAndDrop2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        _this = _super.call(this, {
            handleEvent: _functionsJs.TRUE
        }) || this;
        /***
         * @type {DragAndDropOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {DragAndDropOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {DragAndDropOnSignature<void>}
         */ _this.un;
        /**
         * @private
         * @type {boolean}
         */ _this.readAsBuffer_ = false;
        /**
         * @private
         * @type {Array<import("../format/Feature.js").default>}
         */ _this.formats_ = [];
        var formatConstructors = options.formatConstructors ? options.formatConstructors : [];
        for(var i = 0, ii = formatConstructors.length; i < ii; ++i){
            var format = formatConstructors[i];
            if (typeof format === 'function') format = new format();
            _this.formats_.push(format);
            _this.readAsBuffer_ = _this.readAsBuffer_ || format.getType() === _formatTypeJsDefault.default.ARRAY_BUFFER;
        }
        /**
         * @private
         * @type {import("../proj/Projection.js").default}
         */ _this.projection_ = options.projection ? _projJs.get(options.projection) : null;
        /**
         * @private
         * @type {?Array<import("../events.js").EventsKey>}
         */ _this.dropListenKeys_ = null;
        /**
         * @private
         * @type {import("../source/Vector.js").default}
         */ _this.source_ = options.source || null;
        /**
         * @private
         * @type {HTMLElement}
         */ _this.target = options.target ? options.target : null;
        return _this;
    }
    /**
     * @param {File} file File.
     * @param {Event} event Load event.
     * @private
     */ DragAndDrop2.prototype.handleResult_ = function(file, event) {
        var result = event.target.result;
        var map = this.getMap();
        var projection = this.projection_;
        if (!projection) {
            var view = map.getView();
            projection = view.getProjection();
        }
        var text;
        var formats = this.formats_;
        for(var i = 0, ii = formats.length; i < ii; ++i){
            var format = formats[i];
            var input = result;
            if (this.readAsBuffer_ && format.getType() !== _formatTypeJsDefault.default.ARRAY_BUFFER) {
                if (text === undefined) text = new TextDecoder().decode(result);
                input = text;
            }
            var features = this.tryReadFeatures_(format, input, {
                featureProjection: projection
            });
            if (features && features.length > 0) {
                if (this.source_) {
                    this.source_.clear();
                    this.source_.addFeatures(features);
                }
                this.dispatchEvent(new DragAndDropEvent1(DragAndDropEventType.ADD_FEATURES, file, features, projection));
                break;
            }
        }
    };
    /**
     * @private
     */ DragAndDrop2.prototype.registerListeners_ = function() {
        var map = this.getMap();
        if (map) {
            var dropArea = this.target ? this.target : map.getViewport();
            this.dropListenKeys_ = [
                _eventsJs.listen(dropArea, _eventTypeJsDefault.default.DROP, this.handleDrop, this),
                _eventsJs.listen(dropArea, _eventTypeJsDefault.default.DRAGENTER, this.handleStop, this),
                _eventsJs.listen(dropArea, _eventTypeJsDefault.default.DRAGOVER, this.handleStop, this),
                _eventsJs.listen(dropArea, _eventTypeJsDefault.default.DROP, this.handleStop, this), 
            ];
        }
    };
    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     */ DragAndDrop2.prototype.setActive = function(active) {
        if (!this.getActive() && active) this.registerListeners_();
        if (this.getActive() && !active) this.unregisterListeners_();
        _super.prototype.setActive.call(this, active);
    };
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default} map Map.
     */ DragAndDrop2.prototype.setMap = function(map) {
        this.unregisterListeners_();
        _super.prototype.setMap.call(this, map);
        if (this.getActive()) this.registerListeners_();
    };
    /**
     * @param {import("../format/Feature.js").default} format Format.
     * @param {string} text Text.
     * @param {import("../format/Feature.js").ReadOptions} options Read options.
     * @private
     * @return {Array<import("../Feature.js").default>} Features.
     */ DragAndDrop2.prototype.tryReadFeatures_ = function(format, text, options) {
        try {
            return format.readFeatures(text, options);
        } catch (e) {
            return null;
        }
    };
    /**
     * @private
     */ DragAndDrop2.prototype.unregisterListeners_ = function() {
        if (this.dropListenKeys_) {
            this.dropListenKeys_.forEach(_eventsJs.unlistenByKey);
            this.dropListenKeys_ = null;
        }
    };
    /**
     * @param {DragEvent} event Event.
     */ DragAndDrop2.prototype.handleDrop = function(event) {
        var files = event.dataTransfer.files;
        for(var i = 0, ii = files.length; i < ii; ++i){
            var file = files.item(i);
            var reader = new FileReader();
            reader.addEventListener(_eventTypeJsDefault.default.LOAD, this.handleResult_.bind(this, file));
            if (this.readAsBuffer_) reader.readAsArrayBuffer(file);
            else reader.readAsText(file);
        }
    };
    /**
     * @param {DragEvent} event Event.
     */ DragAndDrop2.prototype.handleStop = function(event) {
        event.stopPropagation();
        event.preventDefault();
        event.dataTransfer.dropEffect = 'copy';
    };
    return DragAndDrop2;
}(_interactionJsDefault.default);
exports.default = DragAndDrop1;

},{"../events/Event.js":"7AR9n","../events/EventType.js":"83vee","../format/FormatType.js":"eKyoL","./Interaction.js":"dRzfo","../functions.js":"d72zA","../proj.js":"hmdWM","../events.js":"e9Qqr","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"eKyoL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    ARRAY_BUFFER: 'arraybuffer',
    JSON: 'json',
    TEXT: 'text',
    XML: 'xml'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"erzzu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/interaction/DragRotateAndZoom
 */ var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _conditionJs = require("../events/condition.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.shiftKeyOnly}.
 * @property {number} [duration=400] Animation duration in milliseconds.
 */ /**
 * @classdesc
 * Allows the user to zoom and rotate the map by clicking and dragging
 * on the map.  By default, this interaction is limited to when the shift
 * key is held down.
 *
 * This interaction is only supported for mouse devices.
 *
 * And this interaction is not included in the default interactions.
 * @api
 */ var DragRotateAndZoom1 = function(_super) {
    __extends(DragRotateAndZoom2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function DragRotateAndZoom2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        _this = _super.call(this, options) || this;
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.condition_ = options.condition ? options.condition : _conditionJs.shiftKeyOnly;
        /**
         * @private
         * @type {number|undefined}
         */ _this.lastAngle_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */ _this.lastMagnitude_ = undefined;
        /**
         * @private
         * @type {number}
         */ _this.lastScaleDelta_ = 0;
        /**
         * @private
         * @type {number}
         */ _this.duration_ = options.duration !== undefined ? options.duration : 400;
        return _this;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */ DragRotateAndZoom2.prototype.handleDragEvent = function(mapBrowserEvent) {
        if (!_conditionJs.mouseOnly(mapBrowserEvent)) return;
        var map = mapBrowserEvent.map;
        var size = map.getSize();
        var offset = mapBrowserEvent.pixel;
        var deltaX = offset[0] - size[0] / 2;
        var deltaY = size[1] / 2 - offset[1];
        var theta = Math.atan2(deltaY, deltaX);
        var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        var view = map.getView();
        if (this.lastAngle_ !== undefined) {
            var angleDelta = this.lastAngle_ - theta;
            view.adjustRotationInternal(angleDelta);
        }
        this.lastAngle_ = theta;
        if (this.lastMagnitude_ !== undefined) view.adjustResolutionInternal(this.lastMagnitude_ / magnitude);
        if (this.lastMagnitude_ !== undefined) this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
        this.lastMagnitude_ = magnitude;
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */ DragRotateAndZoom2.prototype.handleUpEvent = function(mapBrowserEvent) {
        if (!_conditionJs.mouseOnly(mapBrowserEvent)) return true;
        var map = mapBrowserEvent.map;
        var view = map.getView();
        var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
        view.endInteraction(this.duration_, direction);
        this.lastScaleDelta_ = 0;
        return false;
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */ DragRotateAndZoom2.prototype.handleDownEvent = function(mapBrowserEvent) {
        if (!_conditionJs.mouseOnly(mapBrowserEvent)) return false;
        if (this.condition_(mapBrowserEvent)) {
            mapBrowserEvent.map.getView().beginInteraction();
            this.lastAngle_ = undefined;
            this.lastMagnitude_ = undefined;
            return true;
        } else return false;
    };
    return DragRotateAndZoom2;
}(_pointerJsDefault.default);
exports.default = DragRotateAndZoom1;

},{"./Pointer.js":"iatpc","../events/condition.js":"eCqyb","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1tafX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DrawEvent", ()=>DrawEvent1
);
/**
 * Create a `geometryFunction` for `type: 'Circle'` that will create a regular
 * polygon with a user specified number of sides and start angle instead of a
 * `import("../geom/Circle.js").Circle` geometry.
 * @param {number} [opt_sides] Number of sides of the regular polygon.
 *     Default is 32.
 * @param {number} [opt_angle] Angle of the first point in counter-clockwise
 *     radians. 0 means East.
 *     Default is the angle defined by the heading from the center of the
 *     regular polygon to the current pointer position.
 * @return {GeometryFunction} Function that draws a polygon.
 * @api
 */ parcelHelpers.export(exports, "createRegularPolygon", ()=>createRegularPolygon
);
/**
 * Create a `geometryFunction` that will create a box-shaped polygon (aligned
 * with the coordinate system axes).  Use this with the draw interaction and
 * `type: 'Circle'` to return a box instead of a circle geometry.
 * @return {GeometryFunction} Function that draws a box-shaped polygon.
 * @api
 */ parcelHelpers.export(exports, "createBox", ()=>createBox
);
/**
 * @module ol/interaction/Draw
 */ var _circleJs = require("../geom/Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _geometryTypeJs = require("../geom/GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _lineStringJs = require("../geom/LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _mapBrowserEventJs = require("../MapBrowserEvent.js");
var _mapBrowserEventJsDefault = parcelHelpers.interopDefault(_mapBrowserEventJs);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _multiLineStringJs = require("../geom/MultiLineString.js");
var _multiLineStringJsDefault = parcelHelpers.interopDefault(_multiLineStringJs);
var _multiPointJs = require("../geom/MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _multiPolygonJs = require("../geom/MultiPolygon.js");
var _multiPolygonJsDefault = parcelHelpers.interopDefault(_multiPolygonJs);
var _pointJs = require("../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _polygonJs = require("../geom/Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _vectorJs = require("../layer/Vector.js");
var _vectorJsDefault = parcelHelpers.interopDefault(_vectorJs);
var _vectorJs1 = require("../source/Vector.js");
var _vectorJsDefault1 = parcelHelpers.interopDefault(_vectorJs1);
var _functionsJs = require("../functions.js");
var _conditionJs = require("../events/condition.js");
var _extentJs = require("../extent.js");
var _styleJs = require("../style/Style.js");
var _projJs = require("../proj.js");
var _coordinateJs = require("../coordinate.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {import("../geom/GeometryType.js").default} type Geometry type of
 * the geometries being drawn with this instance.
 * @property {number} [clickTolerance=6] The maximum distance in pixels between
 * "down" and "up" for a "up" event to be considered a "click" event and
 * actually add a point/vertex to the geometry being drawn.  The default of `6`
 * was chosen for the draw interaction to behave correctly on mouse as well as
 * on touch devices.
 * @property {import("../Collection.js").default<Feature>} [features]
 * Destination collection for the drawn features.
 * @property {VectorSource} [source] Destination source for
 * the drawn features.
 * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
 * before the current vertex can be dragged to its exact position.
 * @property {number} [snapTolerance=12] Pixel distance for snapping to the
 * drawing finish. Must be greater than `0`.
 * @property {boolean} [stopClick=false] Stop click, singleclick, and
 * doubleclick events from firing during drawing.
 * @property {number} [maxPoints] The number of points that can be drawn before
 * a polygon ring or line string is finished. By default there is no
 * restriction.
 * @property {number} [minPoints] The number of points that must be drawn
 * before a polygon ring or line string can be finished. Default is `3` for
 * polygon rings and `2` for line strings.
 * @property {import("../events/condition.js").Condition} [finishCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether the drawing can be finished. Not used when drawing
 * POINT or MULTI_POINT geometries.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style for sketch features.
 * @property {GeometryFunction} [geometryFunction]
 * Function that is called when a geometry's coordinates are updated.
 * @property {string} [geometryName] Geometry name to use for features created
 * by the draw interaction.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default {@link module:ol/events/condition.noModifierKeys}, i.e. a click,
 * adds a vertex or deactivates freehand drawing.
 * @property {boolean} [freehand=false] Operate in freehand mode for lines,
 * polygons, and circles.  This makes the interaction always operate in freehand
 * mode and takes precedence over any `freehandCondition` option.
 * @property {import("../events/condition.js").Condition} [freehandCondition]
 * Condition that activates freehand drawing for lines and polygons. This
 * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether that event should be handled. The
 * default is {@link module:ol/events/condition.shiftKeyOnly}, meaning that the
 * Shift key activates freehand drawing.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 */ /**
 * Coordinate type when drawing points.
 * @typedef {import("../coordinate.js").Coordinate} PointCoordType
 */ /**
 * Coordinate type when drawing lines.
 * @typedef {Array<import("../coordinate.js").Coordinate>} LineCoordType
 */ /**
 * Coordinate type when drawing polygons.
 * @typedef {Array<Array<import("../coordinate.js").Coordinate>>} PolyCoordType
 */ /**
 * Types used for drawing coordinates.
 * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType
 */ /**
 * Function that takes an array of coordinates and an optional existing geometry
 * and a projection as arguments, and returns a geometry. The optional existing
 * geometry is the geometry that is returned when the function is called without
 * a second argument.
 * @typedef {function(!SketchCoordType, import("../geom/SimpleGeometry.js").default,
 *     import("../proj/Projection.js").default):
 *     import("../geom/SimpleGeometry.js").default} GeometryFunction
 */ /**
 * Draw mode.  This collapses multi-part geometry types with their single-part
 * cousins.
 * @enum {string}
 */ var Mode = {
    POINT: 'Point',
    LINE_STRING: 'LineString',
    POLYGON: 'Polygon',
    CIRCLE: 'Circle'
};
/**
 * @enum {string}
 */ var DrawEventType = {
    /**
     * Triggered upon feature draw start
     * @event DrawEvent#drawstart
     * @api
     */ DRAWSTART: 'drawstart',
    /**
     * Triggered upon feature draw end
     * @event DrawEvent#drawend
     * @api
     */ DRAWEND: 'drawend',
    /**
     * Triggered upon feature draw abortion
     * @event DrawEvent#drawabort
     * @api
     */ DRAWABORT: 'drawabort'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are
 * instances of this type.
 */ var DrawEvent1 = function(_super) {
    __extends(DrawEvent2, _super);
    /**
     * @param {DrawEventType} type Type.
     * @param {Feature} feature The feature drawn.
     */ function DrawEvent2(type, feature) {
        var _this = _super.call(this, type) || this;
        /**
         * The feature being drawn.
         * @type {Feature}
         * @api
         */ _this.feature = feature;
        return _this;
    }
    return DrawEvent2;
}(_eventJsDefault.default);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'drawabort'|'drawend'|'drawstart', DrawEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'drawabort'|'drawend'|'drawstart', Return>} DrawOnSignature
 */ /**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @fires DrawEvent
 * @api
 */ var Draw1 = function(_super) {
    __extends(Draw2, _super);
    /**
     * @param {Options} options Options.
     */ function Draw2(options) {
        var _this = this;
        var pointerOptions = options;
        if (!pointerOptions.stopDown) pointerOptions.stopDown = _functionsJs.FALSE;
        _this = _super.call(this, pointerOptions) || this;
        /***
         * @type {DrawOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {DrawOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {DrawOnSignature<void>}
         */ _this.un;
        /**
         * @type {boolean}
         * @private
         */ _this.shouldHandle_ = false;
        /**
         * @type {import("../pixel.js").Pixel}
         * @private
         */ _this.downPx_ = null;
        /**
         * @type {?}
         * @private
         */ _this.downTimeout_;
        /**
         * @type {number|undefined}
         * @private
         */ _this.lastDragTime_;
        /**
         * Pointer type of the last pointermove event
         * @type {string}
         * @private
         */ _this.pointerType_;
        /**
         * @type {boolean}
         * @private
         */ _this.freehand_ = false;
        /**
         * Target source for drawn features.
         * @type {VectorSource}
         * @private
         */ _this.source_ = options.source ? options.source : null;
        /**
         * Target collection for drawn features.
         * @type {import("../Collection.js").default<Feature>}
         * @private
         */ _this.features_ = options.features ? options.features : null;
        /**
         * Pixel distance for snapping.
         * @type {number}
         * @private
         */ _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;
        /**
         * Geometry type.
         * @type {import("../geom/GeometryType.js").default}
         * @private
         */ _this.type_ = options.type;
        /**
         * Drawing mode (derived from geometry type.
         * @type {Mode}
         * @private
         */ _this.mode_ = getMode(_this.type_);
        /**
         * Stop click, singleclick, and doubleclick events from firing during drawing.
         * Default is `false`.
         * @type {boolean}
         * @private
         */ _this.stopClick_ = !!options.stopClick;
        /**
         * The number of points that must be drawn before a polygon ring or line
         * string can be finished.  The default is 3 for polygon rings and 2 for
         * line strings.
         * @type {number}
         * @private
         */ _this.minPoints_ = options.minPoints ? options.minPoints : _this.mode_ === Mode.POLYGON ? 3 : 2;
        /**
         * The number of points that can be drawn before a polygon ring or line string
         * is finished. The default is no restriction.
         * @type {number}
         * @private
         */ _this.maxPoints_ = _this.mode_ === Mode.CIRCLE ? 2 : options.maxPoints ? options.maxPoints : Infinity;
        /**
         * A function to decide if a potential finish coordinate is permissible
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.finishCondition_ = options.finishCondition ? options.finishCondition : _functionsJs.TRUE;
        var geometryFunction = options.geometryFunction;
        if (!geometryFunction) {
            var mode_1 = _this.mode_;
            if (mode_1 === Mode.CIRCLE) /**
                 * @param {!LineCoordType} coordinates The coordinates.
                 * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
                 * @param {import("../proj/Projection.js").default} projection The view projection.
                 * @return {import("../geom/SimpleGeometry.js").default} A geometry.
                 */ geometryFunction = function(coordinates, geometry, projection) {
                var circle = geometry ? geometry : new _circleJsDefault.default([
                    NaN,
                    NaN
                ]);
                var center = _projJs.fromUserCoordinate(coordinates[0], projection);
                var squaredLength = _coordinateJs.squaredDistance(center, _projJs.fromUserCoordinate(coordinates[coordinates.length - 1], projection));
                circle.setCenterAndRadius(center, Math.sqrt(squaredLength));
                var userProjection = _projJs.getUserProjection();
                if (userProjection) circle.transform(projection, userProjection);
                return circle;
            };
            else {
                var Constructor_1;
                if (mode_1 === Mode.POINT) Constructor_1 = _pointJsDefault.default;
                else if (mode_1 === Mode.LINE_STRING) Constructor_1 = _lineStringJsDefault.default;
                else if (mode_1 === Mode.POLYGON) Constructor_1 = _polygonJsDefault.default;
                /**
                 * @param {!LineCoordType} coordinates The coordinates.
                 * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
                 * @param {import("../proj/Projection.js").default} projection The view projection.
                 * @return {import("../geom/SimpleGeometry.js").default} A geometry.
                 */ geometryFunction = function(coordinates, geometry, projection) {
                    if (geometry) {
                        if (mode_1 === Mode.POLYGON) {
                            if (coordinates[0].length) // Add a closing coordinate to match the first
                            geometry.setCoordinates([
                                coordinates[0].concat([
                                    coordinates[0][0]
                                ]), 
                            ]);
                            else geometry.setCoordinates([]);
                        } else geometry.setCoordinates(coordinates);
                    } else geometry = new Constructor_1(coordinates);
                    return geometry;
                };
            }
        }
        /**
         * @type {GeometryFunction}
         * @private
         */ _this.geometryFunction_ = geometryFunction;
        /**
         * @type {number}
         * @private
         */ _this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;
        /**
         * Finish coordinate for the feature (first point for polygons, last point for
         * linestrings).
         * @type {import("../coordinate.js").Coordinate}
         * @private
         */ _this.finishCoordinate_ = null;
        /**
         * Sketch feature.
         * @type {Feature}
         * @private
         */ _this.sketchFeature_ = null;
        /**
         * Sketch point.
         * @type {Feature<Point>}
         * @private
         */ _this.sketchPoint_ = null;
        /**
         * Sketch coordinates. Used when drawing a line or polygon.
         * @type {SketchCoordType}
         * @private
         */ _this.sketchCoords_ = null;
        /**
         * Sketch line. Used when drawing polygon.
         * @type {Feature<LineString>}
         * @private
         */ _this.sketchLine_ = null;
        /**
         * Sketch line coordinates. Used when drawing a polygon or circle.
         * @type {LineCoordType}
         * @private
         */ _this.sketchLineCoords_ = null;
        /**
         * Squared tolerance for handling up events.  If the squared distance
         * between a down and up event is greater than this tolerance, up events
         * will not be handled.
         * @type {number}
         * @private
         */ _this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;
        /**
         * Draw overlay where our sketch features are drawn.
         * @type {VectorLayer}
         * @private
         */ _this.overlay_ = new _vectorJsDefault.default({
            source: new _vectorJsDefault1.default({
                useSpatialIndex: false,
                wrapX: options.wrapX ? options.wrapX : false
            }),
            style: options.style ? options.style : getDefaultStyleFunction(),
            updateWhileInteracting: true
        });
        /**
         * Name of the geometry attribute for newly created features.
         * @type {string|undefined}
         * @private
         */ _this.geometryName_ = options.geometryName;
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.condition_ = options.condition ? options.condition : _conditionJs.noModifierKeys;
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.freehandCondition_;
        if (options.freehand) _this.freehandCondition_ = _conditionJs.always;
        else _this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : _conditionJs.shiftKeyOnly;
        _this.addChangeListener(_propertyJsDefault.default.ACTIVE, _this.updateState_);
        return _this;
    }
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default} map Map.
     */ Draw2.prototype.setMap = function(map) {
        _super.prototype.setMap.call(this, map);
        this.updateState_();
    };
    /**
     * Get the overlay layer that this interaction renders sketch features to.
     * @return {VectorLayer} Overlay layer.
     * @api
     */ Draw2.prototype.getOverlay = function() {
        return this.overlay_;
    };
    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually draw or finish the drawing.
     * @param {import("../MapBrowserEvent.js").default} event Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */ Draw2.prototype.handleEvent = function(event) {
        if (event.originalEvent.type === _eventTypeJsDefault.default.CONTEXTMENU) // Avoid context menu for long taps when drawing on mobile
        event.originalEvent.preventDefault();
        this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);
        var move = event.type === _mapBrowserEventTypeJsDefault.default.POINTERMOVE;
        var pass = true;
        if (!this.freehand_ && this.lastDragTime_ && event.type === _mapBrowserEventTypeJsDefault.default.POINTERDRAG) {
            var now = Date.now();
            if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
                this.downPx_ = event.pixel;
                this.shouldHandle_ = !this.freehand_;
                move = true;
            } else this.lastDragTime_ = undefined;
            if (this.shouldHandle_ && this.downTimeout_ !== undefined) {
                clearTimeout(this.downTimeout_);
                this.downTimeout_ = undefined;
            }
        }
        if (this.freehand_ && event.type === _mapBrowserEventTypeJsDefault.default.POINTERDRAG && this.sketchFeature_ !== null) {
            this.addToDrawing_(event.coordinate);
            pass = false;
        } else if (this.freehand_ && event.type === _mapBrowserEventTypeJsDefault.default.POINTERDOWN) pass = false;
        else if (move && this.getPointerCount() < 2) {
            pass = event.type === _mapBrowserEventTypeJsDefault.default.POINTERMOVE;
            if (pass && this.freehand_) {
                this.handlePointerMove_(event);
                if (this.shouldHandle_) // Avoid page scrolling when freehand drawing on mobile
                event.originalEvent.preventDefault();
            } else if (event.originalEvent.pointerType === 'mouse' || event.type === _mapBrowserEventTypeJsDefault.default.POINTERDRAG && this.downTimeout_ === undefined) this.handlePointerMove_(event);
        } else if (event.type === _mapBrowserEventTypeJsDefault.default.DBLCLICK) pass = false;
        return _super.prototype.handleEvent.call(this, event) && pass;
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @return {boolean} If the event was consumed.
     */ Draw2.prototype.handleDownEvent = function(event) {
        this.shouldHandle_ = !this.freehand_;
        if (this.freehand_) {
            this.downPx_ = event.pixel;
            if (!this.finishCoordinate_) this.startDrawing_(event.coordinate);
            return true;
        } else if (this.condition_(event)) {
            this.lastDragTime_ = Date.now();
            this.downTimeout_ = setTimeout((function() {
                this.handlePointerMove_(new _mapBrowserEventJsDefault.default(_mapBrowserEventTypeJsDefault.default.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));
            }).bind(this), this.dragVertexDelay_);
            this.downPx_ = event.pixel;
            return true;
        } else {
            this.lastDragTime_ = undefined;
            return false;
        }
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @return {boolean} If the event was consumed.
     */ Draw2.prototype.handleUpEvent = function(event) {
        var pass = true;
        if (this.getPointerCount() === 0) {
            if (this.downTimeout_) {
                clearTimeout(this.downTimeout_);
                this.downTimeout_ = undefined;
            }
            this.handlePointerMove_(event);
            if (this.shouldHandle_) {
                var startingToDraw = !this.finishCoordinate_;
                if (startingToDraw) this.startDrawing_(event.coordinate);
                if (!startingToDraw && this.freehand_) this.finishDrawing();
                else if (!this.freehand_ && (!startingToDraw || this.mode_ === Mode.POINT)) {
                    if (this.atFinish_(event.pixel)) {
                        if (this.finishCondition_(event)) this.finishDrawing();
                    } else this.addToDrawing_(event.coordinate);
                }
                pass = false;
            } else if (this.freehand_) this.abortDrawing();
        }
        if (!pass && this.stopClick_) event.preventDefault();
        return pass;
    };
    /**
     * Handle move events.
     * @param {import("../MapBrowserEvent.js").default} event A move event.
     * @private
     */ Draw2.prototype.handlePointerMove_ = function(event) {
        this.pointerType_ = event.originalEvent.pointerType;
        if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
            var downPx = this.downPx_;
            var clickPx = event.pixel;
            var dx = downPx[0] - clickPx[0];
            var dy = downPx[1] - clickPx[1];
            var squaredDistance = dx * dx + dy * dy;
            this.shouldHandle_ = this.freehand_ ? squaredDistance > this.squaredClickTolerance_ : squaredDistance <= this.squaredClickTolerance_;
            if (!this.shouldHandle_) return;
        }
        if (this.finishCoordinate_) this.modifyDrawing_(event.coordinate);
        else this.createOrUpdateSketchPoint_(event.coordinate.slice());
    };
    /**
     * Determine if an event is within the snapping tolerance of the start coord.
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {boolean} The event is within the snapping tolerance of the start.
     * @private
     */ Draw2.prototype.atFinish_ = function(pixel) {
        var at = false;
        if (this.sketchFeature_) {
            var potentiallyDone = false;
            var potentiallyFinishCoordinates = [
                this.finishCoordinate_
            ];
            var mode = this.mode_;
            if (mode === Mode.POINT) at = true;
            else if (mode === Mode.CIRCLE) at = this.sketchCoords_.length === 2;
            else if (mode === Mode.LINE_STRING) potentiallyDone = this.sketchCoords_.length > this.minPoints_;
            else if (mode === Mode.POLYGON) {
                var sketchCoords = this.sketchCoords_;
                potentiallyDone = sketchCoords[0].length > this.minPoints_;
                potentiallyFinishCoordinates = [
                    sketchCoords[0][0],
                    sketchCoords[0][sketchCoords[0].length - 2], 
                ];
            }
            if (potentiallyDone) {
                var map = this.getMap();
                for(var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++){
                    var finishCoordinate = potentiallyFinishCoordinates[i];
                    var finishPixel = map.getPixelFromCoordinate(finishCoordinate);
                    var dx = pixel[0] - finishPixel[0];
                    var dy = pixel[1] - finishPixel[1];
                    var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
                    at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
                    if (at) {
                        this.finishCoordinate_ = finishCoordinate;
                        break;
                    }
                }
            }
        }
        return at;
    };
    /**
     * @param {import("../coordinate").Coordinate} coordinates Coordinate.
     * @private
     */ Draw2.prototype.createOrUpdateSketchPoint_ = function(coordinates) {
        if (!this.sketchPoint_) {
            this.sketchPoint_ = new _featureJsDefault.default(new _pointJsDefault.default(coordinates));
            this.updateSketchFeatures_();
        } else {
            var sketchPointGeom = this.sketchPoint_.getGeometry();
            sketchPointGeom.setCoordinates(coordinates);
        }
    };
    /**
     * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
     * @private
     */ Draw2.prototype.createOrUpdateCustomSketchLine_ = function(geometry) {
        if (!this.sketchLine_) this.sketchLine_ = new _featureJsDefault.default();
        var ring = geometry.getLinearRing(0);
        var sketchLineGeom = this.sketchLine_.getGeometry();
        if (!sketchLineGeom) {
            sketchLineGeom = new _lineStringJsDefault.default(ring.getFlatCoordinates(), ring.getLayout());
            this.sketchLine_.setGeometry(sketchLineGeom);
        } else {
            sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());
            sketchLineGeom.changed();
        }
    };
    /**
     * Start the drawing.
     * @param {import("../coordinate.js").Coordinate} start Start coordinate.
     * @private
     */ Draw2.prototype.startDrawing_ = function(start) {
        var projection = this.getMap().getView().getProjection();
        this.finishCoordinate_ = start;
        if (this.mode_ === Mode.POINT) this.sketchCoords_ = start.slice();
        else if (this.mode_ === Mode.POLYGON) {
            this.sketchCoords_ = [
                [
                    start.slice(),
                    start.slice()
                ]
            ];
            this.sketchLineCoords_ = this.sketchCoords_[0];
        } else this.sketchCoords_ = [
            start.slice(),
            start.slice()
        ];
        if (this.sketchLineCoords_) this.sketchLine_ = new _featureJsDefault.default(new _lineStringJsDefault.default(this.sketchLineCoords_));
        var geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);
        this.sketchFeature_ = new _featureJsDefault.default();
        if (this.geometryName_) this.sketchFeature_.setGeometryName(this.geometryName_);
        this.sketchFeature_.setGeometry(geometry);
        this.updateSketchFeatures_();
        this.dispatchEvent(new DrawEvent1(DrawEventType.DRAWSTART, this.sketchFeature_));
    };
    /**
     * Modify the drawing.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @private
     */ Draw2.prototype.modifyDrawing_ = function(coordinate) {
        var map = this.getMap();
        var geometry = this.sketchFeature_.getGeometry();
        var projection = map.getView().getProjection();
        var coordinates, last;
        if (this.mode_ === Mode.POINT) last = this.sketchCoords_;
        else if (this.mode_ === Mode.POLYGON) {
            coordinates = /** @type {PolyCoordType} */ this.sketchCoords_[0];
            last = coordinates[coordinates.length - 1];
            if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) // snap to finish
            coordinate = this.finishCoordinate_.slice();
        } else {
            coordinates = this.sketchCoords_;
            last = coordinates[coordinates.length - 1];
        }
        last[0] = coordinate[0];
        last[1] = coordinate[1];
        this.geometryFunction_(this.sketchCoords_, geometry, projection);
        if (this.sketchPoint_) {
            var sketchPointGeom = this.sketchPoint_.getGeometry();
            sketchPointGeom.setCoordinates(coordinate);
        }
        if (geometry.getType() === _geometryTypeJsDefault.default.POLYGON && this.mode_ !== Mode.POLYGON) this.createOrUpdateCustomSketchLine_(geometry);
        else if (this.sketchLineCoords_) {
            var sketchLineGeom = this.sketchLine_.getGeometry();
            sketchLineGeom.setCoordinates(this.sketchLineCoords_);
        }
        this.updateSketchFeatures_();
    };
    /**
     * Add a new coordinate to the drawing.
     * @param {!PointCoordType} coordinate Coordinate
     * @private
     */ Draw2.prototype.addToDrawing_ = function(coordinate) {
        var geometry = this.sketchFeature_.getGeometry();
        var projection = this.getMap().getView().getProjection();
        var done;
        var coordinates;
        var mode = this.mode_;
        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {
            this.finishCoordinate_ = coordinate.slice();
            coordinates = this.sketchCoords_;
            if (coordinates.length >= this.maxPoints_) {
                if (this.freehand_) coordinates.pop();
                else done = true;
            }
            coordinates.push(coordinate.slice());
            this.geometryFunction_(coordinates, geometry, projection);
        } else if (mode === Mode.POLYGON) {
            coordinates = /** @type {PolyCoordType} */ this.sketchCoords_[0];
            if (coordinates.length >= this.maxPoints_) {
                if (this.freehand_) coordinates.pop();
                else done = true;
            }
            coordinates.push(coordinate.slice());
            if (done) this.finishCoordinate_ = coordinates[0];
            this.geometryFunction_(this.sketchCoords_, geometry, projection);
        }
        this.createOrUpdateSketchPoint_(coordinate.slice());
        this.updateSketchFeatures_();
        if (done) this.finishDrawing();
    };
    /**
     * Remove last point of the feature currently being drawn. Does not do anything when
     * drawing POINT or MULTI_POINT geometries.
     * @api
     */ Draw2.prototype.removeLastPoint = function() {
        if (!this.sketchFeature_) return;
        var geometry = this.sketchFeature_.getGeometry();
        var projection = this.getMap().getView().getProjection();
        var coordinates;
        var mode = this.mode_;
        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {
            coordinates = this.sketchCoords_;
            coordinates.splice(-2, 1);
            if (coordinates.length >= 2) {
                this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
                var finishCoordinate = this.finishCoordinate_.slice();
                coordinates[coordinates.length - 1] = finishCoordinate;
                this.createOrUpdateSketchPoint_(finishCoordinate);
            }
            this.geometryFunction_(coordinates, geometry, projection);
            if (geometry.getType() === _geometryTypeJsDefault.default.POLYGON && this.sketchLine_) this.createOrUpdateCustomSketchLine_(geometry);
        } else if (mode === Mode.POLYGON) {
            coordinates = /** @type {PolyCoordType} */ this.sketchCoords_[0];
            coordinates.splice(-2, 1);
            var sketchLineGeom = this.sketchLine_.getGeometry();
            if (coordinates.length >= 2) {
                var finishCoordinate = coordinates[coordinates.length - 2].slice();
                coordinates[coordinates.length - 1] = finishCoordinate;
                this.createOrUpdateSketchPoint_(finishCoordinate);
            }
            sketchLineGeom.setCoordinates(coordinates);
            this.geometryFunction_(this.sketchCoords_, geometry, projection);
        }
        if (coordinates.length === 1) this.abortDrawing();
        this.updateSketchFeatures_();
    };
    /**
     * Stop drawing and add the sketch feature to the target layer.
     * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
     * dispatched before inserting the feature.
     * @api
     */ Draw2.prototype.finishDrawing = function() {
        var sketchFeature = this.abortDrawing_();
        if (!sketchFeature) return;
        var coordinates = this.sketchCoords_;
        var geometry = sketchFeature.getGeometry();
        var projection = this.getMap().getView().getProjection();
        if (this.mode_ === Mode.LINE_STRING) {
            // remove the redundant last point
            coordinates.pop();
            this.geometryFunction_(coordinates, geometry, projection);
        } else if (this.mode_ === Mode.POLYGON) {
            // remove the redundant last point in ring
            /** @type {PolyCoordType} */ coordinates[0].pop();
            this.geometryFunction_(coordinates, geometry, projection);
            coordinates = geometry.getCoordinates();
        }
        // cast multi-part geometries
        if (this.type_ === _geometryTypeJsDefault.default.MULTI_POINT) sketchFeature.setGeometry(new _multiPointJsDefault.default([
            coordinates
        ]));
        else if (this.type_ === _geometryTypeJsDefault.default.MULTI_LINE_STRING) sketchFeature.setGeometry(new _multiLineStringJsDefault.default([
            coordinates
        ]));
        else if (this.type_ === _geometryTypeJsDefault.default.MULTI_POLYGON) sketchFeature.setGeometry(new _multiPolygonJsDefault.default([
            coordinates
        ]));
        // First dispatch event to allow full set up of feature
        this.dispatchEvent(new DrawEvent1(DrawEventType.DRAWEND, sketchFeature));
        // Then insert feature
        if (this.features_) this.features_.push(sketchFeature);
        if (this.source_) this.source_.addFeature(sketchFeature);
    };
    /**
     * Stop drawing without adding the sketch feature to the target layer.
     * @return {Feature} The sketch feature (or null if none).
     * @private
     */ Draw2.prototype.abortDrawing_ = function() {
        this.finishCoordinate_ = null;
        var sketchFeature = this.sketchFeature_;
        this.sketchFeature_ = null;
        this.sketchPoint_ = null;
        this.sketchLine_ = null;
        this.overlay_.getSource().clear(true);
        return sketchFeature;
    };
    /**
     * Stop drawing without adding the sketch feature to the target layer.
     * @api
     */ Draw2.prototype.abortDrawing = function() {
        var sketchFeature = this.abortDrawing_();
        if (sketchFeature) this.dispatchEvent(new DrawEvent1(DrawEventType.DRAWABORT, sketchFeature));
    };
    /**
     * Append coordinates to the end of the geometry that is currently being drawn.
     * This can be used when drawing LineStrings or Polygons. Coordinates will
     * either be appended to the current LineString or the outer ring of the current
     * Polygon. If no geometry is being drawn, a new one will be created.
     * @param {!LineCoordType} coordinates Linear coordinates to be appended to
     * the coordinate array.
     * @api
     */ Draw2.prototype.appendCoordinates = function(coordinates) {
        var mode = this.mode_;
        var newDrawing = !this.sketchFeature_;
        if (newDrawing) this.startDrawing_(coordinates[0]);
        /** @type {LineCoordType} */ var sketchCoords;
        if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) sketchCoords = this.sketchCoords_;
        else if (mode === Mode.POLYGON) sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ? /** @type {PolyCoordType} */ this.sketchCoords_[0] : [];
        else return;
        if (newDrawing) sketchCoords.shift();
        // Remove last coordinate from sketch drawing (this coordinate follows cursor position)
        sketchCoords.pop();
        // Append coordinate list
        for(var i = 0; i < coordinates.length; i++)this.addToDrawing_(coordinates[i]);
        var ending = coordinates[coordinates.length - 1];
        // Duplicate last coordinate for sketch drawing (cursor position)
        this.addToDrawing_(ending);
        this.modifyDrawing_(ending);
    };
    /**
     * Initiate draw mode by starting from an existing geometry which will
     * receive new additional points. This only works on features with
     * `LineString` geometries, where the interaction will extend lines by adding
     * points to the end of the coordinates array.
     * This will change the original feature, instead of drawing a copy.
     *
     * The function will dispatch a `drawstart` event.
     *
     * @param {!Feature<LineString>} feature Feature to be extended.
     * @api
     */ Draw2.prototype.extend = function(feature) {
        var geometry = feature.getGeometry();
        var lineString = geometry;
        this.sketchFeature_ = feature;
        this.sketchCoords_ = lineString.getCoordinates();
        var last = this.sketchCoords_[this.sketchCoords_.length - 1];
        this.finishCoordinate_ = last.slice();
        this.sketchCoords_.push(last.slice());
        this.sketchPoint_ = new _featureJsDefault.default(new _pointJsDefault.default(last));
        this.updateSketchFeatures_();
        this.dispatchEvent(new DrawEvent1(DrawEventType.DRAWSTART, this.sketchFeature_));
    };
    /**
     * Redraw the sketch features.
     * @private
     */ Draw2.prototype.updateSketchFeatures_ = function() {
        var sketchFeatures = [];
        if (this.sketchFeature_) sketchFeatures.push(this.sketchFeature_);
        if (this.sketchLine_) sketchFeatures.push(this.sketchLine_);
        if (this.sketchPoint_) sketchFeatures.push(this.sketchPoint_);
        var overlaySource = this.overlay_.getSource();
        overlaySource.clear(true);
        overlaySource.addFeatures(sketchFeatures);
    };
    /**
     * @private
     */ Draw2.prototype.updateState_ = function() {
        var map = this.getMap();
        var active = this.getActive();
        if (!map || !active) this.abortDrawing();
        this.overlay_.setMap(active ? map : null);
    };
    return Draw2;
}(_pointerJsDefault.default);
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */ function getDefaultStyleFunction() {
    var styles = _styleJs.createEditingStyle();
    return function(feature, resolution) {
        return styles[feature.getGeometry().getType()];
    };
}
function createRegularPolygon(opt_sides, opt_angle) {
    return function(coordinates, opt_geometry, projection) {
        var center = _projJs.fromUserCoordinate(/** @type {LineCoordType} */ coordinates[0], projection);
        var end = _projJs.fromUserCoordinate(/** @type {LineCoordType} */ coordinates[coordinates.length - 1], projection);
        var radius = Math.sqrt(_coordinateJs.squaredDistance(center, end));
        var geometry = opt_geometry ? opt_geometry : _polygonJs.fromCircle(new _circleJsDefault.default(center), opt_sides);
        var angle = opt_angle;
        if (!opt_angle && opt_angle !== 0) {
            var x = end[0] - center[0];
            var y = end[1] - center[1];
            angle = Math.atan2(y, x);
        }
        _polygonJs.makeRegular(geometry, center, radius, angle);
        var userProjection = _projJs.getUserProjection();
        if (userProjection) geometry.transform(projection, userProjection);
        return geometry;
    };
}
function createBox() {
    return function(coordinates, opt_geometry, projection) {
        var extent = _extentJs.boundingExtent(/** @type {LineCoordType} */ [
            coordinates[0],
            coordinates[coordinates.length - 1], 
        ].map(function(coordinate) {
            return _projJs.fromUserCoordinate(coordinate, projection);
        }));
        var boxCoordinates = [
            [
                _extentJs.getBottomLeft(extent),
                _extentJs.getBottomRight(extent),
                _extentJs.getTopRight(extent),
                _extentJs.getTopLeft(extent),
                _extentJs.getBottomLeft(extent), 
            ], 
        ];
        var geometry = opt_geometry;
        if (geometry) geometry.setCoordinates(boxCoordinates);
        else geometry = new _polygonJsDefault.default(boxCoordinates);
        var userProjection = _projJs.getUserProjection();
        if (userProjection) geometry.transform(projection, userProjection);
        return geometry;
    };
}
/**
 * Get the drawing mode.  The mode for multi-part geometries is the same as for
 * their single-part cousins.
 * @param {import("../geom/GeometryType.js").default} type Geometry type.
 * @return {Mode} Drawing mode.
 */ function getMode(type) {
    switch(type){
        case _geometryTypeJsDefault.default.POINT:
        case _geometryTypeJsDefault.default.MULTI_POINT:
            return Mode.POINT;
        case _geometryTypeJsDefault.default.LINE_STRING:
        case _geometryTypeJsDefault.default.MULTI_LINE_STRING:
            return Mode.LINE_STRING;
        case _geometryTypeJsDefault.default.POLYGON:
        case _geometryTypeJsDefault.default.MULTI_POLYGON:
            return Mode.POLYGON;
        case _geometryTypeJsDefault.default.CIRCLE:
            return Mode.CIRCLE;
        default:
            throw new Error('Invalid type: ' + type);
    }
}
exports.default = Draw1;

},{"../geom/Circle.js":"5VeNM","../events/Event.js":"7AR9n","../events/EventType.js":"83vee","../Feature.js":"75Tk1","../geom/GeometryType.js":"3sRlw","./Property.js":"jZl7a","../geom/LineString.js":"bDy7p","../MapBrowserEvent.js":"8kc32","../MapBrowserEventType.js":"coXRZ","../geom/MultiLineString.js":"jGlXO","../geom/MultiPoint.js":"jM6r0","../geom/MultiPolygon.js":"gSTwq","../geom/Point.js":"4ReTD","./Pointer.js":"iatpc","../geom/Polygon.js":"hoOc8","../layer/Vector.js":"2qjJV","../source/Vector.js":"lTwzQ","../functions.js":"d72zA","../events/condition.js":"eCqyb","../extent.js":"jgUz2","../style/Style.js":"9N9zp","../proj.js":"hmdWM","../coordinate.js":"cmApa","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5VeNM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/Circle
 */ var _geometryTypeJs = require("./GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _transformJs = require("./flat/transform.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * Circle geometry.
 *
 * @api
 */ var Circle1 = function(_super) {
    __extends(Circle2, _super);
    /**
     * @param {!import("../coordinate.js").Coordinate} center Center.
     *     For internal use, flat coordinates in combination with `opt_layout` and no
     *     `opt_radius` are also accepted.
     * @param {number} [opt_radius] Radius.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     */ function Circle2(center, opt_radius, opt_layout) {
        var _this = _super.call(this) || this;
        if (opt_layout !== undefined && opt_radius === undefined) _this.setFlatCoordinates(opt_layout, center);
        else {
            var radius = opt_radius ? opt_radius : 0;
            _this.setCenterAndRadius(center, radius, opt_layout);
        }
        return _this;
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Circle} Clone.
     * @api
     */ Circle2.prototype.clone = function() {
        var circle = new Circle2(this.flatCoordinates.slice(), undefined, this.layout);
        circle.applyProperties(this);
        return circle;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */ Circle2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
        var flatCoordinates = this.flatCoordinates;
        var dx = x - flatCoordinates[0];
        var dy = y - flatCoordinates[1];
        var squaredDistance = dx * dx + dy * dy;
        if (squaredDistance < minSquaredDistance) {
            if (squaredDistance === 0) for(var i = 0; i < this.stride; ++i)closestPoint[i] = flatCoordinates[i];
            else {
                var delta = this.getRadius() / Math.sqrt(squaredDistance);
                closestPoint[0] = flatCoordinates[0] + delta * dx;
                closestPoint[1] = flatCoordinates[1] + delta * dy;
                for(var i = 2; i < this.stride; ++i)closestPoint[i] = flatCoordinates[i];
            }
            closestPoint.length = this.stride;
            return squaredDistance;
        } else return minSquaredDistance;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */ Circle2.prototype.containsXY = function(x, y) {
        var flatCoordinates = this.flatCoordinates;
        var dx = x - flatCoordinates[0];
        var dy = y - flatCoordinates[1];
        return dx * dx + dy * dy <= this.getRadiusSquared_();
    };
    /**
     * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
     * @return {import("../coordinate.js").Coordinate} Center.
     * @api
     */ Circle2.prototype.getCenter = function() {
        return this.flatCoordinates.slice(0, this.stride);
    };
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */ Circle2.prototype.computeExtent = function(extent) {
        var flatCoordinates = this.flatCoordinates;
        var radius = flatCoordinates[this.stride] - flatCoordinates[0];
        return _extentJs.createOrUpdate(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);
    };
    /**
     * Return the radius of the circle.
     * @return {number} Radius.
     * @api
     */ Circle2.prototype.getRadius = function() {
        return Math.sqrt(this.getRadiusSquared_());
    };
    /**
     * @private
     * @return {number} Radius squared.
     */ Circle2.prototype.getRadiusSquared_ = function() {
        var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
        var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
        return dx * dx + dy * dy;
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */ Circle2.prototype.getType = function() {
        return _geometryTypeJsDefault.default.CIRCLE;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */ Circle2.prototype.intersectsExtent = function(extent) {
        var circleExtent = this.getExtent();
        if (_extentJs.intersects(extent, circleExtent)) {
            var center = this.getCenter();
            if (extent[0] <= center[0] && extent[2] >= center[0]) return true;
            if (extent[1] <= center[1] && extent[3] >= center[1]) return true;
            return _extentJs.forEachCorner(extent, this.intersectsCoordinate.bind(this));
        }
        return false;
    };
    /**
     * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} center Center.
     * @api
     */ Circle2.prototype.setCenter = function(center) {
        var stride = this.stride;
        var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
        var flatCoordinates = center.slice();
        flatCoordinates[stride] = flatCoordinates[0] + radius;
        for(var i = 1; i < stride; ++i)flatCoordinates[stride + i] = center[i];
        this.setFlatCoordinates(this.layout, flatCoordinates);
        this.changed();
    };
    /**
     * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
     * number) of the circle.
     * @param {!import("../coordinate.js").Coordinate} center Center.
     * @param {number} radius Radius.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @api
     */ Circle2.prototype.setCenterAndRadius = function(center, radius, opt_layout) {
        this.setLayout(opt_layout, center, 0);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        /** @type {Array<number>} */ var flatCoordinates = this.flatCoordinates;
        var offset = _deflateJs.deflateCoordinate(flatCoordinates, 0, center, this.stride);
        flatCoordinates[offset++] = flatCoordinates[0] + radius;
        for(var i = 1, ii = this.stride; i < ii; ++i)flatCoordinates[offset++] = flatCoordinates[i];
        flatCoordinates.length = offset;
        this.changed();
    };
    Circle2.prototype.getCoordinates = function() {
        return null;
    };
    Circle2.prototype.setCoordinates = function(coordinates, opt_layout) {
    };
    /**
     * Set the radius of the circle. The radius is in the units of the projection.
     * @param {number} radius Radius.
     * @api
     */ Circle2.prototype.setRadius = function(radius) {
        this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
        this.changed();
    };
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in counter-clockwise radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */ Circle2.prototype.rotate = function(angle, anchor) {
        var center = this.getCenter();
        var stride = this.getStride();
        this.setCenter(_transformJs.rotate(center, 0, center.length, stride, angle, anchor, center));
        this.changed();
    };
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */ Circle2.prototype.translate = function(deltaX, deltaY) {
        var center = this.getCenter();
        var stride = this.getStride();
        this.setCenter(_transformJs.translate(center, 0, center.length, stride, deltaX, deltaY, center));
        this.changed();
    };
    return Circle2;
}(_simpleGeometryJsDefault.default);
/**
 * Transform each coordinate of the circle from one coordinate reference system
 * to another. The geometry is modified in place.
 * If you do not want the geometry modified in place, first clone() it and
 * then use this function on the clone.
 *
 * Internally a circle is currently represented by two points: the center of
 * the circle `[cx, cy]`, and the point to the right of the circle
 * `[cx + r, cy]`. This `transform` function just transforms these two points.
 * So the resulting geometry is also a circle, and that circle does not
 * correspond to the shape that would be obtained by transforming every point
 * of the original circle.
 *
 * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @return {Circle} This geometry.  Note that original geometry is
 *     modified in place.
 * @function
 * @api
 */ Circle1.prototype.transform;
exports.default = Circle1;

},{"./GeometryType.js":"3sRlw","./SimpleGeometry.js":"4jyQo","../extent.js":"jgUz2","./flat/deflate.js":"gFAia","./flat/transform.js":"eZ5a1","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"75Tk1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of Style or single style objects wrapped
 * in a new feature style function.
 * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {import("./style/Style.js").StyleFunction} A style function.
 */ parcelHelpers.export(exports, "createStyleFunction", ()=>createStyleFunction
);
/**
 * @module ol/Feature
 */ var _objectJs = require("./Object.js");
var _objectJsDefault = parcelHelpers.interopDefault(_objectJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _assertsJs = require("./asserts.js");
var _eventsJs = require("./events.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */ /**
 * @typedef {Feature<import("./geom/Geometry.js").default>|import("./render/Feature.js").default} FeatureLike
 */ /***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:geometry', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types
 *     |'change:geometry', Return>} FeatureOnSignature
 */ /***
 * @template Geometry
 * @typedef {Object<string, *> & { geometry?: Geometry }} ObjectWithGeometry
 */ /**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature';
 * import Polygon from 'ol/geom/Polygon';
 * import Point from 'ol/geom/Point';
 *
 * var feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon'
 * });
 *
 * // get the polygon geometry
 * var poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * var point = feature.getGeometry();
 * ```
 *
 * @api
 * @template {import("./geom/Geometry.js").default} Geometry
 */ var Feature1 = function(_super) {
    __extends(Feature2, _super);
    /**
     * @param {Geometry|ObjectWithGeometry<Geometry>} [opt_geometryOrProperties]
     *     You may pass a Geometry object directly, or an object literal containing
     *     properties. If you pass an object literal, you may include a Geometry
     *     associated with a `geometry` key.
     */ function Feature2(opt_geometryOrProperties) {
        var _this = _super.call(this) || this;
        /***
         * @type {FeatureOnSignature<import("./events").EventsKey>}
         */ _this.on;
        /***
         * @type {FeatureOnSignature<import("./events").EventsKey>}
         */ _this.once;
        /***
         * @type {FeatureOnSignature<void>}
         */ _this.un;
        /**
         * @private
         * @type {number|string|undefined}
         */ _this.id_ = undefined;
        /**
         * @type {string}
         * @private
         */ _this.geometryName_ = 'geometry';
        /**
         * User provided style.
         * @private
         * @type {import("./style/Style.js").StyleLike}
         */ _this.style_ = null;
        /**
         * @private
         * @type {import("./style/Style.js").StyleFunction|undefined}
         */ _this.styleFunction_ = undefined;
        /**
         * @private
         * @type {?import("./events.js").EventsKey}
         */ _this.geometryChangeKey_ = null;
        _this.addChangeListener(_this.geometryName_, _this.handleGeometryChanged_);
        if (opt_geometryOrProperties) {
            if (typeof /** @type {?} */ opt_geometryOrProperties.getSimplifiedGeometry === 'function') {
                var geometry = opt_geometryOrProperties;
                _this.setGeometry(geometry);
            } else {
                /** @type {Object<string, *>} */ var properties = opt_geometryOrProperties;
                _this.setProperties(properties);
            }
        }
        return _this;
    }
    /**
     * Clone this feature. If the original feature has a geometry it
     * is also cloned. The feature id is not set in the clone.
     * @return {Feature<Geometry>} The clone.
     * @api
     */ Feature2.prototype.clone = function() {
        var clone = new Feature2(this.hasProperties() ? this.getProperties() : null);
        clone.setGeometryName(this.getGeometryName());
        var geometry = this.getGeometry();
        if (geometry) clone.setGeometry(geometry.clone());
        var style = this.getStyle();
        if (style) clone.setStyle(style);
        return clone;
    };
    /**
     * Get the feature's default geometry.  A feature may have any number of named
     * geometries.  The "default" geometry (the one that is rendered by default) is
     * set when calling {@link module:ol/Feature~Feature#setGeometry}.
     * @return {Geometry|undefined} The default geometry for the feature.
     * @api
     * @observable
     */ Feature2.prototype.getGeometry = function() {
        return this.get(this.geometryName_);
    };
    /**
     * Get the feature identifier.  This is a stable identifier for the feature and
     * is either set when reading data from a remote source or set explicitly by
     * calling {@link module:ol/Feature~Feature#setId}.
     * @return {number|string|undefined} Id.
     * @api
     */ Feature2.prototype.getId = function() {
        return this.id_;
    };
    /**
     * Get the name of the feature's default geometry.  By default, the default
     * geometry is named `geometry`.
     * @return {string} Get the property name associated with the default geometry
     *     for this feature.
     * @api
     */ Feature2.prototype.getGeometryName = function() {
        return this.geometryName_;
    };
    /**
     * Get the feature's style. Will return what was provided to the
     * {@link module:ol/Feature~Feature#setStyle} method.
     * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
     * @api
     */ Feature2.prototype.getStyle = function() {
        return this.style_;
    };
    /**
     * Get the feature's style function.
     * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
     * representing the current style of this feature.
     * @api
     */ Feature2.prototype.getStyleFunction = function() {
        return this.styleFunction_;
    };
    /**
     * @private
     */ Feature2.prototype.handleGeometryChange_ = function() {
        this.changed();
    };
    /**
     * @private
     */ Feature2.prototype.handleGeometryChanged_ = function() {
        if (this.geometryChangeKey_) {
            _eventsJs.unlistenByKey(this.geometryChangeKey_);
            this.geometryChangeKey_ = null;
        }
        var geometry = this.getGeometry();
        if (geometry) this.geometryChangeKey_ = _eventsJs.listen(geometry, _eventTypeJsDefault.default.CHANGE, this.handleGeometryChange_, this);
        this.changed();
    };
    /**
     * Set the default geometry for the feature.  This will update the property
     * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
     * @param {Geometry|undefined} geometry The new geometry.
     * @api
     * @observable
     */ Feature2.prototype.setGeometry = function(geometry) {
        this.set(this.geometryName_, geometry);
    };
    /**
     * Set the style for the feature to override the layer style.  This can be a
     * single style object, an array of styles, or a function that takes a
     * resolution and returns an array of styles. To unset the feature style, call
     * `setStyle()` without arguments or a falsey value.
     * @param {import("./style/Style.js").StyleLike} [opt_style] Style for this feature.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */ Feature2.prototype.setStyle = function(opt_style) {
        this.style_ = opt_style;
        this.styleFunction_ = !opt_style ? undefined : createStyleFunction(opt_style);
        this.changed();
    };
    /**
     * Set the feature id.  The feature id is considered stable and may be used when
     * requesting features or comparing identifiers returned from a remote source.
     * The feature id can be used with the
     * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
     * @param {number|string|undefined} id The feature id.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */ Feature2.prototype.setId = function(id) {
        this.id_ = id;
        this.changed();
    };
    /**
     * Set the property name to be used when getting the feature's default geometry.
     * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
     * this name will be returned.
     * @param {string} name The property name of the default geometry.
     * @api
     */ Feature2.prototype.setGeometryName = function(name) {
        this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.geometryName_ = name;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.handleGeometryChanged_();
    };
    return Feature2;
}(_objectJsDefault.default);
function createStyleFunction(obj) {
    if (typeof obj === 'function') return obj;
    else {
        /**
         * @type {Array<import("./style/Style.js").default>}
         */ var styles_1;
        if (Array.isArray(obj)) styles_1 = obj;
        else {
            _assertsJs.assert(typeof /** @type {?} */ obj.getZIndex === 'function', 41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`
            var style = obj;
            styles_1 = [
                style
            ];
        }
        return function() {
            return styles_1;
        };
    }
}
exports.default = Feature1;

},{"./Object.js":"3roCV","./events/EventType.js":"83vee","./asserts.js":"cnrP4","./events.js":"e9Qqr","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bDy7p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/LineString
 */ var _geometryLayoutJs = require("./GeometryLayout.js");
var _geometryLayoutJsDefault = parcelHelpers.interopDefault(_geometryLayoutJs);
var _geometryTypeJs = require("./GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _simplifyJs = require("./flat/simplify.js");
var _arrayJs = require("../array.js");
var _segmentsJs = require("./flat/segments.js");
var _inflateJs = require("./flat/inflate.js");
var _interpolateJs = require("./flat/interpolate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
var _lengthJs = require("./flat/length.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * Linestring geometry.
 *
 * @api
 */ var LineString1 = function(_super) {
    __extends(LineString2, _super);
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     */ function LineString2(coordinates, opt_layout) {
        var _this = _super.call(this) || this;
        /**
         * @private
         * @type {import("../coordinate.js").Coordinate}
         */ _this.flatMidpoint_ = null;
        /**
         * @private
         * @type {number}
         */ _this.flatMidpointRevision_ = -1;
        /**
         * @private
         * @type {number}
         */ _this.maxDelta_ = -1;
        /**
         * @private
         * @type {number}
         */ _this.maxDeltaRevision_ = -1;
        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) _this.setFlatCoordinates(opt_layout, coordinates);
        else _this.setCoordinates(coordinates, opt_layout);
        return _this;
    }
    /**
     * Append the passed coordinate to the coordinates of the linestring.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @api
     */ LineString2.prototype.appendCoordinate = function(coordinate) {
        if (!this.flatCoordinates) this.flatCoordinates = coordinate.slice();
        else _arrayJs.extend(this.flatCoordinates, coordinate);
        this.changed();
    };
    /**
     * Make a complete copy of the geometry.
     * @return {!LineString} Clone.
     * @api
     */ LineString2.prototype.clone = function() {
        var lineString = new LineString2(this.flatCoordinates.slice(), this.layout);
        lineString.applyProperties(this);
        return lineString;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */ LineString2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < _extentJs.closestSquaredDistanceXY(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt(_closestJs.maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return _closestJs.assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
    };
    /**
     * Iterate over each segment, calling the provided callback.
     * If the callback returns a truthy value the function returns that
     * value immediately. Otherwise the function returns `false`.
     *
     * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
     *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
     * @return {T|boolean} Value.
     * @template T,S
     * @api
     */ LineString2.prototype.forEachSegment = function(callback) {
        return _segmentsJs.forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
    };
    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * @param {number} m M.
     * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate} Coordinate.
     * @api
     */ LineString2.prototype.getCoordinateAtM = function(m, opt_extrapolate) {
        if (this.layout != _geometryLayoutJsDefault.default.XYM && this.layout != _geometryLayoutJsDefault.default.XYZM) return null;
        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
        return _interpolateJs.lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
    };
    /**
     * Return the coordinates of the linestring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     */ LineString2.prototype.getCoordinates = function() {
        return _inflateJs.inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    };
    /**
     * Return the coordinate at the provided fraction along the linestring.
     * The `fraction` is a number between 0 and 1, where 0 is the start of the
     * linestring and 1 is the end.
     * @param {number} fraction Fraction.
     * @param {import("../coordinate.js").Coordinate} [opt_dest] Optional coordinate whose values will
     *     be modified. If not provided, a new coordinate will be returned.
     * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
     * @api
     */ LineString2.prototype.getCoordinateAt = function(fraction, opt_dest) {
        return _interpolateJs.interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);
    };
    /**
     * Return the length of the linestring on projected plane.
     * @return {number} Length (on projected plane).
     * @api
     */ LineString2.prototype.getLength = function() {
        return _lengthJs.lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    };
    /**
     * @return {Array<number>} Flat midpoint.
     */ LineString2.prototype.getFlatMidpoint = function() {
        if (this.flatMidpointRevision_ != this.getRevision()) {
            this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
            this.flatMidpointRevision_ = this.getRevision();
        }
        return this.flatMidpoint_;
    };
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LineString} Simplified LineString.
     * @protected
     */ LineString2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = _simplifyJs.douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        return new LineString2(simplifiedFlatCoordinates, _geometryLayoutJsDefault.default.XY);
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */ LineString2.prototype.getType = function() {
        return _geometryTypeJsDefault.default.LINE_STRING;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */ LineString2.prototype.intersectsExtent = function(extent) {
        return _intersectsextentJs.intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
    };
    /**
     * Set the coordinates of the linestring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @api
     */ LineString2.prototype.setCoordinates = function(coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 1);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = _deflateJs.deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    };
    return LineString2;
}(_simpleGeometryJsDefault.default);
exports.default = LineString1;

},{"./GeometryLayout.js":"ajlbX","./GeometryType.js":"3sRlw","./SimpleGeometry.js":"4jyQo","./flat/closest.js":"2YhxK","../extent.js":"jgUz2","./flat/deflate.js":"gFAia","./flat/simplify.js":"7GCEm","../array.js":"jKNP0","./flat/segments.js":"54KdJ","./flat/inflate.js":"9BPwr","./flat/interpolate.js":"GUDHC","./flat/intersectsextent.js":"jv50N","./flat/length.js":"a2zAP","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"GUDHC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array<number>} [opt_dest] Destination.
 * @param {number} [opt_dimension] Destination dimension (default is `2`)
 * @return {Array<number>} Destination.
 */ parcelHelpers.export(exports, "interpolatePoint", ()=>interpolatePoint
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {import("../../coordinate.js").Coordinate} Coordinate.
 */ parcelHelpers.export(exports, "lineStringCoordinateAtM", ()=>lineStringCoordinateAtM
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {import("../../coordinate.js").Coordinate} Coordinate.
 */ parcelHelpers.export(exports, "lineStringsCoordinateAtM", ()=>lineStringsCoordinateAtM
);
/**
 * @module ol/geom/flat/interpolate
 */ var _arrayJs = require("../../array.js");
var _mathJs = require("../../math.js");
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {
    var o, t;
    var n = (end - offset) / stride;
    if (n === 1) o = offset;
    else if (n === 2) {
        o = offset;
        t = fraction;
    } else if (n !== 0) {
        var x1 = flatCoordinates[offset];
        var y1 = flatCoordinates[offset + 1];
        var length_1 = 0;
        var cumulativeLengths = [
            0
        ];
        for(var i = offset + stride; i < end; i += stride){
            var x2 = flatCoordinates[i];
            var y2 = flatCoordinates[i + 1];
            length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            cumulativeLengths.push(length_1);
            x1 = x2;
            y1 = y2;
        }
        var target = fraction * length_1;
        var index = _arrayJs.binarySearch(cumulativeLengths, target);
        if (index < 0) {
            t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
            o = offset + (-index - 2) * stride;
        } else o = offset + index * stride;
    }
    var dimension = opt_dimension > 1 ? opt_dimension : 2;
    var dest = opt_dest ? opt_dest : new Array(dimension);
    for(var i = 0; i < dimension; ++i)dest[i] = o === undefined ? NaN : t === undefined ? flatCoordinates[o + i] : _mathJs.lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
    return dest;
}
function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
    if (end == offset) return null;
    var coordinate;
    if (m < flatCoordinates[offset + stride - 1]) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(offset, offset + stride);
            coordinate[stride - 1] = m;
            return coordinate;
        } else return null;
    } else if (flatCoordinates[end - 1] < m) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(end - stride, end);
            coordinate[stride - 1] = m;
            return coordinate;
        } else return null;
    }
    // FIXME use O(1) search
    if (m == flatCoordinates[offset + stride - 1]) return flatCoordinates.slice(offset, offset + stride);
    var lo = offset / stride;
    var hi = end / stride;
    while(lo < hi){
        var mid = lo + hi >> 1;
        if (m < flatCoordinates[(mid + 1) * stride - 1]) hi = mid;
        else lo = mid + 1;
    }
    var m0 = flatCoordinates[lo * stride - 1];
    if (m == m0) return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
    var m1 = flatCoordinates[(lo + 1) * stride - 1];
    var t = (m - m0) / (m1 - m0);
    coordinate = [];
    for(var i = 0; i < stride - 1; ++i)coordinate.push(_mathJs.lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
    coordinate.push(m);
    return coordinate;
}
function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
    if (interpolate) return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
    var coordinate;
    if (m < flatCoordinates[stride - 1]) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(0, stride);
            coordinate[stride - 1] = m;
            return coordinate;
        } else return null;
    }
    if (flatCoordinates[flatCoordinates.length - 1] < m) {
        if (extrapolate) {
            coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
            coordinate[stride - 1] = m;
            return coordinate;
        } else return null;
    }
    for(var i = 0, ii = ends.length; i < ii; ++i){
        var end = ends[i];
        if (offset == end) continue;
        if (m < flatCoordinates[offset + stride - 1]) return null;
        else if (m <= flatCoordinates[end - 1]) return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
        offset = end;
    }
    return null;
}

},{"../../array.js":"jKNP0","../../math.js":"kI4rE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"a2zAP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/flat/length
 */ /**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */ parcelHelpers.export(exports, "lineStringLength", ()=>lineStringLength
);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */ parcelHelpers.export(exports, "linearRingLength", ()=>linearRingLength
);
function lineStringLength(flatCoordinates, offset, end, stride) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    var length = 0;
    for(var i = offset + stride; i < end; i += stride){
        var x2 = flatCoordinates[i];
        var y2 = flatCoordinates[i + 1];
        length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        x1 = x2;
        y1 = y2;
    }
    return length;
}
function linearRingLength(flatCoordinates, offset, end, stride) {
    var perimeter = lineStringLength(flatCoordinates, offset, end, stride);
    var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
    var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
    perimeter += Math.sqrt(dx * dx + dy * dy);
    return perimeter;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jGlXO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/MultiLineString
 */ var _geometryLayoutJs = require("./GeometryLayout.js");
var _geometryLayoutJsDefault = parcelHelpers.interopDefault(_geometryLayoutJs);
var _geometryTypeJs = require("./GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _lineStringJs = require("./LineString.js");
var _lineStringJsDefault = parcelHelpers.interopDefault(_lineStringJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _simplifyJs = require("./flat/simplify.js");
var _arrayJs = require("../array.js");
var _inflateJs = require("./flat/inflate.js");
var _interpolateJs = require("./flat/interpolate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @api
 */ var MultiLineString1 = function(_super) {
    __extends(MultiLineString2, _super);
    /**
     * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
     *     Coordinates or LineString geometries. (For internal use, flat coordinates in
     *     combination with `opt_layout` and `opt_ends` are also accepted.)
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @param {Array<number>} [opt_ends] Flat coordinate ends for internal use.
     */ function MultiLineString2(coordinates, opt_layout, opt_ends) {
        var _this = _super.call(this) || this;
        /**
         * @type {Array<number>}
         * @private
         */ _this.ends_ = [];
        /**
         * @private
         * @type {number}
         */ _this.maxDelta_ = -1;
        /**
         * @private
         * @type {number}
         */ _this.maxDeltaRevision_ = -1;
        if (Array.isArray(coordinates[0])) _this.setCoordinates(coordinates, opt_layout);
        else if (opt_layout !== undefined && opt_ends) {
            _this.setFlatCoordinates(opt_layout, coordinates);
            _this.ends_ = opt_ends;
        } else {
            var layout = _this.getLayout();
            var lineStrings = coordinates;
            var flatCoordinates = [];
            var ends = [];
            for(var i = 0, ii = lineStrings.length; i < ii; ++i){
                var lineString = lineStrings[i];
                if (i === 0) layout = lineString.getLayout();
                _arrayJs.extend(flatCoordinates, lineString.getFlatCoordinates());
                ends.push(flatCoordinates.length);
            }
            _this.setFlatCoordinates(layout, flatCoordinates);
            _this.ends_ = ends;
        }
        return _this;
    }
    /**
     * Append the passed linestring to the multilinestring.
     * @param {LineString} lineString LineString.
     * @api
     */ MultiLineString2.prototype.appendLineString = function(lineString) {
        if (!this.flatCoordinates) this.flatCoordinates = lineString.getFlatCoordinates().slice();
        else _arrayJs.extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
    };
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiLineString} Clone.
     * @api
     */ MultiLineString2.prototype.clone = function() {
        var multiLineString = new MultiLineString2(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
        multiLineString.applyProperties(this);
        return multiLineString;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */ MultiLineString2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < _extentJs.closestSquaredDistanceXY(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt(_closestJs.arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return _closestJs.assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
    };
    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * `opt_interpolate` controls interpolation between consecutive LineStrings
     * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
     * will be linearly interpolated between the last coordinate of one LineString
     * and the first coordinate of the next LineString.  If `opt_interpolate` is
     * `false` then the function will return `null` for Ms falling between
     * LineStrings.
     *
     * @param {number} m M.
     * @param {boolean} [opt_extrapolate] Extrapolate. Default is `false`.
     * @param {boolean} [opt_interpolate] Interpolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate} Coordinate.
     * @api
     */ MultiLineString2.prototype.getCoordinateAtM = function(m, opt_extrapolate, opt_interpolate) {
        if (this.layout != _geometryLayoutJsDefault.default.XYM && this.layout != _geometryLayoutJsDefault.default.XYZM || this.flatCoordinates.length === 0) return null;
        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
        var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
        return _interpolateJs.lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
    };
    /**
     * Return the coordinates of the multilinestring.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     */ MultiLineString2.prototype.getCoordinates = function() {
        return _inflateJs.inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);
    };
    /**
     * @return {Array<number>} Ends.
     */ MultiLineString2.prototype.getEnds = function() {
        return this.ends_;
    };
    /**
     * Return the linestring at the specified index.
     * @param {number} index Index.
     * @return {LineString} LineString.
     * @api
     */ MultiLineString2.prototype.getLineString = function(index) {
        if (index < 0 || this.ends_.length <= index) return null;
        return new _lineStringJsDefault.default(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
    };
    /**
     * Return the linestrings of this multilinestring.
     * @return {Array<LineString>} LineStrings.
     * @api
     */ MultiLineString2.prototype.getLineStrings = function() {
        var flatCoordinates = this.flatCoordinates;
        var ends = this.ends_;
        var layout = this.layout;
        /** @type {Array<LineString>} */ var lineStrings = [];
        var offset = 0;
        for(var i = 0, ii = ends.length; i < ii; ++i){
            var end = ends[i];
            var lineString = new _lineStringJsDefault.default(flatCoordinates.slice(offset, end), layout);
            lineStrings.push(lineString);
            offset = end;
        }
        return lineStrings;
    };
    /**
     * @return {Array<number>} Flat midpoints.
     */ MultiLineString2.prototype.getFlatMidpoints = function() {
        var midpoints = [];
        var flatCoordinates = this.flatCoordinates;
        var offset = 0;
        var ends = this.ends_;
        var stride = this.stride;
        for(var i = 0, ii = ends.length; i < ii; ++i){
            var end = ends[i];
            var midpoint = _interpolateJs.interpolatePoint(flatCoordinates, offset, end, stride, 0.5);
            _arrayJs.extend(midpoints, midpoint);
            offset = end;
        }
        return midpoints;
    };
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiLineString} Simplified MultiLineString.
     * @protected
     */ MultiLineString2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        var simplifiedEnds = [];
        simplifiedFlatCoordinates.length = _simplifyJs.douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
        return new MultiLineString2(simplifiedFlatCoordinates, _geometryLayoutJsDefault.default.XY, simplifiedEnds);
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */ MultiLineString2.prototype.getType = function() {
        return _geometryTypeJsDefault.default.MULTI_LINE_STRING;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */ MultiLineString2.prototype.intersectsExtent = function(extent) {
        return _intersectsextentJs.intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);
    };
    /**
     * Set the coordinates of the multilinestring.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {GeometryLayout} [opt_layout] Layout.
     * @api
     */ MultiLineString2.prototype.setCoordinates = function(coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 2);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        var ends = _deflateJs.deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
    };
    return MultiLineString2;
}(_simpleGeometryJsDefault.default);
exports.default = MultiLineString1;

},{"./GeometryLayout.js":"ajlbX","./GeometryType.js":"3sRlw","./LineString.js":"bDy7p","./SimpleGeometry.js":"4jyQo","./flat/closest.js":"2YhxK","../extent.js":"jgUz2","./flat/deflate.js":"gFAia","./flat/simplify.js":"7GCEm","../array.js":"jKNP0","./flat/inflate.js":"9BPwr","./flat/interpolate.js":"GUDHC","./flat/intersectsextent.js":"jv50N","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jM6r0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/MultiPoint
 */ var _geometryTypeJs = require("./GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _pointJs = require("./Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _arrayJs = require("../array.js");
var _inflateJs = require("./flat/inflate.js");
var _mathJs = require("../math.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * Multi-point geometry.
 *
 * @api
 */ var MultiPoint1 = function(_super) {
    __extends(MultiPoint2, _super);
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     */ function MultiPoint2(coordinates, opt_layout) {
        var _this = _super.call(this) || this;
        if (opt_layout && !Array.isArray(coordinates[0])) _this.setFlatCoordinates(opt_layout, coordinates);
        else _this.setCoordinates(coordinates, opt_layout);
        return _this;
    }
    /**
     * Append the passed point to this multipoint.
     * @param {Point} point Point.
     * @api
     */ MultiPoint2.prototype.appendPoint = function(point) {
        if (!this.flatCoordinates) this.flatCoordinates = point.getFlatCoordinates().slice();
        else _arrayJs.extend(this.flatCoordinates, point.getFlatCoordinates());
        this.changed();
    };
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPoint} Clone.
     * @api
     */ MultiPoint2.prototype.clone = function() {
        var multiPoint = new MultiPoint2(this.flatCoordinates.slice(), this.layout);
        multiPoint.applyProperties(this);
        return multiPoint;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */ MultiPoint2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < _extentJs.closestSquaredDistanceXY(this.getExtent(), x, y)) return minSquaredDistance;
        var flatCoordinates = this.flatCoordinates;
        var stride = this.stride;
        for(var i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            var squaredDistance = _mathJs.squaredDistance(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
            if (squaredDistance < minSquaredDistance) {
                minSquaredDistance = squaredDistance;
                for(var j = 0; j < stride; ++j)closestPoint[j] = flatCoordinates[i + j];
                closestPoint.length = stride;
            }
        }
        return minSquaredDistance;
    };
    /**
     * Return the coordinates of the multipoint.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     */ MultiPoint2.prototype.getCoordinates = function() {
        return _inflateJs.inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
    };
    /**
     * Return the point at the specified index.
     * @param {number} index Index.
     * @return {Point} Point.
     * @api
     */ MultiPoint2.prototype.getPoint = function(index) {
        var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
        if (index < 0 || n <= index) return null;
        return new _pointJsDefault.default(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
    };
    /**
     * Return the points of this multipoint.
     * @return {Array<Point>} Points.
     * @api
     */ MultiPoint2.prototype.getPoints = function() {
        var flatCoordinates = this.flatCoordinates;
        var layout = this.layout;
        var stride = this.stride;
        /** @type {Array<Point>} */ var points = [];
        for(var i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            var point = new _pointJsDefault.default(flatCoordinates.slice(i, i + stride), layout);
            points.push(point);
        }
        return points;
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */ MultiPoint2.prototype.getType = function() {
        return _geometryTypeJsDefault.default.MULTI_POINT;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */ MultiPoint2.prototype.intersectsExtent = function(extent) {
        var flatCoordinates = this.flatCoordinates;
        var stride = this.stride;
        for(var i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            var x = flatCoordinates[i];
            var y = flatCoordinates[i + 1];
            if (_extentJs.containsXY(extent, x, y)) return true;
        }
        return false;
    };
    /**
     * Set the coordinates of the multipoint.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @api
     */ MultiPoint2.prototype.setCoordinates = function(coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 1);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        this.flatCoordinates.length = _deflateJs.deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
    };
    return MultiPoint2;
}(_simpleGeometryJsDefault.default);
exports.default = MultiPoint1;

},{"./GeometryType.js":"3sRlw","./Point.js":"4ReTD","./SimpleGeometry.js":"4jyQo","../extent.js":"jgUz2","./flat/deflate.js":"gFAia","../array.js":"jKNP0","./flat/inflate.js":"9BPwr","../math.js":"kI4rE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"gSTwq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/MultiPolygon
 */ var _geometryLayoutJs = require("./GeometryLayout.js");
var _geometryLayoutJsDefault = parcelHelpers.interopDefault(_geometryLayoutJs);
var _geometryTypeJs = require("./GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _multiPointJs = require("./MultiPoint.js");
var _multiPointJsDefault = parcelHelpers.interopDefault(_multiPointJs);
var _polygonJs = require("./Polygon.js");
var _polygonJsDefault = parcelHelpers.interopDefault(_polygonJs);
var _simpleGeometryJs = require("./SimpleGeometry.js");
var _simpleGeometryJsDefault = parcelHelpers.interopDefault(_simpleGeometryJs);
var _closestJs = require("./flat/closest.js");
var _extentJs = require("../extent.js");
var _deflateJs = require("./flat/deflate.js");
var _arrayJs = require("../array.js");
var _interiorpointJs = require("./flat/interiorpoint.js");
var _inflateJs = require("./flat/inflate.js");
var _intersectsextentJs = require("./flat/intersectsextent.js");
var _orientJs = require("./flat/orient.js");
var _areaJs = require("./flat/area.js");
var _centerJs = require("./flat/center.js");
var _containsJs = require("./flat/contains.js");
var _simplifyJs = require("./flat/simplify.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @api
 */ var MultiPolygon1 = function(_super) {
    __extends(MultiPolygon2, _super);
    /**
     * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @param {Array<Array<number>>} [opt_endss] Array of ends for internal use with flat coordinates.
     */ function MultiPolygon2(coordinates, opt_layout, opt_endss) {
        var _this = _super.call(this) || this;
        /**
         * @type {Array<Array<number>>}
         * @private
         */ _this.endss_ = [];
        /**
         * @private
         * @type {number}
         */ _this.flatInteriorPointsRevision_ = -1;
        /**
         * @private
         * @type {Array<number>}
         */ _this.flatInteriorPoints_ = null;
        /**
         * @private
         * @type {number}
         */ _this.maxDelta_ = -1;
        /**
         * @private
         * @type {number}
         */ _this.maxDeltaRevision_ = -1;
        /**
         * @private
         * @type {number}
         */ _this.orientedRevision_ = -1;
        /**
         * @private
         * @type {Array<number>}
         */ _this.orientedFlatCoordinates_ = null;
        if (!opt_endss && !Array.isArray(coordinates[0])) {
            var layout = _this.getLayout();
            var polygons = coordinates;
            var flatCoordinates = [];
            var endss = [];
            for(var i = 0, ii = polygons.length; i < ii; ++i){
                var polygon = polygons[i];
                if (i === 0) layout = polygon.getLayout();
                var offset = flatCoordinates.length;
                var ends = polygon.getEnds();
                for(var j = 0, jj = ends.length; j < jj; ++j)ends[j] += offset;
                _arrayJs.extend(flatCoordinates, polygon.getFlatCoordinates());
                endss.push(ends);
            }
            opt_layout = layout;
            coordinates = flatCoordinates;
            opt_endss = endss;
        }
        if (opt_layout !== undefined && opt_endss) {
            _this.setFlatCoordinates(opt_layout, coordinates);
            _this.endss_ = opt_endss;
        } else _this.setCoordinates(coordinates, opt_layout);
        return _this;
    }
    /**
     * Append the passed polygon to this multipolygon.
     * @param {Polygon} polygon Polygon.
     * @api
     */ MultiPolygon2.prototype.appendPolygon = function(polygon) {
        /** @type {Array<number>} */ var ends;
        if (!this.flatCoordinates) {
            this.flatCoordinates = polygon.getFlatCoordinates().slice();
            ends = polygon.getEnds().slice();
            this.endss_.push();
        } else {
            var offset = this.flatCoordinates.length;
            _arrayJs.extend(this.flatCoordinates, polygon.getFlatCoordinates());
            ends = polygon.getEnds().slice();
            for(var i = 0, ii = ends.length; i < ii; ++i)ends[i] += offset;
        }
        this.endss_.push(ends);
        this.changed();
    };
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPolygon} Clone.
     * @api
     */ MultiPolygon2.prototype.clone = function() {
        var len = this.endss_.length;
        var newEndss = new Array(len);
        for(var i = 0; i < len; ++i)newEndss[i] = this.endss_[i].slice();
        var multiPolygon = new MultiPolygon2(this.flatCoordinates.slice(), this.layout, newEndss);
        multiPolygon.applyProperties(this);
        return multiPolygon;
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */ MultiPolygon2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < _extentJs.closestSquaredDistanceXY(this.getExtent(), x, y)) return minSquaredDistance;
        if (this.maxDeltaRevision_ != this.getRevision()) {
            this.maxDelta_ = Math.sqrt(_closestJs.multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));
            this.maxDeltaRevision_ = this.getRevision();
        }
        return _closestJs.assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
    };
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */ MultiPolygon2.prototype.containsXY = function(x, y) {
        return _containsJs.linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
    };
    /**
     * Return the area of the multipolygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */ MultiPolygon2.prototype.getArea = function() {
        return _areaJs.linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
    };
    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for multi-polygons.
     *
     * @param {boolean} [opt_right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
     * @api
     */ MultiPolygon2.prototype.getCoordinates = function(opt_right) {
        var flatCoordinates;
        if (opt_right !== undefined) {
            flatCoordinates = this.getOrientedFlatCoordinates().slice();
            _orientJs.orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);
        } else flatCoordinates = this.flatCoordinates;
        return _inflateJs.inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);
    };
    /**
     * @return {Array<Array<number>>} Endss.
     */ MultiPolygon2.prototype.getEndss = function() {
        return this.endss_;
    };
    /**
     * @return {Array<number>} Flat interior points.
     */ MultiPolygon2.prototype.getFlatInteriorPoints = function() {
        if (this.flatInteriorPointsRevision_ != this.getRevision()) {
            var flatCenters = _centerJs.linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);
            this.flatInteriorPoints_ = _interiorpointJs.getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
            this.flatInteriorPointsRevision_ = this.getRevision();
        }
        return this.flatInteriorPoints_;
    };
    /**
     * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.
     * @return {MultiPoint} Interior points as XYM coordinates, where M is
     * the length of the horizontal intersection that the point belongs to.
     * @api
     */ MultiPolygon2.prototype.getInteriorPoints = function() {
        return new _multiPointJsDefault.default(this.getFlatInteriorPoints().slice(), _geometryLayoutJsDefault.default.XYM);
    };
    /**
     * @return {Array<number>} Oriented flat coordinates.
     */ MultiPolygon2.prototype.getOrientedFlatCoordinates = function() {
        if (this.orientedRevision_ != this.getRevision()) {
            var flatCoordinates = this.flatCoordinates;
            if (_orientJs.linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) this.orientedFlatCoordinates_ = flatCoordinates;
            else {
                this.orientedFlatCoordinates_ = flatCoordinates.slice();
                this.orientedFlatCoordinates_.length = _orientJs.orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
            }
            this.orientedRevision_ = this.getRevision();
        }
        return this.orientedFlatCoordinates_;
    };
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiPolygon} Simplified MultiPolygon.
     * @protected
     */ MultiPolygon2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        var simplifiedEndss = [];
        simplifiedFlatCoordinates.length = _simplifyJs.quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
        return new MultiPolygon2(simplifiedFlatCoordinates, _geometryLayoutJsDefault.default.XY, simplifiedEndss);
    };
    /**
     * Return the polygon at the specified index.
     * @param {number} index Index.
     * @return {Polygon} Polygon.
     * @api
     */ MultiPolygon2.prototype.getPolygon = function(index) {
        if (index < 0 || this.endss_.length <= index) return null;
        var offset;
        if (index === 0) offset = 0;
        else {
            var prevEnds = this.endss_[index - 1];
            offset = prevEnds[prevEnds.length - 1];
        }
        var ends = this.endss_[index].slice();
        var end = ends[ends.length - 1];
        if (offset !== 0) for(var i = 0, ii = ends.length; i < ii; ++i)ends[i] -= offset;
        return new _polygonJsDefault.default(this.flatCoordinates.slice(offset, end), this.layout, ends);
    };
    /**
     * Return the polygons of this multipolygon.
     * @return {Array<Polygon>} Polygons.
     * @api
     */ MultiPolygon2.prototype.getPolygons = function() {
        var layout = this.layout;
        var flatCoordinates = this.flatCoordinates;
        var endss = this.endss_;
        var polygons = [];
        var offset = 0;
        for(var i = 0, ii = endss.length; i < ii; ++i){
            var ends = endss[i].slice();
            var end = ends[ends.length - 1];
            if (offset !== 0) for(var j = 0, jj = ends.length; j < jj; ++j)ends[j] -= offset;
            var polygon = new _polygonJsDefault.default(flatCoordinates.slice(offset, end), layout, ends);
            polygons.push(polygon);
            offset = end;
        }
        return polygons;
    };
    /**
     * Get the type of this geometry.
     * @return {import("./GeometryType.js").default} Geometry type.
     * @api
     */ MultiPolygon2.prototype.getType = function() {
        return _geometryTypeJsDefault.default.MULTI_POLYGON;
    };
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */ MultiPolygon2.prototype.intersectsExtent = function(extent) {
        return _intersectsextentJs.intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
    };
    /**
     * Set the coordinates of the multipolygon.
     * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
     * @param {import("./GeometryLayout.js").default} [opt_layout] Layout.
     * @api
     */ MultiPolygon2.prototype.setCoordinates = function(coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 3);
        if (!this.flatCoordinates) this.flatCoordinates = [];
        var endss = _deflateJs.deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
        if (endss.length === 0) this.flatCoordinates.length = 0;
        else {
            var lastEnds = endss[endss.length - 1];
            this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
        }
        this.changed();
    };
    return MultiPolygon2;
}(_simpleGeometryJsDefault.default);
exports.default = MultiPolygon1;

},{"./GeometryLayout.js":"ajlbX","./GeometryType.js":"3sRlw","./MultiPoint.js":"jM6r0","./Polygon.js":"hoOc8","./SimpleGeometry.js":"4jyQo","./flat/closest.js":"2YhxK","../extent.js":"jgUz2","./flat/deflate.js":"gFAia","../array.js":"jKNP0","./flat/interiorpoint.js":"kXs0P","./flat/inflate.js":"9BPwr","./flat/intersectsextent.js":"jv50N","./flat/orient.js":"TP5fs","./flat/area.js":"kSE5y","./flat/center.js":"1TBZ4","./flat/contains.js":"hPmbJ","./flat/simplify.js":"7GCEm","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1TBZ4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array<number>} Flat centers.
 */ parcelHelpers.export(exports, "linearRingss", ()=>linearRingss
);
/**
 * @module ol/geom/flat/center
 */ var _extentJs = require("../../extent.js");
function linearRingss(flatCoordinates, offset, endss, stride) {
    var flatCenters = [];
    var extent = _extentJs.createEmpty();
    for(var i = 0, ii = endss.length; i < ii; ++i){
        var ends = endss[i];
        extent = _extentJs.createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);
        flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
        offset = ends[ends.length - 1];
    }
    return flatCenters;
}

},{"../../extent.js":"jgUz2","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"2qjJV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/layer/Vector
 */ var _baseVectorJs = require("./BaseVector.js");
var _baseVectorJsDefault = parcelHelpers.interopDefault(_baseVectorJs);
var _vectorLayerJs = require("../renderer/canvas/VectorLayer.js");
var _vectorLayerJsDefault = parcelHelpers.interopDefault(_vectorLayerJs);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default} VectorSourceType
 * @extends {BaseVectorLayer<VectorSourceType>}
 * @api
 */ var VectorLayer1 = function(_super) {
    __extends(VectorLayer2, _super);
    /**
     * @param {import("./BaseVector.js").Options<VectorSourceType>} [opt_options] Options.
     */ function VectorLayer2(opt_options) {
        return _super.call(this, opt_options) || this;
    }
    /**
     * Create a renderer for this layer.
     * @return {import("../renderer/Layer.js").default} A layer renderer.
     */ VectorLayer2.prototype.createRenderer = function() {
        return new _vectorLayerJsDefault.default(this);
    };
    return VectorLayer2;
}(_baseVectorJsDefault.default);
exports.default = VectorLayer1;

},{"./BaseVector.js":"lAVi0","../renderer/canvas/VectorLayer.js":"7pdH9","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lAVi0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/layer/BaseVector
 */ var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _rbush = require("rbush");
var _rbushDefault = parcelHelpers.interopDefault(_rbush);
var _objJs = require("../obj.js");
var _styleJs = require("../style/Style.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {VectorSourceType} [source] Source.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../PluggableMap.js").default#addLayer map.addLayer()}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 * @property {import("../style/Style.js").StyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style} for default style
 * which will be used if this is not set.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @enum {string}
 * @private
 */ var Property = {
    RENDER_ORDER: 'renderOrder'
};
/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @extends {Layer<VectorSourceType>}
 * @api
 */ var BaseVectorLayer1 = function(_super) {
    __extends(BaseVectorLayer2, _super);
    /**
     * @param {Options<VectorSourceType>} [opt_options] Options.
     */ function BaseVectorLayer2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        var baseOptions = _objJs.assign({
        }, options);
        delete baseOptions.style;
        delete baseOptions.renderBuffer;
        delete baseOptions.updateWhileAnimating;
        delete baseOptions.updateWhileInteracting;
        _this = _super.call(this, baseOptions) || this;
        /**
         * @private
         * @type {boolean}
         */ _this.declutter_ = options.declutter !== undefined ? options.declutter : false;
        /**
         * @type {number}
         * @private
         */ _this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;
        /**
         * User provided style.
         * @type {import("../style/Style.js").StyleLike}
         * @private
         */ _this.style_ = null;
        /**
         * Style function for use within the library.
         * @type {import("../style/Style.js").StyleFunction|undefined}
         * @private
         */ _this.styleFunction_ = undefined;
        _this.setStyle(options.style);
        /**
         * @type {boolean}
         * @private
         */ _this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;
        /**
         * @type {boolean}
         * @private
         */ _this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;
        return _this;
    }
    /**
     * @return {boolean} Declutter.
     */ BaseVectorLayer2.prototype.getDeclutter = function() {
        return this.declutter_;
    };
    /**
     * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
     * that resolves with an array of features. The array will either contain the topmost feature
     * when a hit was detected, or it will be empty.
     *
     * The hit detection algorithm used for this method is optimized for performance, but is less
     * accurate than the one used in {@link import("../PluggableMap.js").default#getFeaturesAtPixel}: Text
     * is not considered, and icons are only represented by their bounding box instead of the exact
     * image.
     *
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
     * @api
     */ BaseVectorLayer2.prototype.getFeatures = function(pixel) {
        return _super.prototype.getFeatures.call(this, pixel);
    };
    /**
     * @return {number|undefined} Render buffer.
     */ BaseVectorLayer2.prototype.getRenderBuffer = function() {
        return this.renderBuffer_;
    };
    /**
     * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
     *     order.
     */ BaseVectorLayer2.prototype.getRenderOrder = function() {
        return this.get(Property.RENDER_ORDER);
    };
    /**
     * Get the style for features.  This returns whatever was passed to the `style`
     * option at construction or to the `setStyle` method.
     * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
     * @api
     */ BaseVectorLayer2.prototype.getStyle = function() {
        return this.style_;
    };
    /**
     * Get the style function.
     * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
     * @api
     */ BaseVectorLayer2.prototype.getStyleFunction = function() {
        return this.styleFunction_;
    };
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     animating.
     */ BaseVectorLayer2.prototype.getUpdateWhileAnimating = function() {
        return this.updateWhileAnimating_;
    };
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     interacting.
     */ BaseVectorLayer2.prototype.getUpdateWhileInteracting = function() {
        return this.updateWhileInteracting_;
    };
    /**
     * Render declutter items for this layer
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     */ BaseVectorLayer2.prototype.renderDeclutter = function(frameState) {
        if (!frameState.declutterTree) frameState.declutterTree = new _rbushDefault.default(9);
        /** @type {*} */ this.getRenderer().renderDeclutter(frameState);
    };
    /**
     * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
     *     Render order.
     */ BaseVectorLayer2.prototype.setRenderOrder = function(renderOrder) {
        this.set(Property.RENDER_ORDER, renderOrder);
    };
    /**
     * Set the style for features.  This can be a single style object, an array
     * of styles, or a function that takes a feature and resolution and returns
     * an array of styles. If set to `null`, the layer has no style (a `null` style),
     * so only features that have their own styles will be rendered in the layer. Call
     * `setStyle()` without arguments to reset to the default style. See
     * {@link module:ol/style} for information on the default style.
     * @param {import("../style/Style.js").StyleLike|null} [opt_style] Layer style.
     * @api
     */ BaseVectorLayer2.prototype.setStyle = function(opt_style) {
        this.style_ = opt_style !== undefined ? opt_style : _styleJs.createDefaultStyle;
        this.styleFunction_ = opt_style === null ? undefined : _styleJs.toFunction(this.style_);
        this.changed();
    };
    return BaseVectorLayer2;
}(_layerJsDefault.default);
exports.default = BaseVectorLayer1;

},{"./Layer.js":"4vI3D","rbush":"g6Qgo","../obj.js":"g3fPg","../style/Style.js":"9N9zp","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"g6Qgo":[function(require,module,exports) {
!function(t, i) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = t || self).RBush = i();
}(this, function() {
    "use strict";
    function t(t1, r, e, a, h) {
        !function t2(n, r1, e1, a1, h1) {
            for(; a1 > e1;){
                if (a1 - e1 > 600) {
                    var o = a1 - e1 + 1, s = r1 - e1 + 1, l = Math.log(o), f = 0.5 * Math.exp(2 * l / 3), u = 0.5 * Math.sqrt(l * f * (o - f) / o) * (s - o / 2 < 0 ? -1 : 1), m = Math.max(e1, Math.floor(r1 - s * f / o + u)), c = Math.min(a1, Math.floor(r1 + (o - s) * f / o + u));
                    t2(n, r1, m, c, h1);
                }
                var p = n[r1], d = e1, x = a1;
                for(i(n, e1, r1), h1(n[a1], p) > 0 && i(n, e1, a1); d < x;){
                    for(i(n, d, x), d++, x--; h1(n[d], p) < 0;)d++;
                    for(; h1(n[x], p) > 0;)x--;
                }
                0 === h1(n[e1], p) ? i(n, e1, x) : i(n, ++x, a1), x <= r1 && (e1 = x + 1), r1 <= x && (a1 = x - 1);
            }
        }(t1, r, e || 0, a || t1.length - 1, h || n);
    }
    function i(t1, i1, n) {
        var r = t1[i1];
        t1[i1] = t1[n], t1[n] = r;
    }
    function n(t1, i1) {
        return t1 < i1 ? -1 : t1 > i1 ? 1 : 0;
    }
    var r = function(t1) {
        (void 0) === t1 && (t1 = 9), this._maxEntries = Math.max(4, t1), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
    };
    function e(t1, i1, n1) {
        if (!n1) return i1.indexOf(t1);
        for(var r1 = 0; r1 < i1.length; r1++)if (n1(t1, i1[r1])) return r1;
        return -1;
    }
    function a(t1, i1) {
        h(t1, 0, t1.children.length, i1, t1);
    }
    function h(t1, i1, n1, r1, e1) {
        e1 || (e1 = p(null)), e1.minX = 1 / 0, e1.minY = 1 / 0, e1.maxX = -1 / 0, e1.maxY = -1 / 0;
        for(var a1 = i1; a1 < n1; a1++){
            var h1 = t1.children[a1];
            o(e1, t1.leaf ? r1(h1) : h1);
        }
        return e1;
    }
    function o(t1, i1) {
        return t1.minX = Math.min(t1.minX, i1.minX), t1.minY = Math.min(t1.minY, i1.minY), t1.maxX = Math.max(t1.maxX, i1.maxX), t1.maxY = Math.max(t1.maxY, i1.maxY), t1;
    }
    function s(t1, i1) {
        return t1.minX - i1.minX;
    }
    function l(t1, i1) {
        return t1.minY - i1.minY;
    }
    function f(t1) {
        return (t1.maxX - t1.minX) * (t1.maxY - t1.minY);
    }
    function u(t1) {
        return t1.maxX - t1.minX + (t1.maxY - t1.minY);
    }
    function m2(t1, i1) {
        return t1.minX <= i1.minX && t1.minY <= i1.minY && i1.maxX <= t1.maxX && i1.maxY <= t1.maxY;
    }
    function c2(t1, i1) {
        return i1.minX <= t1.maxX && i1.minY <= t1.maxY && i1.maxX >= t1.minX && i1.maxY >= t1.minY;
    }
    function p(t1) {
        return {
            children: t1,
            height: 1,
            leaf: !0,
            minX: 1 / 0,
            minY: 1 / 0,
            maxX: -1 / 0,
            maxY: -1 / 0
        };
    }
    function d(i1, n1, r1, e1, a1) {
        for(var h2 = [
            n1,
            r1
        ]; h2.length;)if (!((r1 = h2.pop()) - (n1 = h2.pop()) <= e1)) {
            var o1 = n1 + Math.ceil((r1 - n1) / e1 / 2) * e1;
            t(i1, o1, n1, r1, a1), h2.push(n1, o1, o1, r1);
        }
    }
    return r.prototype.all = function() {
        return this._all(this.data, []);
    }, r.prototype.search = function(t1) {
        var i1 = this.data, n1 = [];
        if (!c2(t1, i1)) return n1;
        for(var r1 = this.toBBox, e1 = []; i1;){
            for(var a1 = 0; a1 < i1.children.length; a1++){
                var h2 = i1.children[a1], o2 = i1.leaf ? r1(h2) : h2;
                c2(t1, o2) && (i1.leaf ? n1.push(h2) : m2(t1, o2) ? this._all(h2, n1) : e1.push(h2));
            }
            i1 = e1.pop();
        }
        return n1;
    }, r.prototype.collides = function(t1) {
        var i1 = this.data;
        if (!c2(t1, i1)) return !1;
        for(var n1 = []; i1;){
            for(var r1 = 0; r1 < i1.children.length; r1++){
                var e1 = i1.children[r1], a2 = i1.leaf ? this.toBBox(e1) : e1;
                if (c2(t1, a2)) {
                    if (i1.leaf || m2(t1, a2)) return !0;
                    n1.push(e1);
                }
            }
            i1 = n1.pop();
        }
        return !1;
    }, r.prototype.load = function(t1) {
        if (!t1 || !t1.length) return this;
        if (t1.length < this._minEntries) {
            for(var i1 = 0; i1 < t1.length; i1++)this.insert(t1[i1]);
            return this;
        }
        var n1 = this._build(t1.slice(), 0, t1.length - 1, 0);
        if (this.data.children.length) {
            if (this.data.height === n1.height) this._splitRoot(this.data, n1);
            else {
                if (this.data.height < n1.height) {
                    var r2 = this.data;
                    this.data = n1, n1 = r2;
                }
                this._insert(n1, this.data.height - n1.height - 1, !0);
            }
        } else this.data = n1;
        return this;
    }, r.prototype.insert = function(t1) {
        return t1 && this._insert(t1, this.data.height - 1), this;
    }, r.prototype.clear = function() {
        return this.data = p([]), this;
    }, r.prototype.remove = function(t1, i2) {
        if (!t1) return this;
        for(var n1, r3, a3, h3 = this.data, o3 = this.toBBox(t1), s1 = [], l1 = []; h3 || s1.length;){
            if (h3 || (h3 = s1.pop(), r3 = s1[s1.length - 1], n1 = l1.pop(), a3 = !0), h3.leaf) {
                var f1 = e(t1, h3.children, i2);
                if (-1 !== f1) return h3.children.splice(f1, 1), s1.push(h3), this._condense(s1), this;
            }
            a3 || h3.leaf || !m2(h3, o3) ? r3 ? (n1++, h3 = r3.children[n1], a3 = !1) : h3 = null : (s1.push(h3), l1.push(n1), n1 = 0, r3 = h3, h3 = h3.children[0]);
        }
        return this;
    }, r.prototype.toBBox = function(t1) {
        return t1;
    }, r.prototype.compareMinX = function(t1, i2) {
        return t1.minX - i2.minX;
    }, r.prototype.compareMinY = function(t1, i2) {
        return t1.minY - i2.minY;
    }, r.prototype.toJSON = function() {
        return this.data;
    }, r.prototype.fromJSON = function(t1) {
        return this.data = t1, this;
    }, r.prototype._all = function(t1, i2) {
        for(var n1 = []; t1;)t1.leaf ? i2.push.apply(i2, t1.children) : n1.push.apply(n1, t1.children), t1 = n1.pop();
        return i2;
    }, r.prototype._build = function(t1, i2, n1, r3) {
        var e2, h3 = n1 - i2 + 1, o3 = this._maxEntries;
        if (h3 <= o3) return a(e2 = p(t1.slice(i2, n1 + 1)), this.toBBox), e2;
        r3 || (r3 = Math.ceil(Math.log(h3) / Math.log(o3)), o3 = Math.ceil(h3 / Math.pow(o3, r3 - 1))), (e2 = p([])).leaf = !1, e2.height = r3;
        var s1 = Math.ceil(h3 / o3), l1 = s1 * Math.ceil(Math.sqrt(o3));
        d(t1, i2, n1, l1, this.compareMinX);
        for(var f2 = i2; f2 <= n1; f2 += l1){
            var u1 = Math.min(f2 + l1 - 1, n1);
            d(t1, f2, u1, s1, this.compareMinY);
            for(var m1 = f2; m1 <= u1; m1 += s1){
                var c1 = Math.min(m1 + s1 - 1, u1);
                e2.children.push(this._build(t1, m1, c1, r3 - 1));
            }
        }
        return a(e2, this.toBBox), e2;
    }, r.prototype._chooseSubtree = function(t1, i2, n1, r3) {
        for(; r3.push(i2), !i2.leaf && r3.length - 1 !== n1;){
            for(var e2 = 1 / 0, a3 = 1 / 0, h3 = void 0, o3 = 0; o3 < i2.children.length; o3++){
                var s1 = i2.children[o3], l1 = f(s1), u2 = (m3 = t1, c3 = s1, (Math.max(c3.maxX, m3.maxX) - Math.min(c3.minX, m3.minX)) * (Math.max(c3.maxY, m3.maxY) - Math.min(c3.minY, m3.minY)) - l1);
                u2 < a3 ? (a3 = u2, e2 = l1 < e2 ? l1 : e2, h3 = s1) : u2 === a3 && l1 < e2 && (e2 = l1, h3 = s1);
            }
            i2 = h3 || i2.children[0];
        }
        var m3, c3;
        return i2;
    }, r.prototype._insert = function(t1, i2, n1) {
        var r3 = n1 ? t1 : this.toBBox(t1), e3 = [], a4 = this._chooseSubtree(r3, this.data, i2, e3);
        for(a4.children.push(t1), o(a4, r3); i2 >= 0 && e3[i2].children.length > this._maxEntries;)this._split(e3, i2), i2--;
        this._adjustParentBBoxes(r3, e3, i2);
    }, r.prototype._split = function(t1, i2) {
        var n1 = t1[i2], r3 = n1.children.length, e3 = this._minEntries;
        this._chooseSplitAxis(n1, e3, r3);
        var h4 = this._chooseSplitIndex(n1, e3, r3), o4 = p(n1.children.splice(h4, n1.children.length - h4));
        o4.height = n1.height, o4.leaf = n1.leaf, a(n1, this.toBBox), a(o4, this.toBBox), i2 ? t1[i2 - 1].children.push(o4) : this._splitRoot(n1, o4);
    }, r.prototype._splitRoot = function(t1, i2) {
        this.data = p([
            t1,
            i2
        ]), this.data.height = t1.height + 1, this.data.leaf = !1, a(this.data, this.toBBox);
    }, r.prototype._chooseSplitIndex = function(t1, i2, n1) {
        for(var r3, e3, a4, o4, s2, l2, u3, m3 = 1 / 0, c3 = 1 / 0, p1 = i2; p1 <= n1 - i2; p1++){
            var d1 = h(t1, 0, p1, this.toBBox), x = h(t1, p1, n1, this.toBBox), v = (e3 = d1, a4 = x, o4 = void 0, s2 = void 0, l2 = void 0, u3 = void 0, o4 = Math.max(e3.minX, a4.minX), s2 = Math.max(e3.minY, a4.minY), l2 = Math.min(e3.maxX, a4.maxX), u3 = Math.min(e3.maxY, a4.maxY), Math.max(0, l2 - o4) * Math.max(0, u3 - s2)), M = f(d1) + f(x);
            v < m3 ? (m3 = v, r3 = p1, c3 = M < c3 ? M : c3) : v === m3 && M < c3 && (c3 = M, r3 = p1);
        }
        return r3 || n1 - i2;
    }, r.prototype._chooseSplitAxis = function(t1, i2, n1) {
        var r3 = t1.leaf ? this.compareMinX : s, e3 = t1.leaf ? this.compareMinY : l;
        this._allDistMargin(t1, i2, n1, r3) < this._allDistMargin(t1, i2, n1, e3) && t1.children.sort(r3);
    }, r.prototype._allDistMargin = function(t1, i2, n1, r3) {
        t1.children.sort(r3);
        for(var e3 = this.toBBox, a4 = h(t1, 0, i2, e3), s2 = h(t1, n1 - i2, n1, e3), l2 = u(a4) + u(s2), f2 = i2; f2 < n1 - i2; f2++){
            var m3 = t1.children[f2];
            o(a4, t1.leaf ? e3(m3) : m3), l2 += u(a4);
        }
        for(var c3 = n1 - i2 - 1; c3 >= i2; c3--){
            var p1 = t1.children[c3];
            o(s2, t1.leaf ? e3(p1) : p1), l2 += u(s2);
        }
        return l2;
    }, r.prototype._adjustParentBBoxes = function(t1, i2, n1) {
        for(var r3 = n1; r3 >= 0; r3--)o(i2[r3], t1);
    }, r.prototype._condense = function(t1) {
        for(var i2 = t1.length - 1, n1 = void 0; i2 >= 0; i2--)0 === t1[i2].children.length ? i2 > 0 ? (n1 = t1[i2 - 1].children).splice(n1.indexOf(t1[i2]), 1) : this.clear() : a(t1[i2], this.toBBox);
    }, r;
});

},{}],"9N9zp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */ parcelHelpers.export(exports, "toFunction", ()=>toFunction
);
/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */ parcelHelpers.export(exports, "createDefaultStyle", ()=>createDefaultStyle
);
/**
 * Default styles for editing features.
 * @return {Object<import("../geom/GeometryType.js").default, Array<Style>>} Styles
 */ parcelHelpers.export(exports, "createEditingStyle", ()=>createEditingStyle
);
/**
 * @module ol/style/Style
 */ var _circleJs = require("./Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _fillJs = require("./Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _geometryTypeJs = require("../geom/GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _strokeJs = require("./Stroke.js");
var _strokeJsDefault = parcelHelpers.interopDefault(_strokeJs);
var _assertsJs = require("../asserts.js");
/**
 * A function that takes an {@link module:ol/Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style} or an array of them. This way e.g. a
 * vector layer can be styled. If the function returns `undefined`, the
 * feature will not be rendered.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
 */ /**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */ /**
 * A function that takes an {@link module:ol/Feature} as argument and returns an
 * {@link module:ol/geom/Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */ /**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State): void}
 * RenderFunction
 */ /**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */ /**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * ## Feature styles
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Fill, Stroke, Circle, Style} from 'ol/style';
 *
 *  var fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)'
 *  });
 *  var stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25
 *  });
 *  var styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5
 *      }),
 *      fill: fill,
 *      stroke: stroke
 *    })
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Fill, Stroke, Circle, Style} from 'ol/style';
 *  import GeometryType from 'ol/geom/GeometryType';
 *
 *  var white = [255, 255, 255, 1];
 *  var blue = [0, 153, 255, 1];
 *  var width = 3;
 *  styles[GeometryType.POLYGON] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5]
 *      })
 *    })
 *  ];
 *  styles[GeometryType.MULTI_POLYGON] =
 *      styles[GeometryType.POLYGON];
 *  styles[GeometryType.LINE_STRING] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2
 *      })
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width
 *      })
 *    })
 *  ];
 *  styles[GeometryType.MULTI_LINE_STRING] =
 *      styles[GeometryType.LINE_STRING];
 *  styles[GeometryType.POINT] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2
 *        })
 *      }),
 *      zIndex: Infinity
 *    })
 *  ];
 *  styles[GeometryType.MULTI_POINT] =
 *      styles[GeometryType.POINT];
 *  styles[GeometryType.GEOMETRY_COLLECTION] =
 *      styles[GeometryType.POLYGON].concat(
 *          styles[GeometryType.LINE_STRING],
 *          styles[GeometryType.POINT]
 *      );
 * ```
 *
 * @api
 */ var Style = function() {
    /**
     * @param {Options} [opt_options] Style options.
     */ function Style1(opt_options) {
        var options = opt_options || {
        };
        /**
         * @private
         * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
         */ this.geometry_ = null;
        /**
         * @private
         * @type {!GeometryFunction}
         */ this.geometryFunction_ = defaultGeometryFunction;
        if (options.geometry !== undefined) this.setGeometry(options.geometry);
        /**
         * @private
         * @type {import("./Fill.js").default}
         */ this.fill_ = options.fill !== undefined ? options.fill : null;
        /**
         * @private
         * @type {import("./Image.js").default}
         */ this.image_ = options.image !== undefined ? options.image : null;
        /**
         * @private
         * @type {RenderFunction|null}
         */ this.renderer_ = options.renderer !== undefined ? options.renderer : null;
        /**
         * @private
         * @type {import("./Stroke.js").default}
         */ this.stroke_ = options.stroke !== undefined ? options.stroke : null;
        /**
         * @private
         * @type {import("./Text.js").default}
         */ this.text_ = options.text !== undefined ? options.text : null;
        /**
         * @private
         * @type {number|undefined}
         */ this.zIndex_ = options.zIndex;
    }
    /**
     * Clones the style.
     * @return {Style} The cloned style.
     * @api
     */ Style1.prototype.clone = function() {
        var geometry = this.getGeometry();
        if (geometry && typeof geometry === 'object') geometry = /** @type {import("../geom/Geometry.js").default} */ geometry.clone();
        return new Style1({
            geometry: geometry,
            fill: this.getFill() ? this.getFill().clone() : undefined,
            image: this.getImage() ? this.getImage().clone() : undefined,
            renderer: this.getRenderer(),
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            text: this.getText() ? this.getText().clone() : undefined,
            zIndex: this.getZIndex()
        });
    };
    /**
     * Get the custom renderer function that was configured with
     * {@link #setRenderer} or the `renderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */ Style1.prototype.getRenderer = function() {
        return this.renderer_;
    };
    /**
     * Sets a custom renderer function for this style. When set, `fill`, `stroke`
     * and `image` options of the style will be ignored.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */ Style1.prototype.setRenderer = function(renderer) {
        this.renderer_ = renderer;
    };
    /**
     * Get the geometry to be rendered.
     * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
     * Feature property or geometry or function that returns the geometry that will
     * be rendered with this style.
     * @api
     */ Style1.prototype.getGeometry = function() {
        return this.geometry_;
    };
    /**
     * Get the function used to generate a geometry for rendering.
     * @return {!GeometryFunction} Function that is called with a feature
     * and returns the geometry to render instead of the feature's geometry.
     * @api
     */ Style1.prototype.getGeometryFunction = function() {
        return this.geometryFunction_;
    };
    /**
     * Get the fill style.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */ Style1.prototype.getFill = function() {
        return this.fill_;
    };
    /**
     * Set the fill style.
     * @param {import("./Fill.js").default} fill Fill style.
     * @api
     */ Style1.prototype.setFill = function(fill) {
        this.fill_ = fill;
    };
    /**
     * Get the image style.
     * @return {import("./Image.js").default} Image style.
     * @api
     */ Style1.prototype.getImage = function() {
        return this.image_;
    };
    /**
     * Set the image style.
     * @param {import("./Image.js").default} image Image style.
     * @api
     */ Style1.prototype.setImage = function(image) {
        this.image_ = image;
    };
    /**
     * Get the stroke style.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */ Style1.prototype.getStroke = function() {
        return this.stroke_;
    };
    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default} stroke Stroke style.
     * @api
     */ Style1.prototype.setStroke = function(stroke) {
        this.stroke_ = stroke;
    };
    /**
     * Get the text style.
     * @return {import("./Text.js").default} Text style.
     * @api
     */ Style1.prototype.getText = function() {
        return this.text_;
    };
    /**
     * Set the text style.
     * @param {import("./Text.js").default} text Text style.
     * @api
     */ Style1.prototype.setText = function(text) {
        this.text_ = text;
    };
    /**
     * Get the z-index for the style.
     * @return {number|undefined} ZIndex.
     * @api
     */ Style1.prototype.getZIndex = function() {
        return this.zIndex_;
    };
    /**
     * Set a geometry that is rendered instead of the feature's geometry.
     *
     * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
     *     Feature property or geometry or function returning a geometry to render
     *     for this style.
     * @api
     */ Style1.prototype.setGeometry = function(geometry) {
        if (typeof geometry === 'function') this.geometryFunction_ = geometry;
        else if (typeof geometry === 'string') this.geometryFunction_ = function(feature) {
            return feature.get(geometry);
        };
        else if (!geometry) this.geometryFunction_ = defaultGeometryFunction;
        else if (geometry !== undefined) this.geometryFunction_ = function() {
            return geometry;
        };
        this.geometry_ = geometry;
    };
    /**
     * Set the z-index.
     *
     * @param {number|undefined} zIndex ZIndex.
     * @api
     */ Style1.prototype.setZIndex = function(zIndex) {
        this.zIndex_ = zIndex;
    };
    return Style1;
}();
function toFunction(obj) {
    var styleFunction;
    if (typeof obj === 'function') styleFunction = obj;
    else {
        /**
         * @type {Array<Style>}
         */ var styles_1;
        if (Array.isArray(obj)) styles_1 = obj;
        else {
            _assertsJs.assert(typeof /** @type {?} */ obj.getZIndex === 'function', 41); // Expected an `Style` or an array of `Style`
            var style = obj;
            styles_1 = [
                style
            ];
        }
        styleFunction = function() {
            return styles_1;
        };
    }
    return styleFunction;
}
/**
 * @type {Array<Style>}
 */ var defaultStyles = null;
function createDefaultStyle(feature, resolution) {
    // We don't use an immediately-invoked function
    // and a closure so we don't get an error at script evaluation time in
    // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
    // canvas.getContext('2d') at construction time, which will cause an.error
    // in such browsers.)
    if (!defaultStyles) {
        var fill = new _fillJsDefault.default({
            color: 'rgba(255,255,255,0.4)'
        });
        var stroke = new _strokeJsDefault.default({
            color: '#3399CC',
            width: 1.25
        });
        defaultStyles = [
            new Style({
                image: new _circleJsDefault.default({
                    fill: fill,
                    stroke: stroke,
                    radius: 5
                }),
                fill: fill,
                stroke: stroke
            }), 
        ];
    }
    return defaultStyles;
}
function createEditingStyle() {
    /** @type {Object<import("../geom/GeometryType.js").default, Array<Style>>} */ var styles = {
    };
    var white = [
        255,
        255,
        255,
        1
    ];
    var blue = [
        0,
        153,
        255,
        1
    ];
    var width = 3;
    styles[_geometryTypeJsDefault.default.POLYGON] = [
        new Style({
            fill: new _fillJsDefault.default({
                color: [
                    255,
                    255,
                    255,
                    0.5
                ]
            })
        }), 
    ];
    styles[_geometryTypeJsDefault.default.MULTI_POLYGON] = styles[_geometryTypeJsDefault.default.POLYGON];
    styles[_geometryTypeJsDefault.default.LINE_STRING] = [
        new Style({
            stroke: new _strokeJsDefault.default({
                color: white,
                width: width + 2
            })
        }),
        new Style({
            stroke: new _strokeJsDefault.default({
                color: blue,
                width: width
            })
        }), 
    ];
    styles[_geometryTypeJsDefault.default.MULTI_LINE_STRING] = styles[_geometryTypeJsDefault.default.LINE_STRING];
    styles[_geometryTypeJsDefault.default.CIRCLE] = styles[_geometryTypeJsDefault.default.POLYGON].concat(styles[_geometryTypeJsDefault.default.LINE_STRING]);
    styles[_geometryTypeJsDefault.default.POINT] = [
        new Style({
            image: new _circleJsDefault.default({
                radius: width * 2,
                fill: new _fillJsDefault.default({
                    color: blue
                }),
                stroke: new _strokeJsDefault.default({
                    color: white,
                    width: width / 2
                })
            }),
            zIndex: Infinity
        }), 
    ];
    styles[_geometryTypeJsDefault.default.MULTI_POINT] = styles[_geometryTypeJsDefault.default.POINT];
    styles[_geometryTypeJsDefault.default.GEOMETRY_COLLECTION] = styles[_geometryTypeJsDefault.default.POLYGON].concat(styles[_geometryTypeJsDefault.default.LINE_STRING], styles[_geometryTypeJsDefault.default.POINT]);
    return styles;
}
/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */ function defaultGeometryFunction(feature) {
    return feature.getGeometry();
}
exports.default = Style;

},{"./Circle.js":"igecK","./Fill.js":"bJ6U2","../geom/GeometryType.js":"3sRlw","./Stroke.js":"bT7BW","../asserts.js":"cnrP4","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"igecK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _regularShapeJs = require("./RegularShape.js");
var _regularShapeJsDefault = parcelHelpers.interopDefault(_regularShapeJs);
/**
 * @module ol/style/Circle
 */ var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {Array<number>} [displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.
 * @property {number} [rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 */ /**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */ var CircleStyle1 = function(_super) {
    __extends(CircleStyle2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function CircleStyle2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        _this = _super.call(this, {
            points: Infinity,
            fill: options.fill,
            radius: options.radius,
            stroke: options.stroke,
            scale: options.scale !== undefined ? options.scale : 1,
            rotation: options.rotation !== undefined ? options.rotation : 0,
            rotateWithView: options.rotateWithView !== undefined ? options.rotateWithView : false,
            displacement: options.displacement !== undefined ? options.displacement : [
                0,
                0
            ]
        }) || this;
        return _this;
    }
    /**
     * Clones the style.
     * @return {CircleStyle} The cloned style.
     * @api
     */ CircleStyle2.prototype.clone = function() {
        var scale = this.getScale();
        var style = new CircleStyle2({
            fill: this.getFill() ? this.getFill().clone() : undefined,
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            radius: this.getRadius(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            displacement: this.getDisplacement().slice()
        });
        style.setOpacity(this.getOpacity());
        return style;
    };
    /**
     * Set the circle radius.
     *
     * @param {number} radius Circle radius.
     * @api
     */ CircleStyle2.prototype.setRadius = function(radius) {
        this.radius_ = radius;
        this.render();
    };
    return CircleStyle2;
}(_regularShapeJsDefault.default);
exports.default = CircleStyle1;

},{"./RegularShape.js":"dPxON","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"dPxON":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _imageJs = require("./Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _colorJs = require("../color.js");
var _colorlikeJs = require("../colorlike.js");
var _domJs = require("../dom.js");
var _canvasJs = require("../render/canvas.js");
/**
 * @module ol/style/RegularShape
 */ var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] First radius of a star. Ignored if radius is set.
 * @property {number} [radius2] Second radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
 * @property {Array<number>} [displacement=[0,0]] Displacement of the shape
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `radius`, `radius1` and `radius2`.
 */ /**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike} [strokeStyle] StrokeStyle.
 * @property {number} strokeWidth StrokeWidth.
 * @property {number} size Size.
 * @property {Array<number>} lineDash LineDash.
 * @property {number} lineDashOffset LineDashOffset.
 * @property {CanvasLineJoin} lineJoin LineJoin.
 * @property {number} miterLimit MiterLimit.
 */ /**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */ var RegularShape1 = function(_super) {
    __extends(RegularShape2, _super);
    /**
     * @param {Options} options Options.
     */ function RegularShape2(options) {
        var _this = this;
        /**
         * @type {boolean}
         */ var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
        _this = _super.call(this, {
            opacity: 1,
            rotateWithView: rotateWithView,
            rotation: options.rotation !== undefined ? options.rotation : 0,
            scale: options.scale !== undefined ? options.scale : 1,
            displacement: options.displacement !== undefined ? options.displacement : [
                0,
                0
            ]
        }) || this;
        /**
         * @private
         * @type {Object<number, HTMLCanvasElement>}
         */ _this.canvas_ = undefined;
        /**
         * @private
         * @type {HTMLCanvasElement}
         */ _this.hitDetectionCanvas_ = null;
        /**
         * @private
         * @type {import("./Fill.js").default}
         */ _this.fill_ = options.fill !== undefined ? options.fill : null;
        /**
         * @private
         * @type {Array<number>}
         */ _this.origin_ = [
            0,
            0
        ];
        /**
         * @private
         * @type {number}
         */ _this.points_ = options.points;
        /**
         * @protected
         * @type {number}
         */ _this.radius_ = options.radius !== undefined ? options.radius : options.radius1;
        /**
         * @private
         * @type {number|undefined}
         */ _this.radius2_ = options.radius2;
        /**
         * @private
         * @type {number}
         */ _this.angle_ = options.angle !== undefined ? options.angle : 0;
        /**
         * @private
         * @type {import("./Stroke.js").default}
         */ _this.stroke_ = options.stroke !== undefined ? options.stroke : null;
        /**
         * @private
         * @type {Array<number>}
         */ _this.anchor_ = null;
        /**
         * @private
         * @type {import("../size.js").Size}
         */ _this.size_ = null;
        /**
         * @private
         * @type {RenderOptions}
         */ _this.renderOptions_ = null;
        _this.render();
        return _this;
    }
    /**
     * Clones the style.
     * @return {RegularShape} The cloned style.
     * @api
     */ RegularShape2.prototype.clone = function() {
        var scale = this.getScale();
        var style = new RegularShape2({
            fill: this.getFill() ? this.getFill().clone() : undefined,
            points: this.getPoints(),
            radius: this.getRadius(),
            radius2: this.getRadius2(),
            angle: this.getAngle(),
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            displacement: this.getDisplacement().slice()
        });
        style.setOpacity(this.getOpacity());
        return style;
    };
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     */ RegularShape2.prototype.getAnchor = function() {
        return this.anchor_;
    };
    /**
     * Get the angle used in generating the shape.
     * @return {number} Shape's rotation in radians.
     * @api
     */ RegularShape2.prototype.getAngle = function() {
        return this.angle_;
    };
    /**
     * Get the fill style for the shape.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */ RegularShape2.prototype.getFill = function() {
        return this.fill_;
    };
    /**
     * @return {HTMLCanvasElement} Image element.
     */ RegularShape2.prototype.getHitDetectionImage = function() {
        if (!this.hitDetectionCanvas_) this.createHitDetectionCanvas_(this.renderOptions_);
        return this.hitDetectionCanvas_;
    };
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLCanvasElement} Image or Canvas element.
     * @api
     */ RegularShape2.prototype.getImage = function(pixelRatio) {
        var image = this.canvas_[pixelRatio];
        if (!image) {
            var renderOptions = this.renderOptions_;
            var context = _domJs.createCanvasContext2D(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);
            this.draw_(renderOptions, context, pixelRatio);
            image = context.canvas;
            this.canvas_[pixelRatio] = image;
        }
        return image;
    };
    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     */ RegularShape2.prototype.getPixelRatio = function(pixelRatio) {
        return pixelRatio;
    };
    /**
     * @return {import("../size.js").Size} Image size.
     */ RegularShape2.prototype.getImageSize = function() {
        return this.size_;
    };
    /**
     * @return {import("../ImageState.js").default} Image state.
     */ RegularShape2.prototype.getImageState = function() {
        return _imageStateJsDefault.default.LOADED;
    };
    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     */ RegularShape2.prototype.getOrigin = function() {
        return this.origin_;
    };
    /**
     * Get the number of points for generating the shape.
     * @return {number} Number of points for stars and regular polygons.
     * @api
     */ RegularShape2.prototype.getPoints = function() {
        return this.points_;
    };
    /**
     * Get the (primary) radius for the shape.
     * @return {number} Radius.
     * @api
     */ RegularShape2.prototype.getRadius = function() {
        return this.radius_;
    };
    /**
     * Get the secondary radius for the shape.
     * @return {number|undefined} Radius2.
     * @api
     */ RegularShape2.prototype.getRadius2 = function() {
        return this.radius2_;
    };
    /**
     * Get the size of the symbolizer (in pixels).
     * @return {import("../size.js").Size} Size.
     * @api
     */ RegularShape2.prototype.getSize = function() {
        return this.size_;
    };
    /**
     * Get the stroke style for the shape.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */ RegularShape2.prototype.getStroke = function() {
        return this.stroke_;
    };
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */ RegularShape2.prototype.listenImageChange = function(listener) {
    };
    /**
     * Load not yet loaded URI.
     */ RegularShape2.prototype.load = function() {
    };
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */ RegularShape2.prototype.unlistenImageChange = function(listener) {
    };
    /**
     * Calculate additional canvas size needed for the miter.
     * @param {string} lineJoin Line join
     * @param {number} strokeWidth Stroke width
     * @param {number} miterLimit Miter limit
     * @return {number} Additional canvas size needed
     * @private
     */ RegularShape2.prototype.calculateLineJoinSize_ = function(lineJoin, strokeWidth, miterLimit) {
        if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== 'bevel' && lineJoin !== 'miter') return strokeWidth;
        // m  | ^
        // i  | |\                  .
        // t >|  #\
        // e  | |\ \              .
        // r      \s\
        //      |  \t\          .                 .
        //          \r\                      .   .
        //      |    \o\      .          .  . . .
        //          e \k\            .  .    . .
        //      |      \e\  .    .  .       . .
        //       d      \ \  .  .          . .
        //      | _ _a_ _\#  .            . .
        //   r1          / `             . .
        //      |                       . .
        //       b     /               . .
        //      |                     . .
        //           / r2            . .
        //      |                        .   .
        //         /                           .   .
        //      |Î±                                   .   .
        //       /                                         .   .
        //      Â° center
        var r1 = this.radius_;
        var r2 = this.radius2_ === undefined ? r1 : this.radius2_;
        if (r1 < r2) {
            var tmp = r1;
            r1 = r2;
            r2 = tmp;
        }
        var points = this.radius2_ === undefined ? this.points_ : this.points_ * 2;
        var alpha = 2 * Math.PI / points;
        var a = r2 * Math.sin(alpha);
        var b = Math.sqrt(r2 * r2 - a * a);
        var d = r1 - b;
        var e = Math.sqrt(a * a + d * d);
        var miterRatio = e / a;
        if (lineJoin === 'miter' && miterRatio <= miterLimit) return miterRatio * strokeWidth;
        // Calculate the distnce from center to the stroke corner where
        // it was cut short because of the miter limit.
        //              l
        //        ----+---- <= distance from center to here is maxr
        //       /####|k ##\
        //      /#####^#####\
        //     /#### /+\# s #\
        //    /### h/+++\# t #\
        //   /### t/+++++\# r #\
        //  /### a/+++++++\# o #\
        // /### p/++ fill +\# k #\
        ///#### /+++++^+++++\# e #\
        //#####/+++++/+\+++++\#####\
        var k = strokeWidth / 2 / miterRatio;
        var l = strokeWidth / 2 * (d / e);
        var maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
        var bevelAdd = maxr - r1;
        if (this.radius2_ === undefined || lineJoin === 'bevel') return bevelAdd * 2;
        // If outer miter is over the miter limit the inner miter may reach through the
        // center and be longer than the bevel, same calculation as above but swap r1 / r2.
        var aa = r1 * Math.sin(alpha);
        var bb = Math.sqrt(r1 * r1 - aa * aa);
        var dd = r2 - bb;
        var ee = Math.sqrt(aa * aa + dd * dd);
        var innerMiterRatio = ee / aa;
        if (innerMiterRatio <= miterLimit) {
            var innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
            return 2 * Math.max(bevelAdd, innerLength);
        }
        return bevelAdd * 2;
    };
    /**
     * @return {RenderOptions}  The render options
     * @protected
     */ RegularShape2.prototype.createRenderOptions = function() {
        var lineJoin = _canvasJs.defaultLineJoin;
        var miterLimit = 0;
        var lineDash = null;
        var lineDashOffset = 0;
        var strokeStyle;
        var strokeWidth = 0;
        if (this.stroke_) {
            strokeStyle = this.stroke_.getColor();
            if (strokeStyle === null) strokeStyle = _canvasJs.defaultStrokeStyle;
            strokeStyle = _colorlikeJs.asColorLike(strokeStyle);
            strokeWidth = this.stroke_.getWidth();
            if (strokeWidth === undefined) strokeWidth = _canvasJs.defaultLineWidth;
            lineDash = this.stroke_.getLineDash();
            lineDashOffset = this.stroke_.getLineDashOffset();
            lineJoin = this.stroke_.getLineJoin();
            if (lineJoin === undefined) lineJoin = _canvasJs.defaultLineJoin;
            miterLimit = this.stroke_.getMiterLimit();
            if (miterLimit === undefined) miterLimit = _canvasJs.defaultMiterLimit;
        }
        var add = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
        var maxRadius = Math.max(this.radius_, this.radius2_ || 0);
        var size = Math.ceil(2 * maxRadius + add);
        return {
            strokeStyle: strokeStyle,
            strokeWidth: strokeWidth,
            size: size,
            lineDash: lineDash,
            lineDashOffset: lineDashOffset,
            lineJoin: lineJoin,
            miterLimit: miterLimit
        };
    };
    /**
     * @protected
     */ RegularShape2.prototype.render = function() {
        this.renderOptions_ = this.createRenderOptions();
        var size = this.renderOptions_.size;
        var displacement = this.getDisplacement();
        this.canvas_ = {
        };
        this.anchor_ = [
            size / 2 - displacement[0],
            size / 2 + displacement[1]
        ];
        this.size_ = [
            size,
            size
        ];
    };
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The rendering context.
     * @param {number} pixelRatio The pixel ratio.
     */ RegularShape2.prototype.draw_ = function(renderOptions, context, pixelRatio) {
        context.scale(pixelRatio, pixelRatio);
        // set origin to canvas center
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        if (this.fill_) {
            var color = this.fill_.getColor();
            if (color === null) color = _canvasJs.defaultFillStyle;
            context.fillStyle = _colorlikeJs.asColorLike(color);
            context.fill();
        }
        if (this.stroke_) {
            context.strokeStyle = renderOptions.strokeStyle;
            context.lineWidth = renderOptions.strokeWidth;
            if (context.setLineDash && renderOptions.lineDash) {
                context.setLineDash(renderOptions.lineDash);
                context.lineDashOffset = renderOptions.lineDashOffset;
            }
            context.lineJoin = renderOptions.lineJoin;
            context.miterLimit = renderOptions.miterLimit;
            context.stroke();
        }
    };
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     */ RegularShape2.prototype.createHitDetectionCanvas_ = function(renderOptions) {
        if (this.fill_) {
            var color = this.fill_.getColor();
            // determine if fill is transparent (or pattern or gradient)
            var opacity = 0;
            if (typeof color === 'string') color = _colorJs.asArray(color);
            if (color === null) opacity = 1;
            else if (Array.isArray(color)) opacity = color.length === 4 ? color[3] : 1;
            if (opacity === 0) {
                // if a transparent fill style is set, create an extra hit-detection image
                // with a default fill style
                var context = _domJs.createCanvasContext2D(renderOptions.size, renderOptions.size);
                this.hitDetectionCanvas_ = context.canvas;
                this.drawHitDetectionCanvas_(renderOptions, context);
            }
        }
        if (!this.hitDetectionCanvas_) this.hitDetectionCanvas_ = this.getImage(1);
    };
    /**
     * @private
     * @param {CanvasRenderingContext2D} context The context to draw in.
     */ RegularShape2.prototype.createPath_ = function(context) {
        var points = this.points_;
        var radius = this.radius_;
        if (points === Infinity) context.arc(0, 0, radius, 0, 2 * Math.PI);
        else {
            var radius2 = this.radius2_ === undefined ? radius : this.radius2_;
            if (this.radius2_ !== undefined) points *= 2;
            var startAngle = this.angle_ - Math.PI / 2;
            var step = 2 * Math.PI / points;
            for(var i = 0; i < points; i++){
                var angle0 = startAngle + i * step;
                var radiusC = i % 2 === 0 ? radius : radius2;
                context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
            }
            context.closePath();
        }
    };
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The context.
     */ RegularShape2.prototype.drawHitDetectionCanvas_ = function(renderOptions, context) {
        // set origin to canvas center
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        context.fillStyle = _canvasJs.defaultFillStyle;
        context.fill();
        if (this.stroke_) {
            context.strokeStyle = renderOptions.strokeStyle;
            context.lineWidth = renderOptions.strokeWidth;
            if (renderOptions.lineDash) {
                context.setLineDash(renderOptions.lineDash);
                context.lineDashOffset = renderOptions.lineDashOffset;
            }
            context.lineJoin = renderOptions.lineJoin;
            context.miterLimit = renderOptions.miterLimit;
            context.stroke();
        }
    };
    return RegularShape2;
}(_imageJsDefault.default);
exports.default = RegularShape1;

},{"../ImageState.js":"9Ji45","./Image.js":"yHj36","../color.js":"liKgX","../colorlike.js":"fW2wi","../dom.js":"akJqt","../render/canvas.js":"hMw4S","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9Ji45":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    ERROR: 3,
    EMPTY: 4
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"yHj36":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/style/Image
 */ var _utilJs = require("../util.js");
var _sizeJs = require("../size.js");
/**
 * @typedef {Object} Options
 * @property {number} opacity Opacity.
 * @property {boolean} rotateWithView If the image should get rotated with the view.
 * @property {number} rotation Rotation.
 * @property {number|import("../size.js").Size} scale Scale.
 * @property {Array<number>} displacement Displacement.
 */ /**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */ var ImageStyle = function() {
    /**
     * @param {Options} options Options.
     */ function ImageStyle1(options) {
        /**
         * @private
         * @type {number}
         */ this.opacity_ = options.opacity;
        /**
         * @private
         * @type {boolean}
         */ this.rotateWithView_ = options.rotateWithView;
        /**
         * @private
         * @type {number}
         */ this.rotation_ = options.rotation;
        /**
         * @private
         * @type {number|import("../size.js").Size}
         */ this.scale_ = options.scale;
        /**
         * @private
         * @type {import("../size.js").Size}
         */ this.scaleArray_ = _sizeJs.toSize(options.scale);
        /**
         * @private
         * @type {Array<number>}
         */ this.displacement_ = options.displacement;
    }
    /**
     * Clones the style.
     * @return {ImageStyle} The cloned style.
     * @api
     */ ImageStyle1.prototype.clone = function() {
        var scale = this.getScale();
        return new ImageStyle1({
            opacity: this.getOpacity(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            displacement: this.getDisplacement().slice()
        });
    };
    /**
     * Get the symbolizer opacity.
     * @return {number} Opacity.
     * @api
     */ ImageStyle1.prototype.getOpacity = function() {
        return this.opacity_;
    };
    /**
     * Determine whether the symbolizer rotates with the map.
     * @return {boolean} Rotate with map.
     * @api
     */ ImageStyle1.prototype.getRotateWithView = function() {
        return this.rotateWithView_;
    };
    /**
     * Get the symoblizer rotation.
     * @return {number} Rotation.
     * @api
     */ ImageStyle1.prototype.getRotation = function() {
        return this.rotation_;
    };
    /**
     * Get the symbolizer scale.
     * @return {number|import("../size.js").Size} Scale.
     * @api
     */ ImageStyle1.prototype.getScale = function() {
        return this.scale_;
    };
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */ ImageStyle1.prototype.getScaleArray = function() {
        return this.scaleArray_;
    };
    /**
     * Get the displacement of the shape
     * @return {Array<number>} Shape's center displacement
     * @api
     */ ImageStyle1.prototype.getDisplacement = function() {
        return this.displacement_;
    };
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @abstract
     * @return {Array<number>} Anchor.
     */ ImageStyle1.prototype.getAnchor = function() {
        return _utilJs.abstract();
    };
    /**
     * Get the image element for the symbolizer.
     * @abstract
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
     */ ImageStyle1.prototype.getImage = function(pixelRatio) {
        return _utilJs.abstract();
    };
    /**
     * @abstract
     * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
     */ ImageStyle1.prototype.getHitDetectionImage = function() {
        return _utilJs.abstract();
    };
    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     */ ImageStyle1.prototype.getPixelRatio = function(pixelRatio) {
        return 1;
    };
    /**
     * @abstract
     * @return {import("../ImageState.js").default} Image state.
     */ ImageStyle1.prototype.getImageState = function() {
        return _utilJs.abstract();
    };
    /**
     * @abstract
     * @return {import("../size.js").Size} Image size.
     */ ImageStyle1.prototype.getImageSize = function() {
        return _utilJs.abstract();
    };
    /**
     * Get the origin of the symbolizer.
     * @abstract
     * @return {Array<number>} Origin.
     */ ImageStyle1.prototype.getOrigin = function() {
        return _utilJs.abstract();
    };
    /**
     * Get the size of the symbolizer (in pixels).
     * @abstract
     * @return {import("../size.js").Size} Size.
     */ ImageStyle1.prototype.getSize = function() {
        return _utilJs.abstract();
    };
    /**
     * Set the opacity.
     *
     * @param {number} opacity Opacity.
     * @api
     */ ImageStyle1.prototype.setOpacity = function(opacity) {
        this.opacity_ = opacity;
    };
    /**
     * Set whether to rotate the style with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */ ImageStyle1.prototype.setRotateWithView = function(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
    };
    /**
     * Set the rotation.
     *
     * @param {number} rotation Rotation.
     * @api
     */ ImageStyle1.prototype.setRotation = function(rotation) {
        this.rotation_ = rotation;
    };
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size} scale Scale.
     * @api
     */ ImageStyle1.prototype.setScale = function(scale) {
        this.scale_ = scale;
        this.scaleArray_ = _sizeJs.toSize(scale);
    };
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */ ImageStyle1.prototype.listenImageChange = function(listener) {
        _utilJs.abstract();
    };
    /**
     * Load not yet loaded URI.
     * @abstract
     */ ImageStyle1.prototype.load = function() {
        _utilJs.abstract();
    };
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */ ImageStyle1.prototype.unlistenImageChange = function(listener) {
        _utilJs.abstract();
    };
    return ImageStyle1;
}();
exports.default = ImageStyle;

},{"../util.js":"9zOhk","../size.js":"5PZ8p","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"fW2wi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */ /**
 * @param {import("./color.js").Color|ColorLike} color Color.
 * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */ parcelHelpers.export(exports, "asColorLike", ()=>asColorLike
);
/**
 * @module ol/colorlike
 */ var _colorJs = require("./color.js");
function asColorLike(color) {
    if (Array.isArray(color)) return _colorJs.toString(color);
    else return color;
}

},{"./color.js":"liKgX","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bJ6U2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/style/Fill
 */ /**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color=null] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */ /**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */ var Fill = function() {
    /**
     * @param {Options} [opt_options] Options.
     */ function Fill1(opt_options) {
        var options = opt_options || {
        };
        /**
         * @private
         * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
         */ this.color_ = options.color !== undefined ? options.color : null;
    }
    /**
     * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
     * @return {Fill} The cloned style.
     * @api
     */ Fill1.prototype.clone = function() {
        var color = this.getColor();
        return new Fill1({
            color: Array.isArray(color) ? color.slice() : color || undefined
        });
    };
    /**
     * Get the fill color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
     * @api
     */ Fill1.prototype.getColor = function() {
        return this.color_;
    };
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
     * @api
     */ Fill1.prototype.setColor = function(color) {
        this.color_ = color;
    };
    return Fill1;
}();
exports.default = Fill;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bT7BW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/style/Stroke
 */ /**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
 * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on
 * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */ /**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */ var Stroke = function() {
    /**
     * @param {Options} [opt_options] Options.
     */ function Stroke1(opt_options) {
        var options = opt_options || {
        };
        /**
         * @private
         * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
         */ this.color_ = options.color !== undefined ? options.color : null;
        /**
         * @private
         * @type {CanvasLineCap|undefined}
         */ this.lineCap_ = options.lineCap;
        /**
         * @private
         * @type {Array<number>}
         */ this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
        /**
         * @private
         * @type {number|undefined}
         */ this.lineDashOffset_ = options.lineDashOffset;
        /**
         * @private
         * @type {CanvasLineJoin|undefined}
         */ this.lineJoin_ = options.lineJoin;
        /**
         * @private
         * @type {number|undefined}
         */ this.miterLimit_ = options.miterLimit;
        /**
         * @private
         * @type {number|undefined}
         */ this.width_ = options.width;
    }
    /**
     * Clones the style.
     * @return {Stroke} The cloned style.
     * @api
     */ Stroke1.prototype.clone = function() {
        var color = this.getColor();
        return new Stroke1({
            color: Array.isArray(color) ? color.slice() : color || undefined,
            lineCap: this.getLineCap(),
            lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
            lineDashOffset: this.getLineDashOffset(),
            lineJoin: this.getLineJoin(),
            miterLimit: this.getMiterLimit(),
            width: this.getWidth()
        });
    };
    /**
     * Get the stroke color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
     * @api
     */ Stroke1.prototype.getColor = function() {
        return this.color_;
    };
    /**
     * Get the line cap type for the stroke.
     * @return {CanvasLineCap|undefined} Line cap.
     * @api
     */ Stroke1.prototype.getLineCap = function() {
        return this.lineCap_;
    };
    /**
     * Get the line dash style for the stroke.
     * @return {Array<number>} Line dash.
     * @api
     */ Stroke1.prototype.getLineDash = function() {
        return this.lineDash_;
    };
    /**
     * Get the line dash offset for the stroke.
     * @return {number|undefined} Line dash offset.
     * @api
     */ Stroke1.prototype.getLineDashOffset = function() {
        return this.lineDashOffset_;
    };
    /**
     * Get the line join type for the stroke.
     * @return {CanvasLineJoin|undefined} Line join.
     * @api
     */ Stroke1.prototype.getLineJoin = function() {
        return this.lineJoin_;
    };
    /**
     * Get the miter limit for the stroke.
     * @return {number|undefined} Miter limit.
     * @api
     */ Stroke1.prototype.getMiterLimit = function() {
        return this.miterLimit_;
    };
    /**
     * Get the stroke width.
     * @return {number|undefined} Width.
     * @api
     */ Stroke1.prototype.getWidth = function() {
        return this.width_;
    };
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
     * @api
     */ Stroke1.prototype.setColor = function(color) {
        this.color_ = color;
    };
    /**
     * Set the line cap.
     *
     * @param {CanvasLineCap|undefined} lineCap Line cap.
     * @api
     */ Stroke1.prototype.setLineCap = function(lineCap) {
        this.lineCap_ = lineCap;
    };
    /**
     * Set the line dash.
     *
     * Please note that Internet Explorer 10 and lower [do not support][mdn] the
     * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
     * property will have no visual effect in these browsers.
     *
     * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
     *
     * @param {Array<number>} lineDash Line dash.
     * @api
     */ Stroke1.prototype.setLineDash = function(lineDash) {
        this.lineDash_ = lineDash;
    };
    /**
     * Set the line dash offset.
     *
     * @param {number|undefined} lineDashOffset Line dash offset.
     * @api
     */ Stroke1.prototype.setLineDashOffset = function(lineDashOffset) {
        this.lineDashOffset_ = lineDashOffset;
    };
    /**
     * Set the line join.
     *
     * @param {CanvasLineJoin|undefined} lineJoin Line join.
     * @api
     */ Stroke1.prototype.setLineJoin = function(lineJoin) {
        this.lineJoin_ = lineJoin;
    };
    /**
     * Set the miter limit.
     *
     * @param {number|undefined} miterLimit Miter limit.
     * @api
     */ Stroke1.prototype.setMiterLimit = function(miterLimit) {
        this.miterLimit_ = miterLimit;
    };
    /**
     * Set the width.
     *
     * @param {number|undefined} width Width.
     * @api
     */ Stroke1.prototype.setWidth = function(width) {
        this.width_ = width;
    };
    return Stroke1;
}();
exports.default = Stroke;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7pdH9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/renderer/canvas/VectorLayer
 */ var _builderGroupJs = require("../../render/canvas/BuilderGroup.js");
var _builderGroupJsDefault = parcelHelpers.interopDefault(_builderGroupJs);
var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _executorGroupJs = require("../../render/canvas/ExecutorGroup.js");
var _executorGroupJsDefault = parcelHelpers.interopDefault(_executorGroupJs);
var _viewHintJs = require("../../ViewHint.js");
var _viewHintJsDefault = parcelHelpers.interopDefault(_viewHintJs);
var _hitdetectJs = require("../../render/canvas/hitdetect.js");
var _transformJs = require("../../transform.js");
var _extentJs = require("../../extent.js");
var _cssJs = require("../../css.js");
var _vectorJs = require("../vector.js");
var _arrayJs = require("../../array.js");
var _projJs = require("../../proj.js");
var _utilJs = require("../../util.js");
var _coordinateJs = require("../../coordinate.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */ var CanvasVectorLayerRenderer1 = function(_super) {
    __extends(CanvasVectorLayerRenderer2, _super);
    /**
     * @param {import("../../layer/Vector.js").default} vectorLayer Vector layer.
     */ function CanvasVectorLayerRenderer2(vectorLayer) {
        var _this = _super.call(this, vectorLayer) || this;
        /** @private */ _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
        /**
         * @type {boolean}
         */ _this.animatingOrInteracting_;
        /**
         * @private
         * @type {boolean}
         */ _this.dirty_ = false;
        /**
         * @type {ImageData}
         */ _this.hitDetectionImageData_ = null;
        /**
         * @type {Array<import("../../Feature.js").default>}
         */ _this.renderedFeatures_ = null;
        /**
         * @private
         * @type {number}
         */ _this.renderedRevision_ = -1;
        /**
         * @private
         * @type {number}
         */ _this.renderedResolution_ = NaN;
        /**
         * @private
         * @type {import("../../extent.js").Extent}
         */ _this.renderedExtent_ = _extentJs.createEmpty();
        /**
         * @private
         * @type {import("../../extent.js").Extent}
         */ _this.wrappedRenderedExtent_ = _extentJs.createEmpty();
        /**
         * @private
         * @type {number}
         */ _this.renderedRotation_;
        /**
         * @private
         * @type {import("../../coordinate").Coordinate}
         */ _this.renderedCenter_ = null;
        /**
         * @private
         * @type {import("../../proj/Projection").default}
         */ _this.renderedProjection_ = null;
        /**
         * @private
         * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
         */ _this.renderedRenderOrder_ = null;
        /**
         * @private
         * @type {import("../../render/canvas/ExecutorGroup").default}
         */ _this.replayGroup_ = null;
        /**
         * A new replay group had to be created by `prepareFrame()`
         * @type {boolean}
         */ _this.replayGroupChanged = true;
        /**
         * @type {import("../../render/canvas/ExecutorGroup").default}
         */ _this.declutterExecutorGroup = null;
        /**
         * Clipping to be performed by `renderFrame()`
         * @type {boolean}
         */ _this.clipping = true;
        return _this;
    }
    /**
     * Get a rendering container from an existing target, if compatible.
     * @param {HTMLElement} target Potential render target.
     * @param {string} transform CSS Transform.
     * @param {number} opacity Opacity.
     */ CanvasVectorLayerRenderer2.prototype.useContainer = function(target, transform, opacity) {
        if (opacity < 1) target = null;
        _super.prototype.useContainer.call(this, target, transform, opacity);
    };
    /**
     * @param {ExecutorGroup} executorGroup Executor group.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @param {import("rbush").default} [opt_declutterTree] Declutter tree.
     */ CanvasVectorLayerRenderer2.prototype.renderWorlds = function(executorGroup, frameState, opt_declutterTree) {
        var extent = frameState.extent;
        var viewState = frameState.viewState;
        var center = viewState.center;
        var resolution = viewState.resolution;
        var projection = viewState.projection;
        var rotation = viewState.rotation;
        var projectionExtent = projection.getExtent();
        var vectorSource = this.getLayer().getSource();
        var pixelRatio = frameState.pixelRatio;
        var viewHints = frameState.viewHints;
        var snapToPixel = !(viewHints[_viewHintJsDefault.default.ANIMATING] || viewHints[_viewHintJsDefault.default.INTERACTING]);
        var context = this.context;
        var width = Math.round(frameState.size[0] * pixelRatio);
        var height = Math.round(frameState.size[1] * pixelRatio);
        var multiWorld = vectorSource.getWrapX() && projection.canWrapX();
        var worldWidth = multiWorld ? _extentJs.getWidth(projectionExtent) : null;
        var endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
        var world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
        do {
            var transform = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);
            executorGroup.execute(context, 1, transform, rotation, snapToPixel, undefined, opt_declutterTree);
        }while ((++world) < endWorld)
    };
    /**
     * Render declutter items for this layer
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     */ CanvasVectorLayerRenderer2.prototype.renderDeclutter = function(frameState) {
        if (this.declutterExecutorGroup) this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);
    };
    /**
     * Render the layer.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     */ CanvasVectorLayerRenderer2.prototype.renderFrame = function(frameState, target) {
        var pixelRatio = frameState.pixelRatio;
        var layerState = frameState.layerStatesArray[frameState.layerIndex];
        // set forward and inverse pixel transforms
        _transformJs.makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
        _transformJs.makeInverse(this.inversePixelTransform, this.pixelTransform);
        var canvasTransform = _transformJs.toString(this.pixelTransform);
        this.useContainer(target, canvasTransform, layerState.opacity);
        var context = this.context;
        var canvas = context.canvas;
        var replayGroup = this.replayGroup_;
        var declutterExecutorGroup = this.declutterExecutorGroup;
        if ((!replayGroup || replayGroup.isEmpty()) && (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())) return null;
        // resize and clear
        var width = Math.round(frameState.size[0] * pixelRatio);
        var height = Math.round(frameState.size[1] * pixelRatio);
        if (canvas.width != width || canvas.height != height) {
            canvas.width = width;
            canvas.height = height;
            if (canvas.style.transform !== canvasTransform) canvas.style.transform = canvasTransform;
        } else if (!this.containerReused) context.clearRect(0, 0, width, height);
        this.preRender(context, frameState);
        var viewState = frameState.viewState;
        var projection = viewState.projection;
        // clipped rendering if layer extent is set
        var clipped = false;
        var render = true;
        if (layerState.extent && this.clipping) {
            var layerExtent = _projJs.fromUserExtent(layerState.extent, projection);
            render = _extentJs.intersects(layerExtent, frameState.extent);
            clipped = render && !_extentJs.containsExtent(layerExtent, frameState.extent);
            if (clipped) this.clipUnrotated(context, frameState, layerExtent);
        }
        if (render) this.renderWorlds(replayGroup, frameState);
        if (clipped) context.restore();
        this.postRender(context, frameState);
        var opacity = _cssJs.cssOpacity(layerState.opacity);
        var container = this.container;
        if (opacity !== container.style.opacity) container.style.opacity = opacity;
        if (this.renderedRotation_ !== viewState.rotation) {
            this.renderedRotation_ = viewState.rotation;
            this.hitDetectionImageData_ = null;
        }
        return this.container;
    };
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
     */ CanvasVectorLayerRenderer2.prototype.getFeatures = function(pixel) {
        return new Promise(/**
         * @param {function(Array<import("../../Feature").default|import("../../render/Feature").default>): void} resolve Resolver function.
         * @this {CanvasVectorLayerRenderer}
         */ (function(resolve) {
            if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
                var size = [
                    this.context.canvas.width,
                    this.context.canvas.height
                ];
                _transformJs.apply(this.pixelTransform, size);
                var center = this.renderedCenter_;
                var resolution = this.renderedResolution_;
                var rotation = this.renderedRotation_;
                var projection = this.renderedProjection_;
                var extent = this.wrappedRenderedExtent_;
                var layer = this.getLayer();
                var transforms = [];
                var width = size[0] * _hitdetectJs.HIT_DETECT_RESOLUTION;
                var height = size[1] * _hitdetectJs.HIT_DETECT_RESOLUTION;
                transforms.push(this.getRenderTransform(center, resolution, rotation, _hitdetectJs.HIT_DETECT_RESOLUTION, width, height, 0).slice());
                var source = layer.getSource();
                var projectionExtent = projection.getExtent();
                if (source.getWrapX() && projection.canWrapX() && !_extentJs.containsExtent(projectionExtent, extent)) {
                    var startX = extent[0];
                    var worldWidth = _extentJs.getWidth(projectionExtent);
                    var world = 0;
                    var offsetX = void 0;
                    while(startX < projectionExtent[0]){
                        --world;
                        offsetX = worldWidth * world;
                        transforms.push(this.getRenderTransform(center, resolution, rotation, _hitdetectJs.HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
                        startX += worldWidth;
                    }
                    world = 0;
                    startX = extent[2];
                    while(startX > projectionExtent[2]){
                        ++world;
                        offsetX = worldWidth * world;
                        transforms.push(this.getRenderTransform(center, resolution, rotation, _hitdetectJs.HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
                        startX -= worldWidth;
                    }
                }
                this.hitDetectionImageData_ = _hitdetectJs.createHitDetectionImageData(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
            }
            resolve(_hitdetectJs.hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
        }).bind(this));
    };
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */ CanvasVectorLayerRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
        var _this = this;
        if (!this.replayGroup_) return undefined;
        var resolution = frameState.viewState.resolution;
        var rotation = frameState.viewState.rotation;
        var layer = this.getLayer();
        /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */ var features = {
        };
        /**
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
         * @param {number} distanceSq The squared distance to the click position
         * @return {T|undefined} Callback result.
         */ var featureCallback = function(feature, geometry, distanceSq) {
            var key = _utilJs.getUid(feature);
            var match = features[key];
            if (!match) {
                if (distanceSq === 0) {
                    features[key] = true;
                    return callback(feature, layer, geometry);
                }
                matches.push(features[key] = {
                    feature: feature,
                    layer: layer,
                    geometry: geometry,
                    distanceSq: distanceSq,
                    callback: callback
                });
            } else if (match !== true && distanceSq < match.distanceSq) {
                if (distanceSq === 0) {
                    features[key] = true;
                    matches.splice(matches.lastIndexOf(match), 1);
                    return callback(feature, layer, geometry);
                }
                match.geometry = geometry;
                match.distanceSq = distanceSq;
            }
            return undefined;
        };
        var result;
        var executorGroups = [
            this.replayGroup_
        ];
        if (this.declutterExecutorGroup) executorGroups.push(this.declutterExecutorGroup);
        executorGroups.some(function(executorGroup) {
            return result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === _this.declutterExecutorGroup ? frameState.declutterTree.all().map(function(item) {
                return item.value;
            }) : null);
        });
        return result;
    };
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     */ CanvasVectorLayerRenderer2.prototype.handleFontsChanged = function() {
        var layer = this.getLayer();
        if (layer.getVisible() && this.replayGroup_) layer.changed();
    };
    /**
     * Handle changes in image style state.
     * @param {import("../../events/Event.js").default} event Image style change event.
     * @private
     */ CanvasVectorLayerRenderer2.prototype.handleStyleImageChange_ = function(event) {
        this.renderIfReadyAndVisible();
    };
    /**
     * Determine whether render should be called.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */ CanvasVectorLayerRenderer2.prototype.prepareFrame = function(frameState) {
        var vectorLayer = this.getLayer();
        var vectorSource = vectorLayer.getSource();
        if (!vectorSource) return false;
        var animating = frameState.viewHints[_viewHintJsDefault.default.ANIMATING];
        var interacting = frameState.viewHints[_viewHintJsDefault.default.INTERACTING];
        var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
        var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
        if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
            this.animatingOrInteracting_ = true;
            return true;
        }
        this.animatingOrInteracting_ = false;
        var frameStateExtent = frameState.extent;
        var viewState = frameState.viewState;
        var projection = viewState.projection;
        var resolution = viewState.resolution;
        var pixelRatio = frameState.pixelRatio;
        var vectorLayerRevision = vectorLayer.getRevision();
        var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
        var vectorLayerRenderOrder = vectorLayer.getRenderOrder();
        if (vectorLayerRenderOrder === undefined) vectorLayerRenderOrder = _vectorJs.defaultOrder;
        var center = viewState.center.slice();
        var extent = _extentJs.buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);
        var renderedExtent = extent.slice();
        var loadExtents = [
            extent.slice()
        ];
        var projectionExtent = projection.getExtent();
        if (vectorSource.getWrapX() && projection.canWrapX() && !_extentJs.containsExtent(projectionExtent, frameState.extent)) {
            // For the replay group, we need an extent that intersects the real world
            // (-180Â° to +180Â°). To support geometries in a coordinate range from -540Â°
            // to +540Â°, we add at least 1 world width on each side of the projection
            // extent. If the viewport is wider than the world, we need to add half of
            // the viewport width to make sure we cover the whole viewport.
            var worldWidth = _extentJs.getWidth(projectionExtent);
            var gutter = Math.max(_extentJs.getWidth(extent) / 2, worldWidth);
            extent[0] = projectionExtent[0] - gutter;
            extent[2] = projectionExtent[2] + gutter;
            _coordinateJs.wrapX(center, projection);
            var loadExtent = _extentJs.wrapX(loadExtents[0], projection);
            // If the extent crosses the date line, we load data for both edges of the worlds
            if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) loadExtents.push([
                loadExtent[0] + worldWidth,
                loadExtent[1],
                loadExtent[2] + worldWidth,
                loadExtent[3], 
            ]);
            else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) loadExtents.push([
                loadExtent[0] - worldWidth,
                loadExtent[1],
                loadExtent[2] - worldWidth,
                loadExtent[3], 
            ]);
        }
        if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && _extentJs.containsExtent(this.wrappedRenderedExtent_, extent)) {
            if (!_arrayJs.equals(this.renderedExtent_, renderedExtent)) {
                this.hitDetectionImageData_ = null;
                this.renderedExtent_ = renderedExtent;
            }
            this.renderedCenter_ = center;
            this.replayGroupChanged = false;
            return true;
        }
        this.replayGroup_ = null;
        this.dirty_ = false;
        var replayGroup = new _builderGroupJsDefault.default(_vectorJs.getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio);
        var declutterBuilderGroup;
        if (this.getLayer().getDeclutter()) declutterBuilderGroup = new _builderGroupJsDefault.default(_vectorJs.getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio);
        var userProjection = _projJs.getUserProjection();
        var userTransform;
        if (userProjection) {
            for(var i = 0, ii = loadExtents.length; i < ii; ++i){
                var extent_1 = loadExtents[i];
                var userExtent_1 = _projJs.toUserExtent(extent_1, projection);
                vectorSource.loadFeatures(userExtent_1, _projJs.toUserResolution(resolution, projection), userProjection);
            }
            userTransform = _projJs.getTransformFromProjections(userProjection, projection);
        } else for(var i = 0, ii = loadExtents.length; i < ii; ++i)vectorSource.loadFeatures(loadExtents[i], resolution, projection);
        var squaredTolerance = _vectorJs.getSquaredTolerance(resolution, pixelRatio);
        var render = /**
         * @param {import("../../Feature.js").default} feature Feature.
         * @this {CanvasVectorLayerRenderer}
         */ (function(feature) {
            var styles;
            var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
            if (styleFunction) styles = styleFunction(feature, resolution);
            if (styles) {
                var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);
                this.dirty_ = this.dirty_ || dirty;
            }
        }).bind(this);
        var userExtent = _projJs.toUserExtent(extent, projection);
        /** @type {Array<import("../../Feature.js").default>} */ var features = vectorSource.getFeaturesInExtent(userExtent);
        if (vectorLayerRenderOrder) features.sort(vectorLayerRenderOrder);
        for(var i = 0, ii = features.length; i < ii; ++i)render(features[i]);
        this.renderedFeatures_ = features;
        var replayGroupInstructions = replayGroup.finish();
        var executorGroup = new _executorGroupJsDefault.default(extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());
        if (declutterBuilderGroup) this.declutterExecutorGroup = new _executorGroupJsDefault.default(extent, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());
        this.renderedResolution_ = resolution;
        this.renderedRevision_ = vectorLayerRevision;
        this.renderedRenderOrder_ = vectorLayerRenderOrder;
        this.renderedExtent_ = renderedExtent;
        this.wrappedRenderedExtent_ = extent;
        this.renderedCenter_ = center;
        this.renderedProjection_ = projection;
        this.replayGroup_ = executorGroup;
        this.hitDetectionImageData_ = null;
        this.replayGroupChanged = true;
        return true;
    };
    /**
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {number} squaredTolerance Squared render tolerance.
     * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
     * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
     * @param {import("../../proj.js").TransformFunction} [opt_transform] Transform from user to view projection.
     * @param {import("../../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
     * @return {boolean} `true` if an image is loading.
     */ CanvasVectorLayerRenderer2.prototype.renderFeature = function(feature, squaredTolerance, styles, builderGroup, opt_transform, opt_declutterBuilderGroup) {
        if (!styles) return false;
        var loading = false;
        if (Array.isArray(styles)) for(var i = 0, ii = styles.length; i < ii; ++i)loading = _vectorJs.renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup) || loading;
        else loading = _vectorJs.renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup);
        return loading;
    };
    return CanvasVectorLayerRenderer2;
}(_layerJsDefault.default);
exports.default = CanvasVectorLayerRenderer1;

},{"../../render/canvas/BuilderGroup.js":"ccXXR","./Layer.js":"5l48A","../../render/canvas/ExecutorGroup.js":"cAXof","../../ViewHint.js":"EJUkL","../../render/canvas/hitdetect.js":"7bjIB","../../transform.js":"C21tg","../../extent.js":"jgUz2","../../css.js":"23c5q","../vector.js":"iNqng","../../array.js":"jKNP0","../../proj.js":"hmdWM","../../util.js":"9zOhk","../../coordinate.js":"cmApa","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"ccXXR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/render/canvas/BuilderGroup
 */ var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _imageBuilderJs = require("./ImageBuilder.js");
var _imageBuilderJsDefault = parcelHelpers.interopDefault(_imageBuilderJs);
var _lineStringBuilderJs = require("./LineStringBuilder.js");
var _lineStringBuilderJsDefault = parcelHelpers.interopDefault(_lineStringBuilderJs);
var _polygonBuilderJs = require("./PolygonBuilder.js");
var _polygonBuilderJsDefault = parcelHelpers.interopDefault(_polygonBuilderJs);
var _textBuilderJs = require("./TextBuilder.js");
var _textBuilderJsDefault = parcelHelpers.interopDefault(_textBuilderJs);
/**
 * @type {Object<import("./BuilderType").default, typeof Builder>}
 */ var BATCH_CONSTRUCTORS = {
    'Circle': _polygonBuilderJsDefault.default,
    'Default': _builderJsDefault.default,
    'Image': _imageBuilderJsDefault.default,
    'LineString': _lineStringBuilderJsDefault.default,
    'Polygon': _polygonBuilderJsDefault.default,
    'Text': _textBuilderJsDefault.default
};
var BuilderGroup = function() {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Max extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */ function BuilderGroup1(tolerance, maxExtent, resolution, pixelRatio) {
        /**
         * @private
         * @type {number}
         */ this.tolerance_ = tolerance;
        /**
         * @private
         * @type {import("../../extent.js").Extent}
         */ this.maxExtent_ = maxExtent;
        /**
         * @private
         * @type {number}
         */ this.pixelRatio_ = pixelRatio;
        /**
         * @private
         * @type {number}
         */ this.resolution_ = resolution;
        /**
         * @private
         * @type {!Object<string, !Object<import("./BuilderType").default, Builder>>}
         */ this.buildersByZIndex_ = {
        };
    }
    /**
     * @return {!Object<string, !Object<import("./BuilderType").default, import("./Builder.js").SerializableInstructions>>} The serializable instructions
     */ BuilderGroup1.prototype.finish = function() {
        var builderInstructions = {
        };
        for(var zKey in this.buildersByZIndex_){
            builderInstructions[zKey] = builderInstructions[zKey] || {
            };
            var builders = this.buildersByZIndex_[zKey];
            for(var builderKey in builders){
                var builderInstruction = builders[builderKey].finish();
                builderInstructions[zKey][builderKey] = builderInstruction;
            }
        }
        return builderInstructions;
    };
    /**
     * @param {number|undefined} zIndex Z index.
     * @param {import("./BuilderType.js").default} builderType Replay type.
     * @return {import("../VectorContext.js").default} Replay.
     */ BuilderGroup1.prototype.getBuilder = function(zIndex, builderType) {
        var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
        var replays = this.buildersByZIndex_[zIndexKey];
        if (replays === undefined) {
            replays = {
            };
            this.buildersByZIndex_[zIndexKey] = replays;
        }
        var replay = replays[builderType];
        if (replay === undefined) {
            var Constructor = BATCH_CONSTRUCTORS[builderType];
            replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
            replays[builderType] = replay;
        }
        return replay;
    };
    return BuilderGroup1;
}();
exports.default = BuilderGroup;

},{"./Builder.js":"2NIdB","./ImageBuilder.js":"5tt7S","./LineStringBuilder.js":"1k9cP","./PolygonBuilder.js":"gB0oE","./TextBuilder.js":"jejRx","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"2NIdB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/render/canvas/Builder
 */ var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _geometryTypeJs = require("../../geom/GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _relationshipJs = require("../../extent/Relationship.js");
var _relationshipJsDefault = parcelHelpers.interopDefault(_relationshipJs);
var _vectorContextJs = require("../VectorContext.js");
var _vectorContextJsDefault = parcelHelpers.interopDefault(_vectorContextJs);
var _colorlikeJs = require("../../colorlike.js");
var _extentJs = require("../../extent.js");
var _canvasJs = require("../canvas.js");
var _arrayJs = require("../../array.js");
var _inflateJs = require("../../geom/flat/inflate.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var CanvasBuilder1 = function(_super) {
    __extends(CanvasBuilder2, _super);
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */ function CanvasBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
        var _this = _super.call(this) || this;
        /**
         * @protected
         * @type {number}
         */ _this.tolerance = tolerance;
        /**
         * @protected
         * @const
         * @type {import("../../extent.js").Extent}
         */ _this.maxExtent = maxExtent;
        /**
         * @protected
         * @type {number}
         */ _this.pixelRatio = pixelRatio;
        /**
         * @protected
         * @type {number}
         */ _this.maxLineWidth = 0;
        /**
         * @protected
         * @const
         * @type {number}
         */ _this.resolution = resolution;
        /**
         * @private
         * @type {Array<*>}
         */ _this.beginGeometryInstruction1_ = null;
        /**
         * @private
         * @type {Array<*>}
         */ _this.beginGeometryInstruction2_ = null;
        /**
         * @private
         * @type {import("../../extent.js").Extent}
         */ _this.bufferedMaxExtent_ = null;
        /**
         * @protected
         * @type {Array<*>}
         */ _this.instructions = [];
        /**
         * @protected
         * @type {Array<number>}
         */ _this.coordinates = [];
        /**
         * @private
         * @type {import("../../coordinate.js").Coordinate}
         */ _this.tmpCoordinate_ = [];
        /**
         * @protected
         * @type {Array<*>}
         */ _this.hitDetectionInstructions = [];
        /**
         * @protected
         * @type {import("../canvas.js").FillStrokeState}
         */ _this.state = {
        };
        return _this;
    }
    /**
     * @protected
     * @param {Array<number>} dashArray Dash array.
     * @return {Array<number>} Dash array with pixel ratio applied
     */ CanvasBuilder2.prototype.applyPixelRatio = function(dashArray) {
        var pixelRatio = this.pixelRatio;
        return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
            return dash * pixelRatio;
        });
    };
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} stride Stride.
     * @protected
     * @return {number} My end
     */ CanvasBuilder2.prototype.appendFlatPointCoordinates = function(flatCoordinates, stride) {
        var extent = this.getBufferedMaxExtent();
        var tmpCoord = this.tmpCoordinate_;
        var coordinates = this.coordinates;
        var myEnd = coordinates.length;
        for(var i = 0, ii = flatCoordinates.length; i < ii; i += stride){
            tmpCoord[0] = flatCoordinates[i];
            tmpCoord[1] = flatCoordinates[i + 1];
            if (_extentJs.containsCoordinate(extent, tmpCoord)) {
                coordinates[myEnd++] = tmpCoord[0];
                coordinates[myEnd++] = tmpCoord[1];
            }
        }
        return myEnd;
    };
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} closed Last input coordinate equals first.
     * @param {boolean} skipFirst Skip first coordinate.
     * @protected
     * @return {number} My end.
     */ CanvasBuilder2.prototype.appendFlatLineCoordinates = function(flatCoordinates, offset, end, stride, closed, skipFirst) {
        var coordinates = this.coordinates;
        var myEnd = coordinates.length;
        var extent = this.getBufferedMaxExtent();
        if (skipFirst) offset += stride;
        var lastXCoord = flatCoordinates[offset];
        var lastYCoord = flatCoordinates[offset + 1];
        var nextCoord = this.tmpCoordinate_;
        var skipped = true;
        var i, lastRel, nextRel;
        for(i = offset + stride; i < end; i += stride){
            nextCoord[0] = flatCoordinates[i];
            nextCoord[1] = flatCoordinates[i + 1];
            nextRel = _extentJs.coordinateRelationship(extent, nextCoord);
            if (nextRel !== lastRel) {
                if (skipped) {
                    coordinates[myEnd++] = lastXCoord;
                    coordinates[myEnd++] = lastYCoord;
                    skipped = false;
                }
                coordinates[myEnd++] = nextCoord[0];
                coordinates[myEnd++] = nextCoord[1];
            } else if (nextRel === _relationshipJsDefault.default.INTERSECTING) {
                coordinates[myEnd++] = nextCoord[0];
                coordinates[myEnd++] = nextCoord[1];
                skipped = false;
            } else skipped = true;
            lastXCoord = nextCoord[0];
            lastYCoord = nextCoord[1];
            lastRel = nextRel;
        }
        // Last coordinate equals first or only one point to append:
        if (closed && skipped || i === offset + stride) {
            coordinates[myEnd++] = lastXCoord;
            coordinates[myEnd++] = lastYCoord;
        }
        return myEnd;
    };
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Array<number>} builderEnds Builder ends.
     * @return {number} Offset.
     */ CanvasBuilder2.prototype.drawCustomCoordinates_ = function(flatCoordinates, offset, ends, stride, builderEnds) {
        for(var i = 0, ii = ends.length; i < ii; ++i){
            var end = ends[i];
            var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
            builderEnds.push(builderEnd);
            offset = end;
        }
        return offset;
    };
    /**
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     */ CanvasBuilder2.prototype.drawCustom = function(geometry, feature, renderer) {
        this.beginGeometry(geometry, feature);
        var type = geometry.getType();
        var stride = geometry.getStride();
        var builderBegin = this.coordinates.length;
        var flatCoordinates, builderEnd, builderEnds, builderEndss;
        var offset;
        if (type == _geometryTypeJsDefault.default.MULTI_POLYGON) {
            flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getOrientedFlatCoordinates();
            builderEndss = [];
            var endss = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getEndss();
            offset = 0;
            for(var i = 0, ii = endss.length; i < ii; ++i){
                var myEnds = [];
                offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
                builderEndss.push(myEnds);
            }
            this.instructions.push([
                _instructionJsDefault.default.CUSTOM,
                builderBegin,
                builderEndss,
                geometry,
                renderer, _inflateJs.inflateMultiCoordinatesArray, ]);
        } else if (type == _geometryTypeJsDefault.default.POLYGON || type == _geometryTypeJsDefault.default.MULTI_LINE_STRING) {
            builderEnds = [];
            flatCoordinates = type == _geometryTypeJsDefault.default.POLYGON ? /** @type {import("../../geom/Polygon.js").default} */ geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
            offset = this.drawCustomCoordinates_(flatCoordinates, 0, /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */ geometry.getEnds(), stride, builderEnds);
            this.instructions.push([
                _instructionJsDefault.default.CUSTOM,
                builderBegin,
                builderEnds,
                geometry,
                renderer, _inflateJs.inflateCoordinatesArray, ]);
        } else if (type == _geometryTypeJsDefault.default.LINE_STRING || type == _geometryTypeJsDefault.default.CIRCLE) {
            flatCoordinates = geometry.getFlatCoordinates();
            builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
            this.instructions.push([
                _instructionJsDefault.default.CUSTOM,
                builderBegin,
                builderEnd,
                geometry,
                renderer, _inflateJs.inflateCoordinates, ]);
        } else if (type == _geometryTypeJsDefault.default.MULTI_POINT) {
            flatCoordinates = geometry.getFlatCoordinates();
            builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
            if (builderEnd > builderBegin) this.instructions.push([
                _instructionJsDefault.default.CUSTOM,
                builderBegin,
                builderEnd,
                geometry,
                renderer, _inflateJs.inflateCoordinates, ]);
        } else if (type == _geometryTypeJsDefault.default.POINT) {
            flatCoordinates = geometry.getFlatCoordinates();
            this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
            builderEnd = this.coordinates.length;
            this.instructions.push([
                _instructionJsDefault.default.CUSTOM,
                builderBegin,
                builderEnd,
                geometry,
                renderer, 
            ]);
        }
        this.endGeometry(feature);
    };
    /**
     * @protected
     * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */ CanvasBuilder2.prototype.beginGeometry = function(geometry, feature) {
        this.beginGeometryInstruction1_ = [
            _instructionJsDefault.default.BEGIN_GEOMETRY,
            feature,
            0,
            geometry, 
        ];
        this.instructions.push(this.beginGeometryInstruction1_);
        this.beginGeometryInstruction2_ = [
            _instructionJsDefault.default.BEGIN_GEOMETRY,
            feature,
            0,
            geometry, 
        ];
        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
    };
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */ CanvasBuilder2.prototype.finish = function() {
        return {
            instructions: this.instructions,
            hitDetectionInstructions: this.hitDetectionInstructions,
            coordinates: this.coordinates
        };
    };
    /**
     * Reverse the hit detection instructions.
     */ CanvasBuilder2.prototype.reverseHitDetectionInstructions = function() {
        var hitDetectionInstructions = this.hitDetectionInstructions;
        // step 1 - reverse array
        hitDetectionInstructions.reverse();
        // step 2 - reverse instructions within geometry blocks
        var i;
        var n = hitDetectionInstructions.length;
        var instruction;
        var type;
        var begin = -1;
        for(i = 0; i < n; ++i){
            instruction = hitDetectionInstructions[i];
            type = instruction[0];
            if (type == _instructionJsDefault.default.END_GEOMETRY) begin = i;
            else if (type == _instructionJsDefault.default.BEGIN_GEOMETRY) {
                instruction[2] = i;
                _arrayJs.reverseSubArray(this.hitDetectionInstructions, begin, i);
                begin = -1;
            }
        }
    };
    /**
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     */ CanvasBuilder2.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
        var state = this.state;
        if (fillStyle) {
            var fillStyleColor = fillStyle.getColor();
            state.fillStyle = _colorlikeJs.asColorLike(fillStyleColor ? fillStyleColor : _canvasJs.defaultFillStyle);
        } else state.fillStyle = undefined;
        if (strokeStyle) {
            var strokeStyleColor = strokeStyle.getColor();
            state.strokeStyle = _colorlikeJs.asColorLike(strokeStyleColor ? strokeStyleColor : _canvasJs.defaultStrokeStyle);
            var strokeStyleLineCap = strokeStyle.getLineCap();
            state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvasJs.defaultLineCap;
            var strokeStyleLineDash = strokeStyle.getLineDash();
            state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : _canvasJs.defaultLineDash;
            var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
            state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvasJs.defaultLineDashOffset;
            var strokeStyleLineJoin = strokeStyle.getLineJoin();
            state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvasJs.defaultLineJoin;
            var strokeStyleWidth = strokeStyle.getWidth();
            state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _canvasJs.defaultLineWidth;
            var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
            state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvasJs.defaultMiterLimit;
            if (state.lineWidth > this.maxLineWidth) {
                this.maxLineWidth = state.lineWidth;
                // invalidate the buffered max extent cache
                this.bufferedMaxExtent_ = null;
            }
        } else {
            state.strokeStyle = undefined;
            state.lineCap = undefined;
            state.lineDash = null;
            state.lineDashOffset = undefined;
            state.lineJoin = undefined;
            state.lineWidth = undefined;
            state.miterLimit = undefined;
        }
    };
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Fill instruction.
     */ CanvasBuilder2.prototype.createFill = function(state) {
        var fillStyle = state.fillStyle;
        /** @type {Array<*>} */ var fillInstruction = [
            _instructionJsDefault.default.SET_FILL_STYLE,
            fillStyle
        ];
        if (typeof fillStyle !== 'string') // Fill is a pattern or gradient - align it!
        fillInstruction.push(true);
        return fillInstruction;
    };
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     */ CanvasBuilder2.prototype.applyStroke = function(state) {
        this.instructions.push(this.createStroke(state));
    };
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Stroke instruction.
     */ CanvasBuilder2.prototype.createStroke = function(state) {
        return [
            _instructionJsDefault.default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth * this.pixelRatio,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            this.applyPixelRatio(state.lineDash),
            state.lineDashOffset * this.pixelRatio, 
        ];
    };
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
     */ CanvasBuilder2.prototype.updateFillStyle = function(state, createFill) {
        var fillStyle = state.fillStyle;
        if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
            if (fillStyle !== undefined) this.instructions.push(createFill.call(this, state));
            state.currentFillStyle = fillStyle;
        }
    };
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
     */ CanvasBuilder2.prototype.updateStrokeStyle = function(state, applyStroke) {
        var strokeStyle = state.strokeStyle;
        var lineCap = state.lineCap;
        var lineDash = state.lineDash;
        var lineDashOffset = state.lineDashOffset;
        var lineJoin = state.lineJoin;
        var lineWidth = state.lineWidth;
        var miterLimit = state.miterLimit;
        if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !_arrayJs.equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
            if (strokeStyle !== undefined) applyStroke.call(this, state);
            state.currentStrokeStyle = strokeStyle;
            state.currentLineCap = lineCap;
            state.currentLineDash = lineDash;
            state.currentLineDashOffset = lineDashOffset;
            state.currentLineJoin = lineJoin;
            state.currentLineWidth = lineWidth;
            state.currentMiterLimit = miterLimit;
        }
    };
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */ CanvasBuilder2.prototype.endGeometry = function(feature) {
        this.beginGeometryInstruction1_[2] = this.instructions.length;
        this.beginGeometryInstruction1_ = null;
        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
        this.beginGeometryInstruction2_ = null;
        var endGeometryInstruction = [
            _instructionJsDefault.default.END_GEOMETRY,
            feature
        ];
        this.instructions.push(endGeometryInstruction);
        this.hitDetectionInstructions.push(endGeometryInstruction);
    };
    /**
     * Get the buffered rendering extent.  Rendering will be clipped to the extent
     * provided to the constructor.  To account for symbolizers that may intersect
     * this extent, we calculate a buffered extent (e.g. based on stroke width).
     * @return {import("../../extent.js").Extent} The buffered rendering extent.
     * @protected
     */ CanvasBuilder2.prototype.getBufferedMaxExtent = function() {
        if (!this.bufferedMaxExtent_) {
            this.bufferedMaxExtent_ = _extentJs.clone(this.maxExtent);
            if (this.maxLineWidth > 0) {
                var width = this.resolution * (this.maxLineWidth + 1) / 2;
                _extentJs.buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
            }
        }
        return this.bufferedMaxExtent_;
    };
    return CanvasBuilder2;
}(_vectorContextJsDefault.default);
exports.default = CanvasBuilder1;

},{"./Instruction.js":"ki0aV","../../geom/GeometryType.js":"3sRlw","../../extent/Relationship.js":"6qC6Y","../VectorContext.js":"bbfFo","../../colorlike.js":"fW2wi","../../extent.js":"jgUz2","../canvas.js":"hMw4S","../../array.js":"jKNP0","../../geom/flat/inflate.js":"9BPwr","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"ki0aV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fillInstruction", ()=>fillInstruction
);
parcelHelpers.export(exports, "strokeInstruction", ()=>strokeInstruction
);
parcelHelpers.export(exports, "beginPathInstruction", ()=>beginPathInstruction
);
parcelHelpers.export(exports, "closePathInstruction", ()=>closePathInstruction
);
/**
 * @module ol/render/canvas/Instruction
 */ /**
 * @enum {number}
 */ var Instruction = {
    BEGIN_GEOMETRY: 0,
    BEGIN_PATH: 1,
    CIRCLE: 2,
    CLOSE_PATH: 3,
    CUSTOM: 4,
    DRAW_CHARS: 5,
    DRAW_IMAGE: 6,
    END_GEOMETRY: 7,
    FILL: 8,
    MOVE_TO_LINE_TO: 9,
    SET_FILL_STYLE: 10,
    SET_STROKE_STYLE: 11,
    STROKE: 12
};
var fillInstruction = [
    Instruction.FILL
];
var strokeInstruction = [
    Instruction.STROKE
];
var beginPathInstruction = [
    Instruction.BEGIN_PATH
];
var closePathInstruction = [
    Instruction.CLOSE_PATH
];
exports.default = Instruction;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bbfFo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/render/VectorContext
 */ /**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */ var VectorContext = function() {
    function VectorContext1() {
    }
    /**
     * Render a geometry with a custom renderer.
     *
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     */ VectorContext1.prototype.drawCustom = function(geometry, feature, renderer) {
    };
    /**
     * Render a geometry.
     *
     * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
     */ VectorContext1.prototype.drawGeometry = function(geometry) {
    };
    /**
     * Set the rendering style.
     *
     * @param {import("../style/Style.js").default} style The rendering style.
     */ VectorContext1.prototype.setStyle = function(style) {
    };
    /**
     * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../Feature.js").default} feature Feature.
     */ VectorContext1.prototype.drawCircle = function(circleGeometry, feature) {
    };
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("../style/Style.js").default} style Style.
     */ VectorContext1.prototype.drawFeature = function(feature, style) {
    };
    /**
     * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
     * @param {import("../Feature.js").default} feature Feature.
     */ VectorContext1.prototype.drawGeometryCollection = function(geometryCollectionGeometry, feature) {
    };
    /**
     * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */ VectorContext1.prototype.drawLineString = function(lineStringGeometry, feature) {
    };
    /**
     * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */ VectorContext1.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {
    };
    /**
     * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */ VectorContext1.prototype.drawMultiPoint = function(multiPointGeometry, feature) {
    };
    /**
     * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */ VectorContext1.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {
    };
    /**
     * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */ VectorContext1.prototype.drawPoint = function(pointGeometry, feature) {
    };
    /**
     * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */ VectorContext1.prototype.drawPolygon = function(polygonGeometry, feature) {
    };
    /**
     * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */ VectorContext1.prototype.drawText = function(geometry, feature) {
    };
    /**
     * @param {import("../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
     */ VectorContext1.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
    };
    /**
     * @param {import("../style/Image.js").default} imageStyle Image style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [opt_declutterImageWithText] Shared data for combined decluttering with a text style.
     */ VectorContext1.prototype.setImageStyle = function(imageStyle, opt_declutterImageWithText) {
    };
    /**
     * @param {import("../style/Text.js").default} textStyle Text style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [opt_declutterImageWithText] Shared data for combined decluttering with an image style.
     */ VectorContext1.prototype.setTextStyle = function(textStyle, opt_declutterImageWithText) {
    };
    return VectorContext1;
}();
exports.default = VectorContext;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5tt7S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/render/canvas/ImageBuilder
 */ var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var CanvasImageBuilder1 = function(_super) {
    __extends(CanvasImageBuilder2, _super);
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */ function CanvasImageBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
        var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
        /**
         * @private
         * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
         */ _this.hitDetectionImage_ = null;
        /**
         * @private
         * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
         */ _this.image_ = null;
        /**
         * @private
         * @type {number|undefined}
         */ _this.imagePixelRatio_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */ _this.anchorX_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */ _this.anchorY_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */ _this.height_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */ _this.opacity_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */ _this.originX_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */ _this.originY_ = undefined;
        /**
         * @private
         * @type {boolean|undefined}
         */ _this.rotateWithView_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */ _this.rotation_ = undefined;
        /**
         * @private
         * @type {import("../../size.js").Size|undefined}
         */ _this.scale_ = undefined;
        /**
         * @private
         * @type {number|undefined}
         */ _this.width_ = undefined;
        /**
         * Data shared with a text builder for combined decluttering.
         * @private
         * @type {import("../canvas.js").DeclutterImageWithText}
         */ _this.declutterImageWithText_ = undefined;
        return _this;
    }
    /**
     * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */ CanvasImageBuilder2.prototype.drawPoint = function(pointGeometry, feature) {
        if (!this.image_) return;
        this.beginGeometry(pointGeometry, feature);
        var flatCoordinates = pointGeometry.getFlatCoordinates();
        var stride = pointGeometry.getStride();
        var myBegin = this.coordinates.length;
        var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
            _instructionJsDefault.default.DRAW_IMAGE,
            myBegin,
            myEnd,
            this.image_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_ * this.imagePixelRatio_,
            this.anchorY_ * this.imagePixelRatio_,
            Math.ceil(this.height_ * this.imagePixelRatio_),
            this.opacity_,
            this.originX_,
            this.originY_,
            this.rotateWithView_,
            this.rotation_,
            [
                this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
                this.scale_[1] * this.pixelRatio / this.imagePixelRatio_, 
            ],
            Math.ceil(this.width_ * this.imagePixelRatio_),
            this.declutterImageWithText_, 
        ]);
        this.hitDetectionInstructions.push([
            _instructionJsDefault.default.DRAW_IMAGE,
            myBegin,
            myEnd,
            this.hitDetectionImage_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_,
            this.anchorY_,
            this.height_,
            this.opacity_,
            this.originX_,
            this.originY_,
            this.rotateWithView_,
            this.rotation_,
            this.scale_,
            this.width_,
            this.declutterImageWithText_, 
        ]);
        this.endGeometry(feature);
    };
    /**
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */ CanvasImageBuilder2.prototype.drawMultiPoint = function(multiPointGeometry, feature) {
        if (!this.image_) return;
        this.beginGeometry(multiPointGeometry, feature);
        var flatCoordinates = multiPointGeometry.getFlatCoordinates();
        var stride = multiPointGeometry.getStride();
        var myBegin = this.coordinates.length;
        var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
            _instructionJsDefault.default.DRAW_IMAGE,
            myBegin,
            myEnd,
            this.image_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_ * this.imagePixelRatio_,
            this.anchorY_ * this.imagePixelRatio_,
            Math.ceil(this.height_ * this.imagePixelRatio_),
            this.opacity_,
            this.originX_,
            this.originY_,
            this.rotateWithView_,
            this.rotation_,
            [
                this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
                this.scale_[1] * this.pixelRatio / this.imagePixelRatio_, 
            ],
            Math.ceil(this.width_ * this.imagePixelRatio_),
            this.declutterImageWithText_, 
        ]);
        this.hitDetectionInstructions.push([
            _instructionJsDefault.default.DRAW_IMAGE,
            myBegin,
            myEnd,
            this.hitDetectionImage_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_,
            this.anchorY_,
            this.height_,
            this.opacity_,
            this.originX_,
            this.originY_,
            this.rotateWithView_,
            this.rotation_,
            this.scale_,
            this.width_,
            this.declutterImageWithText_, 
        ]);
        this.endGeometry(feature);
    };
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */ CanvasImageBuilder2.prototype.finish = function() {
        this.reverseHitDetectionInstructions();
        // FIXME this doesn't really protect us against further calls to draw*Geometry
        this.anchorX_ = undefined;
        this.anchorY_ = undefined;
        this.hitDetectionImage_ = null;
        this.image_ = null;
        this.imagePixelRatio_ = undefined;
        this.height_ = undefined;
        this.scale_ = undefined;
        this.opacity_ = undefined;
        this.originX_ = undefined;
        this.originY_ = undefined;
        this.rotateWithView_ = undefined;
        this.rotation_ = undefined;
        this.width_ = undefined;
        return _super.prototype.finish.call(this);
    };
    /**
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     * @param {Object} [opt_sharedData] Shared data.
     */ CanvasImageBuilder2.prototype.setImageStyle = function(imageStyle, opt_sharedData) {
        var anchor = imageStyle.getAnchor();
        var size = imageStyle.getSize();
        var hitDetectionImage = imageStyle.getHitDetectionImage();
        var image = imageStyle.getImage(this.pixelRatio);
        var origin = imageStyle.getOrigin();
        this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
        this.anchorX_ = anchor[0];
        this.anchorY_ = anchor[1];
        this.hitDetectionImage_ = hitDetectionImage;
        this.image_ = image;
        this.height_ = size[1];
        this.opacity_ = imageStyle.getOpacity();
        this.originX_ = origin[0] * this.imagePixelRatio_;
        this.originY_ = origin[1] * this.imagePixelRatio_;
        this.rotateWithView_ = imageStyle.getRotateWithView();
        this.rotation_ = imageStyle.getRotation();
        this.scale_ = imageStyle.getScaleArray();
        this.width_ = size[0];
        this.declutterImageWithText_ = opt_sharedData;
    };
    return CanvasImageBuilder2;
}(_builderJsDefault.default);
exports.default = CanvasImageBuilder1;

},{"./Builder.js":"2NIdB","./Instruction.js":"ki0aV","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1k9cP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/render/canvas/LineStringBuilder
 */ var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _canvasJs = require("../canvas.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var CanvasLineStringBuilder1 = function(_super) {
    __extends(CanvasLineStringBuilder2, _super);
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */ function CanvasLineStringBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
        return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     * @return {number} end.
     */ CanvasLineStringBuilder2.prototype.drawFlatCoordinates_ = function(flatCoordinates, offset, end, stride) {
        var myBegin = this.coordinates.length;
        var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
        var moveToLineToInstruction = [
            _instructionJsDefault.default.MOVE_TO_LINE_TO,
            myBegin,
            myEnd, 
        ];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);
        return end;
    };
    /**
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */ CanvasLineStringBuilder2.prototype.drawLineString = function(lineStringGeometry, feature) {
        var state = this.state;
        var strokeStyle = state.strokeStyle;
        var lineWidth = state.lineWidth;
        if (strokeStyle === undefined || lineWidth === undefined) return;
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(lineStringGeometry, feature);
        this.hitDetectionInstructions.push([
            _instructionJsDefault.default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit, _canvasJs.defaultLineDash, _canvasJs.defaultLineDashOffset, ], _instructionJs.beginPathInstruction);
        var flatCoordinates = lineStringGeometry.getFlatCoordinates();
        var stride = lineStringGeometry.getStride();
        this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
        this.hitDetectionInstructions.push(_instructionJs.strokeInstruction);
        this.endGeometry(feature);
    };
    /**
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */ CanvasLineStringBuilder2.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {
        var state = this.state;
        var strokeStyle = state.strokeStyle;
        var lineWidth = state.lineWidth;
        if (strokeStyle === undefined || lineWidth === undefined) return;
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(multiLineStringGeometry, feature);
        this.hitDetectionInstructions.push([
            _instructionJsDefault.default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            state.lineDash,
            state.lineDashOffset, 
        ], _instructionJs.beginPathInstruction);
        var ends = multiLineStringGeometry.getEnds();
        var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
        var stride = multiLineStringGeometry.getStride();
        var offset = 0;
        for(var i = 0, ii = ends.length; i < ii; ++i)offset = this.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);
        this.hitDetectionInstructions.push(_instructionJs.strokeInstruction);
        this.endGeometry(feature);
    };
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */ CanvasLineStringBuilder2.prototype.finish = function() {
        var state = this.state;
        if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) this.instructions.push(_instructionJs.strokeInstruction);
        this.reverseHitDetectionInstructions();
        this.state = null;
        return _super.prototype.finish.call(this);
    };
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     */ CanvasLineStringBuilder2.prototype.applyStroke = function(state) {
        if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
            this.instructions.push(_instructionJs.strokeInstruction);
            state.lastStroke = this.coordinates.length;
        }
        state.lastStroke = 0;
        _super.prototype.applyStroke.call(this, state);
        this.instructions.push(_instructionJs.beginPathInstruction);
    };
    return CanvasLineStringBuilder2;
}(_builderJsDefault.default);
exports.default = CanvasLineStringBuilder1;

},{"./Builder.js":"2NIdB","./Instruction.js":"ki0aV","../canvas.js":"hMw4S","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"gB0oE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/render/canvas/PolygonBuilder
 */ var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _canvasJs = require("../canvas.js");
var _simplifyJs = require("../../geom/flat/simplify.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var CanvasPolygonBuilder1 = function(_super) {
    __extends(CanvasPolygonBuilder2, _super);
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */ function CanvasPolygonBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
        return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */ CanvasPolygonBuilder2.prototype.drawFlatCoordinatess_ = function(flatCoordinates, offset, ends, stride) {
        var state = this.state;
        var fill = state.fillStyle !== undefined;
        var stroke = state.strokeStyle !== undefined;
        var numEnds = ends.length;
        this.instructions.push(_instructionJs.beginPathInstruction);
        this.hitDetectionInstructions.push(_instructionJs.beginPathInstruction);
        for(var i = 0; i < numEnds; ++i){
            var end = ends[i];
            var myBegin = this.coordinates.length;
            var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
            var moveToLineToInstruction = [
                _instructionJsDefault.default.MOVE_TO_LINE_TO,
                myBegin,
                myEnd, 
            ];
            this.instructions.push(moveToLineToInstruction);
            this.hitDetectionInstructions.push(moveToLineToInstruction);
            if (stroke) {
                // Performance optimization: only call closePath() when we have a stroke.
                // Otherwise the ring is closed already (see appendFlatLineCoordinates above).
                this.instructions.push(_instructionJs.closePathInstruction);
                this.hitDetectionInstructions.push(_instructionJs.closePathInstruction);
            }
            offset = end;
        }
        if (fill) {
            this.instructions.push(_instructionJs.fillInstruction);
            this.hitDetectionInstructions.push(_instructionJs.fillInstruction);
        }
        if (stroke) {
            this.instructions.push(_instructionJs.strokeInstruction);
            this.hitDetectionInstructions.push(_instructionJs.strokeInstruction);
        }
        return offset;
    };
    /**
     * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../../Feature.js").default} feature Feature.
     */ CanvasPolygonBuilder2.prototype.drawCircle = function(circleGeometry, feature) {
        var state = this.state;
        var fillStyle = state.fillStyle;
        var strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) return;
        this.setFillStrokeStyles_();
        this.beginGeometry(circleGeometry, feature);
        if (state.fillStyle !== undefined) this.hitDetectionInstructions.push([
            _instructionJsDefault.default.SET_FILL_STYLE, _canvasJs.defaultFillStyle, ]);
        if (state.strokeStyle !== undefined) this.hitDetectionInstructions.push([
            _instructionJsDefault.default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            state.lineDash,
            state.lineDashOffset, 
        ]);
        var flatCoordinates = circleGeometry.getFlatCoordinates();
        var stride = circleGeometry.getStride();
        var myBegin = this.coordinates.length;
        this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
        var circleInstruction = [
            _instructionJsDefault.default.CIRCLE,
            myBegin
        ];
        this.instructions.push(_instructionJs.beginPathInstruction, circleInstruction);
        this.hitDetectionInstructions.push(_instructionJs.beginPathInstruction, circleInstruction);
        if (state.fillStyle !== undefined) {
            this.instructions.push(_instructionJs.fillInstruction);
            this.hitDetectionInstructions.push(_instructionJs.fillInstruction);
        }
        if (state.strokeStyle !== undefined) {
            this.instructions.push(_instructionJs.strokeInstruction);
            this.hitDetectionInstructions.push(_instructionJs.strokeInstruction);
        }
        this.endGeometry(feature);
    };
    /**
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */ CanvasPolygonBuilder2.prototype.drawPolygon = function(polygonGeometry, feature) {
        var state = this.state;
        var fillStyle = state.fillStyle;
        var strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) return;
        this.setFillStrokeStyles_();
        this.beginGeometry(polygonGeometry, feature);
        if (state.fillStyle !== undefined) this.hitDetectionInstructions.push([
            _instructionJsDefault.default.SET_FILL_STYLE, _canvasJs.defaultFillStyle, ]);
        if (state.strokeStyle !== undefined) this.hitDetectionInstructions.push([
            _instructionJsDefault.default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            state.lineDash,
            state.lineDashOffset, 
        ]);
        var ends = polygonGeometry.getEnds();
        var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
        var stride = polygonGeometry.getStride();
        this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
        this.endGeometry(feature);
    };
    /**
     * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */ CanvasPolygonBuilder2.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {
        var state = this.state;
        var fillStyle = state.fillStyle;
        var strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) return;
        this.setFillStrokeStyles_();
        this.beginGeometry(multiPolygonGeometry, feature);
        if (state.fillStyle !== undefined) this.hitDetectionInstructions.push([
            _instructionJsDefault.default.SET_FILL_STYLE, _canvasJs.defaultFillStyle, ]);
        if (state.strokeStyle !== undefined) this.hitDetectionInstructions.push([
            _instructionJsDefault.default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            state.lineDash,
            state.lineDashOffset, 
        ]);
        var endss = multiPolygonGeometry.getEndss();
        var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
        var stride = multiPolygonGeometry.getStride();
        var offset = 0;
        for(var i = 0, ii = endss.length; i < ii; ++i)offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
        this.endGeometry(feature);
    };
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */ CanvasPolygonBuilder2.prototype.finish = function() {
        this.reverseHitDetectionInstructions();
        this.state = null;
        // We want to preserve topology when drawing polygons.  Polygons are
        // simplified using quantization and point elimination. However, we might
        // have received a mix of quantized and non-quantized geometries, so ensure
        // that all are quantized by quantizing all coordinates in the batch.
        var tolerance = this.tolerance;
        if (tolerance !== 0) {
            var coordinates = this.coordinates;
            for(var i = 0, ii = coordinates.length; i < ii; ++i)coordinates[i] = _simplifyJs.snap(coordinates[i], tolerance);
        }
        return _super.prototype.finish.call(this);
    };
    /**
     * @private
     */ CanvasPolygonBuilder2.prototype.setFillStrokeStyles_ = function() {
        var state = this.state;
        var fillStyle = state.fillStyle;
        if (fillStyle !== undefined) this.updateFillStyle(state, this.createFill);
        if (state.strokeStyle !== undefined) this.updateStrokeStyle(state, this.applyStroke);
    };
    return CanvasPolygonBuilder2;
}(_builderJsDefault.default);
exports.default = CanvasPolygonBuilder1;

},{"./Builder.js":"2NIdB","./Instruction.js":"ki0aV","../canvas.js":"hMw4S","../../geom/flat/simplify.js":"7GCEm","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"jejRx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TEXT_ALIGN", ()=>TEXT_ALIGN
);
/**
 * @module ol/render/canvas/TextBuilder
 */ var _builderJs = require("./Builder.js");
var _builderJsDefault = parcelHelpers.interopDefault(_builderJs);
var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _geometryTypeJs = require("../../geom/GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _textPlacementJs = require("../../style/TextPlacement.js");
var _textPlacementJsDefault = parcelHelpers.interopDefault(_textPlacementJs);
var _colorlikeJs = require("../../colorlike.js");
var _canvasJs = require("../canvas.js");
var _utilJs = require("../../util.js");
var _extentJs = require("../../extent.js");
var _straightchunkJs = require("../../geom/flat/straightchunk.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var TEXT_ALIGN = {
    'left': 0,
    'end': 0,
    'center': 0.5,
    'right': 1,
    'start': 1,
    'top': 0,
    'middle': 0.5,
    'hanging': 0.2,
    'alphabetic': 0.8,
    'ideographic': 0.8,
    'bottom': 1
};
var CanvasTextBuilder1 = function(_super) {
    __extends(CanvasTextBuilder2, _super);
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */ function CanvasTextBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
        var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
        /**
         * @private
         * @type {Array<HTMLCanvasElement>}
         */ _this.labels_ = null;
        /**
         * @private
         * @type {string}
         */ _this.text_ = '';
        /**
         * @private
         * @type {number}
         */ _this.textOffsetX_ = 0;
        /**
         * @private
         * @type {number}
         */ _this.textOffsetY_ = 0;
        /**
         * @private
         * @type {boolean|undefined}
         */ _this.textRotateWithView_ = undefined;
        /**
         * @private
         * @type {number}
         */ _this.textRotation_ = 0;
        /**
         * @private
         * @type {?import("../canvas.js").FillState}
         */ _this.textFillState_ = null;
        /**
         * @type {!Object<string, import("../canvas.js").FillState>}
         */ _this.fillStates = {
        };
        /**
         * @private
         * @type {?import("../canvas.js").StrokeState}
         */ _this.textStrokeState_ = null;
        /**
         * @type {!Object<string, import("../canvas.js").StrokeState>}
         */ _this.strokeStates = {
        };
        /**
         * @private
         * @type {import("../canvas.js").TextState}
         */ _this.textState_ = {
        };
        /**
         * @type {!Object<string, import("../canvas.js").TextState>}
         */ _this.textStates = {
        };
        /**
         * @private
         * @type {string}
         */ _this.textKey_ = '';
        /**
         * @private
         * @type {string}
         */ _this.fillKey_ = '';
        /**
         * @private
         * @type {string}
         */ _this.strokeKey_ = '';
        /**
         * Data shared with an image builder for combined decluttering.
         * @private
         * @type {import("../canvas.js").DeclutterImageWithText}
         */ _this.declutterImageWithText_ = undefined;
        return _this;
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */ CanvasTextBuilder2.prototype.finish = function() {
        var instructions = _super.prototype.finish.call(this);
        instructions.textStates = this.textStates;
        instructions.fillStates = this.fillStates;
        instructions.strokeStates = this.strokeStates;
        return instructions;
    };
    /**
     * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */ CanvasTextBuilder2.prototype.drawText = function(geometry, feature) {
        var fillState = this.textFillState_;
        var strokeState = this.textStrokeState_;
        var textState = this.textState_;
        if (this.text_ === '' || !textState || !fillState && !strokeState) return;
        var coordinates = this.coordinates;
        var begin = coordinates.length;
        var geometryType = geometry.getType();
        var flatCoordinates = null;
        var stride = geometry.getStride();
        if (textState.placement === _textPlacementJsDefault.default.LINE && (geometryType == _geometryTypeJsDefault.default.LINE_STRING || geometryType == _geometryTypeJsDefault.default.MULTI_LINE_STRING || geometryType == _geometryTypeJsDefault.default.POLYGON || geometryType == _geometryTypeJsDefault.default.MULTI_POLYGON)) {
            if (!_extentJs.intersects(this.getBufferedMaxExtent(), geometry.getExtent())) return;
            var ends = void 0;
            flatCoordinates = geometry.getFlatCoordinates();
            if (geometryType == _geometryTypeJsDefault.default.LINE_STRING) ends = [
                flatCoordinates.length
            ];
            else if (geometryType == _geometryTypeJsDefault.default.MULTI_LINE_STRING) ends = /** @type {import("../../geom/MultiLineString.js").default} */ geometry.getEnds();
            else if (geometryType == _geometryTypeJsDefault.default.POLYGON) ends = /** @type {import("../../geom/Polygon.js").default} */ geometry.getEnds().slice(0, 1);
            else if (geometryType == _geometryTypeJsDefault.default.MULTI_POLYGON) {
                var endss = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getEndss();
                ends = [];
                for(var i = 0, ii = endss.length; i < ii; ++i)ends.push(endss[i][0]);
            }
            this.beginGeometry(geometry, feature);
            var textAlign = textState.textAlign;
            var flatOffset = 0;
            var flatEnd = void 0;
            for(var o = 0, oo = ends.length; o < oo; ++o){
                if (textAlign == undefined) {
                    var range = _straightchunkJs.matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
                    flatOffset = range[0];
                    flatEnd = range[1];
                } else flatEnd = ends[o];
                for(var i = flatOffset; i < flatEnd; i += stride)coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
                var end = coordinates.length;
                flatOffset = ends[o];
                this.drawChars_(begin, end);
                begin = end;
            }
            this.endGeometry(feature);
        } else {
            var geometryWidths = textState.overflow ? null : [];
            switch(geometryType){
                case _geometryTypeJsDefault.default.POINT:
                case _geometryTypeJsDefault.default.MULTI_POINT:
                    flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */ geometry.getFlatCoordinates();
                    break;
                case _geometryTypeJsDefault.default.LINE_STRING:
                    flatCoordinates = /** @type {import("../../geom/LineString.js").default} */ geometry.getFlatMidpoint();
                    break;
                case _geometryTypeJsDefault.default.CIRCLE:
                    flatCoordinates = /** @type {import("../../geom/Circle.js").default} */ geometry.getCenter();
                    break;
                case _geometryTypeJsDefault.default.MULTI_LINE_STRING:
                    flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */ geometry.getFlatMidpoints();
                    stride = 2;
                    break;
                case _geometryTypeJsDefault.default.POLYGON:
                    flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */ geometry.getFlatInteriorPoint();
                    if (!textState.overflow) geometryWidths.push(flatCoordinates[2] / this.resolution);
                    stride = 3;
                    break;
                case _geometryTypeJsDefault.default.MULTI_POLYGON:
                    var interiorPoints = /** @type {import("../../geom/MultiPolygon.js").default} */ geometry.getFlatInteriorPoints();
                    flatCoordinates = [];
                    for(var i = 0, ii = interiorPoints.length; i < ii; i += 3){
                        if (!textState.overflow) geometryWidths.push(interiorPoints[i + 2] / this.resolution);
                        flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
                    }
                    if (flatCoordinates.length === 0) return;
                    stride = 2;
                    break;
                default:
            }
            var end = this.appendFlatPointCoordinates(flatCoordinates, stride);
            if (end === begin) return;
            if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
                var beg_1 = begin / 2;
                geometryWidths = geometryWidths.filter(function(w, i1) {
                    var keep = coordinates[(beg_1 + i1) * 2] === flatCoordinates[i1 * stride] && coordinates[(beg_1 + i1) * 2 + 1] === flatCoordinates[i1 * stride + 1];
                    if (!keep) --beg_1;
                    return keep;
                });
            }
            this.saveTextStates_();
            if (textState.backgroundFill || textState.backgroundStroke) {
                this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
                if (textState.backgroundFill) {
                    this.updateFillStyle(this.state, this.createFill);
                    this.hitDetectionInstructions.push(this.createFill(this.state));
                }
                if (textState.backgroundStroke) {
                    this.updateStrokeStyle(this.state, this.applyStroke);
                    this.hitDetectionInstructions.push(this.createStroke(this.state));
                }
            }
            this.beginGeometry(geometry, feature);
            // adjust padding for negative scale
            var padding = textState.padding;
            if (padding != _canvasJs.defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
                var p0 = textState.padding[0];
                var p1 = textState.padding[1];
                var p2 = textState.padding[2];
                var p3 = textState.padding[3];
                if (textState.scale[0] < 0) {
                    p1 = -p1;
                    p3 = -p3;
                }
                if (textState.scale[1] < 0) {
                    p0 = -p0;
                    p2 = -p2;
                }
                padding = [
                    p0,
                    p1,
                    p2,
                    p3
                ];
            }
            // The image is unknown at this stage so we pass null; it will be computed at render time.
            // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
            // render time.
            var pixelRatio_1 = this.pixelRatio;
            this.instructions.push([
                _instructionJsDefault.default.DRAW_IMAGE,
                begin,
                end,
                null,
                NaN,
                NaN,
                NaN,
                1,
                0,
                0,
                this.textRotateWithView_,
                this.textRotation_,
                [
                    1,
                    1
                ],
                NaN,
                this.declutterImageWithText_,
                padding == _canvasJs.defaultPadding ? _canvasJs.defaultPadding : padding.map(function(p) {
                    return p * pixelRatio_1;
                }),
                !!textState.backgroundFill,
                !!textState.backgroundStroke,
                this.text_,
                this.textKey_,
                this.strokeKey_,
                this.fillKey_,
                this.textOffsetX_,
                this.textOffsetY_,
                geometryWidths, 
            ]);
            var scale = 1 / pixelRatio_1;
            this.hitDetectionInstructions.push([
                _instructionJsDefault.default.DRAW_IMAGE,
                begin,
                end,
                null,
                NaN,
                NaN,
                NaN,
                1,
                0,
                0,
                this.textRotateWithView_,
                this.textRotation_,
                [
                    scale,
                    scale
                ],
                NaN,
                this.declutterImageWithText_,
                padding,
                !!textState.backgroundFill,
                !!textState.backgroundStroke,
                this.text_,
                this.textKey_,
                this.strokeKey_,
                this.fillKey_,
                this.textOffsetX_,
                this.textOffsetY_,
                geometryWidths, 
            ]);
            this.endGeometry(feature);
        }
    };
    /**
     * @private
     */ CanvasTextBuilder2.prototype.saveTextStates_ = function() {
        var strokeState = this.textStrokeState_;
        var textState = this.textState_;
        var fillState = this.textFillState_;
        var strokeKey = this.strokeKey_;
        if (strokeState) {
            if (!(strokeKey in this.strokeStates)) this.strokeStates[strokeKey] = {
                strokeStyle: strokeState.strokeStyle,
                lineCap: strokeState.lineCap,
                lineDashOffset: strokeState.lineDashOffset,
                lineWidth: strokeState.lineWidth,
                lineJoin: strokeState.lineJoin,
                miterLimit: strokeState.miterLimit,
                lineDash: strokeState.lineDash
            };
        }
        var textKey = this.textKey_;
        if (!(textKey in this.textStates)) this.textStates[textKey] = {
            font: textState.font,
            textAlign: textState.textAlign || _canvasJs.defaultTextAlign,
            textBaseline: textState.textBaseline || _canvasJs.defaultTextBaseline,
            scale: textState.scale
        };
        var fillKey = this.fillKey_;
        if (fillState) {
            if (!(fillKey in this.fillStates)) this.fillStates[fillKey] = {
                fillStyle: fillState.fillStyle
            };
        }
    };
    /**
     * @private
     * @param {number} begin Begin.
     * @param {number} end End.
     */ CanvasTextBuilder2.prototype.drawChars_ = function(begin, end) {
        var strokeState = this.textStrokeState_;
        var textState = this.textState_;
        var strokeKey = this.strokeKey_;
        var textKey = this.textKey_;
        var fillKey = this.fillKey_;
        this.saveTextStates_();
        var pixelRatio = this.pixelRatio;
        var baseline = TEXT_ALIGN[textState.textBaseline];
        var offsetY = this.textOffsetY_ * pixelRatio;
        var text = this.text_;
        var strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
        this.instructions.push([
            _instructionJsDefault.default.DRAW_CHARS,
            begin,
            end,
            baseline,
            textState.overflow,
            fillKey,
            textState.maxAngle,
            pixelRatio,
            offsetY,
            strokeKey,
            strokeWidth * pixelRatio,
            text,
            textKey,
            1, 
        ]);
        this.hitDetectionInstructions.push([
            _instructionJsDefault.default.DRAW_CHARS,
            begin,
            end,
            baseline,
            textState.overflow,
            fillKey,
            textState.maxAngle,
            1,
            offsetY,
            strokeKey,
            strokeWidth,
            text,
            textKey,
            1 / pixelRatio, 
        ]);
    };
    /**
     * @param {import("../../style/Text.js").default} textStyle Text style.
     * @param {Object} [opt_sharedData] Shared data.
     */ CanvasTextBuilder2.prototype.setTextStyle = function(textStyle, opt_sharedData) {
        var textState, fillState, strokeState;
        if (!textStyle) this.text_ = '';
        else {
            var textFillStyle = textStyle.getFill();
            if (!textFillStyle) {
                fillState = null;
                this.textFillState_ = fillState;
            } else {
                fillState = this.textFillState_;
                if (!fillState) {
                    fillState = {
                    };
                    this.textFillState_ = fillState;
                }
                fillState.fillStyle = _colorlikeJs.asColorLike(textFillStyle.getColor() || _canvasJs.defaultFillStyle);
            }
            var textStrokeStyle = textStyle.getStroke();
            if (!textStrokeStyle) {
                strokeState = null;
                this.textStrokeState_ = strokeState;
            } else {
                strokeState = this.textStrokeState_;
                if (!strokeState) {
                    strokeState = {
                    };
                    this.textStrokeState_ = strokeState;
                }
                var lineDash = textStrokeStyle.getLineDash();
                var lineDashOffset = textStrokeStyle.getLineDashOffset();
                var lineWidth = textStrokeStyle.getWidth();
                var miterLimit = textStrokeStyle.getMiterLimit();
                strokeState.lineCap = textStrokeStyle.getLineCap() || _canvasJs.defaultLineCap;
                strokeState.lineDash = lineDash ? lineDash.slice() : _canvasJs.defaultLineDash;
                strokeState.lineDashOffset = lineDashOffset === undefined ? _canvasJs.defaultLineDashOffset : lineDashOffset;
                strokeState.lineJoin = textStrokeStyle.getLineJoin() || _canvasJs.defaultLineJoin;
                strokeState.lineWidth = lineWidth === undefined ? _canvasJs.defaultLineWidth : lineWidth;
                strokeState.miterLimit = miterLimit === undefined ? _canvasJs.defaultMiterLimit : miterLimit;
                strokeState.strokeStyle = _colorlikeJs.asColorLike(textStrokeStyle.getColor() || _canvasJs.defaultStrokeStyle);
            }
            textState = this.textState_;
            var font = textStyle.getFont() || _canvasJs.defaultFont;
            _canvasJs.registerFont(font);
            var textScale = textStyle.getScaleArray();
            textState.overflow = textStyle.getOverflow();
            textState.font = font;
            textState.maxAngle = textStyle.getMaxAngle();
            textState.placement = textStyle.getPlacement();
            textState.textAlign = textStyle.getTextAlign();
            textState.textBaseline = textStyle.getTextBaseline() || _canvasJs.defaultTextBaseline;
            textState.backgroundFill = textStyle.getBackgroundFill();
            textState.backgroundStroke = textStyle.getBackgroundStroke();
            textState.padding = textStyle.getPadding() || _canvasJs.defaultPadding;
            textState.scale = textScale === undefined ? [
                1,
                1
            ] : textScale;
            var textOffsetX = textStyle.getOffsetX();
            var textOffsetY = textStyle.getOffsetY();
            var textRotateWithView = textStyle.getRotateWithView();
            var textRotation = textStyle.getRotation();
            this.text_ = textStyle.getText() || '';
            this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
            this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
            this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
            this.textRotation_ = textRotation === undefined ? 0 : textRotation;
            this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : _utilJs.getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';
            this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?') + (textState.textBaseline || '?');
            this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + _utilJs.getUid(fillState.fillStyle) : '';
        }
        this.declutterImageWithText_ = opt_sharedData;
    };
    return CanvasTextBuilder2;
}(_builderJsDefault.default);
exports.default = CanvasTextBuilder1;

},{"./Builder.js":"2NIdB","./Instruction.js":"ki0aV","../../geom/GeometryType.js":"3sRlw","../../style/TextPlacement.js":"9g9lp","../../colorlike.js":"fW2wi","../canvas.js":"hMw4S","../../util.js":"9zOhk","../../extent.js":"jgUz2","../../geom/flat/straightchunk.js":"02CUi","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9g9lp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    POINT: 'point',
    LINE: 'line'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"02CUi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/geom/flat/straightchunk
 */ /**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */ parcelHelpers.export(exports, "matchingChunk", ()=>matchingChunk
);
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
    var chunkStart = offset;
    var chunkEnd = offset;
    var chunkM = 0;
    var m = 0;
    var start = offset;
    var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
    for(i = offset; i < end; i += stride){
        var x2 = flatCoordinates[i];
        var y2 = flatCoordinates[i + 1];
        if (x1 !== undefined) {
            x23 = x2 - x1;
            y23 = y2 - y1;
            m23 = Math.sqrt(x23 * x23 + y23 * y23);
            if (x12 !== undefined) {
                m += m12;
                acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
                if (acos > maxAngle) {
                    if (m > chunkM) {
                        chunkM = m;
                        chunkStart = start;
                        chunkEnd = i;
                    }
                    m = 0;
                    start = i - stride;
                }
            }
            m12 = m23;
            x12 = x23;
            y12 = y23;
        }
        x1 = x2;
        y1 = y2;
    }
    m += m23;
    return m > chunkM ? [
        start,
        i
    ] : [
        chunkStart,
        chunkEnd
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5l48A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/renderer/canvas/Layer
 */ var _layerJs = require("../Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _eventJs = require("../../render/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../../render/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _transformJs = require("../../transform.js");
var _extentJs = require("../../extent.js");
var _domJs = require("../../dom.js");
var _cssJs = require("../../css.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @abstract
 * @template {import("../../layer/Layer.js").default} LayerType
 * @extends {LayerRenderer<LayerType>}
 */ var CanvasLayerRenderer1 = function(_super) {
    __extends(CanvasLayerRenderer2, _super);
    /**
     * @param {LayerType} layer Layer.
     */ function CanvasLayerRenderer2(layer) {
        var _this = _super.call(this, layer) || this;
        /**
         * @protected
         * @type {HTMLElement}
         */ _this.container = null;
        /**
         * @protected
         * @type {number}
         */ _this.renderedResolution;
        /**
         * A temporary transform.  The values in this transform should only be used in a
         * function that sets the values.
         * @protected
         * @type {import("../../transform.js").Transform}
         */ _this.tempTransform = _transformJs.create();
        /**
         * The transform for rendered pixels to viewport CSS pixels.  This transform must
         * be set when rendering a frame and may be used by other functions after rendering.
         * @protected
         * @type {import("../../transform.js").Transform}
         */ _this.pixelTransform = _transformJs.create();
        /**
         * The transform for viewport CSS pixels to rendered pixels.  This transform must
         * be set when rendering a frame and may be used by other functions after rendering.
         * @protected
         * @type {import("../../transform.js").Transform}
         */ _this.inversePixelTransform = _transformJs.create();
        /**
         * @type {CanvasRenderingContext2D}
         */ _this.context = null;
        /**
         * @type {boolean}
         */ _this.containerReused = false;
        return _this;
    }
    /**
     * Get a rendering container from an existing target, if compatible.
     * @param {HTMLElement} target Potential render target.
     * @param {string} transform CSS Transform.
     * @param {number} opacity Opacity.
     */ CanvasLayerRenderer2.prototype.useContainer = function(target, transform, opacity) {
        var layerClassName = this.getLayer().getClassName();
        var container, context;
        if (target && target.style.opacity === _cssJs.cssOpacity(opacity) && target.className === layerClassName) {
            var canvas = target.firstElementChild;
            if (canvas instanceof HTMLCanvasElement) context = canvas.getContext('2d');
        }
        if (context && context.canvas.style.transform === transform) {
            // Container of the previous layer renderer can be used.
            this.container = target;
            this.context = context;
            this.containerReused = true;
        } else if (this.containerReused) {
            // Previously reused container cannot be used any more.
            this.container = null;
            this.context = null;
            this.containerReused = false;
        }
        if (!this.container) {
            container = document.createElement('div');
            container.className = layerClassName;
            var style = container.style;
            style.position = 'absolute';
            style.width = '100%';
            style.height = '100%';
            context = _domJs.createCanvasContext2D();
            var canvas = context.canvas;
            container.appendChild(canvas);
            style = canvas.style;
            style.position = 'absolute';
            style.left = '0';
            style.transformOrigin = 'top left';
            this.container = container;
            this.context = context;
        }
    };
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent Clip extent.
     * @protected
     */ CanvasLayerRenderer2.prototype.clipUnrotated = function(context, frameState, extent) {
        var topLeft = _extentJs.getTopLeft(extent);
        var topRight = _extentJs.getTopRight(extent);
        var bottomRight = _extentJs.getBottomRight(extent);
        var bottomLeft = _extentJs.getBottomLeft(extent);
        _transformJs.apply(frameState.coordinateToPixelTransform, topLeft);
        _transformJs.apply(frameState.coordinateToPixelTransform, topRight);
        _transformJs.apply(frameState.coordinateToPixelTransform, bottomRight);
        _transformJs.apply(frameState.coordinateToPixelTransform, bottomLeft);
        var inverted = this.inversePixelTransform;
        _transformJs.apply(inverted, topLeft);
        _transformJs.apply(inverted, topRight);
        _transformJs.apply(inverted, bottomRight);
        _transformJs.apply(inverted, bottomLeft);
        context.save();
        context.beginPath();
        context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
        context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
        context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
        context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
        context.clip();
    };
    /**
     * @param {import("../../render/EventType.js").default} type Event type.
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @private
     */ CanvasLayerRenderer2.prototype.dispatchRenderEvent_ = function(type, context, frameState) {
        var layer = this.getLayer();
        if (layer.hasListener(type)) {
            var event_1 = new _eventJsDefault.default(type, this.inversePixelTransform, frameState, context);
            layer.dispatchEvent(event_1);
        }
    };
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @protected
     */ CanvasLayerRenderer2.prototype.preRender = function(context, frameState) {
        this.dispatchRenderEvent_(_eventTypeJsDefault.default.PRERENDER, context, frameState);
    };
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @protected
     */ CanvasLayerRenderer2.prototype.postRender = function(context, frameState) {
        this.dispatchRenderEvent_(_eventTypeJsDefault.default.POSTRENDER, context, frameState);
    };
    /**
     * Creates a transform for rendering to an element that will be rotated after rendering.
     * @param {import("../../coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} width Width of the rendered element (in pixels).
     * @param {number} height Height of the rendered element (in pixels).
     * @param {number} offsetX Offset on the x-axis in view coordinates.
     * @protected
     * @return {!import("../../transform.js").Transform} Transform.
     */ CanvasLayerRenderer2.prototype.getRenderTransform = function(center, resolution, rotation, pixelRatio, width, height, offsetX) {
        var dx1 = width / 2;
        var dy1 = height / 2;
        var sx = pixelRatio / resolution;
        var sy = -sx;
        var dx2 = -center[0] + offsetX;
        var dy2 = -center[1];
        return _transformJs.compose(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
    };
    /**
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @param {import("../../PluggableMap.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
     *    location, null will be returned.  If there is data, but pixel values cannot be
     *    returned, and empty array will be returned.
     */ CanvasLayerRenderer2.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {
        var renderPixel = _transformJs.apply(this.inversePixelTransform, pixel.slice());
        var context = this.context;
        var layer = this.getLayer();
        var layerExtent = layer.getExtent();
        if (layerExtent) {
            var renderCoordinate = _transformJs.apply(frameState.pixelToCoordinateTransform, pixel.slice());
            /** get only data inside of the layer extent */ if (!_extentJs.containsCoordinate(layerExtent, renderCoordinate)) return null;
        }
        var data;
        try {
            var x = Math.round(renderPixel[0]);
            var y = Math.round(renderPixel[1]);
            var newCanvas = document.createElement('canvas');
            var newContext = newCanvas.getContext('2d');
            newCanvas.width = 1;
            newCanvas.height = 1;
            newContext.clearRect(0, 0, 1, 1);
            newContext.drawImage(context.canvas, x, y, 1, 1, 0, 0, 1, 1);
            data = newContext.getImageData(0, 0, 1, 1).data;
        } catch (err) {
            if (err.name === 'SecurityError') // tainted canvas, we assume there is data at the given pixel (although there might not be)
            return new Uint8Array();
            return data;
        }
        if (data[3] === 0) return null;
        return data;
    };
    return CanvasLayerRenderer2;
}(_layerJsDefault.default);
exports.default = CanvasLayerRenderer1;

},{"../Layer.js":"159ZD","../../render/Event.js":"1IrqP","../../render/EventType.js":"6WjvK","../../transform.js":"C21tg","../../extent.js":"jgUz2","../../dom.js":"akJqt","../../css.js":"23c5q","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"159ZD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/renderer/Layer
 */ var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _observableJs = require("../Observable.js");
var _observableJsDefault = parcelHelpers.interopDefault(_observableJs);
var _stateJs = require("../source/State.js");
var _stateJsDefault = parcelHelpers.interopDefault(_stateJs);
var _utilJs = require("../util.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @template {import("../layer/Layer.js").default} LayerType
 */ var LayerRenderer1 = function(_super) {
    __extends(LayerRenderer2, _super);
    /**
     * @param {LayerType} layer Layer.
     */ function LayerRenderer2(layer) {
        var _this = _super.call(this) || this;
        /** @private */ _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);
        /**
         * @protected
         * @type {LayerType}
         */ _this.layer_ = layer;
        /**
         * @type {import("../render/canvas/ExecutorGroup").default}
         */ _this.declutterExecutorGroup = null;
        return _this;
    }
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
     * an array of features.
     */ LayerRenderer2.prototype.getFeatures = function(pixel) {
        return _utilJs.abstract();
    };
    /**
     * Determine whether render should be called.
     * @abstract
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */ LayerRenderer2.prototype.prepareFrame = function(frameState) {
        return _utilJs.abstract();
    };
    /**
     * Render the layer.
     * @abstract
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target that may be used to render content to.
     * @return {HTMLElement} The rendered element.
     */ LayerRenderer2.prototype.renderFrame = function(frameState, target) {
        return _utilJs.abstract();
    };
    /**
     * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
     * @param {number} zoom Zoom level.
     * @param {import("../Tile.js").default} tile Tile.
     * @return {boolean|void} If `false`, the tile will not be considered loaded.
     */ LayerRenderer2.prototype.loadedTileCallback = function(tiles, zoom, tile) {
        if (!tiles[zoom]) tiles[zoom] = {
        };
        tiles[zoom][tile.tileCoord.toString()] = tile;
        return undefined;
    };
    /**
     * Create a function that adds loaded tiles to the tile lookup.
     * @param {import("../source/Tile.js").default} source Tile source.
     * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
     * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
     * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
     *     called with a zoom level and a tile range to add loaded tiles to the lookup.
     * @protected
     */ LayerRenderer2.prototype.createLoadedTileFinder = function(source, projection, tiles) {
        return(/**
         * @param {number} zoom Zoom level.
         * @param {import("../TileRange.js").default} tileRange Tile range.
         * @return {boolean} The tile range is fully loaded.
         * @this {LayerRenderer}
         */ (function(zoom, tileRange) {
            var callback = this.loadedTileCallback.bind(this, tiles, zoom);
            return source.forEachLoadedTile(projection, zoom, tileRange, callback);
        }).bind(this));
    };
    /**
     * @abstract
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */ LayerRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
        return undefined;
    };
    /**
     * @abstract
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
     *    location, null will be returned.  If there is data, but pixel values cannot be
     *    returned, and empty array will be returned.
     */ LayerRenderer2.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {
        return _utilJs.abstract();
    };
    /**
     * @return {LayerType} Layer.
     */ LayerRenderer2.prototype.getLayer = function() {
        return this.layer_;
    };
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     * @abstract
     */ LayerRenderer2.prototype.handleFontsChanged = function() {
    };
    /**
     * Handle changes in image state.
     * @param {import("../events/Event.js").default} event Image change event.
     * @private
     */ LayerRenderer2.prototype.handleImageChange_ = function(event) {
        var image = event.target;
        if (image.getState() === _imageStateJsDefault.default.LOADED) this.renderIfReadyAndVisible();
    };
    /**
     * Load the image if not already loaded, and register the image change
     * listener if needed.
     * @param {import("../ImageBase.js").default} image Image.
     * @return {boolean} `true` if the image is already loaded, `false` otherwise.
     * @protected
     */ LayerRenderer2.prototype.loadImage = function(image) {
        var imageState = image.getState();
        if (imageState != _imageStateJsDefault.default.LOADED && imageState != _imageStateJsDefault.default.ERROR) image.addEventListener(_eventTypeJsDefault.default.CHANGE, this.boundHandleImageChange_);
        if (imageState == _imageStateJsDefault.default.IDLE) {
            image.load();
            imageState = image.getState();
        }
        return imageState == _imageStateJsDefault.default.LOADED;
    };
    /**
     * @protected
     */ LayerRenderer2.prototype.renderIfReadyAndVisible = function() {
        var layer = this.getLayer();
        if (layer.getVisible() && layer.getSourceState() == _stateJsDefault.default.READY) layer.changed();
    };
    return LayerRenderer2;
}(_observableJsDefault.default);
exports.default = LayerRenderer1;

},{"../events/EventType.js":"83vee","../ImageState.js":"9Ji45","../Observable.js":"j1IoA","../source/State.js":"hpoq1","../util.js":"9zOhk","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cAXof":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This methods creates an array with indexes of all pixels within a circle,
 * ordered by how close they are to the center.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @return {Array<number>} An array with indexes within a circle.
 */ parcelHelpers.export(exports, "getPixelIndexArray", ()=>getPixelIndexArray
);
/**
 * @module ol/render/canvas/ExecutorGroup
 */ var _builderTypeJs = require("./BuilderType.js");
var _builderTypeJsDefault = parcelHelpers.interopDefault(_builderTypeJs);
var _executorJs = require("./Executor.js");
var _executorJsDefault = parcelHelpers.interopDefault(_executorJs);
var _extentJs = require("../../extent.js");
var _transformJs = require("../../transform.js");
var _domJs = require("../../dom.js");
var _objJs = require("../../obj.js");
var _arrayJs = require("../../array.js");
var _transformJs1 = require("../../geom/flat/transform.js");
/**
 * @const
 * @type {Array<import("./BuilderType.js").default>}
 */ var ORDER = [
    _builderTypeJsDefault.default.POLYGON,
    _builderTypeJsDefault.default.CIRCLE,
    _builderTypeJsDefault.default.LINE_STRING,
    _builderTypeJsDefault.default.IMAGE,
    _builderTypeJsDefault.default.TEXT,
    _builderTypeJsDefault.default.DEFAULT, 
];
var ExecutorGroup = function() {
    /**
     * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
     * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
     * should be set here, unless the target context does not exceed that extent (which
     * can be the case when rendering to tiles).
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {boolean} overlaps The executor group can have overlapping geometries.
     * @param {!Object<string, !Object<import("./BuilderType.js").default, import("../canvas.js").SerializableInstructions>>} allInstructions
     * The serializable instructions.
     * @param {number} [opt_renderBuffer] Optional rendering buffer.
     */ function ExecutorGroup1(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {
        /**
         * @private
         * @type {import("../../extent.js").Extent}
         */ this.maxExtent_ = maxExtent;
        /**
         * @private
         * @type {boolean}
         */ this.overlaps_ = overlaps;
        /**
         * @private
         * @type {number}
         */ this.pixelRatio_ = pixelRatio;
        /**
         * @private
         * @type {number}
         */ this.resolution_ = resolution;
        /**
         * @private
         * @type {number|undefined}
         */ this.renderBuffer_ = opt_renderBuffer;
        /**
         * @private
         * @type {!Object<string, !Object<import("./BuilderType.js").default, import("./Executor").default>>}
         */ this.executorsByZIndex_ = {
        };
        /**
         * @private
         * @type {CanvasRenderingContext2D}
         */ this.hitDetectionContext_ = null;
        /**
         * @private
         * @type {import("../../transform.js").Transform}
         */ this.hitDetectionTransform_ = _transformJs.create();
        this.createExecutors_(allInstructions);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     */ ExecutorGroup1.prototype.clip = function(context, transform) {
        var flatClipCoords = this.getClipCoords(transform);
        context.beginPath();
        context.moveTo(flatClipCoords[0], flatClipCoords[1]);
        context.lineTo(flatClipCoords[2], flatClipCoords[3]);
        context.lineTo(flatClipCoords[4], flatClipCoords[5]);
        context.lineTo(flatClipCoords[6], flatClipCoords[7]);
        context.clip();
    };
    /**
     * Create executors and populate them using the provided instructions.
     * @private
     * @param {!Object<string, !Object<import("./BuilderType.js").default, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
     */ ExecutorGroup1.prototype.createExecutors_ = function(allInstructions) {
        for(var zIndex in allInstructions){
            var executors = this.executorsByZIndex_[zIndex];
            if (executors === undefined) {
                executors = {
                };
                this.executorsByZIndex_[zIndex] = executors;
            }
            var instructionByZindex = allInstructions[zIndex];
            for(var builderType in instructionByZindex){
                var instructions = instructionByZindex[builderType];
                executors[builderType] = new _executorJsDefault.default(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);
            }
        }
    };
    /**
     * @param {Array<import("./BuilderType.js").default>} executors Executors.
     * @return {boolean} Has executors of the provided types.
     */ ExecutorGroup1.prototype.hasExecutors = function(executors) {
        for(var zIndex in this.executorsByZIndex_){
            var candidates = this.executorsByZIndex_[zIndex];
            for(var i = 0, ii = executors.length; i < ii; ++i){
                if (executors[i] in candidates) return true;
            }
        }
        return false;
    };
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
     * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
     * @return {T|undefined} Callback result.
     * @template T
     */ ExecutorGroup1.prototype.forEachFeatureAtCoordinate = function(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
        hitTolerance = Math.round(hitTolerance);
        var contextSize = hitTolerance * 2 + 1;
        var transform = _transformJs.compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
        var newContext = !this.hitDetectionContext_;
        if (newContext) this.hitDetectionContext_ = _domJs.createCanvasContext2D(contextSize, contextSize);
        var context = this.hitDetectionContext_;
        if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
            context.canvas.width = contextSize;
            context.canvas.height = contextSize;
        } else if (!newContext) context.clearRect(0, 0, contextSize, contextSize);
        /**
         * @type {import("../../extent.js").Extent}
         */ var hitExtent;
        if (this.renderBuffer_ !== undefined) {
            hitExtent = _extentJs.createEmpty();
            _extentJs.extendCoordinate(hitExtent, coordinate);
            _extentJs.buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
        }
        var indexes = getPixelIndexArray(hitTolerance);
        var builderType;
        /**
         * @param {import("../../Feature.js").FeatureLike} feature Feature.
         * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
         * @return {T|undefined} Callback result.
         */ function featureCallback(feature, geometry) {
            var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
            for(var i_1 = 0, ii = indexes.length; i_1 < ii; i_1++)if (imageData[indexes[i_1]] > 0) {
                if (!declutteredFeatures || builderType !== _builderTypeJsDefault.default.IMAGE && builderType !== _builderTypeJsDefault.default.TEXT || declutteredFeatures.indexOf(feature) !== -1) {
                    var idx = (indexes[i_1] - 3) / 4;
                    var x = hitTolerance - idx % contextSize;
                    var y = hitTolerance - (idx / contextSize | 0);
                    var result_1 = callback(feature, geometry, x * x + y * y);
                    if (result_1) return result_1;
                }
                context.clearRect(0, 0, contextSize, contextSize);
                break;
            }
            return undefined;
        }
        /** @type {Array<number>} */ var zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort(_arrayJs.numberSafeCompareFunction);
        var i, j, executors, executor, result;
        for(i = zs.length - 1; i >= 0; --i){
            var zIndexKey = zs[i].toString();
            executors = this.executorsByZIndex_[zIndexKey];
            for(j = ORDER.length - 1; j >= 0; --j){
                builderType = ORDER[j];
                executor = executors[builderType];
                if (executor !== undefined) {
                    result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);
                    if (result) return result;
                }
            }
        }
        return undefined;
    };
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     * @return {Array<number>} Clip coordinates.
     */ ExecutorGroup1.prototype.getClipCoords = function(transform) {
        var maxExtent = this.maxExtent_;
        if (!maxExtent) return null;
        var minX = maxExtent[0];
        var minY = maxExtent[1];
        var maxX = maxExtent[2];
        var maxY = maxExtent[3];
        var flatClipCoords = [
            minX,
            minY,
            minX,
            maxY,
            maxX,
            maxY,
            maxX,
            minY
        ];
        _transformJs1.transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
        return flatClipCoords;
    };
    /**
     * @return {boolean} Is empty.
     */ ExecutorGroup1.prototype.isEmpty = function() {
        return _objJs.isEmpty(this.executorsByZIndex_);
    };
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
     * @param {Array<import("./BuilderType.js").default>} [opt_builderTypes] Ordered replay types to replay.
     *     Default is {@link module:ol/render/replay~ORDER}
     * @param {import("rbush").default} [opt_declutterTree] Declutter tree.
     */ ExecutorGroup1.prototype.execute = function(context, contextScale, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterTree) {
        /** @type {Array<number>} */ var zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort(_arrayJs.numberSafeCompareFunction);
        // setup clipping so that the parts of over-simplified geometries are not
        // visible outside the current extent when panning
        if (this.maxExtent_) {
            context.save();
            this.clip(context, transform);
        }
        var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;
        var i, ii, j, jj, replays, replay;
        if (opt_declutterTree) zs.reverse();
        for(i = 0, ii = zs.length; i < ii; ++i){
            var zIndexKey = zs[i].toString();
            replays = this.executorsByZIndex_[zIndexKey];
            for(j = 0, jj = builderTypes.length; j < jj; ++j){
                var builderType = builderTypes[j];
                replay = replays[builderType];
                if (replay !== undefined) replay.execute(context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree);
            }
        }
        if (this.maxExtent_) context.restore();
    };
    return ExecutorGroup1;
}();
/**
 * This cache is used to store arrays of indexes for calculated pixel circles
 * to increase performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object<number, Array<number>>}
 */ var circlePixelIndexArrayCache = {
};
function getPixelIndexArray(radius) {
    if (circlePixelIndexArrayCache[radius] !== undefined) return circlePixelIndexArrayCache[radius];
    var size = radius * 2 + 1;
    var maxDistanceSq = radius * radius;
    var distances = new Array(maxDistanceSq + 1);
    for(var i = 0; i <= radius; ++i)for(var j = 0; j <= radius; ++j){
        var distanceSq = i * i + j * j;
        if (distanceSq > maxDistanceSq) break;
        var distance = distances[distanceSq];
        if (!distance) {
            distance = [];
            distances[distanceSq] = distance;
        }
        distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
        if (i > 0) distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
        if (j > 0) {
            distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
            if (i > 0) distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
    }
    var pixelIndex = [];
    for(var i = 0, ii = distances.length; i < ii; ++i)if (distances[i]) pixelIndex.push.apply(pixelIndex, distances[i]);
    circlePixelIndexArrayCache[radius] = pixelIndex;
    return pixelIndex;
}
exports.default = ExecutorGroup;

},{"./BuilderType.js":"iBsUa","./Executor.js":"9lJ4g","../../extent.js":"jgUz2","../../transform.js":"C21tg","../../dom.js":"akJqt","../../obj.js":"g3fPg","../../array.js":"jKNP0","../../geom/flat/transform.js":"eZ5a1","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"iBsUa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    CIRCLE: 'Circle',
    DEFAULT: 'Default',
    IMAGE: 'Image',
    LINE_STRING: 'LineString',
    POLYGON: 'Polygon',
    TEXT: 'Text'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9lJ4g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/render/canvas/Executor
 */ var _instructionJs = require("./Instruction.js");
var _instructionJsDefault = parcelHelpers.interopDefault(_instructionJs);
var _textBuilderJs = require("./TextBuilder.js");
var _hasJs = require("../../has.js");
var _transformJs = require("../../transform.js");
var _extentJs = require("../../extent.js");
var _canvasJs = require("../canvas.js");
var _textpathJs = require("../../geom/flat/textpath.js");
var _arrayJs = require("../../array.js");
var _lengthJs = require("../../geom/flat/length.js");
var _transformJs1 = require("../../geom/flat/transform.js");
/**
 * @typedef {Object} BBox
 * @property {number} minX Minimal x.
 * @property {number} minY Minimal y.
 * @property {number} maxX Maximal x.
 * @property {number} maxY Maximal y
 * @property {*} value Value.
 */ /**
 * @typedef {Object} ImageOrLabelDimensions
 * @property {number} drawImageX DrawImageX.
 * @property {number} drawImageY DrawImageY.
 * @property {number} drawImageW DrawImageW.
 * @property {number} drawImageH DrawImageH.
 * @property {number} originX OriginX.
 * @property {number} originY OriginY.
 * @property {Array<number>} scale Scale.
 * @property {BBox} declutterBox DeclutterBox.
 * @property {import("../../transform.js").Transform} canvasTransform CanvasTransform.
 */ /**
 * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs
 */ /**
 * @template T
 * @typedef {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default): T} FeatureCallback
 */ /**
 * @type {import("../../extent.js").Extent}
 */ var tmpExtent = _extentJs.createEmpty();
/** @type {import("../../coordinate.js").Coordinate} */ var p1 = [];
/** @type {import("../../coordinate.js").Coordinate} */ var p2 = [];
/** @type {import("../../coordinate.js").Coordinate} */ var p3 = [];
/** @type {import("../../coordinate.js").Coordinate} */ var p4 = [];
/**
 * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel
 * @return {BBox} Declutter bbox.
 */ function getDeclutterBox(replayImageOrLabelArgs) {
    return replayImageOrLabelArgs[3].declutterBox;
}
var rtlRegEx = new RegExp(/* eslint-disable prettier/prettier */ '[' + String.fromCharCode(1425) + '-' + String.fromCharCode(2303) + String.fromCharCode(64285) + '-' + String.fromCharCode(65023) + String.fromCharCode(65136) + '-' + String.fromCharCode(65276) + String.fromCharCode(67584) + '-' + String.fromCharCode(69631) + String.fromCharCode(124928) + '-' + String.fromCharCode(126975) + ']');
/**
 * @param {string} text Text.
 * @param {string} align Alignment.
 * @return {number} Text alignment.
 */ function horizontalTextAlign(text, align) {
    if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) align = align === 'start' ? 'left' : 'right';
    return _textBuilderJs.TEXT_ALIGN[align];
}
var Executor = function() {
    /**
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {boolean} overlaps The replay can have overlapping geometries.
     * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
     */ function Executor1(resolution, pixelRatio, overlaps, instructions) {
        /**
         * @protected
         * @type {boolean}
         */ this.overlaps = overlaps;
        /**
         * @protected
         * @type {number}
         */ this.pixelRatio = pixelRatio;
        /**
         * @protected
         * @const
         * @type {number}
         */ this.resolution = resolution;
        /**
         * @private
         * @type {boolean}
         */ this.alignFill_;
        /**
         * @protected
         * @type {Array<*>}
         */ this.instructions = instructions.instructions;
        /**
         * @protected
         * @type {Array<number>}
         */ this.coordinates = instructions.coordinates;
        /**
         * @private
         * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
         */ this.coordinateCache_ = {
        };
        /**
         * @private
         * @type {!import("../../transform.js").Transform}
         */ this.renderedTransform_ = _transformJs.create();
        /**
         * @protected
         * @type {Array<*>}
         */ this.hitDetectionInstructions = instructions.hitDetectionInstructions;
        /**
         * @private
         * @type {Array<number>}
         */ this.pixelCoordinates_ = null;
        /**
         * @private
         * @type {number}
         */ this.viewRotation_ = 0;
        /**
         * @type {!Object<string, import("../canvas.js").FillState>}
         */ this.fillStates = instructions.fillStates || {
        };
        /**
         * @type {!Object<string, import("../canvas.js").StrokeState>}
         */ this.strokeStates = instructions.strokeStates || {
        };
        /**
         * @type {!Object<string, import("../canvas.js").TextState>}
         */ this.textStates = instructions.textStates || {
        };
        /**
         * @private
         * @type {Object<string, Object<string, number>>}
         */ this.widths_ = {
        };
        /**
         * @private
         * @type {Object<string, import("../canvas.js").Label>}
         */ this.labels_ = {
        };
    }
    /**
     * @param {string} text Text.
     * @param {string} textKey Text style key.
     * @param {string} fillKey Fill style key.
     * @param {string} strokeKey Stroke style key.
     * @return {import("../canvas.js").Label} Label.
     */ Executor1.prototype.createLabel = function(text, textKey, fillKey, strokeKey) {
        var key = text + textKey + fillKey + strokeKey;
        if (this.labels_[key]) return this.labels_[key];
        var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
        var fillState = fillKey ? this.fillStates[fillKey] : null;
        var textState = this.textStates[textKey];
        var pixelRatio = this.pixelRatio;
        var scale = [
            textState.scale[0] * pixelRatio,
            textState.scale[1] * pixelRatio, 
        ];
        var align = horizontalTextAlign(text, textState.textAlign || _canvasJs.defaultTextAlign);
        var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
        var lines = text.split('\n');
        var numLines = lines.length;
        var widths = [];
        var width = _canvasJs.measureTextWidths(textState.font, lines, widths);
        var lineHeight = _canvasJs.measureTextHeight(textState.font);
        var height = lineHeight * numLines;
        var renderWidth = width + strokeWidth;
        var contextInstructions = [];
        // make canvas 2 pixels wider to account for italic text width measurement errors
        var w = (renderWidth + 2) * scale[0];
        var h = (height + strokeWidth) * scale[1];
        /** @type {import("../canvas.js").Label} */ var label = {
            width: w < 0 ? Math.floor(w) : Math.ceil(w),
            height: h < 0 ? Math.floor(h) : Math.ceil(h),
            contextInstructions: contextInstructions
        };
        if (scale[0] != 1 || scale[1] != 1) contextInstructions.push('scale', scale);
        contextInstructions.push('font', textState.font);
        if (strokeKey) {
            contextInstructions.push('strokeStyle', strokeState.strokeStyle);
            contextInstructions.push('lineWidth', strokeWidth);
            contextInstructions.push('lineCap', strokeState.lineCap);
            contextInstructions.push('lineJoin', strokeState.lineJoin);
            contextInstructions.push('miterLimit', strokeState.miterLimit);
            // eslint-disable-next-line
            var Context = _hasJs.WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;
            if (Context.prototype.setLineDash) {
                contextInstructions.push('setLineDash', [
                    strokeState.lineDash
                ]);
                contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);
            }
        }
        if (fillKey) contextInstructions.push('fillStyle', fillState.fillStyle);
        contextInstructions.push('textBaseline', 'middle');
        contextInstructions.push('textAlign', 'center');
        var leftRight = 0.5 - align;
        var x = align * renderWidth + leftRight * strokeWidth;
        var i;
        if (strokeKey) for(i = 0; i < numLines; ++i)contextInstructions.push('strokeText', [
            lines[i],
            x + leftRight * widths[i],
            0.5 * (strokeWidth + lineHeight) + i * lineHeight, 
        ]);
        if (fillKey) for(i = 0; i < numLines; ++i)contextInstructions.push('fillText', [
            lines[i],
            x + leftRight * widths[i],
            0.5 * (strokeWidth + lineHeight) + i * lineHeight, 
        ]);
        this.labels_[key] = label;
        return label;
    };
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     */ Executor1.prototype.replayTextBackground_ = function(context, p11, p21, p31, p41, fillInstruction, strokeInstruction) {
        context.beginPath();
        context.moveTo.apply(context, p11);
        context.lineTo.apply(context, p21);
        context.lineTo.apply(context, p31);
        context.lineTo.apply(context, p41);
        context.lineTo.apply(context, p11);
        if (fillInstruction) {
            this.alignFill_ = fillInstruction[2];
            this.fill_(context);
        }
        if (strokeInstruction) {
            this.setStrokeStyle_(context, strokeInstruction);
            context.stroke();
        }
    };
    /**
     * @private
     * @param {number} sheetWidth Width of the sprite sheet.
     * @param {number} sheetHeight Height of the sprite sheet.
     * @param {number} centerX X.
     * @param {number} centerY Y.
     * @param {number} width Width.
     * @param {number} height Height.
     * @param {number} anchorX Anchor X.
     * @param {number} anchorY Anchor Y.
     * @param {number} originX Origin X.
     * @param {number} originY Origin Y.
     * @param {number} rotation Rotation.
     * @param {import("../../size.js").Size} scale Scale.
     * @param {boolean} snapToPixel Snap to pixel.
     * @param {Array<number>} padding Padding.
     * @param {boolean} fillStroke Background fill or stroke.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
     */ Executor1.prototype.calculateImageOrLabelDimensions_ = function(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {
        anchorX *= scale[0];
        anchorY *= scale[1];
        var x = centerX - anchorX;
        var y = centerY - anchorY;
        var w = width + originX > sheetWidth ? sheetWidth - originX : width;
        var h = height + originY > sheetHeight ? sheetHeight - originY : height;
        var boxW = padding[3] + w * scale[0] + padding[1];
        var boxH = padding[0] + h * scale[1] + padding[2];
        var boxX = x - padding[3];
        var boxY = y - padding[0];
        if (fillStroke || rotation !== 0) {
            p1[0] = boxX;
            p4[0] = boxX;
            p1[1] = boxY;
            p2[1] = boxY;
            p2[0] = boxX + boxW;
            p3[0] = p2[0];
            p3[1] = boxY + boxH;
            p4[1] = p3[1];
        }
        var transform;
        if (rotation !== 0) {
            transform = _transformJs.compose(_transformJs.create(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
            _transformJs.apply(transform, p1);
            _transformJs.apply(transform, p2);
            _transformJs.apply(transform, p3);
            _transformJs.apply(transform, p4);
            _extentJs.createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
        } else _extentJs.createOrUpdate(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);
        if (snapToPixel) {
            x = Math.round(x);
            y = Math.round(y);
        }
        return {
            drawImageX: x,
            drawImageY: y,
            drawImageW: w,
            drawImageH: h,
            originX: originX,
            originY: originY,
            declutterBox: {
                minX: tmpExtent[0],
                minY: tmpExtent[1],
                maxX: tmpExtent[2],
                maxY: tmpExtent[3],
                value: feature
            },
            canvasTransform: transform,
            scale: scale
        };
    };
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
     * @param {ImageOrLabelDimensions} dimensions Dimensions.
     * @param {number} opacity Opacity.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     * @return {boolean} The image or label was rendered.
     */ Executor1.prototype.replayImageOrLabel_ = function(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {
        var fillStroke = !!(fillInstruction || strokeInstruction);
        var box = dimensions.declutterBox;
        var canvas = context.canvas;
        var strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;
        var intersects = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;
        if (intersects) {
            if (fillStroke) this.replayTextBackground_(context, p1, p2, p3, p4, fillInstruction, strokeInstruction);
            _canvasJs.drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
        }
        return true;
    };
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     */ Executor1.prototype.fill_ = function(context) {
        if (this.alignFill_) {
            var origin_1 = _transformJs.apply(this.renderedTransform_, [
                0,
                0
            ]);
            var repeatSize = 512 * this.pixelRatio;
            context.save();
            context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);
            context.rotate(this.viewRotation_);
        }
        context.fill();
        if (this.alignFill_) context.restore();
    };
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {Array<*>} instruction Instruction.
     */ Executor1.prototype.setStrokeStyle_ = function(context, instruction) {
        context['strokeStyle'] = instruction[1];
        context.lineWidth = instruction[2];
        context.lineCap = instruction[3];
        context.lineJoin = instruction[4];
        context.miterLimit = instruction[5];
        if (context.setLineDash) {
            context.lineDashOffset = instruction[7];
            context.setLineDash(instruction[6]);
        }
    };
    /**
     * @private
     * @param {string} text The text to draw.
     * @param {string} textKey The key of the text state.
     * @param {string} strokeKey The key for the stroke state.
     * @param {string} fillKey The key for the fill state.
     * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
     */ Executor1.prototype.drawLabelWithPointPlacement_ = function(text, textKey, strokeKey, fillKey) {
        var textState = this.textStates[textKey];
        var label = this.createLabel(text, textKey, fillKey, strokeKey);
        var strokeState = this.strokeStates[strokeKey];
        var pixelRatio = this.pixelRatio;
        var align = horizontalTextAlign(text, textState.textAlign || _canvasJs.defaultTextAlign);
        var baseline = _textBuilderJs.TEXT_ALIGN[textState.textBaseline || _canvasJs.defaultTextBaseline];
        var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
        // Remove the 2 pixels we added in createLabel() for the anchor
        var width = label.width / pixelRatio - 2 * textState.scale[0];
        var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
        var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
        return {
            label: label,
            anchorX: anchorX,
            anchorY: anchorY
        };
    };
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {Array<*>} instructions Instructions array.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [opt_hitExtent] Only check
     *     features that intersect this extent.
     * @param {import("rbush").default} [opt_declutterTree] Declutter tree.
     * @return {T|undefined} Callback result.
     * @template T
     */ Executor1.prototype.execute_ = function(context, contextScale, transform, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {
        /** @type {Array<number>} */ var pixelCoordinates;
        if (this.pixelCoordinates_ && _arrayJs.equals(transform, this.renderedTransform_)) pixelCoordinates = this.pixelCoordinates_;
        else {
            if (!this.pixelCoordinates_) this.pixelCoordinates_ = [];
            pixelCoordinates = _transformJs1.transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
            _transformJs.setFromArray(this.renderedTransform_, transform);
        }
        var i = 0; // instruction index
        var ii = instructions.length; // end of instructions
        var d = 0; // data index
        var dd; // end of per-instruction data
        var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
        var pendingFill = 0;
        var pendingStroke = 0;
        var lastFillInstruction = null;
        var lastStrokeInstruction = null;
        var coordinateCache = this.coordinateCache_;
        var viewRotation = this.viewRotation_;
        var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1000000000000) / 1000000000000;
        var state = {
            context: context,
            pixelRatio: this.pixelRatio,
            resolution: this.resolution,
            rotation: viewRotation
        };
        // When the batch size gets too big, performance decreases. 200 is a good
        // balance between batch size and number of fill/stroke instructions.
        var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
        var /** @type {import("../../Feature.js").FeatureLike} */ feature;
        var x, y, currentGeometry;
        while(i < ii){
            var instruction = instructions[i];
            var type = instruction[0];
            switch(type){
                case _instructionJsDefault.default.BEGIN_GEOMETRY:
                    feature = instruction[1];
                    currentGeometry = instruction[3];
                    if (!feature.getGeometry()) i = instruction[2];
                    else if (opt_hitExtent !== undefined && !_extentJs.intersects(opt_hitExtent, currentGeometry.getExtent())) i = /** @type {number} */ instruction[2] + 1;
                    else ++i;
                    break;
                case _instructionJsDefault.default.BEGIN_PATH:
                    if (pendingFill > batchSize) {
                        this.fill_(context);
                        pendingFill = 0;
                    }
                    if (pendingStroke > batchSize) {
                        context.stroke();
                        pendingStroke = 0;
                    }
                    if (!pendingFill && !pendingStroke) {
                        context.beginPath();
                        prevX = NaN;
                        prevY = NaN;
                    }
                    ++i;
                    break;
                case _instructionJsDefault.default.CIRCLE:
                    d = instruction[1];
                    var x1 = pixelCoordinates[d];
                    var y1 = pixelCoordinates[d + 1];
                    var x2 = pixelCoordinates[d + 2];
                    var y2 = pixelCoordinates[d + 3];
                    var dx = x2 - x1;
                    var dy = y2 - y1;
                    var r = Math.sqrt(dx * dx + dy * dy);
                    context.moveTo(x1 + r, y1);
                    context.arc(x1, y1, r, 0, 2 * Math.PI, true);
                    ++i;
                    break;
                case _instructionJsDefault.default.CLOSE_PATH:
                    context.closePath();
                    ++i;
                    break;
                case _instructionJsDefault.default.CUSTOM:
                    d = instruction[1];
                    dd = instruction[2];
                    var geometry = instruction[3];
                    var renderer = instruction[4];
                    var fn = instruction.length == 6 ? instruction[5] : undefined;
                    state.geometry = geometry;
                    state.feature = feature;
                    if (!(i in coordinateCache)) coordinateCache[i] = [];
                    var coords = coordinateCache[i];
                    if (fn) fn(pixelCoordinates, d, dd, 2, coords);
                    else {
                        coords[0] = pixelCoordinates[d];
                        coords[1] = pixelCoordinates[d + 1];
                        coords.length = 2;
                    }
                    renderer(coords, state);
                    ++i;
                    break;
                case _instructionJsDefault.default.DRAW_IMAGE:
                    d = instruction[1];
                    dd = instruction[2];
                    image = instruction[3];
                    // Remaining arguments in DRAW_IMAGE are in alphabetical order
                    anchorX = instruction[4];
                    anchorY = instruction[5];
                    var height = instruction[6];
                    var opacity = instruction[7];
                    var originX = instruction[8];
                    var originY = instruction[9];
                    var rotateWithView = instruction[10];
                    var rotation = instruction[11];
                    var scale = instruction[12];
                    var width = instruction[13];
                    var declutterImageWithText = instruction[14];
                    if (!image && instruction.length >= 19) {
                        // create label images
                        text = instruction[18];
                        textKey = instruction[19];
                        strokeKey = instruction[20];
                        fillKey = instruction[21];
                        var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
                        image = labelWithAnchor.label;
                        instruction[3] = image;
                        var textOffsetX = instruction[22];
                        anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                        instruction[4] = anchorX;
                        var textOffsetY = instruction[23];
                        anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                        instruction[5] = anchorY;
                        height = image.height;
                        instruction[6] = height;
                        width = image.width;
                        instruction[13] = width;
                    }
                    var geometryWidths = void 0;
                    if (instruction.length > 24) geometryWidths = instruction[24];
                    var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;
                    if (instruction.length > 16) {
                        padding = instruction[15];
                        backgroundFill = instruction[16];
                        backgroundStroke = instruction[17];
                    } else {
                        padding = _canvasJs.defaultPadding;
                        backgroundFill = false;
                        backgroundStroke = false;
                    }
                    if (rotateWithView && viewRotationFromTransform) // Canvas is expected to be rotated to reverse view rotation.
                    rotation += viewRotation;
                    else if (!rotateWithView && !viewRotationFromTransform) // Canvas is not rotated, images need to be rotated back to be north-up.
                    rotation -= viewRotation;
                    var widthIndex = 0;
                    for(; d < dd; d += 2){
                        if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) continue;
                        var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);
                        /** @type {ReplayImageOrLabelArgs} */ var args = [
                            context,
                            contextScale,
                            image,
                            dimensions,
                            opacity,
                            backgroundFill ? lastFillInstruction : null,
                            backgroundStroke ? lastStrokeInstruction : null, 
                        ];
                        var imageArgs = void 0;
                        var imageDeclutterBox = void 0;
                        if (opt_declutterTree && declutterImageWithText) {
                            var index = dd - d;
                            if (!declutterImageWithText[index]) {
                                // We now have the image for an image+text combination.
                                declutterImageWithText[index] = args;
                                continue;
                            }
                            imageArgs = declutterImageWithText[index];
                            delete declutterImageWithText[index];
                            imageDeclutterBox = getDeclutterBox(imageArgs);
                            if (opt_declutterTree.collides(imageDeclutterBox)) continue;
                        }
                        if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) continue;
                        if (imageArgs) {
                            // We now have image and text for an image+text combination.
                            if (opt_declutterTree) opt_declutterTree.insert(imageDeclutterBox);
                            // Render the image before we render the text.
                            this.replayImageOrLabel_.apply(this, imageArgs);
                        }
                        if (opt_declutterTree) opt_declutterTree.insert(dimensions.declutterBox);
                        this.replayImageOrLabel_.apply(this, args);
                    }
                    ++i;
                    break;
                case _instructionJsDefault.default.DRAW_CHARS:
                    var begin = instruction[1];
                    var end = instruction[2];
                    var baseline = instruction[3];
                    var overflow = instruction[4];
                    fillKey = instruction[5];
                    var maxAngle = instruction[6];
                    var measurePixelRatio = instruction[7];
                    var offsetY = instruction[8];
                    strokeKey = instruction[9];
                    var strokeWidth = instruction[10];
                    text = instruction[11];
                    textKey = instruction[12];
                    var pixelRatioScale = [
                        instruction[13],
                        instruction[13], 
                    ];
                    var textState = this.textStates[textKey];
                    var font = textState.font;
                    var textScale = [
                        textState.scale[0] * measurePixelRatio,
                        textState.scale[1] * measurePixelRatio, 
                    ];
                    var cachedWidths = void 0;
                    if (font in this.widths_) cachedWidths = this.widths_[font];
                    else {
                        cachedWidths = {
                        };
                        this.widths_[font] = cachedWidths;
                    }
                    var pathLength = _lengthJs.lineStringLength(pixelCoordinates, begin, end, 2);
                    var textLength = Math.abs(textScale[0]) * _canvasJs.measureAndCacheTextWidth(font, text, cachedWidths);
                    if (overflow || textLength <= pathLength) {
                        var textAlign = this.textStates[textKey].textAlign;
                        var startM = (pathLength - textLength) * _textBuilderJs.TEXT_ALIGN[textAlign];
                        var parts = _textpathJs.drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), _canvasJs.measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
                        drawChars: if (parts) {
                            /** @type {Array<ReplayImageOrLabelArgs>} */ var replayImageOrLabelArgs = [];
                            var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;
                            if (strokeKey) for(c = 0, cc = parts.length; c < cc; ++c){
                                part = parts[c]; // x, y, anchorX, rotation, chunk
                                chars = part[4];
                                label = this.createLabel(chars, textKey, '', strokeKey);
                                anchorX = /** @type {number} */ part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                                anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                                var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, _canvasJs.defaultPadding, false, feature);
                                if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) break drawChars;
                                replayImageOrLabelArgs.push([
                                    context,
                                    contextScale,
                                    label,
                                    dimensions,
                                    1,
                                    null,
                                    null, 
                                ]);
                            }
                            if (fillKey) for(c = 0, cc = parts.length; c < cc; ++c){
                                part = parts[c]; // x, y, anchorX, rotation, chunk
                                chars = part[4];
                                label = this.createLabel(chars, textKey, fillKey, '');
                                anchorX = part[2];
                                anchorY = baseline * label.height - offsetY;
                                var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, _canvasJs.defaultPadding, false, feature);
                                if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) break drawChars;
                                replayImageOrLabelArgs.push([
                                    context,
                                    contextScale,
                                    label,
                                    dimensions,
                                    1,
                                    null,
                                    null, 
                                ]);
                            }
                            if (opt_declutterTree) opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                            for(var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1)this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);
                        }
                    }
                    ++i;
                    break;
                case _instructionJsDefault.default.END_GEOMETRY:
                    if (opt_featureCallback !== undefined) {
                        feature = instruction[1];
                        var result = opt_featureCallback(feature, currentGeometry);
                        if (result) return result;
                    }
                    ++i;
                    break;
                case _instructionJsDefault.default.FILL:
                    if (batchSize) pendingFill++;
                    else this.fill_(context);
                    ++i;
                    break;
                case _instructionJsDefault.default.MOVE_TO_LINE_TO:
                    d = instruction[1];
                    dd = instruction[2];
                    x = pixelCoordinates[d];
                    y = pixelCoordinates[d + 1];
                    roundX = x + 0.5 | 0;
                    roundY = y + 0.5 | 0;
                    if (roundX !== prevX || roundY !== prevY) {
                        context.moveTo(x, y);
                        prevX = roundX;
                        prevY = roundY;
                    }
                    for(d += 2; d < dd; d += 2){
                        x = pixelCoordinates[d];
                        y = pixelCoordinates[d + 1];
                        roundX = x + 0.5 | 0;
                        roundY = y + 0.5 | 0;
                        if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                            context.lineTo(x, y);
                            prevX = roundX;
                            prevY = roundY;
                        }
                    }
                    ++i;
                    break;
                case _instructionJsDefault.default.SET_FILL_STYLE:
                    lastFillInstruction = instruction;
                    this.alignFill_ = instruction[2];
                    if (pendingFill) {
                        this.fill_(context);
                        pendingFill = 0;
                        if (pendingStroke) {
                            context.stroke();
                            pendingStroke = 0;
                        }
                    }
                    context.fillStyle = instruction[1];
                    ++i;
                    break;
                case _instructionJsDefault.default.SET_STROKE_STYLE:
                    lastStrokeInstruction = instruction;
                    if (pendingStroke) {
                        context.stroke();
                        pendingStroke = 0;
                    }
                    this.setStrokeStyle_(context, instruction);
                    ++i;
                    break;
                case _instructionJsDefault.default.STROKE:
                    if (batchSize) pendingStroke++;
                    else context.stroke();
                    ++i;
                    break;
                default:
                    ++i; // consume the instruction anyway, to avoid an infinite loop
                    break;
            }
        }
        if (pendingFill) this.fill_(context);
        if (pendingStroke) context.stroke();
        return undefined;
    };
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {import("rbush").default} [opt_declutterTree] Declutter tree.
     */ Executor1.prototype.execute = function(context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree) {
        this.viewRotation_ = viewRotation;
        this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, opt_declutterTree);
    };
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {FeatureCallback<T>} [opt_featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [opt_hitExtent] Only check
     *     features that intersect this extent.
     * @return {T|undefined} Callback result.
     * @template T
     */ Executor1.prototype.executeHitDetection = function(context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {
        this.viewRotation_ = viewRotation;
        return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
    };
    return Executor1;
}();
exports.default = Executor;

},{"./Instruction.js":"ki0aV","./TextBuilder.js":"jejRx","../../has.js":"cdiSc","../../transform.js":"C21tg","../../extent.js":"jgUz2","../canvas.js":"hMw4S","../../geom/flat/textpath.js":"VYamC","../../array.js":"jKNP0","../../geom/flat/length.js":"a2zAP","../../geom/flat/transform.js":"eZ5a1","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"VYamC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {Array<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @param {number} scale The product of the text scale and the device pixel ratio.
 * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
 * @param {string} font The font.
 * @param {Object<string, number>} cache A cache of measured widths.
 * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
 * @return {Array<Array<*>>} The result array (or null if `maxAngle` was
 * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
 */ parcelHelpers.export(exports, "drawTextOnPath", ()=>drawTextOnPath
);
/**
 * @module ol/geom/flat/textpath
 */ var _mathJs = require("../../math.js");
var _transformJs = require("./transform.js");
function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    var x1 = 0;
    var y1 = 0;
    var segmentLength = 0;
    var segmentM = 0;
    function advance() {
        x1 = x2;
        y1 = y2;
        offset += stride;
        x2 = flatCoordinates[offset];
        y2 = flatCoordinates[offset + 1];
        segmentM += segmentLength;
        segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }
    do advance();
    while (offset < end - stride && segmentM + segmentLength < startM)
    var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
    var beginX = _mathJs.lerp(x1, x2, interpolate);
    var beginY = _mathJs.lerp(y1, y2, interpolate);
    var startOffset = offset - stride;
    var startLength = segmentM;
    var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);
    while(offset < end - stride && segmentM + segmentLength < endM)advance();
    interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
    var endX = _mathJs.lerp(x1, x2, interpolate);
    var endY = _mathJs.lerp(y1, y2, interpolate);
    // Keep text upright
    var reverse;
    if (rotation) {
        var flat = [
            beginX,
            beginY,
            endX,
            endY
        ];
        _transformJs.rotate(flat, 0, 4, 2, rotation, flat, flat);
        reverse = flat[0] > flat[2];
    } else reverse = beginX > endX;
    var PI = Math.PI;
    var result = [];
    var singleSegment = startOffset + stride === offset;
    offset = startOffset;
    segmentLength = 0;
    segmentM = startLength;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    var previousAngle;
    // All on the same segment
    if (singleSegment) {
        advance();
        previousAngle = Math.atan2(y2 - y1, x2 - x1);
        if (reverse) previousAngle += previousAngle > 0 ? -PI : PI;
        var x = (endX + beginX) / 2;
        var y = (endY + beginY) / 2;
        result[0] = [
            x,
            y,
            (endM - startM) / 2,
            previousAngle,
            text
        ];
        return result;
    }
    for(var i = 0, ii = text.length; i < ii;){
        advance();
        var angle = Math.atan2(y2 - y1, x2 - x1);
        if (reverse) angle += angle > 0 ? -PI : PI;
        if (previousAngle !== undefined) {
            var delta = angle - previousAngle;
            delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
            if (Math.abs(delta) > maxAngle) return null;
        }
        previousAngle = angle;
        var iStart = i;
        var charLength = 0;
        for(; i < ii; ++i){
            var index = reverse ? ii - i - 1 : i;
            var len = scale * measureAndCacheTextWidth(font, text[index], cache);
            if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) break;
            charLength += len;
        }
        if (i === iStart) continue;
        var chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
        interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
        var x = _mathJs.lerp(x1, x2, interpolate);
        var y = _mathJs.lerp(y1, y2, interpolate);
        result.push([
            x,
            y,
            charLength / 2,
            angle,
            chars
        ]);
        startM += charLength;
    }
    return result;
}

},{"../../math.js":"kI4rE","./transform.js":"eZ5a1","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7bjIB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HIT_DETECT_RESOLUTION", ()=>HIT_DETECT_RESOLUTION
);
/**
 * @param {import("../../size.js").Size} size Canvas size in css pixels.
 * @param {Array<import("../../transform.js").Transform>} transforms Transforms
 * for rendering features to all worlds of the viewport, from coordinates to css
 * pixels.
 * @param {Array<import("../../Feature.js").FeatureLike>} features
 * Features to consider for hit detection.
 * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
 * Layer style function.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {ImageData} Hit detection image data.
 */ parcelHelpers.export(exports, "createHitDetectionImageData", ()=>createHitDetectionImageData
);
/**
 * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
 * detection canvas in css pixels.
 * @param {Array<import("../../Feature").FeatureLike>} features Features. Has to
 * match the `features` array that was passed to `createHitDetectionImageData()`.
 * @param {ImageData} imageData Hit detection image data generated by
 * `createHitDetectionImageData()`.
 * @return {Array<import("../../Feature").FeatureLike>} features Features.
 */ parcelHelpers.export(exports, "hitDetect", ()=>hitDetect
);
/**
 * @module ol/render/canvas/hitdetect
 */ var _immediateJs = require("./Immediate.js");
var _immediateJsDefault = parcelHelpers.interopDefault(_immediateJs);
var _geometryTypeJs = require("../../geom/GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _iconAnchorUnitsJs = require("../../style/IconAnchorUnits.js");
var _iconAnchorUnitsJsDefault = parcelHelpers.interopDefault(_iconAnchorUnitsJs);
var _styleJs = require("../../style.js");
var _mathJs = require("../../math.js");
var _domJs = require("../../dom.js");
var _extentJs = require("../../extent.js");
var _arrayJs = require("../../array.js");
var HIT_DETECT_RESOLUTION = 0.5;
function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {
    var width = size[0] * HIT_DETECT_RESOLUTION;
    var height = size[1] * HIT_DETECT_RESOLUTION;
    var context = _domJs.createCanvasContext2D(width, height);
    context.imageSmoothingEnabled = false;
    var canvas = context.canvas;
    var renderer = new _immediateJsDefault.default(context, HIT_DETECT_RESOLUTION, extent, null, rotation);
    var featureCount = features.length;
    // Stretch hit detection index to use the whole available color range
    var indexFactor = Math.floor(16777215 / featureCount);
    var featuresByZIndex = {
    };
    for(var i = 1; i <= featureCount; ++i){
        var feature = features[i - 1];
        var featureStyleFunction = feature.getStyleFunction() || styleFunction;
        if (!styleFunction) continue;
        var styles = featureStyleFunction(feature, resolution);
        if (!styles) continue;
        if (!Array.isArray(styles)) styles = [
            styles
        ];
        var index = i * indexFactor;
        var color = '#' + ('000000' + index.toString(16)).slice(-6);
        for(var j = 0, jj = styles.length; j < jj; ++j){
            var originalStyle = styles[j];
            var geometry = originalStyle.getGeometryFunction()(feature);
            if (!geometry || !_extentJs.intersects(extent, geometry.getExtent())) continue;
            var style = originalStyle.clone();
            var fill = style.getFill();
            if (fill) fill.setColor(color);
            var stroke = style.getStroke();
            if (stroke) {
                stroke.setColor(color);
                stroke.setLineDash(null);
            }
            style.setText(undefined);
            var image = originalStyle.getImage();
            if (image && image.getOpacity() !== 0) {
                var imgSize = image.getImageSize();
                if (!imgSize) continue;
                var imgContext = _domJs.createCanvasContext2D(imgSize[0], imgSize[1], undefined, {
                    alpha: false
                });
                var img = imgContext.canvas;
                imgContext.fillStyle = color;
                imgContext.fillRect(0, 0, img.width, img.height);
                style.setImage(new _styleJs.Icon({
                    img: img,
                    imgSize: imgSize,
                    anchor: image.getAnchor(),
                    anchorXUnits: _iconAnchorUnitsJsDefault.default.PIXELS,
                    anchorYUnits: _iconAnchorUnitsJsDefault.default.PIXELS,
                    offset: image.getOrigin(),
                    opacity: 1,
                    size: image.getSize(),
                    scale: image.getScale(),
                    rotation: image.getRotation(),
                    rotateWithView: image.getRotateWithView()
                }));
            }
            var zIndex = style.getZIndex() || 0;
            var byGeometryType = featuresByZIndex[zIndex];
            if (!byGeometryType) {
                byGeometryType = {
                };
                featuresByZIndex[zIndex] = byGeometryType;
                byGeometryType[_geometryTypeJsDefault.default.POLYGON] = [];
                byGeometryType[_geometryTypeJsDefault.default.CIRCLE] = [];
                byGeometryType[_geometryTypeJsDefault.default.LINE_STRING] = [];
                byGeometryType[_geometryTypeJsDefault.default.POINT] = [];
            }
            byGeometryType[geometry.getType().replace('Multi', '')].push(geometry, style);
        }
    }
    var zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(_arrayJs.numberSafeCompareFunction);
    for(var i = 0, ii = zIndexKeys.length; i < ii; ++i){
        var byGeometryType = featuresByZIndex[zIndexKeys[i]];
        for(var type in byGeometryType){
            var geomAndStyle = byGeometryType[type];
            for(var j = 0, jj = geomAndStyle.length; j < jj; j += 2){
                renderer.setStyle(geomAndStyle[j + 1]);
                for(var k = 0, kk = transforms.length; k < kk; ++k){
                    renderer.setTransform(transforms[k]);
                    renderer.drawGeometry(geomAndStyle[j]);
                }
            }
        }
    }
    return context.getImageData(0, 0, canvas.width, canvas.height);
}
function hitDetect(pixel, features, imageData) {
    var resultFeatures = [];
    if (imageData) {
        var x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
        var y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
        // The pixel coordinate is clamped down to the hit-detect canvas' size to account
        // for browsers returning coordinates slightly larger than the actual canvas size
        // due to a non-integer pixel ratio.
        var index = (_mathJs.clamp(x, 0, imageData.width - 1) + _mathJs.clamp(y, 0, imageData.height - 1) * imageData.width) * 4;
        var r = imageData.data[index];
        var g = imageData.data[index + 1];
        var b = imageData.data[index + 2];
        var i = b + 256 * (g + 256 * r);
        var indexFactor = Math.floor(16777215 / features.length);
        if (i && i % indexFactor === 0) resultFeatures.push(features[i / indexFactor - 1]);
    }
    return resultFeatures;
}

},{"./Immediate.js":"dpKqL","../../geom/GeometryType.js":"3sRlw","../../style/IconAnchorUnits.js":"i3fS4","../../style.js":"a8X4g","../../math.js":"kI4rE","../../dom.js":"akJqt","../../extent.js":"jgUz2","../../array.js":"jKNP0","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"dpKqL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _geometryTypeJs = require("../../geom/GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _vectorContextJs = require("../VectorContext.js");
var _vectorContextJsDefault = parcelHelpers.interopDefault(_vectorContextJs);
var _colorlikeJs = require("../../colorlike.js");
var _transformJs = require("../../transform.js");
var _canvasJs = require("../canvas.js");
var _arrayJs = require("../../array.js");
var _extentJs = require("../../extent.js");
var _transformJs1 = require("../../geom/flat/transform.js");
var _simpleGeometryJs = require("../../geom/SimpleGeometry.js");
/**
 * @module ol/render/canvas/Immediate
 */ // FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */ var CanvasImmediateRenderer1 = function(_super) {
    __extends(CanvasImmediateRenderer2, _super);
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {number} [opt_squaredTolerance] Optional squared tolerance for simplification.
     * @param {import("../../proj.js").TransformFunction} [opt_userTransform] Transform from user to view projection.
     */ function CanvasImmediateRenderer2(context, pixelRatio, extent, transform, viewRotation, opt_squaredTolerance, opt_userTransform) {
        var _this = _super.call(this) || this;
        /**
         * @private
         * @type {CanvasRenderingContext2D}
         */ _this.context_ = context;
        /**
         * @private
         * @type {number}
         */ _this.pixelRatio_ = pixelRatio;
        /**
         * @private
         * @type {import("../../extent.js").Extent}
         */ _this.extent_ = extent;
        /**
         * @private
         * @type {import("../../transform.js").Transform}
         */ _this.transform_ = transform;
        /**
         * @private
         * @type {number}
         */ _this.viewRotation_ = viewRotation;
        /**
         * @private
         * @type {number}
         */ _this.squaredTolerance_ = opt_squaredTolerance;
        /**
         * @private
         * @type {import("../../proj.js").TransformFunction}
         */ _this.userTransform_ = opt_userTransform;
        /**
         * @private
         * @type {?import("../canvas.js").FillState}
         */ _this.contextFillState_ = null;
        /**
         * @private
         * @type {?import("../canvas.js").StrokeState}
         */ _this.contextStrokeState_ = null;
        /**
         * @private
         * @type {?import("../canvas.js").TextState}
         */ _this.contextTextState_ = null;
        /**
         * @private
         * @type {?import("../canvas.js").FillState}
         */ _this.fillState_ = null;
        /**
         * @private
         * @type {?import("../canvas.js").StrokeState}
         */ _this.strokeState_ = null;
        /**
         * @private
         * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
         */ _this.image_ = null;
        /**
         * @private
         * @type {number}
         */ _this.imageAnchorX_ = 0;
        /**
         * @private
         * @type {number}
         */ _this.imageAnchorY_ = 0;
        /**
         * @private
         * @type {number}
         */ _this.imageHeight_ = 0;
        /**
         * @private
         * @type {number}
         */ _this.imageOpacity_ = 0;
        /**
         * @private
         * @type {number}
         */ _this.imageOriginX_ = 0;
        /**
         * @private
         * @type {number}
         */ _this.imageOriginY_ = 0;
        /**
         * @private
         * @type {boolean}
         */ _this.imageRotateWithView_ = false;
        /**
         * @private
         * @type {number}
         */ _this.imageRotation_ = 0;
        /**
         * @private
         * @type {import("../../size.js").Size}
         */ _this.imageScale_ = [
            0,
            0
        ];
        /**
         * @private
         * @type {number}
         */ _this.imageWidth_ = 0;
        /**
         * @private
         * @type {string}
         */ _this.text_ = '';
        /**
         * @private
         * @type {number}
         */ _this.textOffsetX_ = 0;
        /**
         * @private
         * @type {number}
         */ _this.textOffsetY_ = 0;
        /**
         * @private
         * @type {boolean}
         */ _this.textRotateWithView_ = false;
        /**
         * @private
         * @type {number}
         */ _this.textRotation_ = 0;
        /**
         * @private
         * @type {import("../../size.js").Size}
         */ _this.textScale_ = [
            0,
            0
        ];
        /**
         * @private
         * @type {?import("../canvas.js").FillState}
         */ _this.textFillState_ = null;
        /**
         * @private
         * @type {?import("../canvas.js").StrokeState}
         */ _this.textStrokeState_ = null;
        /**
         * @private
         * @type {?import("../canvas.js").TextState}
         */ _this.textState_ = null;
        /**
         * @private
         * @type {Array<number>}
         */ _this.pixelCoordinates_ = [];
        /**
         * @private
         * @type {import("../../transform.js").Transform}
         */ _this.tmpLocalTransform_ = _transformJs.create();
        return _this;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */ CanvasImmediateRenderer2.prototype.drawImages_ = function(flatCoordinates, offset, end, stride) {
        if (!this.image_) return;
        var pixelCoordinates = _transformJs1.transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        var context = this.context_;
        var localTransform = this.tmpLocalTransform_;
        var alpha = context.globalAlpha;
        if (this.imageOpacity_ != 1) context.globalAlpha = alpha * this.imageOpacity_;
        var rotation = this.imageRotation_;
        if (this.imageRotateWithView_) rotation += this.viewRotation_;
        for(var i = 0, ii = pixelCoordinates.length; i < ii; i += 2){
            var x = pixelCoordinates[i] - this.imageAnchorX_;
            var y = pixelCoordinates[i + 1] - this.imageAnchorY_;
            if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
                var centerX = x + this.imageAnchorX_;
                var centerY = y + this.imageAnchorY_;
                _transformJs.compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
                context.setTransform.apply(context, localTransform);
                context.translate(centerX, centerY);
                context.scale(this.imageScale_[0], this.imageScale_[1]);
                context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
                context.setTransform(1, 0, 0, 1, 0, 0);
            } else context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
        }
        if (this.imageOpacity_ != 1) context.globalAlpha = alpha;
    };
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */ CanvasImmediateRenderer2.prototype.drawText_ = function(flatCoordinates, offset, end, stride) {
        if (!this.textState_ || this.text_ === '') return;
        if (this.textFillState_) this.setContextFillState_(this.textFillState_);
        if (this.textStrokeState_) this.setContextStrokeState_(this.textStrokeState_);
        this.setContextTextState_(this.textState_);
        var pixelCoordinates = _transformJs1.transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        var context = this.context_;
        var rotation = this.textRotation_;
        if (this.textRotateWithView_) rotation += this.viewRotation_;
        for(; offset < end; offset += stride){
            var x = pixelCoordinates[offset] + this.textOffsetX_;
            var y = pixelCoordinates[offset + 1] + this.textOffsetY_;
            if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
                var localTransform = _transformJs.compose(this.tmpLocalTransform_, x, y, 1, 1, rotation, -x, -y);
                context.setTransform.apply(context, localTransform);
                context.translate(x, y);
                context.scale(this.textScale_[0], this.textScale_[1]);
                if (this.textStrokeState_) context.strokeText(this.text_, 0, 0);
                if (this.textFillState_) context.fillText(this.text_, 0, 0);
                context.setTransform(1, 0, 0, 1, 0, 0);
            } else {
                if (this.textStrokeState_) context.strokeText(this.text_, x, y);
                if (this.textFillState_) context.fillText(this.text_, x, y);
            }
        }
    };
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} close Close.
     * @private
     * @return {number} end End.
     */ CanvasImmediateRenderer2.prototype.moveToLineTo_ = function(flatCoordinates, offset, end, stride, close) {
        var context = this.context_;
        var pixelCoordinates = _transformJs1.transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
        context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
        var length = pixelCoordinates.length;
        if (close) length -= 2;
        for(var i = 2; i < length; i += 2)context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
        if (close) context.closePath();
        return end;
    };
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */ CanvasImmediateRenderer2.prototype.drawRings_ = function(flatCoordinates, offset, ends, stride) {
        for(var i = 0, ii = ends.length; i < ii; ++i)offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
        return offset;
    };
    /**
     * Render a circle geometry into the canvas.  Rendering is immediate and uses
     * the current fill and stroke styles.
     *
     * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
     * @api
     */ CanvasImmediateRenderer2.prototype.drawCircle = function(geometry) {
        if (!_extentJs.intersects(this.extent_, geometry.getExtent())) return;
        if (this.fillState_ || this.strokeState_) {
            if (this.fillState_) this.setContextFillState_(this.fillState_);
            if (this.strokeState_) this.setContextStrokeState_(this.strokeState_);
            var pixelCoordinates = _simpleGeometryJs.transformGeom2D(geometry, this.transform_, this.pixelCoordinates_);
            var dx = pixelCoordinates[2] - pixelCoordinates[0];
            var dy = pixelCoordinates[3] - pixelCoordinates[1];
            var radius = Math.sqrt(dx * dx + dy * dy);
            var context = this.context_;
            context.beginPath();
            context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
            if (this.fillState_) context.fill();
            if (this.strokeState_) context.stroke();
        }
        if (this.text_ !== '') this.drawText_(geometry.getCenter(), 0, 2, 2);
    };
    /**
     * Set the rendering style.  Note that since this is an immediate rendering API,
     * any `zIndex` on the provided style will be ignored.
     *
     * @param {import("../../style/Style.js").default} style The rendering style.
     * @api
     */ CanvasImmediateRenderer2.prototype.setStyle = function(style) {
        this.setFillStrokeStyle(style.getFill(), style.getStroke());
        this.setImageStyle(style.getImage());
        this.setTextStyle(style.getText());
    };
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     */ CanvasImmediateRenderer2.prototype.setTransform = function(transform) {
        this.transform_ = transform;
    };
    /**
     * Render a geometry into the canvas.  Call
     * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
     *
     * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
     * @api
     */ CanvasImmediateRenderer2.prototype.drawGeometry = function(geometry) {
        var type = geometry.getType();
        switch(type){
            case _geometryTypeJsDefault.default.POINT:
                this.drawPoint(geometry);
                break;
            case _geometryTypeJsDefault.default.LINE_STRING:
                this.drawLineString(geometry);
                break;
            case _geometryTypeJsDefault.default.POLYGON:
                this.drawPolygon(geometry);
                break;
            case _geometryTypeJsDefault.default.MULTI_POINT:
                this.drawMultiPoint(geometry);
                break;
            case _geometryTypeJsDefault.default.MULTI_LINE_STRING:
                this.drawMultiLineString(geometry);
                break;
            case _geometryTypeJsDefault.default.MULTI_POLYGON:
                this.drawMultiPolygon(geometry);
                break;
            case _geometryTypeJsDefault.default.GEOMETRY_COLLECTION:
                this.drawGeometryCollection(geometry);
                break;
            case _geometryTypeJsDefault.default.CIRCLE:
                this.drawCircle(geometry);
                break;
            default:
        }
    };
    /**
     * Render a feature into the canvas.  Note that any `zIndex` on the provided
     * style will be ignored - features are rendered immediately in the order that
     * this method is called.  If you need `zIndex` support, you should be using an
     * {@link module:ol/layer/Vector~VectorLayer VectorLayer} instead.
     *
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {import("../../style/Style.js").default} style Style.
     * @api
     */ CanvasImmediateRenderer2.prototype.drawFeature = function(feature, style) {
        var geometry = style.getGeometryFunction()(feature);
        if (!geometry || !_extentJs.intersects(this.extent_, geometry.getExtent())) return;
        this.setStyle(style);
        this.drawGeometry(geometry);
    };
    /**
     * Render a GeometryCollection to the canvas.  Rendering is immediate and
     * uses the current styles appropriate for each geometry in the collection.
     *
     * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
     */ CanvasImmediateRenderer2.prototype.drawGeometryCollection = function(geometry) {
        var geometries = geometry.getGeometriesArray();
        for(var i = 0, ii = geometries.length; i < ii; ++i)this.drawGeometry(geometries[i]);
    };
    /**
     * Render a Point geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
     */ CanvasImmediateRenderer2.prototype.drawPoint = function(geometry) {
        if (this.squaredTolerance_) geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        var flatCoordinates = geometry.getFlatCoordinates();
        var stride = geometry.getStride();
        if (this.image_) this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        if (this.text_ !== '') this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    };
    /**
     * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
     * uses the current style.
     *
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
     */ CanvasImmediateRenderer2.prototype.drawMultiPoint = function(geometry) {
        if (this.squaredTolerance_) geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        var flatCoordinates = geometry.getFlatCoordinates();
        var stride = geometry.getStride();
        if (this.image_) this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        if (this.text_ !== '') this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    };
    /**
     * Render a LineString into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
     */ CanvasImmediateRenderer2.prototype.drawLineString = function(geometry) {
        if (this.squaredTolerance_) geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        if (!_extentJs.intersects(this.extent_, geometry.getExtent())) return;
        if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
            var context = this.context_;
            var flatCoordinates = geometry.getFlatCoordinates();
            context.beginPath();
            this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
            context.stroke();
        }
        if (this.text_ !== '') {
            var flatMidpoint = geometry.getFlatMidpoint();
            this.drawText_(flatMidpoint, 0, 2, 2);
        }
    };
    /**
     * Render a MultiLineString geometry into the canvas.  Rendering is immediate
     * and uses the current style.
     *
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
     */ CanvasImmediateRenderer2.prototype.drawMultiLineString = function(geometry) {
        if (this.squaredTolerance_) geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        var geometryExtent = geometry.getExtent();
        if (!_extentJs.intersects(this.extent_, geometryExtent)) return;
        if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
            var context = this.context_;
            var flatCoordinates = geometry.getFlatCoordinates();
            var offset = 0;
            var ends = geometry.getEnds();
            var stride = geometry.getStride();
            context.beginPath();
            for(var i = 0, ii = ends.length; i < ii; ++i)offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
            context.stroke();
        }
        if (this.text_ !== '') {
            var flatMidpoints = geometry.getFlatMidpoints();
            this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
        }
    };
    /**
     * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
     */ CanvasImmediateRenderer2.prototype.drawPolygon = function(geometry) {
        if (this.squaredTolerance_) geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        if (!_extentJs.intersects(this.extent_, geometry.getExtent())) return;
        if (this.strokeState_ || this.fillState_) {
            if (this.fillState_) this.setContextFillState_(this.fillState_);
            if (this.strokeState_) this.setContextStrokeState_(this.strokeState_);
            var context = this.context_;
            context.beginPath();
            this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, geometry.getEnds(), geometry.getStride());
            if (this.fillState_) context.fill();
            if (this.strokeState_) context.stroke();
        }
        if (this.text_ !== '') {
            var flatInteriorPoint = geometry.getFlatInteriorPoint();
            this.drawText_(flatInteriorPoint, 0, 2, 2);
        }
    };
    /**
     * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
     * uses the current style.
     * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
     */ CanvasImmediateRenderer2.prototype.drawMultiPolygon = function(geometry) {
        if (this.squaredTolerance_) geometry = geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
        if (!_extentJs.intersects(this.extent_, geometry.getExtent())) return;
        if (this.strokeState_ || this.fillState_) {
            if (this.fillState_) this.setContextFillState_(this.fillState_);
            if (this.strokeState_) this.setContextStrokeState_(this.strokeState_);
            var context = this.context_;
            var flatCoordinates = geometry.getOrientedFlatCoordinates();
            var offset = 0;
            var endss = geometry.getEndss();
            var stride = geometry.getStride();
            context.beginPath();
            for(var i = 0, ii = endss.length; i < ii; ++i){
                var ends = endss[i];
                offset = this.drawRings_(flatCoordinates, offset, ends, stride);
            }
            if (this.fillState_) context.fill();
            if (this.strokeState_) context.stroke();
        }
        if (this.text_ !== '') {
            var flatInteriorPoints = geometry.getFlatInteriorPoints();
            this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
        }
    };
    /**
     * @param {import("../canvas.js").FillState} fillState Fill state.
     * @private
     */ CanvasImmediateRenderer2.prototype.setContextFillState_ = function(fillState) {
        var context = this.context_;
        var contextFillState = this.contextFillState_;
        if (!contextFillState) {
            context.fillStyle = fillState.fillStyle;
            this.contextFillState_ = {
                fillStyle: fillState.fillStyle
            };
        } else if (contextFillState.fillStyle != fillState.fillStyle) {
            contextFillState.fillStyle = fillState.fillStyle;
            context.fillStyle = fillState.fillStyle;
        }
    };
    /**
     * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
     * @private
     */ CanvasImmediateRenderer2.prototype.setContextStrokeState_ = function(strokeState) {
        var context = this.context_;
        var contextStrokeState = this.contextStrokeState_;
        if (!contextStrokeState) {
            context.lineCap = strokeState.lineCap;
            if (context.setLineDash) {
                context.setLineDash(strokeState.lineDash);
                context.lineDashOffset = strokeState.lineDashOffset;
            }
            context.lineJoin = strokeState.lineJoin;
            context.lineWidth = strokeState.lineWidth;
            context.miterLimit = strokeState.miterLimit;
            context.strokeStyle = strokeState.strokeStyle;
            this.contextStrokeState_ = {
                lineCap: strokeState.lineCap,
                lineDash: strokeState.lineDash,
                lineDashOffset: strokeState.lineDashOffset,
                lineJoin: strokeState.lineJoin,
                lineWidth: strokeState.lineWidth,
                miterLimit: strokeState.miterLimit,
                strokeStyle: strokeState.strokeStyle
            };
        } else {
            if (contextStrokeState.lineCap != strokeState.lineCap) {
                contextStrokeState.lineCap = strokeState.lineCap;
                context.lineCap = strokeState.lineCap;
            }
            if (context.setLineDash) {
                if (!_arrayJs.equals(contextStrokeState.lineDash, strokeState.lineDash)) context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
                if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
                    contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
                    context.lineDashOffset = strokeState.lineDashOffset;
                }
            }
            if (contextStrokeState.lineJoin != strokeState.lineJoin) {
                contextStrokeState.lineJoin = strokeState.lineJoin;
                context.lineJoin = strokeState.lineJoin;
            }
            if (contextStrokeState.lineWidth != strokeState.lineWidth) {
                contextStrokeState.lineWidth = strokeState.lineWidth;
                context.lineWidth = strokeState.lineWidth;
            }
            if (contextStrokeState.miterLimit != strokeState.miterLimit) {
                contextStrokeState.miterLimit = strokeState.miterLimit;
                context.miterLimit = strokeState.miterLimit;
            }
            if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
                contextStrokeState.strokeStyle = strokeState.strokeStyle;
                context.strokeStyle = strokeState.strokeStyle;
            }
        }
    };
    /**
     * @param {import("../canvas.js").TextState} textState Text state.
     * @private
     */ CanvasImmediateRenderer2.prototype.setContextTextState_ = function(textState) {
        var context = this.context_;
        var contextTextState = this.contextTextState_;
        var textAlign = textState.textAlign ? textState.textAlign : _canvasJs.defaultTextAlign;
        if (!contextTextState) {
            context.font = textState.font;
            context.textAlign = textAlign;
            context.textBaseline = textState.textBaseline;
            this.contextTextState_ = {
                font: textState.font,
                textAlign: textAlign,
                textBaseline: textState.textBaseline
            };
        } else {
            if (contextTextState.font != textState.font) {
                contextTextState.font = textState.font;
                context.font = textState.font;
            }
            if (contextTextState.textAlign != textAlign) {
                contextTextState.textAlign = textAlign;
                context.textAlign = textAlign;
            }
            if (contextTextState.textBaseline != textState.textBaseline) {
                contextTextState.textBaseline = textState.textBaseline;
                context.textBaseline = textState.textBaseline;
            }
        }
    };
    /**
     * Set the fill and stroke style for subsequent draw operations.  To clear
     * either fill or stroke styles, pass null for the appropriate parameter.
     *
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     */ CanvasImmediateRenderer2.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
        var _this = this;
        if (!fillStyle) this.fillState_ = null;
        else {
            var fillStyleColor = fillStyle.getColor();
            this.fillState_ = {
                fillStyle: _colorlikeJs.asColorLike(fillStyleColor ? fillStyleColor : _canvasJs.defaultFillStyle)
            };
        }
        if (!strokeStyle) this.strokeState_ = null;
        else {
            var strokeStyleColor = strokeStyle.getColor();
            var strokeStyleLineCap = strokeStyle.getLineCap();
            var strokeStyleLineDash = strokeStyle.getLineDash();
            var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
            var strokeStyleLineJoin = strokeStyle.getLineJoin();
            var strokeStyleWidth = strokeStyle.getWidth();
            var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
            var lineDash = strokeStyleLineDash ? strokeStyleLineDash : _canvasJs.defaultLineDash;
            this.strokeState_ = {
                lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvasJs.defaultLineCap,
                lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map(function(n) {
                    return n * _this.pixelRatio_;
                }),
                lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvasJs.defaultLineDashOffset) * this.pixelRatio_,
                lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvasJs.defaultLineJoin,
                lineWidth: (strokeStyleWidth !== undefined ? strokeStyleWidth : _canvasJs.defaultLineWidth) * this.pixelRatio_,
                miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvasJs.defaultMiterLimit,
                strokeStyle: _colorlikeJs.asColorLike(strokeStyleColor ? strokeStyleColor : _canvasJs.defaultStrokeStyle)
            };
        }
    };
    /**
     * Set the image style for subsequent draw operations.  Pass null to remove
     * the image style.
     *
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     */ CanvasImmediateRenderer2.prototype.setImageStyle = function(imageStyle) {
        var imageSize;
        if (!imageStyle || !(imageSize = imageStyle.getSize())) {
            this.image_ = null;
            return;
        }
        var imageAnchor = imageStyle.getAnchor();
        var imageOrigin = imageStyle.getOrigin();
        this.image_ = imageStyle.getImage(this.pixelRatio_);
        this.imageAnchorX_ = imageAnchor[0] * this.pixelRatio_;
        this.imageAnchorY_ = imageAnchor[1] * this.pixelRatio_;
        this.imageHeight_ = imageSize[1] * this.pixelRatio_;
        this.imageOpacity_ = imageStyle.getOpacity();
        this.imageOriginX_ = imageOrigin[0];
        this.imageOriginY_ = imageOrigin[1];
        this.imageRotateWithView_ = imageStyle.getRotateWithView();
        this.imageRotation_ = imageStyle.getRotation();
        this.imageScale_ = imageStyle.getScaleArray();
        this.imageWidth_ = imageSize[0] * this.pixelRatio_;
    };
    /**
     * Set the text style for subsequent draw operations.  Pass null to
     * remove the text style.
     *
     * @param {import("../../style/Text.js").default} textStyle Text style.
     */ CanvasImmediateRenderer2.prototype.setTextStyle = function(textStyle) {
        if (!textStyle) this.text_ = '';
        else {
            var textFillStyle = textStyle.getFill();
            if (!textFillStyle) this.textFillState_ = null;
            else {
                var textFillStyleColor = textFillStyle.getColor();
                this.textFillState_ = {
                    fillStyle: _colorlikeJs.asColorLike(textFillStyleColor ? textFillStyleColor : _canvasJs.defaultFillStyle)
                };
            }
            var textStrokeStyle = textStyle.getStroke();
            if (!textStrokeStyle) this.textStrokeState_ = null;
            else {
                var textStrokeStyleColor = textStrokeStyle.getColor();
                var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
                var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
                var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
                var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
                var textStrokeStyleWidth = textStrokeStyle.getWidth();
                var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
                this.textStrokeState_ = {
                    lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : _canvasJs.defaultLineCap,
                    lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : _canvasJs.defaultLineDash,
                    lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : _canvasJs.defaultLineDashOffset,
                    lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : _canvasJs.defaultLineJoin,
                    lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : _canvasJs.defaultLineWidth,
                    miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : _canvasJs.defaultMiterLimit,
                    strokeStyle: _colorlikeJs.asColorLike(textStrokeStyleColor ? textStrokeStyleColor : _canvasJs.defaultStrokeStyle)
                };
            }
            var textFont = textStyle.getFont();
            var textOffsetX = textStyle.getOffsetX();
            var textOffsetY = textStyle.getOffsetY();
            var textRotateWithView = textStyle.getRotateWithView();
            var textRotation = textStyle.getRotation();
            var textScale = textStyle.getScaleArray();
            var textText = textStyle.getText();
            var textTextAlign = textStyle.getTextAlign();
            var textTextBaseline = textStyle.getTextBaseline();
            this.textState_ = {
                font: textFont !== undefined ? textFont : _canvasJs.defaultFont,
                textAlign: textTextAlign !== undefined ? textTextAlign : _canvasJs.defaultTextAlign,
                textBaseline: textTextBaseline !== undefined ? textTextBaseline : _canvasJs.defaultTextBaseline
            };
            this.text_ = textText !== undefined ? textText : '';
            this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
            this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
            this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
            this.textRotation_ = textRotation !== undefined ? textRotation : 0;
            this.textScale_ = [
                this.pixelRatio_ * textScale[0],
                this.pixelRatio_ * textScale[1], 
            ];
        }
    };
    return CanvasImmediateRenderer2;
}(_vectorContextJsDefault.default);
exports.default = CanvasImmediateRenderer1;

},{"../../geom/GeometryType.js":"3sRlw","../VectorContext.js":"bbfFo","../../colorlike.js":"fW2wi","../../transform.js":"C21tg","../canvas.js":"hMw4S","../../array.js":"jKNP0","../../extent.js":"jgUz2","../../geom/flat/transform.js":"eZ5a1","../../geom/SimpleGeometry.js":"4jyQo","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"i3fS4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
     * Anchor is a fraction
     * @api
     */ FRACTION: 'fraction',
    /**
     * Anchor is in pixels
     * @api
     */ PIXELS: 'pixels'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"a8X4g":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/style
 */ parcelHelpers.export(exports, "Circle", ()=>_circleJsDefault.default
);
parcelHelpers.export(exports, "Fill", ()=>_fillJsDefault.default
);
parcelHelpers.export(exports, "Icon", ()=>_iconJsDefault.default
);
parcelHelpers.export(exports, "IconImage", ()=>_iconImageJsDefault.default
);
parcelHelpers.export(exports, "Image", ()=>_imageJsDefault.default
);
parcelHelpers.export(exports, "RegularShape", ()=>_regularShapeJsDefault.default
);
parcelHelpers.export(exports, "Stroke", ()=>_strokeJsDefault.default
);
parcelHelpers.export(exports, "Style", ()=>_styleJsDefault.default
);
parcelHelpers.export(exports, "Text", ()=>_textJsDefault.default
);
var _circleJs = require("./style/Circle.js");
var _circleJsDefault = parcelHelpers.interopDefault(_circleJs);
var _fillJs = require("./style/Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _iconJs = require("./style/Icon.js");
var _iconJsDefault = parcelHelpers.interopDefault(_iconJs);
var _iconImageJs = require("./style/IconImage.js");
var _iconImageJsDefault = parcelHelpers.interopDefault(_iconImageJs);
var _imageJs = require("./style/Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _regularShapeJs = require("./style/RegularShape.js");
var _regularShapeJsDefault = parcelHelpers.interopDefault(_regularShapeJs);
var _strokeJs = require("./style/Stroke.js");
var _strokeJsDefault = parcelHelpers.interopDefault(_strokeJs);
var _styleJs = require("./style/Style.js");
var _styleJsDefault = parcelHelpers.interopDefault(_styleJs);
var _textJs = require("./style/Text.js");
var _textJsDefault = parcelHelpers.interopDefault(_textJs);

},{"./style/Circle.js":"igecK","./style/Fill.js":"bJ6U2","./style/Icon.js":"1Z5TJ","./style/IconImage.js":"9VJtb","./style/Image.js":"yHj36","./style/RegularShape.js":"dPxON","./style/Stroke.js":"bT7BW","./style/Style.js":"9N9zp","./style/Text.js":"nG60s","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"1Z5TJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/style/Icon
 */ var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _iconAnchorUnitsJs = require("./IconAnchorUnits.js");
var _iconAnchorUnitsJsDefault = parcelHelpers.interopDefault(_iconAnchorUnitsJs);
var _iconOriginJs = require("./IconOrigin.js");
var _iconOriginJsDefault = parcelHelpers.interopDefault(_iconOriginJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _imageJs = require("./Image.js");
var _imageJsDefault = parcelHelpers.interopDefault(_imageJs);
var _colorJs = require("../color.js");
var _assertsJs = require("../asserts.js");
var _iconImageJs = require("./IconImage.js");
var _utilJs = require("../util.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {import("./IconOrigin.js").default} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("./IconAnchorUnits.js").default} [anchorXUnits='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {import("./IconAnchorUnits.js").default} [anchorYUnits='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {HTMLImageElement|HTMLCanvasElement} [img] Image object for the icon. If the `src` option is not provided then the
 * provided image must already be loaded. And in that case, it is required
 * to provide the size of the image, with the `imgSize` option.
 * @property {Array<number>} [offset=[0, 0]] Offset, which, together with the size and the offset origin, define the
 * sub-rectangle to use from the original icon image.
 * @property {Array<number>} [displacement=[0,0]] Displacement the icon
 * @property {import("./IconOrigin.js").default} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {number} [opacity=1] Opacity of the icon.
 * @property {number|import("../size.js").Size} [scale=1] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {import("../size.js").Size} [size] Icon size in pixel. Can be used together with `offset` to define the
 * sub-rectangle to use from the origin (sprite) icon image.
 * @property {import("../size.js").Size} [imgSize] Image size in pixels. Only required if `img` is set and `src` is not, and
 * for SVG images in Internet Explorer 11. The provided `imgSize` needs to match the actual size of the image.
 * @property {string} [src] Image source URI.
 */ /**
 * @classdesc
 * Set icon style for vector features.
 * @api
 */ var Icon1 = function(_super) {
    __extends(Icon2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function Icon2(opt_options) {
        var _this = this;
        var options = opt_options || {
        };
        /**
         * @type {number}
         */ var opacity = options.opacity !== undefined ? options.opacity : 1;
        /**
         * @type {number}
         */ var rotation = options.rotation !== undefined ? options.rotation : 0;
        /**
         * @type {number|import("../size.js").Size}
         */ var scale = options.scale !== undefined ? options.scale : 1;
        /**
         * @type {boolean}
         */ var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
        _this = _super.call(this, {
            opacity: opacity,
            rotation: rotation,
            scale: scale,
            displacement: options.displacement !== undefined ? options.displacement : [
                0,
                0
            ],
            rotateWithView: rotateWithView
        }) || this;
        /**
         * @private
         * @type {Array<number>}
         */ _this.anchor_ = options.anchor !== undefined ? options.anchor : [
            0.5,
            0.5
        ];
        /**
         * @private
         * @type {Array<number>}
         */ _this.normalizedAnchor_ = null;
        /**
         * @private
         * @type {import("./IconOrigin.js").default}
         */ _this.anchorOrigin_ = options.anchorOrigin !== undefined ? options.anchorOrigin : _iconOriginJsDefault.default.TOP_LEFT;
        /**
         * @private
         * @type {import("./IconAnchorUnits.js").default}
         */ _this.anchorXUnits_ = options.anchorXUnits !== undefined ? options.anchorXUnits : _iconAnchorUnitsJsDefault.default.FRACTION;
        /**
         * @private
         * @type {import("./IconAnchorUnits.js").default}
         */ _this.anchorYUnits_ = options.anchorYUnits !== undefined ? options.anchorYUnits : _iconAnchorUnitsJsDefault.default.FRACTION;
        /**
         * @private
         * @type {?string}
         */ _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
        /**
         * @type {HTMLImageElement|HTMLCanvasElement}
         */ var image = options.img !== undefined ? options.img : null;
        /**
         * @type {import("../size.js").Size}
         */ var imgSize = options.imgSize !== undefined ? options.imgSize : null;
        /**
         * @type {string|undefined}
         */ var src = options.src;
        _assertsJs.assert(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time
        _assertsJs.assert(!image || image && imgSize, 5); // `imgSize` must be set when `image` is provided
        if ((src === undefined || src.length === 0) && image) src = /** @type {HTMLImageElement} */ image.src || _utilJs.getUid(image);
        _assertsJs.assert(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided
        /**
         * @type {import("../ImageState.js").default}
         */ var imageState = options.src !== undefined ? _imageStateJsDefault.default.IDLE : _imageStateJsDefault.default.LOADED;
        /**
         * @private
         * @type {import("../color.js").Color}
         */ _this.color_ = options.color !== undefined ? _colorJs.asArray(options.color) : null;
        /**
         * @private
         * @type {import("./IconImage.js").default}
         */ _this.iconImage_ = _iconImageJs.get(image, src, imgSize, _this.crossOrigin_, imageState, _this.color_);
        /**
         * @private
         * @type {Array<number>}
         */ _this.offset_ = options.offset !== undefined ? options.offset : [
            0,
            0
        ];
        /**
         * @private
         * @type {import("./IconOrigin.js").default}
         */ _this.offsetOrigin_ = options.offsetOrigin !== undefined ? options.offsetOrigin : _iconOriginJsDefault.default.TOP_LEFT;
        /**
         * @private
         * @type {Array<number>}
         */ _this.origin_ = null;
        /**
         * @private
         * @type {import("../size.js").Size}
         */ _this.size_ = options.size !== undefined ? options.size : null;
        return _this;
    }
    /**
     * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
     * @return {Icon} The cloned style.
     * @api
     */ Icon2.prototype.clone = function() {
        var scale = this.getScale();
        return new Icon2({
            anchor: this.anchor_.slice(),
            anchorOrigin: this.anchorOrigin_,
            anchorXUnits: this.anchorXUnits_,
            anchorYUnits: this.anchorYUnits_,
            crossOrigin: this.crossOrigin_,
            color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || undefined,
            src: this.getSrc(),
            offset: this.offset_.slice(),
            offsetOrigin: this.offsetOrigin_,
            size: this.size_ !== null ? this.size_.slice() : undefined,
            opacity: this.getOpacity(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView()
        });
    };
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     */ Icon2.prototype.getAnchor = function() {
        if (this.normalizedAnchor_) return this.normalizedAnchor_;
        var anchor = this.anchor_;
        var size = this.getSize();
        if (this.anchorXUnits_ == _iconAnchorUnitsJsDefault.default.FRACTION || this.anchorYUnits_ == _iconAnchorUnitsJsDefault.default.FRACTION) {
            if (!size) return null;
            anchor = this.anchor_.slice();
            if (this.anchorXUnits_ == _iconAnchorUnitsJsDefault.default.FRACTION) anchor[0] *= size[0];
            if (this.anchorYUnits_ == _iconAnchorUnitsJsDefault.default.FRACTION) anchor[1] *= size[1];
        }
        if (this.anchorOrigin_ != _iconOriginJsDefault.default.TOP_LEFT) {
            if (!size) return null;
            if (anchor === this.anchor_) anchor = this.anchor_.slice();
            if (this.anchorOrigin_ == _iconOriginJsDefault.default.TOP_RIGHT || this.anchorOrigin_ == _iconOriginJsDefault.default.BOTTOM_RIGHT) anchor[0] = -anchor[0] + size[0];
            if (this.anchorOrigin_ == _iconOriginJsDefault.default.BOTTOM_LEFT || this.anchorOrigin_ == _iconOriginJsDefault.default.BOTTOM_RIGHT) anchor[1] = -anchor[1] + size[1];
        }
        var displacement = this.getDisplacement();
        anchor[0] -= displacement[0];
        anchor[1] += displacement[1];
        this.normalizedAnchor_ = anchor;
        return this.normalizedAnchor_;
    };
    /**
     * Set the anchor point. The anchor determines the center point for the
     * symbolizer.
     *
     * @param {Array<number>} anchor Anchor.
     * @api
     */ Icon2.prototype.setAnchor = function(anchor) {
        this.anchor_ = anchor;
        this.normalizedAnchor_ = null;
    };
    /**
     * Get the icon color.
     * @return {import("../color.js").Color} Color.
     * @api
     */ Icon2.prototype.getColor = function() {
        return this.color_;
    };
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
     * @api
     */ Icon2.prototype.getImage = function(pixelRatio) {
        return this.iconImage_.getImage(pixelRatio);
    };
    /**
     * Get the pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} The pixel ratio of the image.
     * @api
     */ Icon2.prototype.getPixelRatio = function(pixelRatio) {
        return this.iconImage_.getPixelRatio(pixelRatio);
    };
    /**
     * @return {import("../size.js").Size} Image size.
     */ Icon2.prototype.getImageSize = function() {
        return this.iconImage_.getSize();
    };
    /**
     * @return {import("../ImageState.js").default} Image state.
     */ Icon2.prototype.getImageState = function() {
        return this.iconImage_.getImageState();
    };
    /**
     * @return {HTMLImageElement|HTMLCanvasElement} Image element.
     */ Icon2.prototype.getHitDetectionImage = function() {
        return this.iconImage_.getHitDetectionImage();
    };
    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     */ Icon2.prototype.getOrigin = function() {
        if (this.origin_) return this.origin_;
        var offset = this.offset_;
        if (this.offsetOrigin_ != _iconOriginJsDefault.default.TOP_LEFT) {
            var size = this.getSize();
            var iconImageSize = this.iconImage_.getSize();
            if (!size || !iconImageSize) return null;
            offset = offset.slice();
            if (this.offsetOrigin_ == _iconOriginJsDefault.default.TOP_RIGHT || this.offsetOrigin_ == _iconOriginJsDefault.default.BOTTOM_RIGHT) offset[0] = iconImageSize[0] - size[0] - offset[0];
            if (this.offsetOrigin_ == _iconOriginJsDefault.default.BOTTOM_LEFT || this.offsetOrigin_ == _iconOriginJsDefault.default.BOTTOM_RIGHT) offset[1] = iconImageSize[1] - size[1] - offset[1];
        }
        this.origin_ = offset;
        return this.origin_;
    };
    /**
     * Get the image URL.
     * @return {string|undefined} Image src.
     * @api
     */ Icon2.prototype.getSrc = function() {
        return this.iconImage_.getSrc();
    };
    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     * @api
     */ Icon2.prototype.getSize = function() {
        return !this.size_ ? this.iconImage_.getSize() : this.size_;
    };
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */ Icon2.prototype.listenImageChange = function(listener) {
        this.iconImage_.addEventListener(_eventTypeJsDefault.default.CHANGE, listener);
    };
    /**
     * Load not yet loaded URI.
     * When rendering a feature with an icon style, the vector renderer will
     * automatically call this method. However, you might want to call this
     * method yourself for preloading or other purposes.
     * @api
     */ Icon2.prototype.load = function() {
        this.iconImage_.load();
    };
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */ Icon2.prototype.unlistenImageChange = function(listener) {
        this.iconImage_.removeEventListener(_eventTypeJsDefault.default.CHANGE, listener);
    };
    return Icon2;
}(_imageJsDefault.default);
exports.default = Icon1;

},{"../events/EventType.js":"83vee","./IconAnchorUnits.js":"i3fS4","./IconOrigin.js":"cLbI9","../ImageState.js":"9Ji45","./Image.js":"yHj36","../color.js":"liKgX","../asserts.js":"cnrP4","./IconImage.js":"9VJtb","../util.js":"9zOhk","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cLbI9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
     * Origin is at bottom left
     * @api
     */ BOTTOM_LEFT: 'bottom-left',
    /**
     * Origin is at bottom right
     * @api
     */ BOTTOM_RIGHT: 'bottom-right',
    /**
     * Origin is at top left
     * @api
     */ TOP_LEFT: 'top-left',
    /**
     * Origin is at top right
     * @api
     */ TOP_RIGHT: 'top-right'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"9VJtb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {HTMLImageElement|HTMLCanvasElement} image Image.
 * @param {string} src Src.
 * @param {import("../size.js").Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../ImageState.js").default} imageState Image state.
 * @param {import("../color.js").Color} color Color.
 * @return {IconImage} Icon image.
 */ parcelHelpers.export(exports, "get", ()=>get
);
var _targetJs = require("../events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _colorJs = require("../color.js");
var _domJs = require("../dom.js");
var _iconImageCacheJs = require("./IconImageCache.js");
var _imageJs = require("../Image.js");
/**
 * @module ol/style/IconImage
 */ var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @type {CanvasRenderingContext2D}
 */ var taintedTestContext = null;
var IconImage1 = function(_super) {
    __extends(IconImage2, _super);
    /**
     * @param {HTMLImageElement|HTMLCanvasElement} image Image.
     * @param {string|undefined} src Src.
     * @param {import("../size.js").Size} size Size.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../ImageState.js").default} imageState Image state.
     * @param {import("../color.js").Color} color Color.
     */ function IconImage2(image, src, size, crossOrigin, imageState, color) {
        var _this = _super.call(this) || this;
        /**
         * @private
         * @type {HTMLImageElement|HTMLCanvasElement}
         */ _this.hitDetectionImage_ = null;
        /**
         * @private
         * @type {HTMLImageElement|HTMLCanvasElement}
         */ _this.image_ = !image ? new Image() : image;
        if (crossOrigin !== null) /** @type {HTMLImageElement} */ (_this.image_).crossOrigin = crossOrigin;
        /**
         * @private
         * @type {Object<number, HTMLCanvasElement>}
         */ _this.canvas_ = {
        };
        /**
         * @private
         * @type {import("../color.js").Color}
         */ _this.color_ = color;
        /**
         * @private
         * @type {?function():void}
         */ _this.unlisten_ = null;
        /**
         * @private
         * @type {import("../ImageState.js").default}
         */ _this.imageState_ = imageState;
        /**
         * @private
         * @type {import("../size.js").Size}
         */ _this.size_ = size;
        /**
         * @private
         * @type {string|undefined}
         */ _this.src_ = src;
        /**
         * @private
         */ _this.tainted_;
        return _this;
    }
    /**
     * @private
     * @return {boolean} The image canvas is tainted.
     */ IconImage2.prototype.isTainted_ = function() {
        if (this.tainted_ === undefined && this.imageState_ === _imageStateJsDefault.default.LOADED) {
            if (!taintedTestContext) taintedTestContext = _domJs.createCanvasContext2D(1, 1);
            taintedTestContext.drawImage(this.image_, 0, 0);
            try {
                taintedTestContext.getImageData(0, 0, 1, 1);
                this.tainted_ = false;
            } catch (e) {
                taintedTestContext = null;
                this.tainted_ = true;
            }
        }
        return this.tainted_ === true;
    };
    /**
     * @private
     */ IconImage2.prototype.dispatchChangeEvent_ = function() {
        this.dispatchEvent(_eventTypeJsDefault.default.CHANGE);
    };
    /**
     * @private
     */ IconImage2.prototype.handleImageError_ = function() {
        this.imageState_ = _imageStateJsDefault.default.ERROR;
        this.unlistenImage_();
        this.dispatchChangeEvent_();
    };
    /**
     * @private
     */ IconImage2.prototype.handleImageLoad_ = function() {
        this.imageState_ = _imageStateJsDefault.default.LOADED;
        if (this.size_) {
            this.image_.width = this.size_[0];
            this.image_.height = this.size_[1];
        } else this.size_ = [
            this.image_.width,
            this.image_.height
        ];
        this.unlistenImage_();
        this.dispatchChangeEvent_();
    };
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
     */ IconImage2.prototype.getImage = function(pixelRatio) {
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
    };
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Image or Canvas element.
     */ IconImage2.prototype.getPixelRatio = function(pixelRatio) {
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? pixelRatio : 1;
    };
    /**
     * @return {import("../ImageState.js").default} Image state.
     */ IconImage2.prototype.getImageState = function() {
        return this.imageState_;
    };
    /**
     * @return {HTMLImageElement|HTMLCanvasElement} Image element.
     */ IconImage2.prototype.getHitDetectionImage = function() {
        if (!this.hitDetectionImage_) {
            if (this.isTainted_()) {
                var width = this.size_[0];
                var height = this.size_[1];
                var context = _domJs.createCanvasContext2D(width, height);
                context.fillRect(0, 0, width, height);
                this.hitDetectionImage_ = context.canvas;
            } else this.hitDetectionImage_ = this.image_;
        }
        return this.hitDetectionImage_;
    };
    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     */ IconImage2.prototype.getSize = function() {
        return this.size_;
    };
    /**
     * @return {string|undefined} Image src.
     */ IconImage2.prototype.getSrc = function() {
        return this.src_;
    };
    /**
     * Load not yet loaded URI.
     */ IconImage2.prototype.load = function() {
        if (this.imageState_ == _imageStateJsDefault.default.IDLE) {
            this.imageState_ = _imageStateJsDefault.default.LOADING;
            try {
                /** @type {HTMLImageElement} */ (this.image_).src = this.src_;
            } catch (e) {
                this.handleImageError_();
            }
            this.unlisten_ = _imageJs.listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
        }
    };
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @private
     */ IconImage2.prototype.replaceColor_ = function(pixelRatio) {
        if (!this.color_ || this.canvas_[pixelRatio]) return;
        var canvas = document.createElement('canvas');
        this.canvas_[pixelRatio] = canvas;
        canvas.width = Math.ceil(this.image_.width * pixelRatio);
        canvas.height = Math.ceil(this.image_.height * pixelRatio);
        var ctx = canvas.getContext('2d');
        ctx.scale(pixelRatio, pixelRatio);
        ctx.drawImage(this.image_, 0, 0);
        ctx.globalCompositeOperation = 'multiply';
        // Internet Explorer 11 does not support the multiply operation.
        // If the canvas is tainted in Internet Explorer this still produces
        // a solid color image with the shape of the icon.
        if (ctx.globalCompositeOperation === 'multiply' || this.isTainted_()) {
            ctx.fillStyle = _colorJs.asString(this.color_);
            ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
            ctx.globalCompositeOperation = 'destination-in';
            ctx.drawImage(this.image_, 0, 0);
        } else {
            var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imgData.data;
            var r = this.color_[0] / 255;
            var g = this.color_[1] / 255;
            var b = this.color_[2] / 255;
            var a = this.color_[3];
            for(var i = 0, ii = data.length; i < ii; i += 4){
                data[i] *= r;
                data[i + 1] *= g;
                data[i + 2] *= b;
                data[i + 3] *= a;
            }
            ctx.putImageData(imgData, 0, 0);
        }
    };
    /**
     * Discards event handlers which listen for load completion or errors.
     *
     * @private
     */ IconImage2.prototype.unlistenImage_ = function() {
        if (this.unlisten_) {
            this.unlisten_();
            this.unlisten_ = null;
        }
    };
    return IconImage2;
}(_targetJsDefault.default);
function get(image, src, size, crossOrigin, imageState, color) {
    var iconImage = _iconImageCacheJs.shared.get(src, crossOrigin, color);
    if (!iconImage) {
        iconImage = new IconImage1(image, src, size, crossOrigin, imageState, color);
        _iconImageCacheJs.shared.set(src, crossOrigin, color, iconImage);
    }
    return iconImage;
}
exports.default = IconImage1;

},{"../events/Target.js":"dj5zz","../events/EventType.js":"83vee","../ImageState.js":"9Ji45","../color.js":"liKgX","../dom.js":"akJqt","./IconImageCache.js":"iLULD","../Image.js":"dcFLD","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"dcFLD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image element.
 * @param {function():any} loadHandler Load callback function.
 * @param {function():any} errorHandler Error callback function.
 * @return {function():void} Callback to stop listening.
 */ parcelHelpers.export(exports, "listenImage", ()=>listenImage
);
/**
 * @module ol/Image
 */ var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageBaseJs = require("./ImageBase.js");
var _imageBaseJsDefault = parcelHelpers.interopDefault(_imageBaseJs);
var _imageStateJs = require("./ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _hasJs = require("./has.js");
var _extentJs = require("./extent.js");
var _eventsJs = require("./events.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * A function that takes an {@link module:ol/Image~Image} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:ol/Image~Image#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(ImageWrapper, string): void} LoadFunction
 * @api
 */ var ImageWrapper1 = function(_super) {
    __extends(ImageWrapper2, _super);
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number|undefined} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {string} src Image source URI.
     * @param {?string} crossOrigin Cross origin.
     * @param {LoadFunction} imageLoadFunction Image load function.
     */ function ImageWrapper2(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
        var _this = _super.call(this, extent, resolution, pixelRatio, _imageStateJsDefault.default.IDLE) || this;
        /**
         * @private
         * @type {string}
         */ _this.src_ = src;
        /**
         * @private
         * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
         */ _this.image_ = new Image();
        if (crossOrigin !== null) _this.image_.crossOrigin = crossOrigin;
        /**
         * @private
         * @type {?function():void}
         */ _this.unlisten_ = null;
        /**
         * @protected
         * @type {import("./ImageState.js").default}
         */ _this.state = _imageStateJsDefault.default.IDLE;
        /**
         * @private
         * @type {LoadFunction}
         */ _this.imageLoadFunction_ = imageLoadFunction;
        return _this;
    }
    /**
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @api
     */ ImageWrapper2.prototype.getImage = function() {
        return this.image_;
    };
    /**
     * Tracks loading or read errors.
     *
     * @private
     */ ImageWrapper2.prototype.handleImageError_ = function() {
        this.state = _imageStateJsDefault.default.ERROR;
        this.unlistenImage_();
        this.changed();
    };
    /**
     * Tracks successful image load.
     *
     * @private
     */ ImageWrapper2.prototype.handleImageLoad_ = function() {
        if (this.resolution === undefined) this.resolution = _extentJs.getHeight(this.extent) / this.image_.height;
        this.state = _imageStateJsDefault.default.LOADED;
        this.unlistenImage_();
        this.changed();
    };
    /**
     * Load the image or retry if loading previously failed.
     * Loading is taken care of by the tile queue, and calling this method is
     * only needed for preloading or for reloading in case of an error.
     * @api
     */ ImageWrapper2.prototype.load = function() {
        if (this.state == _imageStateJsDefault.default.IDLE || this.state == _imageStateJsDefault.default.ERROR) {
            this.state = _imageStateJsDefault.default.LOADING;
            this.changed();
            this.imageLoadFunction_(this, this.src_);
            this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
        }
    };
    /**
     * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
     */ ImageWrapper2.prototype.setImage = function(image) {
        this.image_ = image;
        this.resolution = _extentJs.getHeight(this.extent) / this.image_.height;
    };
    /**
     * Discards event handlers which listen for load completion or errors.
     *
     * @private
     */ ImageWrapper2.prototype.unlistenImage_ = function() {
        if (this.unlisten_) {
            this.unlisten_();
            this.unlisten_ = null;
        }
    };
    return ImageWrapper2;
}(_imageBaseJsDefault.default);
function listenImage(image, loadHandler, errorHandler) {
    var img = image;
    if (img.src && _hasJs.IMAGE_DECODE) {
        var promise = img.decode();
        var listening_1 = true;
        var unlisten = function() {
            listening_1 = false;
        };
        promise.then(function() {
            if (listening_1) loadHandler();
        }).catch(function(error) {
            if (listening_1) {
                // FIXME: Unconditionally call errorHandler() when this bug is fixed upstream:
                //        https://bugs.webkit.org/show_bug.cgi?id=198527
                if (error.name === 'EncodingError' && error.message === 'Invalid image type.') loadHandler();
                else errorHandler();
            }
        });
        return unlisten;
    }
    var listenerKeys = [
        _eventsJs.listenOnce(img, _eventTypeJsDefault.default.LOAD, loadHandler),
        _eventsJs.listenOnce(img, _eventTypeJsDefault.default.ERROR, errorHandler), 
    ];
    return function unlisten() {
        listenerKeys.forEach(_eventsJs.unlistenByKey);
    };
}
exports.default = ImageWrapper1;

},{"./events/EventType.js":"83vee","./ImageBase.js":"it9gz","./ImageState.js":"9Ji45","./has.js":"cdiSc","./extent.js":"jgUz2","./events.js":"e9Qqr","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"it9gz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/ImageBase
 */ var _targetJs = require("./events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("./events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _utilJs = require("./util.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @abstract
 */ var ImageBase1 = function(_super) {
    __extends(ImageBase2, _super);
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number|undefined} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./ImageState.js").default} state State.
     */ function ImageBase2(extent, resolution, pixelRatio, state) {
        var _this = _super.call(this) || this;
        /**
         * @protected
         * @type {import("./extent.js").Extent}
         */ _this.extent = extent;
        /**
         * @private
         * @type {number}
         */ _this.pixelRatio_ = pixelRatio;
        /**
         * @protected
         * @type {number|undefined}
         */ _this.resolution = resolution;
        /**
         * @protected
         * @type {import("./ImageState.js").default}
         */ _this.state = state;
        return _this;
    }
    /**
     * @protected
     */ ImageBase2.prototype.changed = function() {
        this.dispatchEvent(_eventTypeJsDefault.default.CHANGE);
    };
    /**
     * @return {import("./extent.js").Extent} Extent.
     */ ImageBase2.prototype.getExtent = function() {
        return this.extent;
    };
    /**
     * @abstract
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     */ ImageBase2.prototype.getImage = function() {
        return _utilJs.abstract();
    };
    /**
     * @return {number} PixelRatio.
     */ ImageBase2.prototype.getPixelRatio = function() {
        return this.pixelRatio_;
    };
    /**
     * @return {number} Resolution.
     */ ImageBase2.prototype.getResolution = function() {
        return this.resolution;
    };
    /**
     * @return {import("./ImageState.js").default} State.
     */ ImageBase2.prototype.getState = function() {
        return this.state;
    };
    /**
     * Load not yet loaded URI.
     * @abstract
     */ ImageBase2.prototype.load = function() {
        _utilJs.abstract();
    };
    return ImageBase2;
}(_targetJsDefault.default);
exports.default = ImageBase1;

},{"./events/Target.js":"dj5zz","./events/EventType.js":"83vee","./util.js":"9zOhk","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"nG60s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/style/Text
 */ var _fillJs = require("./Fill.js");
var _fillJsDefault = parcelHelpers.interopDefault(_fillJs);
var _textPlacementJs = require("./TextPlacement.js");
var _textPlacementJsDefault = parcelHelpers.interopDefault(_textPlacementJs);
var _sizeJs = require("../size.js");
/**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 */ var DEFAULT_FILL_COLOR = '#333';
/**
 * @typedef {Object} Options
 * @property {string} [font] Font style as CSS 'font' value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is '10px sans-serif'
 * @property {number} [maxAngle=Math.PI/4] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45Â° (`Math.PI / 4`).
 * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {import("./TextPlacement.js").default|string} [placement='point'] Text placement.
 * @property {number|import("../size.js").Size} [scale] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {string} [text] Text content.
 * @property {string} [textAlign] Text alignment. Possible values: 'left', 'right', 'center', 'end' or 'start'.
 * Default is 'center' for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a
 * placement where `maxAngle` is not exceeded.
 * @property {string} [textBaseline='middle'] Text base line. Possible values: 'bottom', 'top', 'middle', 'alphabetic',
 * 'hanging', 'ideographic'.
 * @property {import("./Fill.js").default} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333).
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Fill.js").default} [backgroundFill] Fill style for the text background when `placement` is
 * `'point'`. Default is no fill.
 * @property {import("./Stroke.js").default} [backgroundStroke] Stroke style for the text background  when `placement`
 * is `'point'`. Default is no stroke.
 * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 */ /**
 * @classdesc
 * Set text style for vector features.
 * @api
 */ var Text1 = function() {
    /**
     * @param {Options} [opt_options] Options.
     */ function Text2(opt_options) {
        var options = opt_options || {
        };
        /**
         * @private
         * @type {string|undefined}
         */ this.font_ = options.font;
        /**
         * @private
         * @type {number|undefined}
         */ this.rotation_ = options.rotation;
        /**
         * @private
         * @type {boolean|undefined}
         */ this.rotateWithView_ = options.rotateWithView;
        /**
         * @private
         * @type {number|import("../size.js").Size|undefined}
         */ this.scale_ = options.scale;
        /**
         * @private
         * @type {import("../size.js").Size}
         */ this.scaleArray_ = _sizeJs.toSize(options.scale !== undefined ? options.scale : 1);
        /**
         * @private
         * @type {string|undefined}
         */ this.text_ = options.text;
        /**
         * @private
         * @type {string|undefined}
         */ this.textAlign_ = options.textAlign;
        /**
         * @private
         * @type {string|undefined}
         */ this.textBaseline_ = options.textBaseline;
        /**
         * @private
         * @type {import("./Fill.js").default}
         */ this.fill_ = options.fill !== undefined ? options.fill : new _fillJsDefault.default({
            color: DEFAULT_FILL_COLOR
        });
        /**
         * @private
         * @type {number}
         */ this.maxAngle_ = options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;
        /**
         * @private
         * @type {import("./TextPlacement.js").default|string}
         */ this.placement_ = options.placement !== undefined ? options.placement : _textPlacementJsDefault.default.POINT;
        /**
         * @private
         * @type {boolean}
         */ this.overflow_ = !!options.overflow;
        /**
         * @private
         * @type {import("./Stroke.js").default}
         */ this.stroke_ = options.stroke !== undefined ? options.stroke : null;
        /**
         * @private
         * @type {number}
         */ this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;
        /**
         * @private
         * @type {number}
         */ this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;
        /**
         * @private
         * @type {import("./Fill.js").default}
         */ this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
        /**
         * @private
         * @type {import("./Stroke.js").default}
         */ this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
        /**
         * @private
         * @type {Array<number>}
         */ this.padding_ = options.padding === undefined ? null : options.padding;
    }
    /**
     * Clones the style.
     * @return {Text} The cloned style.
     * @api
     */ Text2.prototype.clone = function() {
        var scale = this.getScale();
        return new Text2({
            font: this.getFont(),
            placement: this.getPlacement(),
            maxAngle: this.getMaxAngle(),
            overflow: this.getOverflow(),
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            scale: Array.isArray(scale) ? scale.slice() : scale,
            text: this.getText(),
            textAlign: this.getTextAlign(),
            textBaseline: this.getTextBaseline(),
            fill: this.getFill() ? this.getFill().clone() : undefined,
            stroke: this.getStroke() ? this.getStroke().clone() : undefined,
            offsetX: this.getOffsetX(),
            offsetY: this.getOffsetY(),
            backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : undefined,
            backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : undefined,
            padding: this.getPadding()
        });
    };
    /**
     * Get the `overflow` configuration.
     * @return {boolean} Let text overflow the length of the path they follow.
     * @api
     */ Text2.prototype.getOverflow = function() {
        return this.overflow_;
    };
    /**
     * Get the font name.
     * @return {string|undefined} Font.
     * @api
     */ Text2.prototype.getFont = function() {
        return this.font_;
    };
    /**
     * Get the maximum angle between adjacent characters.
     * @return {number} Angle in radians.
     * @api
     */ Text2.prototype.getMaxAngle = function() {
        return this.maxAngle_;
    };
    /**
     * Get the label placement.
     * @return {import("./TextPlacement.js").default|string} Text placement.
     * @api
     */ Text2.prototype.getPlacement = function() {
        return this.placement_;
    };
    /**
     * Get the x-offset for the text.
     * @return {number} Horizontal text offset.
     * @api
     */ Text2.prototype.getOffsetX = function() {
        return this.offsetX_;
    };
    /**
     * Get the y-offset for the text.
     * @return {number} Vertical text offset.
     * @api
     */ Text2.prototype.getOffsetY = function() {
        return this.offsetY_;
    };
    /**
     * Get the fill style for the text.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */ Text2.prototype.getFill = function() {
        return this.fill_;
    };
    /**
     * Determine whether the text rotates with the map.
     * @return {boolean|undefined} Rotate with map.
     * @api
     */ Text2.prototype.getRotateWithView = function() {
        return this.rotateWithView_;
    };
    /**
     * Get the text rotation.
     * @return {number|undefined} Rotation.
     * @api
     */ Text2.prototype.getRotation = function() {
        return this.rotation_;
    };
    /**
     * Get the text scale.
     * @return {number|import("../size.js").Size|undefined} Scale.
     * @api
     */ Text2.prototype.getScale = function() {
        return this.scale_;
    };
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */ Text2.prototype.getScaleArray = function() {
        return this.scaleArray_;
    };
    /**
     * Get the stroke style for the text.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */ Text2.prototype.getStroke = function() {
        return this.stroke_;
    };
    /**
     * Get the text to be rendered.
     * @return {string|undefined} Text.
     * @api
     */ Text2.prototype.getText = function() {
        return this.text_;
    };
    /**
     * Get the text alignment.
     * @return {string|undefined} Text align.
     * @api
     */ Text2.prototype.getTextAlign = function() {
        return this.textAlign_;
    };
    /**
     * Get the text baseline.
     * @return {string|undefined} Text baseline.
     * @api
     */ Text2.prototype.getTextBaseline = function() {
        return this.textBaseline_;
    };
    /**
     * Get the background fill style for the text.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */ Text2.prototype.getBackgroundFill = function() {
        return this.backgroundFill_;
    };
    /**
     * Get the background stroke style for the text.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */ Text2.prototype.getBackgroundStroke = function() {
        return this.backgroundStroke_;
    };
    /**
     * Get the padding for the text.
     * @return {Array<number>} Padding.
     * @api
     */ Text2.prototype.getPadding = function() {
        return this.padding_;
    };
    /**
     * Set the `overflow` property.
     *
     * @param {boolean} overflow Let text overflow the path that it follows.
     * @api
     */ Text2.prototype.setOverflow = function(overflow) {
        this.overflow_ = overflow;
    };
    /**
     * Set the font.
     *
     * @param {string|undefined} font Font.
     * @api
     */ Text2.prototype.setFont = function(font) {
        this.font_ = font;
    };
    /**
     * Set the maximum angle between adjacent characters.
     *
     * @param {number} maxAngle Angle in radians.
     * @api
     */ Text2.prototype.setMaxAngle = function(maxAngle) {
        this.maxAngle_ = maxAngle;
    };
    /**
     * Set the x offset.
     *
     * @param {number} offsetX Horizontal text offset.
     * @api
     */ Text2.prototype.setOffsetX = function(offsetX) {
        this.offsetX_ = offsetX;
    };
    /**
     * Set the y offset.
     *
     * @param {number} offsetY Vertical text offset.
     * @api
     */ Text2.prototype.setOffsetY = function(offsetY) {
        this.offsetY_ = offsetY;
    };
    /**
     * Set the text placement.
     *
     * @param {import("./TextPlacement.js").default|string} placement Placement.
     * @api
     */ Text2.prototype.setPlacement = function(placement) {
        this.placement_ = placement;
    };
    /**
     * Set whether to rotate the text with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */ Text2.prototype.setRotateWithView = function(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
    };
    /**
     * Set the fill.
     *
     * @param {import("./Fill.js").default} fill Fill style.
     * @api
     */ Text2.prototype.setFill = function(fill) {
        this.fill_ = fill;
    };
    /**
     * Set the rotation.
     *
     * @param {number|undefined} rotation Rotation.
     * @api
     */ Text2.prototype.setRotation = function(rotation) {
        this.rotation_ = rotation;
    };
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size|undefined} scale Scale.
     * @api
     */ Text2.prototype.setScale = function(scale) {
        this.scale_ = scale;
        this.scaleArray_ = _sizeJs.toSize(scale !== undefined ? scale : 1);
    };
    /**
     * Set the stroke.
     *
     * @param {import("./Stroke.js").default} stroke Stroke style.
     * @api
     */ Text2.prototype.setStroke = function(stroke) {
        this.stroke_ = stroke;
    };
    /**
     * Set the text.
     *
     * @param {string|undefined} text Text.
     * @api
     */ Text2.prototype.setText = function(text) {
        this.text_ = text;
    };
    /**
     * Set the text alignment.
     *
     * @param {string|undefined} textAlign Text align.
     * @api
     */ Text2.prototype.setTextAlign = function(textAlign) {
        this.textAlign_ = textAlign;
    };
    /**
     * Set the text baseline.
     *
     * @param {string|undefined} textBaseline Text baseline.
     * @api
     */ Text2.prototype.setTextBaseline = function(textBaseline) {
        this.textBaseline_ = textBaseline;
    };
    /**
     * Set the background fill.
     *
     * @param {import("./Fill.js").default} fill Fill style.
     * @api
     */ Text2.prototype.setBackgroundFill = function(fill) {
        this.backgroundFill_ = fill;
    };
    /**
     * Set the background stroke.
     *
     * @param {import("./Stroke.js").default} stroke Stroke style.
     * @api
     */ Text2.prototype.setBackgroundStroke = function(stroke) {
        this.backgroundStroke_ = stroke;
    };
    /**
     * Set the padding (`[top, right, bottom, left]`).
     *
     * @param {!Array<number>} padding Padding.
     * @api
     */ Text2.prototype.setPadding = function(padding) {
        this.padding_ = padding;
    };
    return Text2;
}();
exports.default = Text1;

},{"./Fill.js":"bJ6U2","./TextPlacement.js":"9g9lp","../size.js":"5PZ8p","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"iNqng":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
 * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
 * @return {number} Order.
 */ parcelHelpers.export(exports, "defaultOrder", ()=>defaultOrder
);
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */ parcelHelpers.export(exports, "getSquaredTolerance", ()=>getSquaredTolerance
);
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */ parcelHelpers.export(exports, "getTolerance", ()=>getTolerance
);
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(import("../events/Event.js").default): void} listener Listener function.
 * @param {import("../proj.js").TransformFunction} [opt_transform] Transform from user to view projection.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 * @return {boolean} `true` if style is loading.
 */ parcelHelpers.export(exports, "renderFeature", ()=>renderFeature
);
/**
 * @module ol/renderer/vector
 */ var _builderTypeJs = require("../render/canvas/BuilderType.js");
var _builderTypeJsDefault = parcelHelpers.interopDefault(_builderTypeJs);
var _geometryTypeJs = require("../geom/GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _imageStateJs = require("../ImageState.js");
var _imageStateJsDefault = parcelHelpers.interopDefault(_imageStateJs);
var _utilJs = require("../util.js");
/**
 * Feature callback. The callback will be called with three arguments. The first
 * argument is one {@link module:ol/Feature feature} or {@link module:ol/render/Feature render feature}
 * at the pixel, the second is the {@link module:ol/layer/Layer layer} of the feature and will be null for
 * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry} of the feature. For features
 * with a GeometryCollection geometry, it will be the first detected geometry from the collection.
 * @template T
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default<import("../source/Source").default>, import("../geom/SimpleGeometry.js").default): T} FeatureCallback
 */ /**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */ var SIMPLIFY_TOLERANCE = 0.5;
/**
 * @const
 * @type {Object<import("../geom/GeometryType.js").default,
 *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
 *                         import("../style/Style.js").default, Object): void>}
 */ var GEOMETRY_RENDERERS = {
    'Point': renderPointGeometry,
    'LineString': renderLineStringGeometry,
    'Polygon': renderPolygonGeometry,
    'MultiPoint': renderMultiPointGeometry,
    'MultiLineString': renderMultiLineStringGeometry,
    'MultiPolygon': renderMultiPolygonGeometry,
    'GeometryCollection': renderGeometryCollectionGeometry,
    'Circle': renderCircleGeometry
};
function defaultOrder(feature1, feature2) {
    return parseInt(_utilJs.getUid(feature1), 10) - parseInt(_utilJs.getUid(feature2), 10);
}
function getSquaredTolerance(resolution, pixelRatio) {
    var tolerance = getTolerance(resolution, pixelRatio);
    return tolerance * tolerance;
}
function getTolerance(resolution, pixelRatio) {
    return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
 * @param {import("../geom/Circle.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */ function renderCircleGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var fillStyle = style.getFill();
    var strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
        var circleReplay = builderGroup.getBuilder(style.getZIndex(), _builderTypeJsDefault.default.CIRCLE);
        circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        circleReplay.drawCircle(geometry, feature);
    }
    var textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _builderTypeJsDefault.default.TEXT);
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform, opt_declutterBuilderGroup) {
    var loading = false;
    var imageStyle = style.getImage();
    if (imageStyle) {
        var imageState = imageStyle.getImageState();
        if (imageState == _imageStateJsDefault.default.LOADED || imageState == _imageStateJsDefault.default.ERROR) imageStyle.unlistenImageChange(listener);
        else {
            if (imageState == _imageStateJsDefault.default.IDLE) imageStyle.load();
            imageState = imageStyle.getImageState();
            imageStyle.listenImageChange(listener);
            loading = true;
        }
    }
    renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup);
    return loading;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */ function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {
    var geometry = style.getGeometryFunction()(feature);
    if (!geometry) return;
    var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);
    var renderer = style.getRenderer();
    if (renderer) renderGeometry(replayGroup, simplifiedGeometry, style, feature);
    else {
        var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
        geometryRenderer(replayGroup, simplifiedGeometry, style, feature, opt_declutterBuilderGroup);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */ function renderGeometry(replayGroup, geometry, style, feature) {
    if (geometry.getType() == _geometryTypeJsDefault.default.GEOMETRY_COLLECTION) {
        var geometries = /** @type {import("../geom/GeometryCollection.js").default} */ geometry.getGeometries();
        for(var i = 0, ii = geometries.length; i < ii; ++i)renderGeometry(replayGroup, geometries[i], style, feature);
        return;
    }
    var replay = replayGroup.getBuilder(style.getZIndex(), _builderTypeJsDefault.default.DEFAULT);
    replay.drawCustom(geometry, feature, style.getRenderer());
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */ function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var geometries = geometry.getGeometriesArray();
    var i, ii;
    for(i = 0, ii = geometries.length; i < ii; ++i){
        var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
        geometryRenderer(replayGroup, geometries[i], style, feature, opt_declutterBuilderGroup);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */ function renderLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var strokeStyle = style.getStroke();
    if (strokeStyle) {
        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), _builderTypeJsDefault.default.LINE_STRING);
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        lineStringReplay.drawLineString(geometry, feature);
    }
    var textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _builderTypeJsDefault.default.TEXT);
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */ function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var strokeStyle = style.getStroke();
    if (strokeStyle) {
        var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), _builderTypeJsDefault.default.LINE_STRING);
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        lineStringReplay.drawMultiLineString(geometry, feature);
    }
    var textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _builderTypeJsDefault.default.TEXT);
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */ function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var fillStyle = style.getFill();
    var strokeStyle = style.getStroke();
    if (strokeStyle || fillStyle) {
        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), _builderTypeJsDefault.default.POLYGON);
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        polygonReplay.drawMultiPolygon(geometry, feature);
    }
    var textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _builderTypeJsDefault.default.TEXT);
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */ function renderPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var imageStyle = style.getImage();
    var textStyle = style.getText();
    /** @type {import("../render/canvas.js").DeclutterImageWithText} */ var declutterImageWithText;
    if (opt_declutterBuilderGroup) {
        builderGroup = opt_declutterBuilderGroup;
        declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {
        } : undefined;
    }
    if (imageStyle) {
        if (imageStyle.getImageState() != _imageStateJsDefault.default.LOADED) return;
        var imageReplay = builderGroup.getBuilder(style.getZIndex(), _builderTypeJsDefault.default.IMAGE);
        imageReplay.setImageStyle(imageStyle, declutterImageWithText);
        imageReplay.drawPoint(geometry, feature);
    }
    if (textStyle && textStyle.getText()) {
        var textReplay = builderGroup.getBuilder(style.getZIndex(), _builderTypeJsDefault.default.TEXT);
        textReplay.setTextStyle(textStyle, declutterImageWithText);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */ function renderMultiPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var imageStyle = style.getImage();
    var textStyle = style.getText();
    /** @type {import("../render/canvas.js").DeclutterImageWithText} */ var declutterImageWithText;
    if (opt_declutterBuilderGroup) {
        builderGroup = opt_declutterBuilderGroup;
        declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {
        } : undefined;
    }
    if (imageStyle) {
        if (imageStyle.getImageState() != _imageStateJsDefault.default.LOADED) return;
        var imageReplay = builderGroup.getBuilder(style.getZIndex(), _builderTypeJsDefault.default.IMAGE);
        imageReplay.setImageStyle(imageStyle, declutterImageWithText);
        imageReplay.drawMultiPoint(geometry, feature);
    }
    if (textStyle && textStyle.getText()) {
        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _builderTypeJsDefault.default.TEXT);
        textReplay.setTextStyle(textStyle, declutterImageWithText);
        textReplay.drawText(geometry, feature);
    }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default} [opt_declutterBuilderGroup] Builder for decluttering.
 */ function renderPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
    var fillStyle = style.getFill();
    var strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
        var polygonReplay = builderGroup.getBuilder(style.getZIndex(), _builderTypeJsDefault.default.POLYGON);
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        polygonReplay.drawPolygon(geometry, feature);
    }
    var textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
        var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _builderTypeJsDefault.default.TEXT);
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(geometry, feature);
    }
}

},{"../render/canvas/BuilderType.js":"iBsUa","../geom/GeometryType.js":"3sRlw","../ImageState.js":"9Ji45","../util.js":"9zOhk","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lTwzQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VectorSourceEvent", ()=>VectorSourceEvent1
);
var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _collectionEventTypeJs = require("../CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _objectEventTypeJs = require("../ObjectEventType.js");
var _objectEventTypeJsDefault = parcelHelpers.interopDefault(_objectEventTypeJs);
var _rbushJs = require("../structs/RBush.js");
var _rbushJsDefault = parcelHelpers.interopDefault(_rbushJs);
var _sourceJs = require("./Source.js");
var _sourceJsDefault = parcelHelpers.interopDefault(_sourceJs);
var _stateJs = require("./State.js");
var _stateJsDefault = parcelHelpers.interopDefault(_stateJs);
var _vectorEventTypeJs = require("./VectorEventType.js");
var _vectorEventTypeJsDefault = parcelHelpers.interopDefault(_vectorEventTypeJs);
var _functionsJs = require("../functions.js");
var _loadingstrategyJs = require("../loadingstrategy.js");
var _assertsJs = require("../asserts.js");
var _extentJs = require("../extent.js");
var _arrayJs = require("../array.js");
var _utilJs = require("../util.js");
var _objJs = require("../obj.js");
var _eventsJs = require("../events.js");
var _featureloaderJs = require("../featureloader.js");
/**
 * @module ol/source/Vector
 */ var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number, import("../proj/Projection.js").default): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */ /**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector} instances are instances of this
 * type.
 * @template {import("../geom/Geometry.js").default} Geometry
 */ var VectorSourceEvent1 = function(_super) {
    __extends(VectorSourceEvent2, _super);
    /**
     * @param {string} type Type.
     * @param {import("../Feature.js").default<Geometry>} [opt_feature] Feature.
     * @param {Array<import("../Feature.js").default<Geometry>>} [opt_features] Features.
     */ function VectorSourceEvent2(type, opt_feature, opt_features) {
        var _this = _super.call(this, type) || this;
        /**
         * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.
         * @type {import("../Feature.js").default<Geometry>|undefined}
         * @api
         */ _this.feature = opt_feature;
        /**
         * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.
         * @type {Array<import("../Feature.js").default<Geometry>>|undefined}
         * @api
         */ _this.features = opt_features;
        return _this;
    }
    return VectorSourceEvent2;
}(_eventJsDefault.default);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("./VectorEventType").VectorSourceEventTypes, VectorSourceEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     import("./VectorEventType").VectorSourceEventTypes, Return>} VectorSourceOnSignature
 */ /**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<import("../Feature.js").default>|Collection<import("../Feature.js").default>} [features]
 * Features. If provided as {@link module:ol/Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader. The `'featuresloadend'` and `'featuresloaderror'` events
 * will only fire if the `success` and `failure` callbacks are used.
 *
 * Example:
 *
 * ```js
 * import {Vector} from 'ol/source';
 * import {GeoJSON} from 'ol/format';
 * import {bbox} from 'ol/loadingstrategy';
 *
 * var vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection, success, failure) {
 *      var proj = projection.getCode();
 *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      var xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      var onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *        failure();
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          var features = vectorSource.getFormat().readFeatures(xhr.responseText);
 *          vectorSource.addFeatures(features);
 *          success(features);
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy.all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader.xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy.all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180Â° and 180Â° meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 */ /**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires VectorSourceEvent
 * @api
 * @template {import("../geom/Geometry.js").default} Geometry
 */ var VectorSource1 = function(_super) {
    __extends(VectorSource2, _super);
    /**
     * @param {Options} [opt_options] Vector source options.
     */ function VectorSource2(opt_options) {
        var _this = this;
        var options = opt_options || {
        };
        _this = _super.call(this, {
            attributions: options.attributions,
            projection: undefined,
            state: _stateJsDefault.default.READY,
            wrapX: options.wrapX !== undefined ? options.wrapX : true
        }) || this;
        /***
         * @type {VectorSourceOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {VectorSourceOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {VectorSourceOnSignature<void>}
         */ _this.un;
        /**
         * @private
         * @type {import("../featureloader.js").FeatureLoader}
         */ _this.loader_ = _functionsJs.VOID;
        /**
         * @private
         * @type {import("../format/Feature.js").default|undefined}
         */ _this.format_ = options.format;
        /**
         * @private
         * @type {boolean}
         */ _this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;
        /**
         * @private
         * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
         */ _this.url_ = options.url;
        if (options.loader !== undefined) _this.loader_ = options.loader;
        else if (_this.url_ !== undefined) {
            _assertsJs.assert(_this.format_, 7); // `format` must be set when `url` is set
            // create a XHR feature loader for "url" and "format"
            _this.loader_ = _featureloaderJs.xhr(_this.url_, _this.format_);
        }
        /**
         * @private
         * @type {LoadingStrategy}
         */ _this.strategy_ = options.strategy !== undefined ? options.strategy : _loadingstrategyJs.all;
        var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
        /**
         * @private
         * @type {RBush<import("../Feature.js").default<Geometry>>}
         */ _this.featuresRtree_ = useSpatialIndex ? new _rbushJsDefault.default() : null;
        /**
         * @private
         * @type {RBush<{extent: import("../extent.js").Extent}>}
         */ _this.loadedExtentsRtree_ = new _rbushJsDefault.default();
        /**
         * @type {number}
         * @private
         */ _this.loadingExtentsCount_ = 0;
        /**
         * @private
         * @type {!Object<string, import("../Feature.js").default<Geometry>>}
         */ _this.nullGeometryFeatures_ = {
        };
        /**
         * A lookup of features by id (the return from feature.getId()).
         * @private
         * @type {!Object<string, import("../Feature.js").default<Geometry>>}
         */ _this.idIndex_ = {
        };
        /**
         * A lookup of features by uid (using getUid(feature)).
         * @private
         * @type {!Object<string, import("../Feature.js").default<Geometry>>}
         */ _this.uidIndex_ = {
        };
        /**
         * @private
         * @type {Object<string, Array<import("../events.js").EventsKey>>}
         */ _this.featureChangeKeys_ = {
        };
        /**
         * @private
         * @type {Collection<import("../Feature.js").default<Geometry>>}
         */ _this.featuresCollection_ = null;
        var collection, features;
        if (Array.isArray(options.features)) features = options.features;
        else if (options.features) {
            collection = options.features;
            features = collection.getArray();
        }
        if (!useSpatialIndex && collection === undefined) collection = new _collectionJsDefault.default(features);
        if (features !== undefined) _this.addFeaturesInternal(features);
        if (collection !== undefined) _this.bindFeaturesCollection_(collection);
        return _this;
    }
    /**
     * Add a single feature to the source.  If you want to add a batch of features
     * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
     * instead. A feature will not be added to the source if feature with
     * the same id is already there. The reason for this behavior is to avoid
     * feature duplication when using bbox or tile loading strategies.
     * Note: this also applies if an {@link module:ol/Collection} is used for features,
     * meaning that if a feature with a duplicate id is added in the collection, it will
     * be removed from it right away.
     * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
     * @api
     */ VectorSource2.prototype.addFeature = function(feature) {
        this.addFeatureInternal(feature);
        this.changed();
    };
    /**
     * Add a feature without firing a `change` event.
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     * @protected
     */ VectorSource2.prototype.addFeatureInternal = function(feature) {
        var featureKey = _utilJs.getUid(feature);
        if (!this.addToIndex_(featureKey, feature)) {
            if (this.featuresCollection_) this.featuresCollection_.remove(feature);
            return;
        }
        this.setupChangeEvents_(featureKey, feature);
        var geometry = feature.getGeometry();
        if (geometry) {
            var extent = geometry.getExtent();
            if (this.featuresRtree_) this.featuresRtree_.insert(extent, feature);
        } else this.nullGeometryFeatures_[featureKey] = feature;
        this.dispatchEvent(new VectorSourceEvent1(_vectorEventTypeJsDefault.default.ADDFEATURE, feature));
    };
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {import("../Feature.js").default<Geometry>} feature The feature.
     * @private
     */ VectorSource2.prototype.setupChangeEvents_ = function(featureKey, feature) {
        this.featureChangeKeys_[featureKey] = [
            _eventsJs.listen(feature, _eventTypeJsDefault.default.CHANGE, this.handleFeatureChange_, this),
            _eventsJs.listen(feature, _objectEventTypeJsDefault.default.PROPERTYCHANGE, this.handleFeatureChange_, this), 
        ];
    };
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {import("../Feature.js").default<Geometry>} feature The feature.
     * @return {boolean} The feature is "valid", in the sense that it is also a
     *     candidate for insertion into the Rtree.
     * @private
     */ VectorSource2.prototype.addToIndex_ = function(featureKey, feature) {
        var valid = true;
        var id = feature.getId();
        if (id !== undefined) {
            if (!(id.toString() in this.idIndex_)) this.idIndex_[id.toString()] = feature;
            else valid = false;
        }
        if (valid) {
            _assertsJs.assert(!(featureKey in this.uidIndex_), 30); // The passed `feature` was already added to the source
            this.uidIndex_[featureKey] = feature;
        }
        return valid;
    };
    /**
     * Add a batch of features to the source.
     * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
     * @api
     */ VectorSource2.prototype.addFeatures = function(features) {
        this.addFeaturesInternal(features);
        this.changed();
    };
    /**
     * Add features without firing a `change` event.
     * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
     * @protected
     */ VectorSource2.prototype.addFeaturesInternal = function(features) {
        var extents = [];
        var newFeatures = [];
        var geometryFeatures = [];
        for(var i = 0, length_1 = features.length; i < length_1; i++){
            var feature = features[i];
            var featureKey = _utilJs.getUid(feature);
            if (this.addToIndex_(featureKey, feature)) newFeatures.push(feature);
        }
        for(var i = 0, length_2 = newFeatures.length; i < length_2; i++){
            var feature = newFeatures[i];
            var featureKey = _utilJs.getUid(feature);
            this.setupChangeEvents_(featureKey, feature);
            var geometry = feature.getGeometry();
            if (geometry) {
                var extent = geometry.getExtent();
                extents.push(extent);
                geometryFeatures.push(feature);
            } else this.nullGeometryFeatures_[featureKey] = feature;
        }
        if (this.featuresRtree_) this.featuresRtree_.load(extents, geometryFeatures);
        for(var i = 0, length_3 = newFeatures.length; i < length_3; i++)this.dispatchEvent(new VectorSourceEvent1(_vectorEventTypeJsDefault.default.ADDFEATURE, newFeatures[i]));
    };
    /**
     * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
     * @private
     */ VectorSource2.prototype.bindFeaturesCollection_ = function(collection) {
        var modifyingCollection = false;
        this.addEventListener(_vectorEventTypeJsDefault.default.ADDFEATURE, /**
         * @param {VectorSourceEvent<Geometry>} evt The vector source event
         */ function(evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                collection.push(evt.feature);
                modifyingCollection = false;
            }
        });
        this.addEventListener(_vectorEventTypeJsDefault.default.REMOVEFEATURE, /**
         * @param {VectorSourceEvent<Geometry>} evt The vector source event
         */ function(evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                collection.remove(evt.feature);
                modifyingCollection = false;
            }
        });
        collection.addEventListener(_collectionEventTypeJsDefault.default.ADD, /**
         * @param {import("../Collection.js").CollectionEvent} evt The collection event
         */ (function(evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                this.addFeature(evt.element);
                modifyingCollection = false;
            }
        }).bind(this));
        collection.addEventListener(_collectionEventTypeJsDefault.default.REMOVE, /**
         * @param {import("../Collection.js").CollectionEvent} evt The collection event
         */ (function(evt) {
            if (!modifyingCollection) {
                modifyingCollection = true;
                this.removeFeature(evt.element);
                modifyingCollection = false;
            }
        }).bind(this));
        this.featuresCollection_ = collection;
    };
    /**
     * Remove all features from the source.
     * @param {boolean} [opt_fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature removefeature} events.
     * @api
     */ VectorSource2.prototype.clear = function(opt_fast) {
        if (opt_fast) {
            for(var featureId in this.featureChangeKeys_){
                var keys = this.featureChangeKeys_[featureId];
                keys.forEach(_eventsJs.unlistenByKey);
            }
            if (!this.featuresCollection_) {
                this.featureChangeKeys_ = {
                };
                this.idIndex_ = {
                };
                this.uidIndex_ = {
                };
            }
        } else if (this.featuresRtree_) {
            this.featuresRtree_.forEach(this.removeFeatureInternal.bind(this));
            for(var id in this.nullGeometryFeatures_)this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
        if (this.featuresCollection_) this.featuresCollection_.clear();
        if (this.featuresRtree_) this.featuresRtree_.clear();
        this.nullGeometryFeatures_ = {
        };
        var clearEvent = new VectorSourceEvent1(_vectorEventTypeJsDefault.default.CLEAR);
        this.dispatchEvent(clearEvent);
        this.changed();
    };
    /**
     * Iterate through all features on the source, calling the provided callback
     * with each one.  If the callback returns any "truthy" value, iteration will
     * stop and the function will return the same value.
     * Note: this function only iterate through the feature that have a defined geometry.
     *
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     on the source.  Return a truthy value to stop iteration.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */ VectorSource2.prototype.forEachFeature = function(callback) {
        if (this.featuresRtree_) return this.featuresRtree_.forEach(callback);
        else if (this.featuresCollection_) this.featuresCollection_.forEach(callback);
    };
    /**
     * Iterate through all features whose geometries contain the provided
     * coordinate, calling the callback with each feature.  If the callback returns
     * a "truthy" value, iteration will stop and the function will return the same
     * value.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     whose goemetry contains the provided coordinate.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     */ VectorSource2.prototype.forEachFeatureAtCoordinateDirect = function(coordinate, callback) {
        var extent = [
            coordinate[0],
            coordinate[1],
            coordinate[0],
            coordinate[1]
        ];
        return this.forEachFeatureInExtent(extent, function(feature) {
            var geometry = feature.getGeometry();
            if (geometry.intersectsCoordinate(coordinate)) return callback(feature);
            else return undefined;
        });
    };
    /**
     * Iterate through all features whose bounding box intersects the provided
     * extent (note that the feature's geometry may not intersect the extent),
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you are interested in features whose geometry intersects an extent, call
     * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
     *
     * When `useSpatialIndex` is set to false, this method will loop through all
     * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     whose bounding box intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */ VectorSource2.prototype.forEachFeatureInExtent = function(extent, callback) {
        if (this.featuresRtree_) return this.featuresRtree_.forEachInExtent(extent, callback);
        else if (this.featuresCollection_) this.featuresCollection_.forEach(callback);
    };
    /**
     * Iterate through all features whose geometry intersects the provided extent,
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you only want to test for bounding box intersection, call the
     * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     whose geometry intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */ VectorSource2.prototype.forEachFeatureIntersectingExtent = function(extent, callback) {
        return this.forEachFeatureInExtent(extent, /**
         * @param {import("../Feature.js").default<Geometry>} feature Feature.
         * @return {T|undefined} The return value from the last call to the callback.
         */ function(feature) {
            var geometry = feature.getGeometry();
            if (geometry.intersectsExtent(extent)) {
                var result = callback(feature);
                if (result) return result;
            }
        });
    };
    /**
     * Get the features collection associated with this source. Will be `null`
     * unless the source was configured with `useSpatialIndex` set to `false`, or
     * with an {@link module:ol/Collection} as `features`.
     * @return {Collection<import("../Feature.js").default<Geometry>>} The collection of features.
     * @api
     */ VectorSource2.prototype.getFeaturesCollection = function() {
        return this.featuresCollection_;
    };
    /**
     * Get a snapshot of the features currently on the source in random order. The returned array
     * is a copy, the features are references to the features in the source.
     * @return {Array<import("../Feature.js").default<Geometry>>} Features.
     * @api
     */ VectorSource2.prototype.getFeatures = function() {
        var features;
        if (this.featuresCollection_) features = this.featuresCollection_.getArray().slice(0);
        else if (this.featuresRtree_) {
            features = this.featuresRtree_.getAll();
            if (!_objJs.isEmpty(this.nullGeometryFeatures_)) _arrayJs.extend(features, _objJs.getValues(this.nullGeometryFeatures_));
        }
        return features;
    };
    /**
     * Get all features whose geometry intersects the provided coordinate.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {Array<import("../Feature.js").default<Geometry>>} Features.
     * @api
     */ VectorSource2.prototype.getFeaturesAtCoordinate = function(coordinate) {
        var features = [];
        this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
            features.push(feature);
        });
        return features;
    };
    /**
     * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
     * all features intersecting the given extent in random order (so it may include
     * features whose geometries do not intersect the extent).
     *
     * When `useSpatialIndex` is set to false, this method will return all
     * features.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {Array<import("../Feature.js").default<Geometry>>} Features.
     * @api
     */ VectorSource2.prototype.getFeaturesInExtent = function(extent) {
        if (this.featuresRtree_) return this.featuresRtree_.getInExtent(extent);
        else if (this.featuresCollection_) return this.featuresCollection_.getArray().slice(0);
        else return [];
    };
    /**
     * Get the closest feature to the provided coordinate.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(import("../Feature.js").default<Geometry>):boolean} [opt_filter] Feature filter function.
     *     The filter function will receive one argument, the {@link module:ol/Feature feature}
     *     and it should return a boolean value. By default, no filtering is made.
     * @return {import("../Feature.js").default<Geometry>} Closest feature.
     * @api
     */ VectorSource2.prototype.getClosestFeatureToCoordinate = function(coordinate, opt_filter) {
        // Find the closest feature using branch and bound.  We start searching an
        // infinite extent, and find the distance from the first feature found.  This
        // becomes the closest feature.  We then compute a smaller extent which any
        // closer feature must intersect.  We continue searching with this smaller
        // extent, trying to find a closer feature.  Every time we find a closer
        // feature, we update the extent being searched so that any even closer
        // feature must intersect it.  We continue until we run out of features.
        var x = coordinate[0];
        var y = coordinate[1];
        var closestFeature = null;
        var closestPoint = [
            NaN,
            NaN
        ];
        var minSquaredDistance = Infinity;
        var extent = [-Infinity, -Infinity, Infinity,
            Infinity
        ];
        var filter = opt_filter ? opt_filter : _functionsJs.TRUE;
        this.featuresRtree_.forEachInExtent(extent, /**
         * @param {import("../Feature.js").default<Geometry>} feature Feature.
         */ function(feature) {
            if (filter(feature)) {
                var geometry = feature.getGeometry();
                var previousMinSquaredDistance = minSquaredDistance;
                minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
                if (minSquaredDistance < previousMinSquaredDistance) {
                    closestFeature = feature;
                    // This is sneaky.  Reduce the extent that it is currently being
                    // searched while the R-Tree traversal using this same extent object
                    // is still in progress.  This is safe because the new extent is
                    // strictly contained by the old extent.
                    var minDistance = Math.sqrt(minSquaredDistance);
                    extent[0] = x - minDistance;
                    extent[1] = y - minDistance;
                    extent[2] = x + minDistance;
                    extent[3] = y + minDistance;
                }
            }
        });
        return closestFeature;
    };
    /**
     * Get the extent of the features currently in the source.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {import("../extent.js").Extent} [opt_extent] Destination extent. If provided, no new extent
     *     will be created. Instead, that extent's coordinates will be overwritten.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */ VectorSource2.prototype.getExtent = function(opt_extent) {
        return this.featuresRtree_.getExtent(opt_extent);
    };
    /**
     * Get a feature by its identifier (the value returned by feature.getId()).
     * Note that the index treats string and numeric identifiers as the same.  So
     * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
     *
     * @param {string|number} id Feature identifier.
     * @return {import("../Feature.js").default<Geometry>} The feature (or `null` if not found).
     * @api
     */ VectorSource2.prototype.getFeatureById = function(id) {
        var feature = this.idIndex_[id.toString()];
        return feature !== undefined ? feature : null;
    };
    /**
     * Get a feature by its internal unique identifier (using `getUid`).
     *
     * @param {string} uid Feature identifier.
     * @return {import("../Feature.js").default<Geometry>} The feature (or `null` if not found).
     */ VectorSource2.prototype.getFeatureByUid = function(uid) {
        var feature = this.uidIndex_[uid];
        return feature !== undefined ? feature : null;
    };
    /**
     * Get the format associated with this source.
     *
     * @return {import("../format/Feature.js").default|undefined} The feature format.
     * @api
     */ VectorSource2.prototype.getFormat = function() {
        return this.format_;
    };
    /**
     * @return {boolean} The source can have overlapping geometries.
     */ VectorSource2.prototype.getOverlaps = function() {
        return this.overlaps_;
    };
    /**
     * Get the url associated with this source.
     *
     * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
     * @api
     */ VectorSource2.prototype.getUrl = function() {
        return this.url_;
    };
    /**
     * @param {Event} event Event.
     * @private
     */ VectorSource2.prototype.handleFeatureChange_ = function(event) {
        var feature = event.target;
        var featureKey = _utilJs.getUid(feature);
        var geometry = feature.getGeometry();
        if (!geometry) {
            if (!(featureKey in this.nullGeometryFeatures_)) {
                if (this.featuresRtree_) this.featuresRtree_.remove(feature);
                this.nullGeometryFeatures_[featureKey] = feature;
            }
        } else {
            var extent = geometry.getExtent();
            if (featureKey in this.nullGeometryFeatures_) {
                delete this.nullGeometryFeatures_[featureKey];
                if (this.featuresRtree_) this.featuresRtree_.insert(extent, feature);
            } else if (this.featuresRtree_) this.featuresRtree_.update(extent, feature);
        }
        var id = feature.getId();
        if (id !== undefined) {
            var sid = id.toString();
            if (this.idIndex_[sid] !== feature) {
                this.removeFromIdIndex_(feature);
                this.idIndex_[sid] = feature;
            }
        } else {
            this.removeFromIdIndex_(feature);
            this.uidIndex_[featureKey] = feature;
        }
        this.changed();
        this.dispatchEvent(new VectorSourceEvent1(_vectorEventTypeJsDefault.default.CHANGEFEATURE, feature));
    };
    /**
     * Returns true if the feature is contained within the source.
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     * @return {boolean} Has feature.
     * @api
     */ VectorSource2.prototype.hasFeature = function(feature) {
        var id = feature.getId();
        if (id !== undefined) return id in this.idIndex_;
        else return _utilJs.getUid(feature) in this.uidIndex_;
    };
    /**
     * @return {boolean} Is empty.
     */ VectorSource2.prototype.isEmpty = function() {
        return this.featuresRtree_.isEmpty() && _objJs.isEmpty(this.nullGeometryFeatures_);
    };
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */ VectorSource2.prototype.loadFeatures = function(extent, resolution, projection) {
        var loadedExtentsRtree = this.loadedExtentsRtree_;
        var extentsToLoad = this.strategy_(extent, resolution, projection);
        var _loop_1 = function(i, ii) {
            var extentToLoad = extentsToLoad[i];
            var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad, /**
             * @param {{extent: import("../extent.js").Extent}} object Object.
             * @return {boolean} Contains.
             */ function(object) {
                return _extentJs.containsExtent(object.extent, extentToLoad);
            });
            if (!alreadyLoaded) {
                ++this_1.loadingExtentsCount_;
                this_1.dispatchEvent(new VectorSourceEvent1(_vectorEventTypeJsDefault.default.FEATURESLOADSTART));
                this_1.loader_.call(this_1, extentToLoad, resolution, projection, (function(features) {
                    --this.loadingExtentsCount_;
                    this.dispatchEvent(new VectorSourceEvent1(_vectorEventTypeJsDefault.default.FEATURESLOADEND, undefined, features));
                }).bind(this_1), (function() {
                    --this.loadingExtentsCount_;
                    this.dispatchEvent(new VectorSourceEvent1(_vectorEventTypeJsDefault.default.FEATURESLOADERROR));
                }).bind(this_1));
                loadedExtentsRtree.insert(extentToLoad, {
                    extent: extentToLoad.slice()
                });
            }
        };
        var this_1 = this;
        for(var i = 0, ii = extentsToLoad.length; i < ii; ++i)_loop_1(i, ii);
        this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
    };
    VectorSource2.prototype.refresh = function() {
        this.clear(true);
        this.loadedExtentsRtree_.clear();
        _super.prototype.refresh.call(this);
    };
    /**
     * Remove an extent from the list of loaded extents.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */ VectorSource2.prototype.removeLoadedExtent = function(extent) {
        var loadedExtentsRtree = this.loadedExtentsRtree_;
        var obj;
        loadedExtentsRtree.forEachInExtent(extent, function(object) {
            if (_extentJs.equals(object.extent, extent)) {
                obj = object;
                return true;
            }
        });
        if (obj) loadedExtentsRtree.remove(obj);
    };
    /**
     * Remove a single feature from the source.  If you want to remove all features
     * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
     * instead.
     * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
     * @api
     */ VectorSource2.prototype.removeFeature = function(feature) {
        var featureKey = _utilJs.getUid(feature);
        if (featureKey in this.nullGeometryFeatures_) delete this.nullGeometryFeatures_[featureKey];
        else if (this.featuresRtree_) this.featuresRtree_.remove(feature);
        this.removeFeatureInternal(feature);
        this.changed();
    };
    /**
     * Remove feature without firing a `change` event.
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     * @protected
     */ VectorSource2.prototype.removeFeatureInternal = function(feature) {
        var featureKey = _utilJs.getUid(feature);
        this.featureChangeKeys_[featureKey].forEach(_eventsJs.unlistenByKey);
        delete this.featureChangeKeys_[featureKey];
        var id = feature.getId();
        if (id !== undefined) delete this.idIndex_[id.toString()];
        delete this.uidIndex_[featureKey];
        this.dispatchEvent(new VectorSourceEvent1(_vectorEventTypeJsDefault.default.REMOVEFEATURE, feature));
    };
    /**
     * Remove a feature from the id index.  Called internally when the feature id
     * may have changed.
     * @param {import("../Feature.js").default<Geometry>} feature The feature.
     * @return {boolean} Removed the feature from the index.
     * @private
     */ VectorSource2.prototype.removeFromIdIndex_ = function(feature) {
        var removed = false;
        for(var id in this.idIndex_)if (this.idIndex_[id] === feature) {
            delete this.idIndex_[id];
            removed = true;
            break;
        }
        return removed;
    };
    /**
     * Set the new loader of the source. The next render cycle will use the
     * new loader.
     * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
     * @api
     */ VectorSource2.prototype.setLoader = function(loader) {
        this.loader_ = loader;
    };
    /**
     * Points the source to a new url. The next render cycle will use the new url.
     * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
     * @api
     */ VectorSource2.prototype.setUrl = function(url) {
        _assertsJs.assert(this.format_, 7); // `format` must be set when `url` is set
        this.url_ = url;
        this.setLoader(_featureloaderJs.xhr(url, this.format_));
    };
    return VectorSource2;
}(_sourceJsDefault.default);
exports.default = VectorSource1;

},{"../Collection.js":"d2f3b","../CollectionEventType.js":"jxyhy","../events/Event.js":"7AR9n","../events/EventType.js":"83vee","../ObjectEventType.js":"j6hH6","../structs/RBush.js":"l9R2P","./Source.js":"2JiFe","./State.js":"hpoq1","./VectorEventType.js":"hswmg","../functions.js":"d72zA","../loadingstrategy.js":"ebVqw","../asserts.js":"cnrP4","../extent.js":"jgUz2","../array.js":"jKNP0","../util.js":"9zOhk","../obj.js":"g3fPg","../events.js":"e9Qqr","../featureloader.js":"bOF1e","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"l9R2P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/structs/RBush
 */ var _rbush = require("rbush");
var _rbushDefault = parcelHelpers.interopDefault(_rbush);
var _extentJs = require("../extent.js");
var _utilJs = require("../util.js");
var _objJs = require("../obj.js");
/**
 * @typedef {Object} Entry
 * @property {number} minX MinX.
 * @property {number} minY MinY.
 * @property {number} maxX MaxX.
 * @property {number} maxY MaxY.
 * @property {Object} [value] Value.
 */ /**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */ var RBush = function() {
    /**
     * @param {number} [opt_maxEntries] Max entries.
     */ function RBush1(opt_maxEntries) {
        /**
         * @private
         */ this.rbush_ = new _rbushDefault.default(opt_maxEntries);
        /**
         * A mapping between the objects added to this rbush wrapper
         * and the objects that are actually added to the internal rbush.
         * @private
         * @type {Object<string, Entry>}
         */ this.items_ = {
        };
    }
    /**
     * Insert a value into the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */ RBush1.prototype.insert = function(extent, value) {
        /** @type {Entry} */ var item = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3],
            value: value
        };
        this.rbush_.insert(item);
        this.items_[_utilJs.getUid(value)] = item;
    };
    /**
     * Bulk-insert values into the RBush.
     * @param {Array<import("../extent.js").Extent>} extents Extents.
     * @param {Array<T>} values Values.
     */ RBush1.prototype.load = function(extents, values) {
        var items = new Array(values.length);
        for(var i = 0, l = values.length; i < l; i++){
            var extent = extents[i];
            var value = values[i];
            /** @type {Entry} */ var item = {
                minX: extent[0],
                minY: extent[1],
                maxX: extent[2],
                maxY: extent[3],
                value: value
            };
            items[i] = item;
            this.items_[_utilJs.getUid(value)] = item;
        }
        this.rbush_.load(items);
    };
    /**
     * Remove a value from the RBush.
     * @param {T} value Value.
     * @return {boolean} Removed.
     */ RBush1.prototype.remove = function(value) {
        var uid = _utilJs.getUid(value);
        // get the object in which the value was wrapped when adding to the
        // internal rbush. then use that object to do the removal.
        var item = this.items_[uid];
        delete this.items_[uid];
        return this.rbush_.remove(item) !== null;
    };
    /**
     * Update the extent of a value in the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */ RBush1.prototype.update = function(extent, value) {
        var item = this.items_[_utilJs.getUid(value)];
        var bbox = [
            item.minX,
            item.minY,
            item.maxX,
            item.maxY
        ];
        if (!_extentJs.equals(bbox, extent)) {
            this.remove(value);
            this.insert(extent, value);
        }
    };
    /**
     * Return all values in the RBush.
     * @return {Array<T>} All.
     */ RBush1.prototype.getAll = function() {
        var items = this.rbush_.all();
        return items.map(function(item) {
            return item.value;
        });
    };
    /**
     * Return all values in the given extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {Array<T>} All in extent.
     */ RBush1.prototype.getInExtent = function(extent) {
        /** @type {Entry} */ var bbox = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3]
        };
        var items = this.rbush_.search(bbox);
        return items.map(function(item) {
            return item.value;
        });
    };
    /**
     * Calls a callback function with each value in the tree.
     * If the callback returns a truthy value, this value is returned without
     * checking the rest of the tree.
     * @param {function(T): *} callback Callback.
     * @return {*} Callback return value.
     */ RBush1.prototype.forEach = function(callback) {
        return this.forEach_(this.getAll(), callback);
    };
    /**
     * Calls a callback function with each value in the provided extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(T): *} callback Callback.
     * @return {*} Callback return value.
     */ RBush1.prototype.forEachInExtent = function(extent, callback) {
        return this.forEach_(this.getInExtent(extent), callback);
    };
    /**
     * @param {Array<T>} values Values.
     * @param {function(T): *} callback Callback.
     * @private
     * @return {*} Callback return value.
     */ RBush1.prototype.forEach_ = function(values, callback) {
        var result;
        for(var i = 0, l = values.length; i < l; i++){
            result = callback(values[i]);
            if (result) return result;
        }
        return result;
    };
    /**
     * @return {boolean} Is empty.
     */ RBush1.prototype.isEmpty = function() {
        return _objJs.isEmpty(this.items_);
    };
    /**
     * Remove all values from the RBush.
     */ RBush1.prototype.clear = function() {
        this.rbush_.clear();
        this.items_ = {
        };
    };
    /**
     * @param {import("../extent.js").Extent} [opt_extent] Extent.
     * @return {import("../extent.js").Extent} Extent.
     */ RBush1.prototype.getExtent = function(opt_extent) {
        var data = this.rbush_.toJSON();
        return _extentJs.createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
    };
    /**
     * @param {RBush} rbush R-Tree.
     */ RBush1.prototype.concat = function(rbush) {
        this.rbush_.load(rbush.rbush_.all());
        for(var i in rbush.items_)this.items_[i] = rbush.items_[i];
    };
    return RBush1;
}();
exports.default = RBush;

},{"rbush":"g6Qgo","../extent.js":"jgUz2","../util.js":"9zOhk","../obj.js":"g3fPg","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hswmg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    /**
     * Triggered when a feature is added to the source.
     * @event module:ol/source/Vector.VectorSourceEvent#addfeature
     * @api
     */ ADDFEATURE: 'addfeature',
    /**
     * Triggered when a feature is updated.
     * @event module:ol/source/Vector.VectorSourceEvent#changefeature
     * @api
     */ CHANGEFEATURE: 'changefeature',
    /**
     * Triggered when the clear method is called on the source.
     * @event module:ol/source/Vector.VectorSourceEvent#clear
     * @api
     */ CLEAR: 'clear',
    /**
     * Triggered when a feature is removed from the source.
     * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
     * @event module:ol/source/Vector.VectorSourceEvent#removefeature
     * @api
     */ REMOVEFEATURE: 'removefeature',
    /**
     * Triggered when features starts loading.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
     * @api
     */ FEATURESLOADSTART: 'featuresloadstart',
    /**
     * Triggered when features finishes loading.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
     * @api
     */ FEATURESLOADEND: 'featuresloadend',
    /**
     * Triggered if feature loading results in an error.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
     * @api
     */ FEATURESLOADERROR: 'featuresloaderror'
}; /**
 * @typedef {'addfeature'|'changefeature'|'clear'|'removefeature'|'featuresloadstart'|'featuresloadend'|'featuresloaderror'} VectorSourceEventTypes
 */ 

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"ebVqw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */ parcelHelpers.export(exports, "all", ()=>all
);
/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */ parcelHelpers.export(exports, "bbox", ()=>bbox
);
/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number, import("./proj.js").Projection): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */ parcelHelpers.export(exports, "tile", ()=>tile
);
/**
 * @module ol/loadingstrategy
 */ var _projJs = require("./proj.js");
function all(extent, resolution) {
    return [
        [-Infinity, -Infinity, Infinity,
            Infinity
        ]
    ];
}
function bbox(extent, resolution) {
    return [
        extent
    ];
}
function tile(tileGrid) {
    return(/**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj.js").Projection} projection Projection.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */ function(extent, resolution, projection) {
        var z = tileGrid.getZForResolution(_projJs.fromUserResolution(resolution, projection));
        var tileRange = tileGrid.getTileRangeForExtentAndZ(_projJs.fromUserExtent(extent, projection), z);
        /** @type {Array<import("./extent.js").Extent>} */ var extents = [];
        /** @type {import("./tilecoord.js").TileCoord} */ var tileCoord = [
            z,
            0,
            0
        ];
        for(tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1])for(tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2])extents.push(_projJs.toUserExtent(tileGrid.getTileCoordExtent(tileCoord), projection));
        return extents;
    });
}

},{"./proj.js":"hmdWM","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bOF1e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * {@link module:ol/source/Vector} sources use a function of this type to
 * load features.
 *
 * This function takes up to 5 arguments. These are an {@link module:ol/extent~Extent} representing
 * the area to be loaded, a `{number}` representing the resolution (map units per pixel), an
 * {@link module:ol/proj/Projection} for the projection, an optional success callback that should get
 * the loaded features passed as an argument and an optional failure callback with no arguments. If
 * the callbacks are not used, the corresponding vector source will not fire `'featuresloadend'` and
 * `'featuresloaderror'` events. `this` within the function is bound to the
 * {@link module:ol/source/Vector} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default),
 *           import("./extent.js").Extent,
 *           number,
 *           import("./proj/Projection.js").default,
 *           function(Array<import("./Feature.js").default>): void=,
 *           function(): void=): void} FeatureLoader
 * @api
 */ /**
 * {@link module:ol/source/Vector} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */ /**
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {function(Array<import("./Feature.js").default>, import("./proj/Projection.js").default): void} success Success
 *      Function called with the loaded features and optionally with the data projection.
 * @param {function(): void} failure Failure
 *      Function called when loading failed.
 */ parcelHelpers.export(exports, "loadFeaturesXhr", ()=>loadFeaturesXhr
);
/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @return {FeatureLoader} The feature loader.
 * @api
 */ parcelHelpers.export(exports, "xhr", ()=>xhr
);
/**
 * Setter for the withCredentials configuration for the XHR.
 *
 * @param {boolean} xhrWithCredentials The value of withCredentials to set.
 * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/
 * @api
 */ parcelHelpers.export(exports, "setWithCredentials", ()=>setWithCredentials
);
/**
 * @module ol/featureloader
 */ var _formatTypeJs = require("./format/FormatType.js");
var _formatTypeJsDefault = parcelHelpers.interopDefault(_formatTypeJs);
var _functionsJs = require("./functions.js");
/**
 *
 * @type {boolean}
 * @private
 */ var withCredentials = false;
function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);
    if (format.getType() == _formatTypeJsDefault.default.ARRAY_BUFFER) xhr.responseType = 'arraybuffer';
    xhr.withCredentials = withCredentials;
    /**
     * @param {Event} event Event.
     * @private
     */ xhr.onload = function(event) {
        // status will be 0 for file:// urls
        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
            var type = format.getType();
            /** @type {Document|Node|Object|string|undefined} */ var source = void 0;
            if (type == _formatTypeJsDefault.default.JSON || type == _formatTypeJsDefault.default.TEXT) source = xhr.responseText;
            else if (type == _formatTypeJsDefault.default.XML) {
                source = xhr.responseXML;
                if (!source) source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
            } else if (type == _formatTypeJsDefault.default.ARRAY_BUFFER) source = xhr.response;
            if (source) success(format.readFeatures(source, {
                extent: extent,
                featureProjection: projection
            }), format.readProjection(source));
            else failure();
        } else failure();
    };
    /**
     * @private
     */ xhr.onerror = failure;
    xhr.send();
}
function xhr(url, format) {
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @param {function(Array<import("./Feature.js").default>): void} [success] Success
     *      Function called when loading succeeded.
     * @param {function(): void} [failure] Failure
     *      Function called when loading failed.
     * @this {import("./source/Vector").default}
     */ return function(extent, resolution, projection, success, failure) {
        var source = this;
        loadFeaturesXhr(url, format, extent, resolution, projection, /**
         * @param {Array<import("./Feature.js").default>} features The loaded features.
         * @param {import("./proj/Projection.js").default} dataProjection Data
         * projection.
         */ function(features, dataProjection) {
            source.addFeatures(features);
            if (success !== undefined) success(features);
        }, /* FIXME handle error */ failure ? failure : _functionsJs.VOID);
    };
}
function setWithCredentials(xhrWithCredentials) {
    withCredentials = xhrWithCredentials;
}

},{"./format/FormatType.js":"eKyoL","./functions.js":"d72zA","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lfwwe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ExtentEvent", ()=>ExtentEvent1
);
/**
 * @module ol/interaction/Extent
 */ var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _geometryTypeJs = require("../geom/GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _pointJs = require("../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _vectorJs = require("../layer/Vector.js");
var _vectorJsDefault = parcelHelpers.interopDefault(_vectorJs);
var _vectorJs1 = require("../source/Vector.js");
var _vectorJsDefault1 = parcelHelpers.interopDefault(_vectorJs1);
var _conditionJs = require("../events/condition.js");
var _extentJs = require("../extent.js");
var _coordinateJs = require("../coordinate.js");
var _styleJs = require("../style/Style.js");
var _polygonJs = require("../geom/Polygon.js");
var _projJs = require("../proj.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.always}.
 * @property {import("../extent.js").Extent} [extent] Initial extent. Defaults to no
 * initial extent.
 * @property {import("../style/Style.js").StyleLike} [boxStyle]
 * Style for the drawn extent box. Defaults to
 * {@link module:ol/style/Style~createEditing()['Polygon']}
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike} [pointerStyle]
 * Style for the cursor used to draw the extent. Defaults to
 * {@link module:ol/style/Style~createEditing()['Point']}
 * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps
 * in the X direction? Only affects visuals, not functionality.
 */ /**
 * @enum {string}
 */ var ExtentEventType = {
    /**
     * Triggered after the extent is changed
     * @event ExtentEvent#extentchanged
     * @api
     */ EXTENTCHANGED: 'extentchanged'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Extent~Extent} instances are
 * instances of this type.
 */ var ExtentEvent1 = function(_super) {
    __extends(ExtentEvent2, _super);
    /**
     * @param {import("../extent.js").Extent} extent the new extent
     */ function ExtentEvent2(extent) {
        var _this = _super.call(this, ExtentEventType.EXTENTCHANGED) || this;
        /**
         * The current extent.
         * @type {import("../extent.js").Extent}
         * @api
         */ _this.extent = extent;
        return _this;
    }
    return ExtentEvent2;
}(_eventJsDefault.default);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'extentchanged', ExtentEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'extentchanged', Return>} ExtentOnSignature
 */ /**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map.
 * Once drawn, the vector box can be modified by dragging its vertices or edges.
 * This interaction is only supported for mouse devices.
 *
 * @fires ExtentEvent
 * @api
 */ var Extent1 = function(_super) {
    __extends(Extent2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function Extent2(opt_options) {
        var _this = this;
        var options = opt_options || {
        };
        _this = _super.call(this, options) || this;
        /***
         * @type {ExtentOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {ExtentOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {ExtentOnSignature<void>}
         */ _this.un;
        /**
         * Condition
         * @type {import("../events/condition.js").Condition}
         * @private
         */ _this.condition_ = options.condition ? options.condition : _conditionJs.always;
        /**
         * Extent of the drawn box
         * @type {import("../extent.js").Extent}
         * @private
         */ _this.extent_ = null;
        /**
         * Handler for pointer move events
         * @type {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null}
         * @private
         */ _this.pointerHandler_ = null;
        /**
         * Pixel threshold to snap to extent
         * @type {number}
         * @private
         */ _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
        /**
         * Is the pointer snapped to an extent vertex
         * @type {boolean}
         * @private
         */ _this.snappedToVertex_ = false;
        /**
         * Feature for displaying the visible extent
         * @type {Feature}
         * @private
         */ _this.extentFeature_ = null;
        /**
         * Feature for displaying the visible pointer
         * @type {Feature<Point>}
         * @private
         */ _this.vertexFeature_ = null;
        if (!opt_options) opt_options = {
        };
        /**
         * Layer for the extentFeature
         * @type {VectorLayer}
         * @private
         */ _this.extentOverlay_ = new _vectorJsDefault.default({
            source: new _vectorJsDefault1.default({
                useSpatialIndex: false,
                wrapX: !!opt_options.wrapX
            }),
            style: opt_options.boxStyle ? opt_options.boxStyle : getDefaultExtentStyleFunction(),
            updateWhileAnimating: true,
            updateWhileInteracting: true
        });
        /**
         * Layer for the vertexFeature
         * @type {VectorLayer}
         * @private
         */ _this.vertexOverlay_ = new _vectorJsDefault.default({
            source: new _vectorJsDefault1.default({
                useSpatialIndex: false,
                wrapX: !!opt_options.wrapX
            }),
            style: opt_options.pointerStyle ? opt_options.pointerStyle : getDefaultPointerStyleFunction(),
            updateWhileAnimating: true,
            updateWhileInteracting: true
        });
        if (opt_options.extent) _this.setExtent(opt_options.extent);
        return _this;
    }
    /**
     * @param {import("../pixel.js").Pixel} pixel cursor location
     * @param {import("../PluggableMap.js").default} map map
     * @return {import("../coordinate.js").Coordinate|null} snapped vertex on extent
     * @private
     */ Extent2.prototype.snapToVertex_ = function(pixel, map) {
        var pixelCoordinate = map.getCoordinateFromPixelInternal(pixel);
        var sortByDistance = function(a, b) {
            return _coordinateJs.squaredDistanceToSegment(pixelCoordinate, a) - _coordinateJs.squaredDistanceToSegment(pixelCoordinate, b);
        };
        var extent = this.getExtentInternal();
        if (extent) {
            //convert extents to line segments and find the segment closest to pixelCoordinate
            var segments = getSegments(extent);
            segments.sort(sortByDistance);
            var closestSegment = segments[0];
            var vertex = _coordinateJs.closestOnSegment(pixelCoordinate, closestSegment);
            var vertexPixel = map.getPixelFromCoordinateInternal(vertex);
            //if the distance is within tolerance, snap to the segment
            if (_coordinateJs.distance(pixel, vertexPixel) <= this.pixelTolerance_) {
                //test if we should further snap to a vertex
                var pixel1 = map.getPixelFromCoordinateInternal(closestSegment[0]);
                var pixel2 = map.getPixelFromCoordinateInternal(closestSegment[1]);
                var squaredDist1 = _coordinateJs.squaredDistance(vertexPixel, pixel1);
                var squaredDist2 = _coordinateJs.squaredDistance(vertexPixel, pixel2);
                var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                this.snappedToVertex_ = dist <= this.pixelTolerance_;
                if (this.snappedToVertex_) vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                return vertex;
            }
        }
        return null;
    };
    /**
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent pointer move event
     * @private
     */ Extent2.prototype.handlePointerMove_ = function(mapBrowserEvent) {
        var pixel = mapBrowserEvent.pixel;
        var map = mapBrowserEvent.map;
        var vertex = this.snapToVertex_(pixel, map);
        if (!vertex) vertex = map.getCoordinateFromPixelInternal(pixel);
        this.createOrUpdatePointerFeature_(vertex);
    };
    /**
     * @param {import("../extent.js").Extent} extent extent
     * @return {Feature} extent as featrue
     * @private
     */ Extent2.prototype.createOrUpdateExtentFeature_ = function(extent) {
        var extentFeature = this.extentFeature_;
        if (!extentFeature) {
            if (!extent) extentFeature = new _featureJsDefault.default({
            });
            else extentFeature = new _featureJsDefault.default(_polygonJs.fromExtent(extent));
            this.extentFeature_ = extentFeature;
            this.extentOverlay_.getSource().addFeature(extentFeature);
        } else if (!extent) extentFeature.setGeometry(undefined);
        else extentFeature.setGeometry(_polygonJs.fromExtent(extent));
        return extentFeature;
    };
    /**
     * @param {import("../coordinate.js").Coordinate} vertex location of feature
     * @return {Feature} vertex as feature
     * @private
     */ Extent2.prototype.createOrUpdatePointerFeature_ = function(vertex) {
        var vertexFeature = this.vertexFeature_;
        if (!vertexFeature) {
            vertexFeature = new _featureJsDefault.default(new _pointJsDefault.default(vertex));
            this.vertexFeature_ = vertexFeature;
            this.vertexOverlay_.getSource().addFeature(vertexFeature);
        } else {
            var geometry = vertexFeature.getGeometry();
            geometry.setCoordinates(vertex);
        }
        return vertexFeature;
    };
    /**
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     */ Extent2.prototype.handleEvent = function(mapBrowserEvent) {
        if (!mapBrowserEvent.originalEvent || !this.condition_(mapBrowserEvent)) return true;
        //display pointer (if not dragging)
        if (mapBrowserEvent.type == _mapBrowserEventTypeJsDefault.default.POINTERMOVE && !this.handlingDownUpSequence) this.handlePointerMove_(mapBrowserEvent);
        //call pointer to determine up/down/drag
        _super.prototype.handleEvent.call(this, mapBrowserEvent);
        //return false to stop propagation
        return false;
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */ Extent2.prototype.handleDownEvent = function(mapBrowserEvent) {
        var pixel = mapBrowserEvent.pixel;
        var map = mapBrowserEvent.map;
        var extent = this.getExtentInternal();
        var vertex = this.snapToVertex_(pixel, map);
        //find the extent corner opposite the passed corner
        var getOpposingPoint = function(point) {
            var x_ = null;
            var y_ = null;
            if (point[0] == extent[0]) x_ = extent[2];
            else if (point[0] == extent[2]) x_ = extent[0];
            if (point[1] == extent[1]) y_ = extent[3];
            else if (point[1] == extent[3]) y_ = extent[1];
            if (x_ !== null && y_ !== null) return [
                x_,
                y_
            ];
            return null;
        };
        if (vertex && extent) {
            var x = vertex[0] == extent[0] || vertex[0] == extent[2] ? vertex[0] : null;
            var y = vertex[1] == extent[1] || vertex[1] == extent[3] ? vertex[1] : null;
            //snap to point
            if (x !== null && y !== null) this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex));
            else if (x !== null) this.pointerHandler_ = getEdgeHandler(getOpposingPoint([
                x,
                extent[1]
            ]), getOpposingPoint([
                x,
                extent[3]
            ]));
            else if (y !== null) this.pointerHandler_ = getEdgeHandler(getOpposingPoint([
                extent[0],
                y
            ]), getOpposingPoint([
                extent[2],
                y
            ]));
        //no snap - new bbox
        } else {
            vertex = map.getCoordinateFromPixelInternal(pixel);
            this.setExtent([
                vertex[0],
                vertex[1],
                vertex[0],
                vertex[1]
            ]);
            this.pointerHandler_ = getPointHandler(vertex);
        }
        return true; //event handled; start downup sequence
    };
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */ Extent2.prototype.handleDragEvent = function(mapBrowserEvent) {
        if (this.pointerHandler_) {
            var pixelCoordinate = mapBrowserEvent.coordinate;
            this.setExtent(this.pointerHandler_(pixelCoordinate));
            this.createOrUpdatePointerFeature_(pixelCoordinate);
        }
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */ Extent2.prototype.handleUpEvent = function(mapBrowserEvent) {
        this.pointerHandler_ = null;
        //If bbox is zero area, set to null;
        var extent = this.getExtentInternal();
        if (!extent || _extentJs.getArea(extent) === 0) this.setExtent(null);
        return false; //Stop handling downup sequence
    };
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default} map Map.
     */ Extent2.prototype.setMap = function(map) {
        this.extentOverlay_.setMap(map);
        this.vertexOverlay_.setMap(map);
        _super.prototype.setMap.call(this, map);
    };
    /**
     * Returns the current drawn extent in the view projection (or user projection if set)
     *
     * @return {import("../extent.js").Extent} Drawn extent in the view projection.
     * @api
     */ Extent2.prototype.getExtent = function() {
        return _projJs.toUserExtent(this.getExtentInternal(), this.getMap().getView().getProjection());
    };
    /**
     * Returns the current drawn extent in the view projection
     *
     * @return {import("../extent.js").Extent} Drawn extent in the view projection.
     * @api
     */ Extent2.prototype.getExtentInternal = function() {
        return this.extent_;
    };
    /**
     * Manually sets the drawn extent, using the view projection.
     *
     * @param {import("../extent.js").Extent} extent Extent
     * @api
     */ Extent2.prototype.setExtent = function(extent) {
        //Null extent means no bbox
        this.extent_ = extent ? extent : null;
        this.createOrUpdateExtentFeature_(extent);
        this.dispatchEvent(new ExtentEvent1(this.extent_));
    };
    return Extent2;
}(_pointerJsDefault.default);
/**
 * Returns the default style for the drawn bbox
 *
 * @return {import("../style/Style.js").StyleFunction} Default Extent style
 */ function getDefaultExtentStyleFunction() {
    var style = _styleJs.createEditingStyle();
    return function(feature, resolution) {
        return style[_geometryTypeJsDefault.default.POLYGON];
    };
}
/**
 * Returns the default style for the pointer
 *
 * @return {import("../style/Style.js").StyleFunction} Default pointer style
 */ function getDefaultPointerStyleFunction() {
    var style = _styleJs.createEditingStyle();
    return function(feature, resolution) {
        return style[_geometryTypeJsDefault.default.POINT];
    };
}
/**
 * @param {import("../coordinate.js").Coordinate} fixedPoint corner that will be unchanged in the new extent
 * @return {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent} event handler
 */ function getPointHandler(fixedPoint) {
    return function(point) {
        return _extentJs.boundingExtent([
            fixedPoint,
            point
        ]);
    };
}
/**
 * @param {import("../coordinate.js").Coordinate} fixedP1 first corner that will be unchanged in the new extent
 * @param {import("../coordinate.js").Coordinate} fixedP2 second corner that will be unchanged in the new extent
 * @return {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null} event handler
 */ function getEdgeHandler(fixedP1, fixedP2) {
    if (fixedP1[0] == fixedP2[0]) return function(point) {
        return _extentJs.boundingExtent([
            fixedP1,
            [
                point[0],
                fixedP2[1]
            ]
        ]);
    };
    else if (fixedP1[1] == fixedP2[1]) return function(point) {
        return _extentJs.boundingExtent([
            fixedP1,
            [
                fixedP2[0],
                point[1]
            ]
        ]);
    };
    else return null;
}
/**
 * @param {import("../extent.js").Extent} extent extent
 * @return {Array<Array<import("../coordinate.js").Coordinate>>} extent line segments
 */ function getSegments(extent) {
    return [
        [
            [
                extent[0],
                extent[1]
            ],
            [
                extent[0],
                extent[3]
            ], 
        ],
        [
            [
                extent[0],
                extent[3]
            ],
            [
                extent[2],
                extent[3]
            ], 
        ],
        [
            [
                extent[2],
                extent[3]
            ],
            [
                extent[2],
                extent[1]
            ], 
        ],
        [
            [
                extent[2],
                extent[1]
            ],
            [
                extent[0],
                extent[1]
            ], 
        ], 
    ];
}
exports.default = Extent1;

},{"../events/Event.js":"7AR9n","../Feature.js":"75Tk1","../geom/GeometryType.js":"3sRlw","../MapBrowserEventType.js":"coXRZ","../geom/Point.js":"4ReTD","./Pointer.js":"iatpc","../layer/Vector.js":"2qjJV","../source/Vector.js":"lTwzQ","../events/condition.js":"eCqyb","../extent.js":"jgUz2","../coordinate.js":"cmApa","../style/Style.js":"9N9zp","../geom/Polygon.js":"hoOc8","../proj.js":"hmdWM","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"5MUrp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ModifyEvent", ()=>ModifyEvent1
);
/**
 * @module ol/interaction/Modify
 */ var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _collectionEventTypeJs = require("../CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _featureJs = require("../Feature.js");
var _featureJsDefault = parcelHelpers.interopDefault(_featureJs);
var _geometryTypeJs = require("../geom/GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _mapBrowserEventTypeJs = require("../MapBrowserEventType.js");
var _mapBrowserEventTypeJsDefault = parcelHelpers.interopDefault(_mapBrowserEventTypeJs);
var _pointJs = require("../geom/Point.js");
var _pointJsDefault = parcelHelpers.interopDefault(_pointJs);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _rbushJs = require("../structs/RBush.js");
var _rbushJsDefault = parcelHelpers.interopDefault(_rbushJs);
var _vectorEventTypeJs = require("../source/VectorEventType.js");
var _vectorEventTypeJsDefault = parcelHelpers.interopDefault(_vectorEventTypeJs);
var _vectorJs = require("../layer/Vector.js");
var _vectorJsDefault = parcelHelpers.interopDefault(_vectorJs);
var _vectorJs1 = require("../source/Vector.js");
var _vectorJsDefault1 = parcelHelpers.interopDefault(_vectorJs1);
var _conditionJs = require("../events/condition.js");
var _extentJs = require("../extent.js");
var _coordinateJs = require("../coordinate.js");
var _styleJs = require("../style/Style.js");
var _arrayJs = require("../array.js");
var _polygonJs = require("../geom/Polygon.js");
var _projJs = require("../proj.js");
var _utilJs = require("../util.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * The segment index assigned to a circle's center when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */ var CIRCLE_CENTER_INDEX = 0;
/**
 * The segment index assigned to a circle's circumference when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */ var CIRCLE_CIRCUMFERENCE_INDEX = 1;
var tempExtent = [
    0,
    0,
    0,
    0
];
var tempSegment = [];
/**
 * @enum {string}
 */ var ModifyEventType = {
    /**
     * Triggered upon feature modification start
     * @event ModifyEvent#modifystart
     * @api
     */ MODIFYSTART: 'modifystart',
    /**
     * Triggered upon feature modification end
     * @event ModifyEvent#modifyend
     * @api
     */ MODIFYEND: 'modifyend'
};
/**
 * @typedef {Object} SegmentData
 * @property {Array<number>} [depth] Depth.
 * @property {import("../Feature").FeatureLike} feature Feature.
 * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
 * @property {number} [index] Index.
 * @property {Array<Array<number>>} segment Segment.
 * @property {Array<SegmentData>} [featureSegments] FeatureSegments.
 */ /**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event will be considered to add or move a
 * vertex to the sketch. Default is
 * {@link module:ol/events/condition.primaryAction}.
 * @property {import("../events/condition.js").Condition} [deleteCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. By default,
 * {@link module:ol/events/condition.singleClick} with
 * {@link module:ol/events/condition.altKeyOnly} results in a vertex deletion.
 * @property {import("../events/condition.js").Condition} [insertVertexCondition] A
 * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether a new vertex should be added to the sketch
 * features. Default is {@link module:ol/events/condition.always}.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style used for the modification point or vertex. For linestrings and polygons, this will
 * be the affected vertex, for circles a point along the circle, and for points the actual
 * point. If not configured, the default edit style is used (see {@link module:ol/style}).
 * When using a style function, the point feature passed to the function will have a `features`
 * property - an array whose entries are the features that are being modified, and a `geometries`
 * property - an array whose entries are the geometries that are being modified. Both arrays are
 * in the same order. The `geometries` are only useful when modifying geometry collections, where
 * the geometry will be the particular geometry from the collection that is being modified.
 * @property {VectorSource} [source] The vector source with
 * features to modify.  If a vector source is not provided, a feature collection
 * must be provided with the `features` option.
 * @property {boolean|import("../layer/BaseVector").default} [hitDetection] When configured, point
 * features will be considered for modification based on their visual appearance, instead of being within
 * the `pixelTolerance` from the pointer location. When a {@link module:ol/layer/BaseVector} is
 * provided, only the rendered representation of the features on that layer will be considered.
 * @property {Collection<Feature>} [features]
 * The features the interaction works on.  If a feature collection is not
 * provided, a vector source must be provided with the `source` option.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 * @property {boolean} [snapToPointer=!hitDetection] The vertex, point or segment being modified snaps to the
 * pointer coordinate when clicked within the `pixelTolerance`.
 */ /**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are
 * instances of this type.
 */ var ModifyEvent1 = function(_super) {
    __extends(ModifyEvent2, _super);
    /**
     * @param {ModifyEventType} type Type.
     * @param {Collection<import("../Feature").FeatureLike>} features
     * The features modified.
     * @param {import("../MapBrowserEvent.js").default} MapBrowserEvent
     * Associated {@link module:ol/MapBrowserEvent}.
     */ function ModifyEvent2(type, features, MapBrowserEvent) {
        var _this = _super.call(this, type) || this;
        /**
         * The features being modified.
         * @type {Collection<import("../Feature").FeatureLike>}
         * @api
         */ _this.features = features;
        /**
         * Associated {@link module:ol/MapBrowserEvent}.
         * @type {import("../MapBrowserEvent.js").default}
         * @api
         */ _this.mapBrowserEvent = MapBrowserEvent;
        return _this;
    }
    return ModifyEvent2;
}(_eventJsDefault.default);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'modifyend'|'modifystart', ModifyEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'modifyend'|'modifystart', Return>} ModifyOnSignature
 */ /**
 * @classdesc
 * Interaction for modifying feature geometries.  To modify features that have
 * been added to an existing source, construct the modify interaction with the
 * `source` option.  If you want to modify features in a collection (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.  The interaction must be constructed with either a
 * `source` or `features` option.
 *
 * Cartesian distance from the pointer is used to determine the features that
 * will be modified. This means that geometries will only be considered for
 * modification when they are within the configured `pixelTolerane`. For point
 * geometries, the `hitDetection` option can be used to match their visual
 * appearance.
 *
 * By default, the interaction will allow deletion of vertices when the `alt`
 * key is pressed.  To configure the interaction with a different condition
 * for deletion, use the `deleteCondition` option.
 * @fires ModifyEvent
 * @api
 */ var Modify1 = function(_super) {
    __extends(Modify2, _super);
    /**
     * @param {Options} options Options.
     */ function Modify2(options) {
        var _this = _super.call(this, options) || this;
        /***
         * @type {ModifyOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {ModifyOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {ModifyOnSignature<void>}
         */ _this.un;
        /** @private */ _this.boundHandleFeatureChange_ = _this.handleFeatureChange_.bind(_this);
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.condition_ = options.condition ? options.condition : _conditionJs.primaryAction;
        /**
         * @private
         * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
         * @return {boolean} Combined condition result.
         */ _this.defaultDeleteCondition_ = function(mapBrowserEvent) {
            return _conditionJs.altKeyOnly(mapBrowserEvent) && _conditionJs.singleClick(mapBrowserEvent);
        };
        /**
         * @type {import("../events/condition.js").Condition}
         * @private
         */ _this.deleteCondition_ = options.deleteCondition ? options.deleteCondition : _this.defaultDeleteCondition_;
        /**
         * @type {import("../events/condition.js").Condition}
         * @private
         */ _this.insertVertexCondition_ = options.insertVertexCondition ? options.insertVertexCondition : _conditionJs.always;
        /**
         * Editing vertex.
         * @type {Feature}
         * @private
         */ _this.vertexFeature_ = null;
        /**
         * Segments intersecting {@link this.vertexFeature_} by segment uid.
         * @type {Object<string, boolean>}
         * @private
         */ _this.vertexSegments_ = null;
        /**
         * @type {import("../pixel.js").Pixel}
         * @private
         */ _this.lastPixel_ = [
            0,
            0
        ];
        /**
         * Tracks if the next `singleclick` event should be ignored to prevent
         * accidental deletion right after vertex creation.
         * @type {boolean}
         * @private
         */ _this.ignoreNextSingleClick_ = false;
        /**
         * @type {Collection<import("../Feature").FeatureLike>}
         * @private
         */ _this.featuresBeingModified_ = null;
        /**
         * Segment RTree for each layer
         * @type {RBush<SegmentData>}
         * @private
         */ _this.rBush_ = new _rbushJsDefault.default();
        /**
         * @type {number}
         * @private
         */ _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
        /**
         * @type {boolean}
         * @private
         */ _this.snappedToVertex_ = false;
        /**
         * Indicate whether the interaction is currently changing a feature's
         * coordinates.
         * @type {boolean}
         * @private
         */ _this.changingFeature_ = false;
        /**
         * @type {Array}
         * @private
         */ _this.dragSegments_ = [];
        /**
         * Draw overlay where sketch features are drawn.
         * @type {VectorLayer}
         * @private
         */ _this.overlay_ = new _vectorJsDefault.default({
            source: new _vectorJsDefault1.default({
                useSpatialIndex: false,
                wrapX: !!options.wrapX
            }),
            style: options.style ? options.style : getDefaultStyleFunction(),
            updateWhileAnimating: true,
            updateWhileInteracting: true
        });
        /**
         * @const
         * @private
         * @type {!Object<string, function(Feature, import("../geom/Geometry.js").default): void>}
         */ _this.SEGMENT_WRITERS_ = {
            'Point': _this.writePointGeometry_.bind(_this),
            'LineString': _this.writeLineStringGeometry_.bind(_this),
            'LinearRing': _this.writeLineStringGeometry_.bind(_this),
            'Polygon': _this.writePolygonGeometry_.bind(_this),
            'MultiPoint': _this.writeMultiPointGeometry_.bind(_this),
            'MultiLineString': _this.writeMultiLineStringGeometry_.bind(_this),
            'MultiPolygon': _this.writeMultiPolygonGeometry_.bind(_this),
            'Circle': _this.writeCircleGeometry_.bind(_this),
            'GeometryCollection': _this.writeGeometryCollectionGeometry_.bind(_this)
        };
        /**
         * @type {VectorSource}
         * @private
         */ _this.source_ = null;
        /**
         * @type {boolean|import("../layer/BaseVector").default}
         */ _this.hitDetection_ = null;
        var features;
        if (options.features) features = options.features;
        else if (options.source) {
            _this.source_ = options.source;
            features = new _collectionJsDefault.default(_this.source_.getFeatures());
            _this.source_.addEventListener(_vectorEventTypeJsDefault.default.ADDFEATURE, _this.handleSourceAdd_.bind(_this));
            _this.source_.addEventListener(_vectorEventTypeJsDefault.default.REMOVEFEATURE, _this.handleSourceRemove_.bind(_this));
        }
        if (!features) throw new Error('The modify interaction requires features, a source or a layer');
        if (options.hitDetection) _this.hitDetection_ = options.hitDetection;
        /**
         * @type {Collection<import("../Feature.js").FeatureLike>}
         * @private
         */ _this.features_ = features;
        _this.features_.forEach(_this.addFeature_.bind(_this));
        _this.features_.addEventListener(_collectionEventTypeJsDefault.default.ADD, _this.handleFeatureAdd_.bind(_this));
        _this.features_.addEventListener(_collectionEventTypeJsDefault.default.REMOVE, _this.handleFeatureRemove_.bind(_this));
        /**
         * @type {import("../MapBrowserEvent.js").default}
         * @private
         */ _this.lastPointerEvent_ = null;
        /**
         * Delta (x, y in map units) between matched rtree vertex and pointer vertex.
         * @type {Array<number>}
         */ _this.delta_ = [
            0,
            0
        ];
        /**
         * @private
         */ _this.snapToPointer_ = options.snapToPointer === undefined ? !_this.hitDetection_ : options.snapToPointer;
        return _this;
    }
    /**
     * @param {Feature} feature Feature.
     * @private
     */ Modify2.prototype.addFeature_ = function(feature) {
        var geometry = feature.getGeometry();
        if (geometry) {
            var writer = this.SEGMENT_WRITERS_[geometry.getType()];
            if (writer) writer(feature, geometry);
        }
        var map = this.getMap();
        if (map && map.isRendered() && this.getActive()) this.handlePointerAtPixel_(this.lastPixel_, map);
        feature.addEventListener(_eventTypeJsDefault.default.CHANGE, this.boundHandleFeatureChange_);
    };
    /**
     * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
     * @param {Array<Array<SegmentData>>} segments The segments subject to modification.
     * @private
     */ Modify2.prototype.willModifyFeatures_ = function(evt, segments) {
        if (!this.featuresBeingModified_) {
            this.featuresBeingModified_ = new _collectionJsDefault.default();
            var features = this.featuresBeingModified_.getArray();
            for(var i = 0, ii = segments.length; i < ii; ++i){
                var segment = segments[i];
                for(var s = 0, ss = segment.length; s < ss; ++s){
                    var feature = segment[s].feature;
                    if (feature && features.indexOf(feature) === -1) this.featuresBeingModified_.push(feature);
                }
            }
            if (this.featuresBeingModified_.getLength() === 0) this.featuresBeingModified_ = null;
            else this.dispatchEvent(new ModifyEvent1(ModifyEventType.MODIFYSTART, this.featuresBeingModified_, evt));
        }
    };
    /**
     * @param {Feature} feature Feature.
     * @private
     */ Modify2.prototype.removeFeature_ = function(feature) {
        this.removeFeatureSegmentData_(feature);
        // Remove the vertex feature if the collection of canditate features is empty.
        if (this.vertexFeature_ && this.features_.getLength() === 0) {
            this.overlay_.getSource().removeFeature(this.vertexFeature_);
            this.vertexFeature_ = null;
        }
        feature.removeEventListener(_eventTypeJsDefault.default.CHANGE, this.boundHandleFeatureChange_);
    };
    /**
     * @param {Feature} feature Feature.
     * @private
     */ Modify2.prototype.removeFeatureSegmentData_ = function(feature) {
        var rBush = this.rBush_;
        /** @type {Array<SegmentData>} */ var nodesToRemove = [];
        rBush.forEach(/**
         * @param {SegmentData} node RTree node.
         */ function(node) {
            if (feature === node.feature) nodesToRemove.push(node);
        });
        for(var i = nodesToRemove.length - 1; i >= 0; --i){
            var nodeToRemove = nodesToRemove[i];
            for(var j = this.dragSegments_.length - 1; j >= 0; --j)if (this.dragSegments_[j][0] === nodeToRemove) this.dragSegments_.splice(j, 1);
            rBush.remove(nodeToRemove);
        }
    };
    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     */ Modify2.prototype.setActive = function(active) {
        if (this.vertexFeature_ && !active) {
            this.overlay_.getSource().removeFeature(this.vertexFeature_);
            this.vertexFeature_ = null;
        }
        _super.prototype.setActive.call(this, active);
    };
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default} map Map.
     */ Modify2.prototype.setMap = function(map) {
        this.overlay_.setMap(map);
        _super.prototype.setMap.call(this, map);
    };
    /**
     * Get the overlay layer that this interaction renders the modification point or vertex to.
     * @return {VectorLayer} Overlay layer.
     * @api
     */ Modify2.prototype.getOverlay = function() {
        return this.overlay_;
    };
    /**
     * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */ Modify2.prototype.handleSourceAdd_ = function(event) {
        if (event.feature) this.features_.push(event.feature);
    };
    /**
     * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
     * @private
     */ Modify2.prototype.handleSourceRemove_ = function(event) {
        if (event.feature) this.features_.remove(event.feature);
    };
    /**
     * @param {import("../Collection.js").CollectionEvent} evt Event.
     * @private
     */ Modify2.prototype.handleFeatureAdd_ = function(evt) {
        this.addFeature_(evt.element);
    };
    /**
     * @param {import("../events/Event.js").default} evt Event.
     * @private
     */ Modify2.prototype.handleFeatureChange_ = function(evt) {
        if (!this.changingFeature_) {
            var feature = evt.target;
            this.removeFeature_(feature);
            this.addFeature_(feature);
        }
    };
    /**
     * @param {import("../Collection.js").CollectionEvent} evt Event.
     * @private
     */ Modify2.prototype.handleFeatureRemove_ = function(evt) {
        var feature = evt.element;
        this.removeFeature_(feature);
    };
    /**
     * @param {Feature} feature Feature
     * @param {Point} geometry Geometry.
     * @private
     */ Modify2.prototype.writePointGeometry_ = function(feature, geometry) {
        var coordinates = geometry.getCoordinates();
        /** @type {SegmentData} */ var segmentData = {
            feature: feature,
            geometry: geometry,
            segment: [
                coordinates,
                coordinates
            ]
        };
        this.rBush_.insert(geometry.getExtent(), segmentData);
    };
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
     * @private
     */ Modify2.prototype.writeMultiPointGeometry_ = function(feature, geometry) {
        var points = geometry.getCoordinates();
        for(var i = 0, ii = points.length; i < ii; ++i){
            var coordinates = points[i];
            /** @type {SegmentData} */ var segmentData = {
                feature: feature,
                geometry: geometry,
                depth: [
                    i
                ],
                index: i,
                segment: [
                    coordinates,
                    coordinates
                ]
            };
            this.rBush_.insert(geometry.getExtent(), segmentData);
        }
    };
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/LineString.js").default} geometry Geometry.
     * @private
     */ Modify2.prototype.writeLineStringGeometry_ = function(feature, geometry) {
        var coordinates = geometry.getCoordinates();
        for(var i = 0, ii = coordinates.length - 1; i < ii; ++i){
            var segment = coordinates.slice(i, i + 2);
            /** @type {SegmentData} */ var segmentData = {
                feature: feature,
                geometry: geometry,
                index: i,
                segment: segment
            };
            this.rBush_.insert(_extentJs.boundingExtent(segment), segmentData);
        }
    };
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
     * @private
     */ Modify2.prototype.writeMultiLineStringGeometry_ = function(feature, geometry) {
        var lines = geometry.getCoordinates();
        for(var j = 0, jj = lines.length; j < jj; ++j){
            var coordinates = lines[j];
            for(var i = 0, ii = coordinates.length - 1; i < ii; ++i){
                var segment = coordinates.slice(i, i + 2);
                /** @type {SegmentData} */ var segmentData = {
                    feature: feature,
                    geometry: geometry,
                    depth: [
                        j
                    ],
                    index: i,
                    segment: segment
                };
                this.rBush_.insert(_extentJs.boundingExtent(segment), segmentData);
            }
        }
    };
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/Polygon.js").default} geometry Geometry.
     * @private
     */ Modify2.prototype.writePolygonGeometry_ = function(feature, geometry) {
        var rings = geometry.getCoordinates();
        for(var j = 0, jj = rings.length; j < jj; ++j){
            var coordinates = rings[j];
            for(var i = 0, ii = coordinates.length - 1; i < ii; ++i){
                var segment = coordinates.slice(i, i + 2);
                /** @type {SegmentData} */ var segmentData = {
                    feature: feature,
                    geometry: geometry,
                    depth: [
                        j
                    ],
                    index: i,
                    segment: segment
                };
                this.rBush_.insert(_extentJs.boundingExtent(segment), segmentData);
            }
        }
    };
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
     * @private
     */ Modify2.prototype.writeMultiPolygonGeometry_ = function(feature, geometry) {
        var polygons = geometry.getCoordinates();
        for(var k = 0, kk = polygons.length; k < kk; ++k){
            var rings = polygons[k];
            for(var j = 0, jj = rings.length; j < jj; ++j){
                var coordinates = rings[j];
                for(var i = 0, ii = coordinates.length - 1; i < ii; ++i){
                    var segment = coordinates.slice(i, i + 2);
                    /** @type {SegmentData} */ var segmentData = {
                        feature: feature,
                        geometry: geometry,
                        depth: [
                            j,
                            k
                        ],
                        index: i,
                        segment: segment
                    };
                    this.rBush_.insert(_extentJs.boundingExtent(segment), segmentData);
                }
            }
        }
    };
    /**
     * We convert a circle into two segments.  The segment at index
     * {@link CIRCLE_CENTER_INDEX} is the
     * circle's center (a point).  The segment at index
     * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
     * the circumference, and is not a line segment.
     *
     * @param {Feature} feature Feature.
     * @param {import("../geom/Circle.js").default} geometry Geometry.
     * @private
     */ Modify2.prototype.writeCircleGeometry_ = function(feature, geometry) {
        var coordinates = geometry.getCenter();
        /** @type {SegmentData} */ var centerSegmentData = {
            feature: feature,
            geometry: geometry,
            index: CIRCLE_CENTER_INDEX,
            segment: [
                coordinates,
                coordinates
            ]
        };
        /** @type {SegmentData} */ var circumferenceSegmentData = {
            feature: feature,
            geometry: geometry,
            index: CIRCLE_CIRCUMFERENCE_INDEX,
            segment: [
                coordinates,
                coordinates
            ]
        };
        var featureSegments = [
            centerSegmentData,
            circumferenceSegmentData
        ];
        centerSegmentData.featureSegments = featureSegments;
        circumferenceSegmentData.featureSegments = featureSegments;
        this.rBush_.insert(_extentJs.createOrUpdateFromCoordinate(coordinates), centerSegmentData);
        var circleGeometry = geometry;
        var userProjection = _projJs.getUserProjection();
        if (userProjection && this.getMap()) {
            var projection = this.getMap().getView().getProjection();
            circleGeometry = circleGeometry.clone().transform(userProjection, projection);
            circleGeometry = _polygonJs.fromCircle(circleGeometry).transform(projection, userProjection);
        }
        this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
    };
    /**
     * @param {Feature} feature Feature
     * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
     * @private
     */ Modify2.prototype.writeGeometryCollectionGeometry_ = function(feature, geometry) {
        var geometries = geometry.getGeometriesArray();
        for(var i = 0; i < geometries.length; ++i){
            var geometry_1 = geometries[i];
            var writer = this.SEGMENT_WRITERS_[geometry_1.getType()];
            writer(feature, geometry_1);
        }
    };
    /**
     * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
     * @param {Array<import("../Feature").FeatureLike>} features The features being modified.
     * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
     * @return {Feature} Vertex feature.
     * @private
     */ Modify2.prototype.createOrUpdateVertexFeature_ = function(coordinates, features, geometries) {
        var vertexFeature = this.vertexFeature_;
        if (!vertexFeature) {
            vertexFeature = new _featureJsDefault.default(new _pointJsDefault.default(coordinates));
            this.vertexFeature_ = vertexFeature;
            this.overlay_.getSource().addFeature(vertexFeature);
        } else {
            var geometry = vertexFeature.getGeometry();
            geometry.setCoordinates(coordinates);
        }
        vertexFeature.set('features', features);
        vertexFeature.set('geometries', geometries);
        return vertexFeature;
    };
    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} and may modify the geometry.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     */ Modify2.prototype.handleEvent = function(mapBrowserEvent) {
        if (!mapBrowserEvent.originalEvent) return true;
        this.lastPointerEvent_ = mapBrowserEvent;
        var handled;
        if (!mapBrowserEvent.map.getView().getInteracting() && mapBrowserEvent.type == _mapBrowserEventTypeJsDefault.default.POINTERMOVE && !this.handlingDownUpSequence) this.handlePointerMove_(mapBrowserEvent);
        if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
            if (mapBrowserEvent.type != _mapBrowserEventTypeJsDefault.default.SINGLECLICK || !this.ignoreNextSingleClick_) handled = this.removePoint();
            else handled = true;
        }
        if (mapBrowserEvent.type == _mapBrowserEventTypeJsDefault.default.SINGLECLICK) this.ignoreNextSingleClick_ = false;
        return _super.prototype.handleEvent.call(this, mapBrowserEvent) && !handled;
    };
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} evt Event.
     */ Modify2.prototype.handleDragEvent = function(evt) {
        this.ignoreNextSingleClick_ = false;
        this.willModifyFeatures_(evt, this.dragSegments_);
        var vertex = [
            evt.coordinate[0] + this.delta_[0],
            evt.coordinate[1] + this.delta_[1], 
        ];
        var features = [];
        var geometries = [];
        for(var i = 0, ii = this.dragSegments_.length; i < ii; ++i){
            var dragSegment = this.dragSegments_[i];
            var segmentData = dragSegment[0];
            var feature = segmentData.feature;
            if (features.indexOf(feature) === -1) features.push(feature);
            var geometry = segmentData.geometry;
            if (geometries.indexOf(geometry) === -1) geometries.push(geometry);
            var depth = segmentData.depth;
            var coordinates = void 0;
            var segment = segmentData.segment;
            var index = dragSegment[1];
            while(vertex.length < geometry.getStride())vertex.push(segment[index][vertex.length]);
            switch(geometry.getType()){
                case _geometryTypeJsDefault.default.POINT:
                    coordinates = vertex;
                    segment[0] = vertex;
                    segment[1] = vertex;
                    break;
                case _geometryTypeJsDefault.default.MULTI_POINT:
                    coordinates = geometry.getCoordinates();
                    coordinates[segmentData.index] = vertex;
                    segment[0] = vertex;
                    segment[1] = vertex;
                    break;
                case _geometryTypeJsDefault.default.LINE_STRING:
                    coordinates = geometry.getCoordinates();
                    coordinates[segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case _geometryTypeJsDefault.default.MULTI_LINE_STRING:
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[0]][segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case _geometryTypeJsDefault.default.POLYGON:
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[0]][segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case _geometryTypeJsDefault.default.MULTI_POLYGON:
                    coordinates = geometry.getCoordinates();
                    coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
                    segment[index] = vertex;
                    break;
                case _geometryTypeJsDefault.default.CIRCLE:
                    segment[0] = vertex;
                    segment[1] = vertex;
                    if (segmentData.index === CIRCLE_CENTER_INDEX) {
                        this.changingFeature_ = true;
                        geometry.setCenter(vertex);
                        this.changingFeature_ = false;
                    } else {
                        // We're dragging the circle's circumference:
                        this.changingFeature_ = true;
                        var projection = evt.map.getView().getProjection();
                        var radius = _coordinateJs.distance(_projJs.fromUserCoordinate(geometry.getCenter(), projection), _projJs.fromUserCoordinate(vertex, projection));
                        var userProjection = _projJs.getUserProjection();
                        if (userProjection) {
                            var circleGeometry = geometry.clone().transform(userProjection, projection);
                            circleGeometry.setRadius(radius);
                            radius = circleGeometry.transform(projection, userProjection).getRadius();
                        }
                        geometry.setRadius(radius);
                        this.changingFeature_ = false;
                    }
                    break;
                default:
            }
            if (coordinates) this.setGeometryCoordinates_(geometry, coordinates);
        }
        this.createOrUpdateVertexFeature_(vertex, features, geometries);
    };
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} evt Event.
     * @return {boolean} If the event was consumed.
     */ Modify2.prototype.handleDownEvent = function(evt) {
        if (!this.condition_(evt)) return false;
        var pixelCoordinate = evt.coordinate;
        this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);
        this.dragSegments_.length = 0;
        this.featuresBeingModified_ = null;
        var vertexFeature = this.vertexFeature_;
        if (vertexFeature) {
            var projection = evt.map.getView().getProjection();
            var insertVertices = [];
            var vertex = vertexFeature.getGeometry().getCoordinates();
            var vertexExtent = _extentJs.boundingExtent([
                vertex
            ]);
            var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
            var componentSegments = {
            };
            segmentDataMatches.sort(compareIndexes);
            for(var i = 0, ii = segmentDataMatches.length; i < ii; ++i){
                var segmentDataMatch = segmentDataMatches[i];
                var segment = segmentDataMatch.segment;
                var uid = _utilJs.getUid(segmentDataMatch.geometry);
                var depth = segmentDataMatch.depth;
                if (depth) uid += '-' + depth.join('-'); // separate feature components
                if (!componentSegments[uid]) componentSegments[uid] = new Array(2);
                if (segmentDataMatch.geometry.getType() === _geometryTypeJsDefault.default.CIRCLE && segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                    var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch, projection);
                    if (_coordinateJs.equals(closestVertex, vertex) && !componentSegments[uid][0]) {
                        this.dragSegments_.push([
                            segmentDataMatch,
                            0
                        ]);
                        componentSegments[uid][0] = segmentDataMatch;
                    }
                    continue;
                }
                if (_coordinateJs.equals(segment[0], vertex) && !componentSegments[uid][0]) {
                    this.dragSegments_.push([
                        segmentDataMatch,
                        0
                    ]);
                    componentSegments[uid][0] = segmentDataMatch;
                    continue;
                }
                if (_coordinateJs.equals(segment[1], vertex) && !componentSegments[uid][1]) {
                    // prevent dragging closed linestrings by the connecting node
                    if ((segmentDataMatch.geometry.getType() === _geometryTypeJsDefault.default.LINE_STRING || segmentDataMatch.geometry.getType() === _geometryTypeJsDefault.default.MULTI_LINE_STRING) && componentSegments[uid][0] && componentSegments[uid][0].index === 0) continue;
                    this.dragSegments_.push([
                        segmentDataMatch,
                        1
                    ]);
                    componentSegments[uid][1] = segmentDataMatch;
                    continue;
                }
                if (_utilJs.getUid(segment) in this.vertexSegments_ && !componentSegments[uid][0] && !componentSegments[uid][1] && this.insertVertexCondition_(evt)) insertVertices.push(segmentDataMatch);
            }
            if (insertVertices.length) this.willModifyFeatures_(evt, [
                insertVertices
            ]);
            for(var j = insertVertices.length - 1; j >= 0; --j)this.insertVertex_(insertVertices[j], vertex);
        }
        return !!this.vertexFeature_;
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} evt Event.
     * @return {boolean} If the event was consumed.
     */ Modify2.prototype.handleUpEvent = function(evt) {
        for(var i = this.dragSegments_.length - 1; i >= 0; --i){
            var segmentData = this.dragSegments_[i][0];
            var geometry = segmentData.geometry;
            if (geometry.getType() === _geometryTypeJsDefault.default.CIRCLE) {
                // Update a circle object in the R* bush:
                var coordinates = geometry.getCenter();
                var centerSegmentData = segmentData.featureSegments[0];
                var circumferenceSegmentData = segmentData.featureSegments[1];
                centerSegmentData.segment[0] = coordinates;
                centerSegmentData.segment[1] = coordinates;
                circumferenceSegmentData.segment[0] = coordinates;
                circumferenceSegmentData.segment[1] = coordinates;
                this.rBush_.update(_extentJs.createOrUpdateFromCoordinate(coordinates), centerSegmentData);
                var circleGeometry = geometry;
                var userProjection = _projJs.getUserProjection();
                if (userProjection) {
                    var projection = evt.map.getView().getProjection();
                    circleGeometry = circleGeometry.clone().transform(userProjection, projection);
                    circleGeometry = _polygonJs.fromCircle(circleGeometry).transform(projection, userProjection);
                }
                this.rBush_.update(circleGeometry.getExtent(), circumferenceSegmentData);
            } else this.rBush_.update(_extentJs.boundingExtent(segmentData.segment), segmentData);
        }
        if (this.featuresBeingModified_) {
            this.dispatchEvent(new ModifyEvent1(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
            this.featuresBeingModified_ = null;
        }
        return false;
    };
    /**
     * @param {import("../MapBrowserEvent.js").default} evt Event.
     * @private
     */ Modify2.prototype.handlePointerMove_ = function(evt) {
        this.lastPixel_ = evt.pixel;
        this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);
    };
    /**
     * @param {import("../pixel.js").Pixel} pixel Pixel
     * @param {import("../PluggableMap.js").default} map Map.
     * @param {import("../coordinate.js").Coordinate} [opt_coordinate] The pixel Coordinate.
     * @private
     */ Modify2.prototype.handlePointerAtPixel_ = function(pixel, map, opt_coordinate) {
        var _this = this;
        var pixelCoordinate = opt_coordinate || map.getCoordinateFromPixel(pixel);
        var projection = map.getView().getProjection();
        var sortByDistance = function(a, b) {
            return projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) - projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection);
        };
        /** @type {Array<SegmentData>|undefined} */ var nodes;
        var hitPointGeometry;
        if (this.hitDetection_) {
            var layerFilter = typeof this.hitDetection_ === 'object' ? function(layer) {
                return layer === _this.hitDetection_;
            } : undefined;
            map.forEachFeatureAtPixel(pixel, function(feature, layer, geometry) {
                geometry = geometry || feature.getGeometry();
                if (geometry.getType() === _geometryTypeJsDefault.default.POINT && _arrayJs.includes(_this.features_.getArray(), feature)) {
                    hitPointGeometry = geometry;
                    var coordinate = geometry.getFlatCoordinates().slice(0, 2);
                    nodes = [
                        {
                            feature: feature,
                            geometry: geometry,
                            segment: [
                                coordinate,
                                coordinate
                            ]
                        }, 
                    ];
                }
                return true;
            }, {
                layerFilter: layerFilter
            });
        }
        if (!nodes) {
            var viewExtent = _projJs.fromUserExtent(_extentJs.createOrUpdateFromCoordinate(pixelCoordinate, tempExtent), projection);
            var buffer = map.getView().getResolution() * this.pixelTolerance_;
            var box = _projJs.toUserExtent(_extentJs.buffer(viewExtent, buffer, tempExtent), projection);
            nodes = this.rBush_.getInExtent(box);
        }
        if (nodes && nodes.length > 0) {
            var node = nodes.sort(sortByDistance)[0];
            var closestSegment = node.segment;
            var vertex = closestOnSegmentData(pixelCoordinate, node, projection);
            var vertexPixel = map.getPixelFromCoordinate(vertex);
            var dist = _coordinateJs.distance(pixel, vertexPixel);
            if (hitPointGeometry || dist <= this.pixelTolerance_) {
                /** @type {Object<string, boolean>} */ var vertexSegments = {
                };
                vertexSegments[_utilJs.getUid(closestSegment)] = true;
                if (!this.snapToPointer_) {
                    this.delta_[0] = vertex[0] - pixelCoordinate[0];
                    this.delta_[1] = vertex[1] - pixelCoordinate[1];
                }
                if (node.geometry.getType() === _geometryTypeJsDefault.default.CIRCLE && node.index === CIRCLE_CIRCUMFERENCE_INDEX) {
                    this.snappedToVertex_ = true;
                    this.createOrUpdateVertexFeature_(vertex, [
                        node.feature
                    ], [
                        node.geometry
                    ]);
                } else {
                    var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
                    var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
                    var squaredDist1 = _coordinateJs.squaredDistance(vertexPixel, pixel1);
                    var squaredDist2 = _coordinateJs.squaredDistance(vertexPixel, pixel2);
                    dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                    this.snappedToVertex_ = dist <= this.pixelTolerance_;
                    if (this.snappedToVertex_) vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                    this.createOrUpdateVertexFeature_(vertex, [
                        node.feature
                    ], [
                        node.geometry
                    ]);
                    var geometries = {
                    };
                    geometries[_utilJs.getUid(node.geometry)] = true;
                    for(var i = 1, ii = nodes.length; i < ii; ++i){
                        var segment = nodes[i].segment;
                        if (_coordinateJs.equals(closestSegment[0], segment[0]) && _coordinateJs.equals(closestSegment[1], segment[1]) || _coordinateJs.equals(closestSegment[0], segment[1]) && _coordinateJs.equals(closestSegment[1], segment[0])) {
                            var geometryUid = _utilJs.getUid(nodes[i].geometry);
                            if (!(geometryUid in geometries)) {
                                geometries[geometryUid] = true;
                                vertexSegments[_utilJs.getUid(segment)] = true;
                            }
                        } else break;
                    }
                }
                this.vertexSegments_ = vertexSegments;
                return;
            }
        }
        if (this.vertexFeature_) {
            this.overlay_.getSource().removeFeature(this.vertexFeature_);
            this.vertexFeature_ = null;
        }
    };
    /**
     * @param {SegmentData} segmentData Segment data.
     * @param {import("../coordinate.js").Coordinate} vertex Vertex.
     * @private
     */ Modify2.prototype.insertVertex_ = function(segmentData, vertex) {
        var segment = segmentData.segment;
        var feature = segmentData.feature;
        var geometry = segmentData.geometry;
        var depth = segmentData.depth;
        var index = segmentData.index;
        var coordinates;
        while(vertex.length < geometry.getStride())vertex.push(0);
        switch(geometry.getType()){
            case _geometryTypeJsDefault.default.MULTI_LINE_STRING:
                coordinates = geometry.getCoordinates();
                coordinates[depth[0]].splice(index + 1, 0, vertex);
                break;
            case _geometryTypeJsDefault.default.POLYGON:
                coordinates = geometry.getCoordinates();
                coordinates[depth[0]].splice(index + 1, 0, vertex);
                break;
            case _geometryTypeJsDefault.default.MULTI_POLYGON:
                coordinates = geometry.getCoordinates();
                coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
                break;
            case _geometryTypeJsDefault.default.LINE_STRING:
                coordinates = geometry.getCoordinates();
                coordinates.splice(index + 1, 0, vertex);
                break;
            default:
                return;
        }
        this.setGeometryCoordinates_(geometry, coordinates);
        var rTree = this.rBush_;
        rTree.remove(segmentData);
        this.updateSegmentIndices_(geometry, index, depth, 1);
        /** @type {SegmentData} */ var newSegmentData = {
            segment: [
                segment[0],
                vertex
            ],
            feature: feature,
            geometry: geometry,
            depth: depth,
            index: index
        };
        rTree.insert(_extentJs.boundingExtent(newSegmentData.segment), newSegmentData);
        this.dragSegments_.push([
            newSegmentData,
            1
        ]);
        /** @type {SegmentData} */ var newSegmentData2 = {
            segment: [
                vertex,
                segment[1]
            ],
            feature: feature,
            geometry: geometry,
            depth: depth,
            index: index + 1
        };
        rTree.insert(_extentJs.boundingExtent(newSegmentData2.segment), newSegmentData2);
        this.dragSegments_.push([
            newSegmentData2,
            0
        ]);
        this.ignoreNextSingleClick_ = true;
    };
    /**
     * Removes the vertex currently being pointed.
     * @return {boolean} True when a vertex was removed.
     * @api
     */ Modify2.prototype.removePoint = function() {
        if (this.lastPointerEvent_ && this.lastPointerEvent_.type != _mapBrowserEventTypeJsDefault.default.POINTERDRAG) {
            var evt = this.lastPointerEvent_;
            this.willModifyFeatures_(evt, this.dragSegments_);
            var removed = this.removeVertex_();
            this.dispatchEvent(new ModifyEvent1(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
            this.featuresBeingModified_ = null;
            return removed;
        }
        return false;
    };
    /**
     * Removes a vertex from all matching features.
     * @return {boolean} True when a vertex was removed.
     * @private
     */ Modify2.prototype.removeVertex_ = function() {
        var dragSegments = this.dragSegments_;
        var segmentsByFeature = {
        };
        var deleted = false;
        var component, coordinates, dragSegment, geometry, i, index, left;
        var newIndex, right, segmentData, uid;
        for(i = dragSegments.length - 1; i >= 0; --i){
            dragSegment = dragSegments[i];
            segmentData = dragSegment[0];
            uid = _utilJs.getUid(segmentData.feature);
            if (segmentData.depth) // separate feature components
            uid += '-' + segmentData.depth.join('-');
            if (!(uid in segmentsByFeature)) segmentsByFeature[uid] = {
            };
            if (dragSegment[1] === 0) {
                segmentsByFeature[uid].right = segmentData;
                segmentsByFeature[uid].index = segmentData.index;
            } else if (dragSegment[1] == 1) {
                segmentsByFeature[uid].left = segmentData;
                segmentsByFeature[uid].index = segmentData.index + 1;
            }
        }
        for(uid in segmentsByFeature){
            right = segmentsByFeature[uid].right;
            left = segmentsByFeature[uid].left;
            index = segmentsByFeature[uid].index;
            newIndex = index - 1;
            if (left !== undefined) segmentData = left;
            else segmentData = right;
            if (newIndex < 0) newIndex = 0;
            geometry = segmentData.geometry;
            coordinates = geometry.getCoordinates();
            component = coordinates;
            deleted = false;
            switch(geometry.getType()){
                case _geometryTypeJsDefault.default.MULTI_LINE_STRING:
                    if (coordinates[segmentData.depth[0]].length > 2) {
                        coordinates[segmentData.depth[0]].splice(index, 1);
                        deleted = true;
                    }
                    break;
                case _geometryTypeJsDefault.default.LINE_STRING:
                    if (coordinates.length > 2) {
                        coordinates.splice(index, 1);
                        deleted = true;
                    }
                    break;
                case _geometryTypeJsDefault.default.MULTI_POLYGON:
                    component = component[segmentData.depth[1]];
                /* falls through */ case _geometryTypeJsDefault.default.POLYGON:
                    component = component[segmentData.depth[0]];
                    if (component.length > 4) {
                        if (index == component.length - 1) index = 0;
                        component.splice(index, 1);
                        deleted = true;
                        if (index === 0) {
                            // close the ring again
                            component.pop();
                            component.push(component[0]);
                            newIndex = component.length - 1;
                        }
                    }
                    break;
                default:
            }
            if (deleted) {
                this.setGeometryCoordinates_(geometry, coordinates);
                var segments = [];
                if (left !== undefined) {
                    this.rBush_.remove(left);
                    segments.push(left.segment[0]);
                }
                if (right !== undefined) {
                    this.rBush_.remove(right);
                    segments.push(right.segment[1]);
                }
                if (left !== undefined && right !== undefined) {
                    /** @type {SegmentData} */ var newSegmentData = {
                        depth: segmentData.depth,
                        feature: segmentData.feature,
                        geometry: segmentData.geometry,
                        index: newIndex,
                        segment: segments
                    };
                    this.rBush_.insert(_extentJs.boundingExtent(newSegmentData.segment), newSegmentData);
                }
                this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
                if (this.vertexFeature_) {
                    this.overlay_.getSource().removeFeature(this.vertexFeature_);
                    this.vertexFeature_ = null;
                }
                dragSegments.length = 0;
            }
        }
        return deleted;
    };
    /**
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {Array} coordinates Coordinates.
     * @private
     */ Modify2.prototype.setGeometryCoordinates_ = function(geometry, coordinates) {
        this.changingFeature_ = true;
        geometry.setCoordinates(coordinates);
        this.changingFeature_ = false;
    };
    /**
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {number} index Index.
     * @param {Array<number>|undefined} depth Depth.
     * @param {number} delta Delta (1 or -1).
     * @private
     */ Modify2.prototype.updateSegmentIndices_ = function(geometry, index, depth, delta) {
        this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {
            if (segmentDataMatch.geometry === geometry && (depth === undefined || segmentDataMatch.depth === undefined || _arrayJs.equals(segmentDataMatch.depth, depth)) && segmentDataMatch.index > index) segmentDataMatch.index += delta;
        });
    };
    return Modify2;
}(_pointerJsDefault.default);
/**
 * @param {SegmentData} a The first segment data.
 * @param {SegmentData} b The second segment data.
 * @return {number} The difference in indexes.
 */ function compareIndexes(a, b) {
    return a.index - b.index;
}
/**
 * Returns the distance from a point to a line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The coordinates of the point from
 *        which to calculate the distance.
 * @param {SegmentData} segmentData The object describing the line
 *        segment we are calculating the distance to.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {number} The square of the distance between a point and a line segment.
 */ function projectedDistanceToSegmentDataSquared(pointCoordinates, segmentData, projection) {
    var geometry = segmentData.geometry;
    if (geometry.getType() === _geometryTypeJsDefault.default.CIRCLE) {
        var circleGeometry = geometry;
        if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
            var userProjection = _projJs.getUserProjection();
            if (userProjection) circleGeometry = circleGeometry.clone().transform(userProjection, projection);
            var distanceToCenterSquared = _coordinateJs.squaredDistance(circleGeometry.getCenter(), _projJs.fromUserCoordinate(pointCoordinates, projection));
            var distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
            return distanceToCircumference * distanceToCircumference;
        }
    }
    var coordinate = _projJs.fromUserCoordinate(pointCoordinates, projection);
    tempSegment[0] = _projJs.fromUserCoordinate(segmentData.segment[0], projection);
    tempSegment[1] = _projJs.fromUserCoordinate(segmentData.segment[1], projection);
    return _coordinateJs.squaredDistanceToSegment(coordinate, tempSegment);
}
/**
 * Returns the point closest to a given line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The point to which a closest point
 *        should be found.
 * @param {SegmentData} segmentData The object describing the line
 *        segment which should contain the closest point.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {import("../coordinate.js").Coordinate} The point closest to the specified line segment.
 */ function closestOnSegmentData(pointCoordinates, segmentData, projection) {
    var geometry = segmentData.geometry;
    if (geometry.getType() === _geometryTypeJsDefault.default.CIRCLE && segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
        var circleGeometry = geometry;
        var userProjection = _projJs.getUserProjection();
        if (userProjection) circleGeometry = circleGeometry.clone().transform(userProjection, projection);
        return _projJs.toUserCoordinate(circleGeometry.getClosestPoint(_projJs.fromUserCoordinate(pointCoordinates, projection)), projection);
    }
    var coordinate = _projJs.fromUserCoordinate(pointCoordinates, projection);
    tempSegment[0] = _projJs.fromUserCoordinate(segmentData.segment[0], projection);
    tempSegment[1] = _projJs.fromUserCoordinate(segmentData.segment[1], projection);
    return _projJs.toUserCoordinate(_coordinateJs.closestOnSegment(coordinate, tempSegment), projection);
}
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */ function getDefaultStyleFunction() {
    var style = _styleJs.createEditingStyle();
    return function(feature, resolution) {
        return style[_geometryTypeJsDefault.default.POINT];
    };
}
exports.default = Modify1;

},{"../Collection.js":"d2f3b","../CollectionEventType.js":"jxyhy","../events/Event.js":"7AR9n","../events/EventType.js":"83vee","../Feature.js":"75Tk1","../geom/GeometryType.js":"3sRlw","../MapBrowserEventType.js":"coXRZ","../geom/Point.js":"4ReTD","./Pointer.js":"iatpc","../structs/RBush.js":"l9R2P","../source/VectorEventType.js":"hswmg","../layer/Vector.js":"2qjJV","../source/Vector.js":"lTwzQ","../events/condition.js":"eCqyb","../extent.js":"jgUz2","../coordinate.js":"cmApa","../style/Style.js":"9N9zp","../array.js":"jKNP0","../geom/Polygon.js":"hoOc8","../proj.js":"hmdWM","../util.js":"9zOhk","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"bMXNv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SelectEvent", ()=>SelectEvent1
);
/**
 * @module ol/interaction/Select
 */ var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _collectionEventTypeJs = require("../CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _geometryTypeJs = require("../geom/GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _interactionJs = require("./Interaction.js");
var _interactionJsDefault = parcelHelpers.interopDefault(_interactionJs);
var _functionsJs = require("../functions.js");
var _objJs = require("../obj.js");
var _styleJs = require("../style/Style.js");
var _arrayJs = require("../array.js");
var _utilJs = require("../util.js");
var _conditionJs = require("../events/condition.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @enum {string}
 */ var SelectEventType = {
    /**
     * Triggered when feature(s) has been (de)selected.
     * @event SelectEvent#select
     * @api
     */ SELECT: 'select'
};
/**
 * A function that takes an {@link module:ol/Feature} or
 * {@link module:ol/render/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default<import("../source/Source").default>):boolean} FilterFunction
 */ /**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [addCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition.never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is the event
 * for the selected features as a whole. By default, this is
 * {@link module:ol/events/condition.singleClick}. Clicking on a feature selects that
 * feature and removes any that were in the selection. Clicking outside any
 * feature removes all from the selection.
 * See `toggle`, `add`, `remove` options for adding/removing extra features to/
 * from the selection.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} [layers]
 * A list of layers from which features should be selected. Alternatively, a
 * filter function can be provided. The function will be called for each layer
 * in the map and should return `true` for layers that you want to be
 * selectable. If the option is absent, all visible layers will be considered
 * selectable.
 * @property {import("../style/Style.js").StyleLike|null} [style]
 * Style for the selected features. By default the default edit style is used
 * (see {@link module:ol/style}). Set to `null` if this interaction should not apply
 * any style changes for selected features.
 * If set to a falsey value, the selected feature's style will not change.
 * @property {import("../events/condition.js").Condition} [removeCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition.never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [toggleCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is in addition
 * to the `condition` event. By default,
 * {@link module:ol/events/condition.shiftKeyOnly}, i.e. pressing `shift` as
 * well as the `condition` event, adds that feature to the current selection if
 * it is not currently selected, and removes it if it is. See `add` and `remove`
 * if you want to use different events instead of a toggle.
 * @property {boolean} [multi=false] A boolean that determines if the default
 * behaviour should select only single features or all (overlapping) features at
 * the clicked map position. The default of `false` means single select.
 * @property {import("../Collection.js").default<import("../Feature.js").default>} [features]
 * Collection where the interaction will place selected features. Optional. If
 * not set the interaction will create a collection. In any case the collection
 * used by the interaction is returned by
 * {@link module:ol/interaction/Select~Select#getFeatures}.
 * @property {FilterFunction} [filter] A function
 * that takes an {@link module:ol/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside
 * the radius around the given position will be checked for features.
 */ /**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of
 * this type.
 */ var SelectEvent1 = function(_super) {
    __extends(SelectEvent2, _super);
    /**
     * @param {SelectEventType} type The event type.
     * @param {Array<import("../Feature.js").default>} selected Selected features.
     * @param {Array<import("../Feature.js").default>} deselected Deselected features.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
     *     {@link module:ol/MapBrowserEvent}.
     */ function SelectEvent2(type, selected, deselected, mapBrowserEvent) {
        var _this = _super.call(this, type) || this;
        /**
         * Selected features array.
         * @type {Array<import("../Feature.js").default>}
         * @api
         */ _this.selected = selected;
        /**
         * Deselected features array.
         * @type {Array<import("../Feature.js").default>}
         * @api
         */ _this.deselected = deselected;
        /**
         * Associated {@link module:ol/MapBrowserEvent}.
         * @type {import("../MapBrowserEvent.js").default}
         * @api
         */ _this.mapBrowserEvent = mapBrowserEvent;
        return _this;
    }
    return SelectEvent2;
}(_eventJsDefault.default);
/**
 * Original feature styles to reset to when features are no longer selected.
 * @type {Object<number, import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction>}
 */ var originalFeatureStyles = {
};
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'select', SelectEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'select', Return>} SelectOnSignature
 */ /**
 * @classdesc
 * Interaction for selecting vector features. By default, selected features are
 * styled differently, so this interaction can be used for visual highlighting,
 * as well as selecting features for other actions, such as modification or
 * output. There are three ways of controlling which features are selected:
 * using the browser event as defined by the `condition` and optionally the
 * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
 * further feature filter using the `filter` option.
 *
 * @fires SelectEvent
 * @api
 */ var Select1 = function(_super) {
    __extends(Select2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function Select2(opt_options) {
        var _this = _super.call(this) || this;
        /***
         * @type {SelectOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {SelectOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {SelectOnSignature<void>}
         */ _this.un;
        var options = opt_options ? opt_options : {
        };
        /**
         * @private
         */ _this.boundAddFeature_ = _this.addFeature_.bind(_this);
        /**
         * @private
         */ _this.boundRemoveFeature_ = _this.removeFeature_.bind(_this);
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.condition_ = options.condition ? options.condition : _conditionJs.singleClick;
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.addCondition_ = options.addCondition ? options.addCondition : _conditionJs.never;
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.removeCondition_ = options.removeCondition ? options.removeCondition : _conditionJs.never;
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : _conditionJs.shiftKeyOnly;
        /**
         * @private
         * @type {boolean}
         */ _this.multi_ = options.multi ? options.multi : false;
        /**
         * @private
         * @type {FilterFunction}
         */ _this.filter_ = options.filter ? options.filter : _functionsJs.TRUE;
        /**
         * @private
         * @type {number}
         */ _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
        /**
         * @private
         * @type {import("../style/Style.js").default|Array<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null}
         */ _this.style_ = options.style !== undefined ? options.style : getDefaultStyleFunction();
        /**
         * @private
         * @type {import("../Collection.js").default}
         */ _this.features_ = options.features || new _collectionJsDefault.default();
        /** @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} */ var layerFilter;
        if (options.layers) {
            if (typeof options.layers === 'function') layerFilter = options.layers;
            else {
                var layers_1 = options.layers;
                layerFilter = function(layer) {
                    return _arrayJs.includes(layers_1, layer);
                };
            }
        } else layerFilter = _functionsJs.TRUE;
        /**
         * @private
         * @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean}
         */ _this.layerFilter_ = layerFilter;
        /**
         * An association between selected feature (key)
         * and layer (value)
         * @private
         * @type {Object<string, import("../layer/Layer.js").default>}
         */ _this.featureLayerAssociation_ = {
        };
        return _this;
    }
    /**
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @private
     */ Select2.prototype.addFeatureLayerAssociation_ = function(feature, layer) {
        this.featureLayerAssociation_[_utilJs.getUid(feature)] = layer;
    };
    /**
     * Get the selected features.
     * @return {import("../Collection.js").default<import("../Feature.js").default>} Features collection.
     * @api
     */ Select2.prototype.getFeatures = function() {
        return this.features_;
    };
    /**
     * Returns the Hit-detection tolerance.
     * @return {number} Hit tolerance in pixels.
     * @api
     */ Select2.prototype.getHitTolerance = function() {
        return this.hitTolerance_;
    };
    /**
     * Returns the associated {@link module:ol/layer/Vector~Vector vectorlayer} of
     * the (last) selected feature. Note that this will not work with any
     * programmatic method like pushing features to
     * {@link module:ol/interaction/Select~Select#getFeatures collection}.
     * @param {import("../Feature.js").FeatureLike} feature Feature
     * @return {import('../layer/Vector.js').default} Layer.
     * @api
     */ Select2.prototype.getLayer = function(feature) {
        return this.featureLayerAssociation_[_utilJs.getUid(feature)];
    };
    /**
     * Hit-detection tolerance. Pixels inside the radius around the given position
     * will be checked for features.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @api
     */ Select2.prototype.setHitTolerance = function(hitTolerance) {
        this.hitTolerance_ = hitTolerance;
    };
    /**
     * Remove the interaction from its current map, if any,  and attach it to a new
     * map, if any. Pass `null` to just remove the interaction from the current map.
     * @param {import("../PluggableMap.js").default} map Map.
     * @api
     */ Select2.prototype.setMap = function(map) {
        var currentMap = this.getMap();
        if (currentMap && this.style_) this.features_.forEach(this.restorePreviousStyle_.bind(this));
        _super.prototype.setMap.call(this, map);
        if (map) {
            this.features_.addEventListener(_collectionEventTypeJsDefault.default.ADD, this.boundAddFeature_);
            this.features_.addEventListener(_collectionEventTypeJsDefault.default.REMOVE, this.boundRemoveFeature_);
            if (this.style_) this.features_.forEach(this.applySelectedStyle_.bind(this));
        } else {
            this.features_.removeEventListener(_collectionEventTypeJsDefault.default.ADD, this.boundAddFeature_);
            this.features_.removeEventListener(_collectionEventTypeJsDefault.default.REMOVE, this.boundRemoveFeature_);
        }
    };
    /**
     * @param {import("../Collection.js").CollectionEvent} evt Event.
     * @private
     */ Select2.prototype.addFeature_ = function(evt) {
        var feature = evt.element;
        if (this.style_) this.applySelectedStyle_(feature);
    };
    /**
     * @param {import("../Collection.js").CollectionEvent} evt Event.
     * @private
     */ Select2.prototype.removeFeature_ = function(evt) {
        var feature = evt.element;
        if (this.style_) this.restorePreviousStyle_(feature);
    };
    /**
     * @return {import("../style/Style.js").StyleLike|null} Select style.
     */ Select2.prototype.getStyle = function() {
        return this.style_;
    };
    /**
     * @param {import("../Feature.js").default} feature Feature
     * @private
     */ Select2.prototype.applySelectedStyle_ = function(feature) {
        var key = _utilJs.getUid(feature);
        if (!(key in originalFeatureStyles)) originalFeatureStyles[key] = feature.getStyle();
        feature.setStyle(this.style_);
    };
    /**
     * @param {import("../Feature.js").default} feature Feature
     * @private
     */ Select2.prototype.restorePreviousStyle_ = function(feature) {
        var interactions = this.getMap().getInteractions().getArray();
        for(var i = interactions.length - 1; i >= 0; --i){
            var interaction = interactions[i];
            if (interaction !== this && interaction instanceof Select2 && interaction.getStyle() && interaction.getFeatures().getArray().lastIndexOf(feature) !== -1) {
                feature.setStyle(interaction.getStyle());
                return;
            }
        }
        var key = _utilJs.getUid(feature);
        feature.setStyle(originalFeatureStyles[key]);
        delete originalFeatureStyles[key];
    };
    /**
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @private
     */ Select2.prototype.removeFeatureLayerAssociation_ = function(feature) {
        delete this.featureLayerAssociation_[_utilJs.getUid(feature)];
    };
    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} and may change the
     * selected state of features.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @this {Select}
     */ Select2.prototype.handleEvent = function(mapBrowserEvent) {
        if (!this.condition_(mapBrowserEvent)) return true;
        var add = this.addCondition_(mapBrowserEvent);
        var remove = this.removeCondition_(mapBrowserEvent);
        var toggle = this.toggleCondition_(mapBrowserEvent);
        var set = !add && !remove && !toggle;
        var map = mapBrowserEvent.map;
        var features = this.getFeatures();
        var deselected = [];
        var selected = [];
        if (set) {
            // Replace the currently selected feature(s) with the feature(s) at the
            // pixel, or clear the selected feature(s) if there is no feature at
            // the pixel.
            _objJs.clear(this.featureLayerAssociation_);
            map.forEachFeatureAtPixel(mapBrowserEvent.pixel, /**
             * @param {import("../Feature.js").FeatureLike} feature Feature.
             * @param {import("../layer/Layer.js").default} layer Layer.
             * @return {boolean|undefined} Continue to iterate over the features.
             */ (function(feature, layer) {
                if (this.filter_(feature, layer)) {
                    selected.push(feature);
                    this.addFeatureLayerAssociation_(feature, layer);
                    return !this.multi_;
                }
            }).bind(this), {
                layerFilter: this.layerFilter_,
                hitTolerance: this.hitTolerance_
            });
            for(var i = features.getLength() - 1; i >= 0; --i){
                var feature = features.item(i);
                var index = selected.indexOf(feature);
                if (index > -1) // feature is already selected
                selected.splice(index, 1);
                else {
                    features.remove(feature);
                    deselected.push(feature);
                }
            }
            if (selected.length !== 0) features.extend(selected);
        } else {
            // Modify the currently selected feature(s).
            map.forEachFeatureAtPixel(mapBrowserEvent.pixel, /**
             * @param {import("../Feature.js").FeatureLike} feature Feature.
             * @param {import("../layer/Layer.js").default} layer Layer.
             * @return {boolean|undefined} Continue to iterate over the features.
             */ (function(feature, layer) {
                if (this.filter_(feature, layer)) {
                    if ((add || toggle) && !_arrayJs.includes(features.getArray(), feature)) {
                        selected.push(feature);
                        this.addFeatureLayerAssociation_(feature, layer);
                    } else if ((remove || toggle) && _arrayJs.includes(features.getArray(), feature)) {
                        deselected.push(feature);
                        this.removeFeatureLayerAssociation_(feature);
                    }
                    return !this.multi_;
                }
            }).bind(this), {
                layerFilter: this.layerFilter_,
                hitTolerance: this.hitTolerance_
            });
            for(var j = deselected.length - 1; j >= 0; --j)features.remove(deselected[j]);
            features.extend(selected);
        }
        if (selected.length > 0 || deselected.length > 0) this.dispatchEvent(new SelectEvent1(SelectEventType.SELECT, selected, deselected, mapBrowserEvent));
        return true;
    };
    return Select2;
}(_interactionJsDefault.default);
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */ function getDefaultStyleFunction() {
    var styles = _styleJs.createEditingStyle();
    _arrayJs.extend(styles[_geometryTypeJsDefault.default.POLYGON], styles[_geometryTypeJsDefault.default.LINE_STRING]);
    _arrayJs.extend(styles[_geometryTypeJsDefault.default.GEOMETRY_COLLECTION], styles[_geometryTypeJsDefault.default.LINE_STRING]);
    return function(feature) {
        if (!feature.getGeometry()) return null;
        return styles[feature.getGeometry().getType()];
    };
}
exports.default = Select1;

},{"../Collection.js":"d2f3b","../CollectionEventType.js":"jxyhy","../events/Event.js":"7AR9n","../geom/GeometryType.js":"3sRlw","./Interaction.js":"dRzfo","../functions.js":"d72zA","../obj.js":"g3fPg","../style/Style.js":"9N9zp","../array.js":"jKNP0","../util.js":"9zOhk","../events/condition.js":"eCqyb","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"7zWYD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/interaction/Snap
 */ var _collectionEventTypeJs = require("../CollectionEventType.js");
var _collectionEventTypeJsDefault = parcelHelpers.interopDefault(_collectionEventTypeJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _geometryTypeJs = require("../geom/GeometryType.js");
var _geometryTypeJsDefault = parcelHelpers.interopDefault(_geometryTypeJs);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _rbushJs = require("../structs/RBush.js");
var _rbushJsDefault = parcelHelpers.interopDefault(_rbushJs);
var _vectorEventTypeJs = require("../source/VectorEventType.js");
var _vectorEventTypeJsDefault = parcelHelpers.interopDefault(_vectorEventTypeJs);
var _functionsJs = require("../functions.js");
var _extentJs = require("../extent.js");
var _coordinateJs = require("../coordinate.js");
var _polygonJs = require("../geom/Polygon.js");
var _projJs = require("../proj.js");
var _utilJs = require("../util.js");
var _objJs = require("../obj.js");
var _eventsJs = require("../events.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Result
 * @property {boolean} snapped Snapped.
 * @property {import("../coordinate.js").Coordinate|null} vertex Vertex.
 * @property {import("../pixel.js").Pixel|null} vertexPixel VertexPixel.
 */ /**
 * @typedef {Object} SegmentData
 * @property {import("../Feature.js").default} feature Feature.
 * @property {Array<import("../coordinate.js").Coordinate>} segment Segment.
 */ /**
 * @typedef {Object} Options
 * @property {import("../Collection.js").default<import("../Feature.js").default>} [features] Snap to these features. Either this option or source should be provided.
 * @property {boolean} [edge=true] Snap to edges.
 * @property {boolean} [vertex=true] Snap to vertices.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or
 * vertex for snapping.
 * @property {import("../source/Vector.js").default} [source] Snap to features from this source. Either this option or features should be provided
 */ /**
 * @param  {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
 * @return {import("../Feature.js").default} Feature.
 */ function getFeatureFromEvent(evt) {
    if (/** @type {import("../source/Vector.js").VectorSourceEvent} */ evt.feature) return(/** @type {import("../source/Vector.js").VectorSourceEvent} */ evt.feature);
    else if (/** @type {import("../Collection.js").CollectionEvent} */ evt.element) return(/** @type {import("../Collection.js").CollectionEvent} */ evt.element);
}
var tempSegment = [];
/**
 * @classdesc
 * Handles snapping of vector features while modifying or drawing them.  The
 * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}
 * Any interaction object that allows the user to interact
 * with the features using the mouse can benefit from the snapping, as long
 * as it is added before.
 *
 * The snap interaction modifies map browser event `coordinate` and `pixel`
 * properties to force the snap to occur to any interaction that them.
 *
 * Example:
 *
 *     import Snap from 'ol/interaction/Snap';
 *
 *     const snap = new Snap({
 *       source: source
 *     });
 *
 *     map.addInteraction(snap);
 *
 * @api
 */ var Snap1 = function(_super) {
    __extends(Snap2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function Snap2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        var pointerOptions = options;
        if (!pointerOptions.handleDownEvent) pointerOptions.handleDownEvent = _functionsJs.TRUE;
        if (!pointerOptions.stopDown) pointerOptions.stopDown = _functionsJs.FALSE;
        _this = _super.call(this, pointerOptions) || this;
        /**
         * @type {import("../source/Vector.js").default}
         * @private
         */ _this.source_ = options.source ? options.source : null;
        /**
         * @private
         * @type {boolean}
         */ _this.vertex_ = options.vertex !== undefined ? options.vertex : true;
        /**
         * @private
         * @type {boolean}
         */ _this.edge_ = options.edge !== undefined ? options.edge : true;
        /**
         * @type {import("../Collection.js").default<import("../Feature.js").default>}
         * @private
         */ _this.features_ = options.features ? options.features : null;
        /**
         * @type {Array<import("../events.js").EventsKey>}
         * @private
         */ _this.featuresListenerKeys_ = [];
        /**
         * @type {Object<string, import("../events.js").EventsKey>}
         * @private
         */ _this.featureChangeListenerKeys_ = {
        };
        /**
         * Extents are preserved so indexed segment can be quickly removed
         * when its feature geometry changes
         * @type {Object<string, import("../extent.js").Extent>}
         * @private
         */ _this.indexedFeaturesExtents_ = {
        };
        /**
         * If a feature geometry changes while a pointer drag|move event occurs, the
         * feature doesn't get updated right away.  It will be at the next 'pointerup'
         * event fired.
         * @type {!Object<string, import("../Feature.js").default>}
         * @private
         */ _this.pendingFeatures_ = {
        };
        /**
         * @type {number}
         * @private
         */ _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
        /**
         * Segment RTree for each layer
         * @type {import("../structs/RBush.js").default<SegmentData>}
         * @private
         */ _this.rBush_ = new _rbushJsDefault.default();
        /**
         * @const
         * @private
         * @type {Object<string, function(import("../Feature.js").default, import("../geom/Geometry.js").default): void>}
         */ _this.SEGMENT_WRITERS_ = {
            'Point': _this.writePointGeometry_.bind(_this),
            'LineString': _this.writeLineStringGeometry_.bind(_this),
            'LinearRing': _this.writeLineStringGeometry_.bind(_this),
            'Polygon': _this.writePolygonGeometry_.bind(_this),
            'MultiPoint': _this.writeMultiPointGeometry_.bind(_this),
            'MultiLineString': _this.writeMultiLineStringGeometry_.bind(_this),
            'MultiPolygon': _this.writeMultiPolygonGeometry_.bind(_this),
            'GeometryCollection': _this.writeGeometryCollectionGeometry_.bind(_this),
            'Circle': _this.writeCircleGeometry_.bind(_this)
        };
        return _this;
    }
    /**
     * Add a feature to the collection of features that we may snap to.
     * @param {import("../Feature.js").default} feature Feature.
     * @param {boolean} [opt_listen] Whether to listen to the feature change or not
     *     Defaults to `true`.
     * @api
     */ Snap2.prototype.addFeature = function(feature, opt_listen) {
        var register = opt_listen !== undefined ? opt_listen : true;
        var feature_uid = _utilJs.getUid(feature);
        var geometry = feature.getGeometry();
        if (geometry) {
            var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];
            if (segmentWriter) {
                this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(_extentJs.createEmpty());
                segmentWriter(feature, geometry);
            }
        }
        if (register) this.featureChangeListenerKeys_[feature_uid] = _eventsJs.listen(feature, _eventTypeJsDefault.default.CHANGE, this.handleFeatureChange_, this);
    };
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @private
     */ Snap2.prototype.forEachFeatureAdd_ = function(feature) {
        this.addFeature(feature);
    };
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @private
     */ Snap2.prototype.forEachFeatureRemove_ = function(feature) {
        this.removeFeature(feature);
    };
    /**
     * @return {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} Features.
     * @private
     */ Snap2.prototype.getFeatures_ = function() {
        var features;
        if (this.features_) features = this.features_;
        else if (this.source_) features = this.source_.getFeatures();
        return features;
    };
    /**
     * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
     * @return {boolean} `false` to stop event propagation.
     */ Snap2.prototype.handleEvent = function(evt) {
        var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);
        if (result.snapped) {
            evt.coordinate = result.vertex.slice(0, 2);
            evt.pixel = result.vertexPixel;
        }
        return _super.prototype.handleEvent.call(this, evt);
    };
    /**
     * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
     * @private
     */ Snap2.prototype.handleFeatureAdd_ = function(evt) {
        var feature = getFeatureFromEvent(evt);
        this.addFeature(feature);
    };
    /**
     * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
     * @private
     */ Snap2.prototype.handleFeatureRemove_ = function(evt) {
        var feature = getFeatureFromEvent(evt);
        this.removeFeature(feature);
    };
    /**
     * @param {import("../events/Event.js").default} evt Event.
     * @private
     */ Snap2.prototype.handleFeatureChange_ = function(evt) {
        var feature = evt.target;
        if (this.handlingDownUpSequence) {
            var uid = _utilJs.getUid(feature);
            if (!(uid in this.pendingFeatures_)) this.pendingFeatures_[uid] = feature;
        } else this.updateFeature_(feature);
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} evt Event.
     * @return {boolean} If the event was consumed.
     */ Snap2.prototype.handleUpEvent = function(evt) {
        var featuresToUpdate = _objJs.getValues(this.pendingFeatures_);
        if (featuresToUpdate.length) {
            featuresToUpdate.forEach(this.updateFeature_.bind(this));
            this.pendingFeatures_ = {
            };
        }
        return false;
    };
    /**
     * Remove a feature from the collection of features that we may snap to.
     * @param {import("../Feature.js").default} feature Feature
     * @param {boolean} [opt_unlisten] Whether to unlisten to the feature change
     *     or not. Defaults to `true`.
     * @api
     */ Snap2.prototype.removeFeature = function(feature, opt_unlisten) {
        var unregister = opt_unlisten !== undefined ? opt_unlisten : true;
        var feature_uid = _utilJs.getUid(feature);
        var extent = this.indexedFeaturesExtents_[feature_uid];
        if (extent) {
            var rBush = this.rBush_;
            var nodesToRemove_1 = [];
            rBush.forEachInExtent(extent, function(node) {
                if (feature === node.feature) nodesToRemove_1.push(node);
            });
            for(var i = nodesToRemove_1.length - 1; i >= 0; --i)rBush.remove(nodesToRemove_1[i]);
        }
        if (unregister) {
            _eventsJs.unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);
            delete this.featureChangeListenerKeys_[feature_uid];
        }
    };
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default} map Map.
     */ Snap2.prototype.setMap = function(map) {
        var currentMap = this.getMap();
        var keys = this.featuresListenerKeys_;
        var features = this.getFeatures_();
        if (currentMap) {
            keys.forEach(_eventsJs.unlistenByKey);
            keys.length = 0;
            features.forEach(this.forEachFeatureRemove_.bind(this));
        }
        _super.prototype.setMap.call(this, map);
        if (map) {
            if (this.features_) keys.push(_eventsJs.listen(this.features_, _collectionEventTypeJsDefault.default.ADD, this.handleFeatureAdd_, this), _eventsJs.listen(this.features_, _collectionEventTypeJsDefault.default.REMOVE, this.handleFeatureRemove_, this));
            else if (this.source_) keys.push(_eventsJs.listen(this.source_, _vectorEventTypeJsDefault.default.ADDFEATURE, this.handleFeatureAdd_, this), _eventsJs.listen(this.source_, _vectorEventTypeJsDefault.default.REMOVEFEATURE, this.handleFeatureRemove_, this));
            features.forEach(this.forEachFeatureAdd_.bind(this));
        }
    };
    /**
     * @param {import("../pixel.js").Pixel} pixel Pixel
     * @param {import("../coordinate.js").Coordinate} pixelCoordinate Coordinate
     * @param {import("../PluggableMap.js").default} map Map.
     * @return {Result} Snap result
     */ Snap2.prototype.snapTo = function(pixel, pixelCoordinate, map) {
        var lowerLeft = map.getCoordinateFromPixel([
            pixel[0] - this.pixelTolerance_,
            pixel[1] + this.pixelTolerance_, 
        ]);
        var upperRight = map.getCoordinateFromPixel([
            pixel[0] + this.pixelTolerance_,
            pixel[1] - this.pixelTolerance_, 
        ]);
        var box = _extentJs.boundingExtent([
            lowerLeft,
            upperRight
        ]);
        var segments = this.rBush_.getInExtent(box);
        // If snapping on vertices only, don't consider circles
        if (this.vertex_ && !this.edge_) segments = segments.filter(function(segment) {
            return segment.feature.getGeometry().getType() !== _geometryTypeJsDefault.default.CIRCLE;
        });
        var snapped = false;
        var vertex = null;
        var vertexPixel = null;
        if (segments.length === 0) return {
            snapped: snapped,
            vertex: vertex,
            vertexPixel: vertexPixel
        };
        var projection = map.getView().getProjection();
        var projectedCoordinate = _projJs.fromUserCoordinate(pixelCoordinate, projection);
        var closestSegmentData;
        var minSquaredDistance = Infinity;
        for(var i = 0; i < segments.length; ++i){
            var segmentData = segments[i];
            tempSegment[0] = _projJs.fromUserCoordinate(segmentData.segment[0], projection);
            tempSegment[1] = _projJs.fromUserCoordinate(segmentData.segment[1], projection);
            var delta = _coordinateJs.squaredDistanceToSegment(projectedCoordinate, tempSegment);
            if (delta < minSquaredDistance) {
                closestSegmentData = segmentData;
                minSquaredDistance = delta;
            }
        }
        var closestSegment = closestSegmentData.segment;
        if (this.vertex_ && !this.edge_) {
            var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
            var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
            var squaredDist1 = _coordinateJs.squaredDistance(pixel, pixel1);
            var squaredDist2 = _coordinateJs.squaredDistance(pixel, pixel2);
            var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
            if (dist <= this.pixelTolerance_) {
                snapped = true;
                vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                vertexPixel = map.getPixelFromCoordinate(vertex);
            }
        } else if (this.edge_) {
            var isCircle = closestSegmentData.feature.getGeometry().getType() === _geometryTypeJsDefault.default.CIRCLE;
            if (isCircle) {
                var circleGeometry = closestSegmentData.feature.getGeometry();
                var userProjection = _projJs.getUserProjection();
                if (userProjection) circleGeometry = circleGeometry.clone().transform(userProjection, projection);
                vertex = _projJs.toUserCoordinate(_coordinateJs.closestOnCircle(projectedCoordinate, circleGeometry), projection);
            } else {
                tempSegment[0] = _projJs.fromUserCoordinate(closestSegment[0], projection);
                tempSegment[1] = _projJs.fromUserCoordinate(closestSegment[1], projection);
                vertex = _projJs.toUserCoordinate(_coordinateJs.closestOnSegment(projectedCoordinate, tempSegment), projection);
            }
            vertexPixel = map.getPixelFromCoordinate(vertex);
            if (_coordinateJs.distance(pixel, vertexPixel) <= this.pixelTolerance_) {
                snapped = true;
                if (this.vertex_ && !isCircle) {
                    var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
                    var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
                    var squaredDist1 = _coordinateJs.squaredDistance(vertexPixel, pixel1);
                    var squaredDist2 = _coordinateJs.squaredDistance(vertexPixel, pixel2);
                    var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                    if (dist <= this.pixelTolerance_) {
                        vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                        vertexPixel = map.getPixelFromCoordinate(vertex);
                    }
                }
            }
        }
        if (snapped) vertexPixel = [
            Math.round(vertexPixel[0]),
            Math.round(vertexPixel[1])
        ];
        return {
            snapped: snapped,
            vertex: vertex,
            vertexPixel: vertexPixel
        };
    };
    /**
     * @param {import("../Feature.js").default} feature Feature
     * @private
     */ Snap2.prototype.updateFeature_ = function(feature) {
        this.removeFeature(feature, false);
        this.addFeature(feature, false);
    };
    /**
     * @param {import("../Feature.js").default} feature Feature
     * @param {import("../geom/Circle.js").default} geometry Geometry.
     * @private
     */ Snap2.prototype.writeCircleGeometry_ = function(feature, geometry) {
        var projection = this.getMap().getView().getProjection();
        var circleGeometry = geometry;
        var userProjection = _projJs.getUserProjection();
        if (userProjection) circleGeometry = circleGeometry.clone().transform(userProjection, projection);
        var polygon = _polygonJs.fromCircle(circleGeometry);
        if (userProjection) polygon.transform(projection, userProjection);
        var coordinates = polygon.getCoordinates()[0];
        for(var i = 0, ii = coordinates.length - 1; i < ii; ++i){
            var segment = coordinates.slice(i, i + 2);
            var segmentData = {
                feature: feature,
                segment: segment
            };
            this.rBush_.insert(_extentJs.boundingExtent(segment), segmentData);
        }
    };
    /**
     * @param {import("../Feature.js").default} feature Feature
     * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
     * @private
     */ Snap2.prototype.writeGeometryCollectionGeometry_ = function(feature, geometry) {
        var geometries = geometry.getGeometriesArray();
        for(var i = 0; i < geometries.length; ++i){
            var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];
            if (segmentWriter) segmentWriter(feature, geometries[i]);
        }
    };
    /**
     * @param {import("../Feature.js").default} feature Feature
     * @param {import("../geom/LineString.js").default} geometry Geometry.
     * @private
     */ Snap2.prototype.writeLineStringGeometry_ = function(feature, geometry) {
        var coordinates = geometry.getCoordinates();
        for(var i = 0, ii = coordinates.length - 1; i < ii; ++i){
            var segment = coordinates.slice(i, i + 2);
            var segmentData = {
                feature: feature,
                segment: segment
            };
            this.rBush_.insert(_extentJs.boundingExtent(segment), segmentData);
        }
    };
    /**
     * @param {import("../Feature.js").default} feature Feature
     * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
     * @private
     */ Snap2.prototype.writeMultiLineStringGeometry_ = function(feature, geometry) {
        var lines = geometry.getCoordinates();
        for(var j = 0, jj = lines.length; j < jj; ++j){
            var coordinates = lines[j];
            for(var i = 0, ii = coordinates.length - 1; i < ii; ++i){
                var segment = coordinates.slice(i, i + 2);
                var segmentData = {
                    feature: feature,
                    segment: segment
                };
                this.rBush_.insert(_extentJs.boundingExtent(segment), segmentData);
            }
        }
    };
    /**
     * @param {import("../Feature.js").default} feature Feature
     * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
     * @private
     */ Snap2.prototype.writeMultiPointGeometry_ = function(feature, geometry) {
        var points = geometry.getCoordinates();
        for(var i = 0, ii = points.length; i < ii; ++i){
            var coordinates = points[i];
            var segmentData = {
                feature: feature,
                segment: [
                    coordinates,
                    coordinates
                ]
            };
            this.rBush_.insert(geometry.getExtent(), segmentData);
        }
    };
    /**
     * @param {import("../Feature.js").default} feature Feature
     * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
     * @private
     */ Snap2.prototype.writeMultiPolygonGeometry_ = function(feature, geometry) {
        var polygons = geometry.getCoordinates();
        for(var k = 0, kk = polygons.length; k < kk; ++k){
            var rings = polygons[k];
            for(var j = 0, jj = rings.length; j < jj; ++j){
                var coordinates = rings[j];
                for(var i = 0, ii = coordinates.length - 1; i < ii; ++i){
                    var segment = coordinates.slice(i, i + 2);
                    var segmentData = {
                        feature: feature,
                        segment: segment
                    };
                    this.rBush_.insert(_extentJs.boundingExtent(segment), segmentData);
                }
            }
        }
    };
    /**
     * @param {import("../Feature.js").default} feature Feature
     * @param {import("../geom/Point.js").default} geometry Geometry.
     * @private
     */ Snap2.prototype.writePointGeometry_ = function(feature, geometry) {
        var coordinates = geometry.getCoordinates();
        var segmentData = {
            feature: feature,
            segment: [
                coordinates,
                coordinates
            ]
        };
        this.rBush_.insert(geometry.getExtent(), segmentData);
    };
    /**
     * @param {import("../Feature.js").default} feature Feature
     * @param {import("../geom/Polygon.js").default} geometry Geometry.
     * @private
     */ Snap2.prototype.writePolygonGeometry_ = function(feature, geometry) {
        var rings = geometry.getCoordinates();
        for(var j = 0, jj = rings.length; j < jj; ++j){
            var coordinates = rings[j];
            for(var i = 0, ii = coordinates.length - 1; i < ii; ++i){
                var segment = coordinates.slice(i, i + 2);
                var segmentData = {
                    feature: feature,
                    segment: segment
                };
                this.rBush_.insert(_extentJs.boundingExtent(segment), segmentData);
            }
        }
    };
    return Snap2;
}(_pointerJsDefault.default);
exports.default = Snap1;

},{"../CollectionEventType.js":"jxyhy","../events/EventType.js":"83vee","../geom/GeometryType.js":"3sRlw","./Pointer.js":"iatpc","../structs/RBush.js":"l9R2P","../source/VectorEventType.js":"hswmg","../functions.js":"d72zA","../extent.js":"jgUz2","../coordinate.js":"cmApa","../geom/Polygon.js":"hoOc8","../proj.js":"hmdWM","../util.js":"9zOhk","../obj.js":"g3fPg","../events.js":"e9Qqr","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"kfbdg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TranslateEvent", ()=>TranslateEvent1
);
/**
 * @module ol/interaction/Translate
 */ var _collectionJs = require("../Collection.js");
var _collectionJsDefault = parcelHelpers.interopDefault(_collectionJs);
var _eventJs = require("../events/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _propertyJs = require("./Property.js");
var _propertyJsDefault = parcelHelpers.interopDefault(_propertyJs);
var _pointerJs = require("./Pointer.js");
var _pointerJsDefault = parcelHelpers.interopDefault(_pointerJs);
var _functionsJs = require("../functions.js");
var _conditionJs = require("../events/condition.js");
var _arrayJs = require("../array.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @enum {string}
 */ var TranslateEventType = {
    /**
     * Triggered upon feature translation start.
     * @event TranslateEvent#translatestart
     * @api
     */ TRANSLATESTART: 'translatestart',
    /**
     * Triggered upon feature translation.
     * @event TranslateEvent#translating
     * @api
     */ TRANSLATING: 'translating',
    /**
     * Triggered upon feature translation end.
     * @event TranslateEvent#translateend
     * @api
     */ TRANSLATEEND: 'translateend'
};
/**
 * A function that takes an {@link module:ol/Feature} or
 * {@link module:ol/render/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * translated or `false` otherwise.
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default<import("../source/Source").default>):boolean} FilterFunction
 */ /**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition.always}.
 * @property {Collection<import("../Feature.js").default>} [features] Features contained in this collection will be able to be translated together.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} [layers] A list of layers from which features should be
 * translated. Alternatively, a filter function can be provided. The
 * function will be called for each layer in the map and should return
 * `true` for layers that you want to be translatable. If the option is
 * absent, all visible layers will be considered translatable.
 * Not used if `features` is provided.
 * @property {FilterFunction} [filter] A function
 * that takes an {@link module:ol/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * translated or `false` otherwise. Not used if `features` is provided.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position
 * will be checked for features.
 */ /**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Translate~Translate} instances
 * are instances of this type.
 */ var TranslateEvent1 = function(_super) {
    __extends(TranslateEvent2, _super);
    /**
     * @param {TranslateEventType} type Type.
     * @param {Collection<import("../Feature.js").default>} features The features translated.
     * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
     * @param {import("../coordinate.js").Coordinate} startCoordinate The original coordinates before.translation started
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     */ function TranslateEvent2(type, features, coordinate, startCoordinate, mapBrowserEvent) {
        var _this = _super.call(this, type) || this;
        /**
         * The features being translated.
         * @type {Collection<import("../Feature.js").default>}
         * @api
         */ _this.features = features;
        /**
         * The coordinate of the drag event.
         * @const
         * @type {import("../coordinate.js").Coordinate}
         * @api
         */ _this.coordinate = coordinate;
        /**
         * The coordinate of the start position before translation started.
         * @const
         * @type {import("../coordinate.js").Coordinate}
         * @api
         */ _this.startCoordinate = startCoordinate;
        /**
         * Associated {@link module:ol/MapBrowserEvent}.
         * @type {import("../MapBrowserEvent.js").default}
         * @api
         */ _this.mapBrowserEvent = mapBrowserEvent;
        return _this;
    }
    return TranslateEvent2;
}(_eventJsDefault.default);
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
 *     'change:active', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<'translateend'|'translatestart'|'translating', TranslateEvent, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
 *     'change:active'|'translateend'|'translatestart'|'translating', Return>} TranslateOnSignature
 */ /**
 * @classdesc
 * Interaction for translating (moving) features.
 * If you want to translate multiple features in a single action (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.
 *
 * @fires TranslateEvent
 * @api
 */ var Translate1 = function(_super) {
    __extends(Translate2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function Translate2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        _this = _super.call(this, options) || this;
        /***
         * @type {TranslateOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {TranslateOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {TranslateOnSignature<void>}
         */ _this.un;
        /**
         * The last position we translated to.
         * @type {import("../coordinate.js").Coordinate}
         * @private
         */ _this.lastCoordinate_ = null;
        /**
         * The start position before translation started.
         * @type {import("../coordinate.js").Coordinate}
         * @private
         */ _this.startCoordinate_ = null;
        /**
         * @type {Collection<import("../Feature.js").default>}
         * @private
         */ _this.features_ = options.features !== undefined ? options.features : null;
        /** @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean} */ var layerFilter;
        if (options.layers && !_this.features_) {
            if (typeof options.layers === 'function') layerFilter = options.layers;
            else {
                var layers_1 = options.layers;
                layerFilter = function(layer) {
                    return _arrayJs.includes(layers_1, layer);
                };
            }
        } else layerFilter = _functionsJs.TRUE;
        /**
         * @private
         * @type {function(import("../layer/Layer.js").default<import("../source/Source").default>): boolean}
         */ _this.layerFilter_ = layerFilter;
        /**
         * @private
         * @type {FilterFunction}
         */ _this.filter_ = options.filter && !_this.features_ ? options.filter : _functionsJs.TRUE;
        /**
         * @private
         * @type {number}
         */ _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
        /**
         * @private
         * @type {import("../events/condition.js").Condition}
         */ _this.condition_ = options.condition ? options.condition : _conditionJs.always;
        /**
         * @type {import("../Feature.js").default}
         * @private
         */ _this.lastFeature_ = null;
        _this.addChangeListener(_propertyJsDefault.default.ACTIVE, _this.handleActiveChanged_);
        return _this;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @return {boolean} If the event was consumed.
     */ Translate2.prototype.handleDownEvent = function(event) {
        if (!event.originalEvent || !this.condition_(event)) return false;
        this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);
        if (!this.lastCoordinate_ && this.lastFeature_) {
            this.startCoordinate_ = event.coordinate;
            this.lastCoordinate_ = event.coordinate;
            this.handleMoveEvent(event);
            var features = this.features_ || new _collectionJsDefault.default([
                this.lastFeature_
            ]);
            this.dispatchEvent(new TranslateEvent1(TranslateEventType.TRANSLATESTART, features, event.coordinate, this.startCoordinate_, event));
            return true;
        }
        return false;
    };
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @return {boolean} If the event was consumed.
     */ Translate2.prototype.handleUpEvent = function(event) {
        if (this.lastCoordinate_) {
            this.lastCoordinate_ = null;
            this.handleMoveEvent(event);
            var features = this.features_ || new _collectionJsDefault.default([
                this.lastFeature_
            ]);
            this.dispatchEvent(new TranslateEvent1(TranslateEventType.TRANSLATEEND, features, event.coordinate, this.startCoordinate_, event));
            // cleanup
            this.startCoordinate_ = null;
            return true;
        }
        return false;
    };
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     */ Translate2.prototype.handleDragEvent = function(event) {
        if (this.lastCoordinate_) {
            var newCoordinate = event.coordinate;
            var deltaX_1 = newCoordinate[0] - this.lastCoordinate_[0];
            var deltaY_1 = newCoordinate[1] - this.lastCoordinate_[1];
            var features = this.features_ || new _collectionJsDefault.default([
                this.lastFeature_
            ]);
            features.forEach(function(feature) {
                var geom = feature.getGeometry();
                geom.translate(deltaX_1, deltaY_1);
                feature.setGeometry(geom);
            });
            this.lastCoordinate_ = newCoordinate;
            this.dispatchEvent(new TranslateEvent1(TranslateEventType.TRANSLATING, features, newCoordinate, this.startCoordinate_, event));
        }
    };
    /**
     * Handle pointer move events.
     * @param {import("../MapBrowserEvent.js").default} event Event.
     */ Translate2.prototype.handleMoveEvent = function(event) {
        var elem = event.map.getViewport();
        // Change the cursor to grab/grabbing if hovering any of the features managed
        // by the interaction
        if (this.featuresAtPixel_(event.pixel, event.map)) {
            elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');
            elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');
        } else elem.classList.remove('ol-grab', 'ol-grabbing');
    };
    /**
     * Tests to see if the given coordinates intersects any of our selected
     * features.
     * @param {import("../pixel.js").Pixel} pixel Pixel coordinate to test for intersection.
     * @param {import("../PluggableMap.js").default} map Map to test the intersection on.
     * @return {import("../Feature.js").default} Returns the feature found at the specified pixel
     * coordinates.
     * @private
     */ Translate2.prototype.featuresAtPixel_ = function(pixel, map) {
        return map.forEachFeatureAtPixel(pixel, (function(feature, layer) {
            if (this.filter_(feature, layer)) {
                if (!this.features_ || _arrayJs.includes(this.features_.getArray(), feature)) return feature;
            }
        }).bind(this), {
            layerFilter: this.layerFilter_,
            hitTolerance: this.hitTolerance_
        });
    };
    /**
     * Returns the Hit-detection tolerance.
     * @return {number} Hit tolerance in pixels.
     * @api
     */ Translate2.prototype.getHitTolerance = function() {
        return this.hitTolerance_;
    };
    /**
     * Hit-detection tolerance. Pixels inside the radius around the given position
     * will be checked for features.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @api
     */ Translate2.prototype.setHitTolerance = function(hitTolerance) {
        this.hitTolerance_ = hitTolerance;
    };
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../PluggableMap.js").default} map Map.
     */ Translate2.prototype.setMap = function(map) {
        var oldMap = this.getMap();
        _super.prototype.setMap.call(this, map);
        this.updateState_(oldMap);
    };
    /**
     * @private
     */ Translate2.prototype.handleActiveChanged_ = function() {
        this.updateState_(null);
    };
    /**
     * @param {import("../PluggableMap.js").default} oldMap Old map.
     * @private
     */ Translate2.prototype.updateState_ = function(oldMap) {
        var map = this.getMap();
        var active = this.getActive();
        if (!map || !active) {
            map = map || oldMap;
            if (map) {
                var elem = map.getViewport();
                elem.classList.remove('ol-grab', 'ol-grabbing');
            }
        }
    };
    return Translate2;
}(_pointerJsDefault.default);
exports.default = Translate1;

},{"../Collection.js":"d2f3b","../events/Event.js":"7AR9n","./Property.js":"jZl7a","./Pointer.js":"iatpc","../functions.js":"d72zA","../events/condition.js":"eCqyb","../array.js":"jKNP0","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3h2AK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/layer/WebGLTile
 */ var _baseTileJs = require("./BaseTile.js");
var _baseTileJsDefault = parcelHelpers.interopDefault(_baseTileJs);
var _tileLayerJs = require("../renderer/webgl/TileLayer.js");
var _tileLayerJsDefault = parcelHelpers.interopDefault(_tileLayerJs);
var _expressionsJs = require("../style/expressions.js");
var _objJs = require("../obj.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/**
 * @typedef {Object} Style
 * Translates tile data to rendered pixels.
 *
 * @property {Object<string, number>} [variables] Style variables.  Each variable must hold a number.  These
 * variables can be used in the `color`, `brightness`, `contrast`, `exposure`, `saturation` and `gamma`
 * {@link import("../style/expressions.js").ExpressionValue expressions}, using the `['var', 'varName']` operator.
 * To update style variables, use the {@link import("./WebGLTile.js").default#updateStyleVariables} method.
 * @property {import("../style/expressions.js").ExpressionValue} [color] An expression applied to color values.
 * @property {import("../style/expressions.js").ExpressionValue} [brightness=0] Value used to decrease or increase
 * the layer brightness.  Values range from -1 to 1.
 * @property {import("../style/expressions.js").ExpressionValue} [contrast=0] Value used to decrease or increase
 * the layer contrast.  Values range from -1 to 1.
 * @property {import("../style/expressions.js").ExpressionValue} [exposure=0] Value used to decrease or increase
 * the layer exposure.  Values range from -1 to 1.
 * @property {import("../style/expressions.js").ExpressionValue} [saturation=0] Value used to decrease or increase
 * the layer saturation.  Values range from -1 to 1.
 * @property {import("../style/expressions.js").ExpressionValue} [gamma=1] Apply a gamma correction to the layer.
 * Values range from 0 to infinity.
 */ /**
 * @typedef {Object} Options
 * @property {Style} [style] Style to apply to the layer.
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {import("../source/Tile.js").default} [source] Source for this layer.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render
 * two zoom levels worth of tiles.
 */ /**
 * @typedef {Object} ParsedStyle
 * @property {string} vertexShader The vertex shader.
 * @property {string} fragmentShader The fragment shader.
 * @property {Object<string,import("../webgl/Helper.js").UniformValue>} uniforms Uniform definitions.
 */ /**
 * @param {Style} style The layer style.
 * @param {number} [bandCount] The number of bands.
 * @return {ParsedStyle} Shaders and uniforms generated from the style.
 */ function parseStyle(style, bandCount) {
    var vertexShader = "\n    attribute vec2 " + _tileLayerJs.Attributes.TEXTURE_COORD + ";\n    uniform mat4 " + _tileLayerJs.Uniforms.TILE_TRANSFORM + ";\n    uniform float " + _tileLayerJs.Uniforms.DEPTH + ";\n\n    varying vec2 v_textureCoord;\n\n    void main() {\n      v_textureCoord = " + _tileLayerJs.Attributes.TEXTURE_COORD + ";\n      gl_Position = " + _tileLayerJs.Uniforms.TILE_TRANSFORM + " * vec4(" + _tileLayerJs.Attributes.TEXTURE_COORD + ", " + _tileLayerJs.Uniforms.DEPTH + ", 1.0);\n    }\n  ";
    /**
     * @type {import("../style/expressions.js").ParsingContext}
     */ var context = {
        inFragmentShader: true,
        variables: [],
        attributes: [],
        stringLiteralsMap: {
        },
        bandCount: bandCount
    };
    var pipeline = [];
    if (style.color !== undefined) {
        var color = _expressionsJs.expressionToGlsl(context, style.color, _expressionsJs.ValueTypes.COLOR);
        pipeline.push("color = " + color + ";");
    }
    if (style.contrast !== undefined) {
        var contrast = _expressionsJs.expressionToGlsl(context, style.contrast, _expressionsJs.ValueTypes.NUMBER);
        pipeline.push("color.rgb = clamp((" + contrast + " + 1.0) * color.rgb - (" + contrast + " / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));");
    }
    if (style.exposure !== undefined) {
        var exposure = _expressionsJs.expressionToGlsl(context, style.exposure, _expressionsJs.ValueTypes.NUMBER);
        pipeline.push("color.rgb = clamp((" + exposure + " + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));");
    }
    if (style.saturation !== undefined) {
        var saturation = _expressionsJs.expressionToGlsl(context, style.saturation, _expressionsJs.ValueTypes.NUMBER);
        pipeline.push("\n      float saturation = " + saturation + " + 1.0;\n      float sr = (1.0 - saturation) * 0.2126;\n      float sg = (1.0 - saturation) * 0.7152;\n      float sb = (1.0 - saturation) * 0.0722;\n      mat3 saturationMatrix = mat3(\n        sr + saturation, sr, sr,\n        sg, sg + saturation, sg,\n        sb, sb, sb + saturation\n      );\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    ");
    }
    if (style.gamma !== undefined) {
        var gamma = _expressionsJs.expressionToGlsl(context, style.gamma, _expressionsJs.ValueTypes.NUMBER);
        pipeline.push("color.rgb = pow(color.rgb, vec3(1.0 / " + gamma + "));");
    }
    if (style.brightness !== undefined) {
        var brightness = _expressionsJs.expressionToGlsl(context, style.brightness, _expressionsJs.ValueTypes.NUMBER);
        pipeline.push("color.rgb = clamp(color.rgb + " + brightness + ", vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));");
    }
    /** @type {Object<string,import("../webgl/Helper").UniformValue>} */ var uniforms = {
    };
    var numVariables = context.variables.length;
    if (numVariables > 1 && !style.variables) throw new Error("Missing variables in style (expected " + context.variables + ")");
    var _loop_1 = function(i) {
        var variableName = context.variables[i];
        if (!(variableName in style.variables)) throw new Error("Missing '" + variableName + "' in style variables");
        var uniformName = _expressionsJs.uniformNameForVariable(variableName);
        uniforms[uniformName] = function() {
            var value = style.variables[variableName];
            if (typeof value === 'string') value = _expressionsJs.getStringNumberEquivalent(context, value);
            return value !== undefined ? value : -9999999; // to avoid matching with the first string literal
        };
    };
    for(var i = 0; i < numVariables; ++i)_loop_1(i);
    var uniformDeclarations = Object.keys(uniforms).map(function(name) {
        return "uniform float " + name + ";";
    });
    var textureCount = Math.ceil(bandCount / 4);
    var colorAssignments = new Array(textureCount);
    for(var textureIndex = 0; textureIndex < textureCount; ++textureIndex){
        var uniformName = _tileLayerJs.Uniforms.TILE_TEXTURE_PREFIX + textureIndex;
        uniformDeclarations.push("uniform sampler2D " + uniformName + ";");
        colorAssignments[textureIndex] = "vec4 color" + textureIndex + " = texture2D(" + uniformName + ", v_textureCoord);";
    }
    var fragmentShader = "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    varying vec2 v_textureCoord;\n    uniform float " + _tileLayerJs.Uniforms.TRANSITION_ALPHA + ";\n    uniform float " + _tileLayerJs.Uniforms.TEXTURE_PIXEL_WIDTH + ";\n    uniform float " + _tileLayerJs.Uniforms.TEXTURE_PIXEL_HEIGHT + ";\n    uniform float " + _tileLayerJs.Uniforms.RESOLUTION + ";\n    uniform float " + _tileLayerJs.Uniforms.ZOOM + ";\n\n    " + uniformDeclarations.join('\n') + "\n\n    void main() {\n      " + colorAssignments.join('\n') + "\n\n      vec4 color = color0;\n\n      " + pipeline.join('\n') + "\n\n      if (color.a == 0.0) {\n        discard;\n      }\n\n      gl_FragColor = color;\n      gl_FragColor.rgb *= gl_FragColor.a;\n      gl_FragColor *= " + _tileLayerJs.Uniforms.TRANSITION_ALPHA + ";\n    }";
    return {
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        uniforms: uniforms
    };
}
/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * **Important**: after removing a `WebGLTile` layer from your map, call `layer.dispose()`
 * to clean up underlying resources.
 *
 * @extends BaseTileLayer<import("../source/DataTile.js").default|import("../source/TileImage.js").default>
 * @api
 */ var WebGLTileLayer1 = function(_super) {
    __extends(WebGLTileLayer2, _super);
    /**
     * @param {Options} opt_options Tile layer options.
     */ function WebGLTileLayer2(opt_options) {
        var _this = this;
        var options = opt_options ? _objJs.assign({
        }, opt_options) : {
        };
        var style = options.style || {
        };
        delete options.style;
        var cacheSize = options.cacheSize;
        delete options.cacheSize;
        _this = _super.call(this, options) || this;
        /**
         * @type {Style}
         * @private
         */ _this.style_ = style;
        /**
         * @type {number}
         * @private
         */ _this.cacheSize_ = cacheSize;
        return _this;
    }
    /**
     * Create a renderer for this layer.
     * @return {import("../renderer/Layer.js").default} A layer renderer.
     * @protected
     */ WebGLTileLayer2.prototype.createRenderer = function() {
        var source = this.getSource();
        var parsedStyle = parseStyle(this.style_, 'bandCount' in source ? source.bandCount : 4);
        this.styleVariables_ = this.style_.variables || {
        };
        return new _tileLayerJsDefault.default(this, {
            vertexShader: parsedStyle.vertexShader,
            fragmentShader: parsedStyle.fragmentShader,
            uniforms: parsedStyle.uniforms,
            className: this.getClassName(),
            cacheSize: this.cacheSize_
        });
    };
    /**
     * Update any variables used by the layer style and trigger a re-render.
     * @param {Object<string, number>} variables Variables to update.
     * @api
     */ WebGLTileLayer2.prototype.updateStyleVariables = function(variables) {
        _objJs.assign(this.styleVariables_, variables);
        this.changed();
    };
    return WebGLTileLayer2;
}(_baseTileJsDefault.default);
/**
 * Clean up underlying WebGL resources.
 * @function
 * @api
 */ WebGLTileLayer1.prototype.dispose;
exports.default = WebGLTileLayer1;

},{"./BaseTile.js":"6KLXC","../renderer/webgl/TileLayer.js":"IIUIV","../style/expressions.js":"hep5n","../obj.js":"g3fPg","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"6KLXC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/layer/BaseTile
 */ var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _tilePropertyJs = require("./TileProperty.js");
var _tilePropertyJsDefault = parcelHelpers.interopDefault(_tilePropertyJs);
var _objJs = require("../obj.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
/***
 * @template Return
 * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
 *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
 *     'change:source'|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
 *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
 *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
 *   'change:source'|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature
 */ /**
 * @template {import("../source/Tile.js").default} TileSourceType
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {TileSourceType} [source] Source for this layer.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link import("../PluggableMap.js").default#addLayer map.addLayer()}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */ /**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Tile.js").default} TileSourceType
 * @extends {Layer<TileSourceType>}
 * @api
 */ var BaseTileLayer1 = function(_super) {
    __extends(BaseTileLayer2, _super);
    /**
     * @param {Options<TileSourceType>} [opt_options] Tile layer options.
     */ function BaseTileLayer2(opt_options) {
        var _this = this;
        var options = opt_options ? opt_options : {
        };
        var baseOptions = _objJs.assign({
        }, options);
        delete baseOptions.preload;
        delete baseOptions.useInterimTilesOnError;
        _this = _super.call(this, baseOptions) || this;
        /***
         * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
         */ _this.on;
        /***
         * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
         */ _this.once;
        /***
         * @type {BaseTileLayerOnSignature<void>}
         */ _this.un;
        _this.setPreload(options.preload !== undefined ? options.preload : 0);
        _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);
        return _this;
    }
    /**
     * Return the level as number to which we will preload tiles up to.
     * @return {number} The level to preload tiles up to.
     * @observable
     * @api
     */ BaseTileLayer2.prototype.getPreload = function() {
        return this.get(_tilePropertyJsDefault.default.PRELOAD);
    };
    /**
     * Set the level as number to which we will preload tiles up to.
     * @param {number} preload The level to preload tiles up to.
     * @observable
     * @api
     */ BaseTileLayer2.prototype.setPreload = function(preload) {
        this.set(_tilePropertyJsDefault.default.PRELOAD, preload);
    };
    /**
     * Whether we use interim tiles on error.
     * @return {boolean} Use interim tiles on error.
     * @observable
     * @api
     */ BaseTileLayer2.prototype.getUseInterimTilesOnError = function() {
        return this.get(_tilePropertyJsDefault.default.USE_INTERIM_TILES_ON_ERROR);
    };
    /**
     * Set whether we use interim tiles on error.
     * @param {boolean} useInterimTilesOnError Use interim tiles on error.
     * @observable
     * @api
     */ BaseTileLayer2.prototype.setUseInterimTilesOnError = function(useInterimTilesOnError) {
        this.set(_tilePropertyJsDefault.default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
    };
    return BaseTileLayer2;
}(_layerJsDefault.default);
exports.default = BaseTileLayer1;

},{"./Layer.js":"4vI3D","./TileProperty.js":"0Izuc","../obj.js":"g3fPg","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"0Izuc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    PRELOAD: 'preload',
    USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"IIUIV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Uniforms", ()=>Uniforms
);
parcelHelpers.export(exports, "Attributes", ()=>Attributes
);
/**
 * @module ol/renderer/webgl/TileLayer
 */ var _lrucacheJs = require("../../structs/LRUCache.js");
var _lrucacheJsDefault = parcelHelpers.interopDefault(_lrucacheJs);
var _stateJs = require("../../source/State.js");
var _stateJsDefault = parcelHelpers.interopDefault(_stateJs);
var _tileRangeJs = require("../../TileRange.js");
var _tileRangeJsDefault = parcelHelpers.interopDefault(_tileRangeJs);
var _tileStateJs = require("../../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _tileTextureJs = require("../../webgl/TileTexture.js");
var _tileTextureJsDefault = parcelHelpers.interopDefault(_tileTextureJs);
var _bufferJs = require("../../webgl/Buffer.js");
var _bufferJsDefault = parcelHelpers.interopDefault(_bufferJs);
var _layerJs = require("./Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _helperJs = require("../../webgl/Helper.js");
var _webglJs = require("../../webgl.js");
var _transformJs = require("../../transform.js");
var _mat4Js = require("../../vec/mat4.js");
var _tilecoordJs = require("../../tilecoord.js");
var _projJs = require("../../proj.js");
var _extentJs = require("../../extent.js");
var _utilJs = require("../../util.js");
var _arrayJs = require("../../array.js");
var _sizeJs = require("../../size.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var Uniforms = {
    TILE_TEXTURE_PREFIX: 'u_tileTexture',
    TILE_TRANSFORM: 'u_tileTransform',
    TRANSITION_ALPHA: 'u_transitionAlpha',
    DEPTH: 'u_depth',
    TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',
    TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',
    RESOLUTION: 'u_resolution',
    ZOOM: 'u_zoom'
};
var Attributes = {
    TEXTURE_COORD: 'a_textureCoord'
};
/**
 * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
 */ var attributeDescriptions = [
    {
        name: Attributes.TEXTURE_COORD,
        size: 2,
        type: _helperJs.AttributeType.FLOAT
    }, 
];
var empty = {
};
/**
 * Transform a zoom level into a depth value ranging from -1 to 1.
 * @param {number} z A zoom level.
 * @return {number} A depth value.
 */ function depthForZ(z) {
    return 2 * (1 - 1 / (z + 1)) - 1;
}
/**
 * Add a tile texture to the lookup.
 * @param {Object<string, Array<import("../../webgl/TileTexture.js").default>>} tileTexturesByZ Lookup of
 * tile textures by zoom level.
 * @param {import("../../webgl/TileTexture.js").default} tileTexture A tile texture.
 * @param {number} z The zoom level.
 */ function addTileTextureToLookup(tileTexturesByZ, tileTexture, z) {
    if (!(z in tileTexturesByZ)) tileTexturesByZ[z] = [];
    tileTexturesByZ[z].push(tileTexture);
}
/**
 * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
 * @param {import("../../extent.js").Extent} extent The frame extent.
 * @return {import("../../extent.js").Extent} Frame extent intersected with layer extents.
 */ function getRenderExtent(frameState, extent) {
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    if (layerState.extent) extent = _extentJs.getIntersection(extent, _projJs.fromUserExtent(layerState.extent, frameState.viewState.projection));
    return extent;
}
/**
 * @typedef {Object} Options
 * @property {string} vertexShader Vertex shader source.
 * @property {string} fragmentShader Fragment shader source.
 * @property {Object<string, import("../../webgl/Helper").UniformValue>} [uniforms] Additional uniforms
 * made available to shaders.
 * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.
 * @property {number} [cacheSize=512] The texture cache size.
 */ /**
 * @classdesc
 * WebGL renderer for tile layers.
 * @api
 */ var WebGLTileLayerRenderer1 = function(_super) {
    __extends(WebGLTileLayerRenderer2, _super);
    /**
     * @param {import("../../layer/WebGLTile.js").default} tileLayer Tile layer.
     * @param {Options} options Options.
     */ function WebGLTileLayerRenderer2(tileLayer, options) {
        var _this = _super.call(this, tileLayer, {
            uniforms: options.uniforms,
            className: options.className
        }) || this;
        /**
         * This transform converts tile i, j coordinates to screen coordinates.
         * @type {import("../../transform.js").Transform}
         * @private
         */ _this.tileTransform_ = _transformJs.create();
        /**
         * @type {Array<number>}
         * @private
         */ _this.tempMat4_ = _mat4Js.create();
        /**
         * @type {import("../../TileRange.js").default}
         * @private
         */ _this.tempTileRange_ = new _tileRangeJsDefault.default(0, 0, 0, 0);
        /**
         * @type {import("../../tilecoord.js").TileCoord}
         * @private
         */ _this.tempTileCoord_ = _tilecoordJs.createOrUpdate(0, 0, 0);
        /**
         * @type {import("../../size.js").Size}
         * @private
         */ _this.tempSize_ = [
            0,
            0
        ];
        _this.program_ = _this.helper.getProgram(options.fragmentShader, options.vertexShader);
        /**
         * Tiles are rendered as a quad with the following structure:
         *
         *  [P3]---------[P2]
         *   |`           |
         *   |  `     B   |
         *   |    `       |
         *   |      `     |
         *   |   A    `   |
         *   |          ` |
         *  [P0]---------[P1]
         *
         * Triangle A: P0, P1, P3
         * Triangle B: P1, P2, P3
         */ var indices = new _bufferJsDefault.default(_webglJs.ELEMENT_ARRAY_BUFFER, _webglJs.STATIC_DRAW);
        indices.fromArray([
            0,
            1,
            3,
            1,
            2,
            3
        ]);
        _this.helper.flushBufferData(indices);
        _this.indices_ = indices;
        var cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;
        /**
         * @type {import("../../structs/LRUCache.js").default<import("../../webgl/TileTexture.js").default>}
         * @private
         */ _this.tileTextureCache_ = new _lrucacheJsDefault.default(cacheSize);
        _this.renderedOpacity_ = NaN;
        return _this;
    }
    /**
     * @protected
     * @param {import("../../Tile.js").default} tile Tile.
     * @return {boolean} Tile is drawable.
     */ WebGLTileLayerRenderer2.prototype.isDrawableTile = function(tile) {
        var tileLayer = this.getLayer();
        var tileState = tile.getState();
        var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
        return tileState == _tileStateJsDefault.default.LOADED || tileState == _tileStateJsDefault.default.EMPTY || tileState == _tileStateJsDefault.default.ERROR && !useInterimTilesOnError;
    };
    /**
     * Determine whether render should be called.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */ WebGLTileLayerRenderer2.prototype.prepareFrame = function(frameState) {
        if (_extentJs.isEmpty(getRenderExtent(frameState, frameState.extent))) return false;
        var source = this.getLayer().getSource();
        if (!source) return false;
        return source.getState() === _stateJsDefault.default.READY;
    };
    WebGLTileLayerRenderer2.prototype.enqueueTiles = function(frameState, extent, z, tileTexturesByZ) {
        var viewState = frameState.viewState;
        var tileLayer = this.getLayer();
        var tileSource = tileLayer.getSource();
        var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
        var tileTextureCache = this.tileTextureCache_;
        var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
        var tileSourceKey = _utilJs.getUid(tileSource);
        if (!(tileSourceKey in frameState.wantedTiles)) frameState.wantedTiles[tileSourceKey] = {
        };
        var wantedTiles = frameState.wantedTiles[tileSourceKey];
        var tileResolution = tileGrid.getResolution(z);
        for(var x = tileRange.minX; x <= tileRange.maxX; ++x)for(var y = tileRange.minY; y <= tileRange.maxY; ++y){
            var tileCoord = _tilecoordJs.createOrUpdate(z, x, y, this.tempTileCoord_);
            var tileCoordKey = _tilecoordJs.getKey(tileCoord);
            var tileTexture = void 0, tile = void 0;
            if (tileTextureCache.containsKey(tileCoordKey)) {
                tileTexture = tileTextureCache.get(tileCoordKey);
                tile = tileTexture.tile;
            }
            if (!tileTexture || tileTexture.tile.key !== tileSource.getKey()) {
                tile = tileSource.getTile(z, x, y, frameState.pixelRatio, viewState.projection);
                if (!tileTexture) {
                    tileTexture = new _tileTextureJsDefault.default(tile, tileGrid, this.helper);
                    tileTextureCache.set(tileCoordKey, tileTexture);
                } else tileTexture.setTile(this.isDrawableTile(tile) ? tile : tile.getInterimTile());
            }
            addTileTextureToLookup(tileTexturesByZ, tileTexture, z);
            var tileQueueKey = tile.getKey();
            wantedTiles[tileQueueKey] = true;
            if (tile.getState() === _tileStateJsDefault.default.IDLE) {
                if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) frameState.tileQueue.enqueue([
                    tile,
                    tileSourceKey,
                    tileGrid.getTileCoordCenter(tileCoord),
                    tileResolution, 
                ]);
            }
        }
    };
    /**
     * Render the layer.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @return {HTMLElement} The rendered element.
     */ WebGLTileLayerRenderer2.prototype.renderFrame = function(frameState) {
        this.preRender(frameState);
        var viewState = frameState.viewState;
        var layerState = frameState.layerStatesArray[frameState.layerIndex];
        var extent = getRenderExtent(frameState, frameState.extent);
        var tileLayer = this.getLayer();
        var tileSource = tileLayer.getSource();
        var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
        var z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);
        /**
         * @type {Object<string, Array<import("../../webgl/TileTexture.js").default>>}
         */ var tileTexturesByZ = {
        };
        if (frameState.nextExtent) {
            var targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);
            var nextExtent = getRenderExtent(frameState, frameState.nextExtent);
            this.enqueueTiles(frameState, nextExtent, targetZ, tileTexturesByZ);
        }
        this.enqueueTiles(frameState, extent, z, tileTexturesByZ);
        /**
         * A lookup of alpha values for tiles at the target rendering resolution
         * for tiles that are in transition.  If a tile coord key is absent from
         * this lookup, the tile should be rendered at alpha 1.
         * @type {Object<string, number>}
         */ var alphaLookup = {
        };
        var uid = _utilJs.getUid(this);
        var time = frameState.time;
        var blend = false;
        // look for cached tiles to use if a target tile is not ready
        var tileTextures = tileTexturesByZ[z];
        for(var i = 0, ii = tileTextures.length; i < ii; ++i){
            var tileTexture = tileTextures[i];
            var tile = tileTexture.tile;
            var tileCoord = tile.tileCoord;
            if (tileTexture.loaded) {
                var alpha = tile.getAlpha(uid, time);
                if (alpha === 1) {
                    // no need to look for alt tiles
                    tile.endTransition(uid);
                    continue;
                }
                blend = true;
                var tileCoordKey = _tilecoordJs.getKey(tileCoord);
                alphaLookup[tileCoordKey] = alpha;
            }
            // first look for child tiles (at z + 1)
            var coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tileTexturesByZ);
            if (coveredByChildren) continue;
            // next look for parent tiles
            for(var parentZ = z - 1; parentZ >= tileGrid.minZoom; --parentZ){
                var coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileTexturesByZ);
                if (coveredByParent) break;
            }
        }
        this.helper.useProgram(this.program_);
        this.helper.prepareDraw(frameState, !blend);
        var zs = Object.keys(tileTexturesByZ).map(Number).sort(_arrayJs.numberSafeCompareFunction);
        var gl = this.helper.getGL();
        var centerX = viewState.center[0];
        var centerY = viewState.center[1];
        for(var j = 0, jj = zs.length; j < jj; ++j){
            var tileZ = zs[j];
            var tileResolution = tileGrid.getResolution(tileZ);
            var tileSize = _sizeJs.toSize(tileGrid.getTileSize(tileZ), this.tempSize_);
            var tileOrigin = tileGrid.getOrigin(tileZ);
            var centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);
            var centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);
            var tileScale = viewState.resolution / tileResolution;
            var depth = depthForZ(tileZ);
            var tileTextures_1 = tileTexturesByZ[tileZ];
            for(var i = 0, ii = tileTextures_1.length; i < ii; ++i){
                var tileTexture = tileTextures_1[i];
                if (!tileTexture.loaded) continue;
                var tile = tileTexture.tile;
                var tileCoord = tile.tileCoord;
                var tileCoordKey = _tilecoordJs.getKey(tileCoord);
                var tileCenterI = tileCoord[1];
                var tileCenterJ = tileCoord[2];
                _transformJs.compose(this.tileTransform_, 0, 0, 2 / (frameState.size[0] * tileScale / tileSize[0]), -2 / (frameState.size[1] * tileScale / tileSize[1]), viewState.rotation, -(centerI - tileCenterI), -(centerJ - tileCenterJ));
                this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, _mat4Js.fromTransform(this.tempMat4_, this.tileTransform_));
                this.helper.bindBuffer(tileTexture.coords);
                this.helper.bindBuffer(this.indices_);
                this.helper.enableAttributes(attributeDescriptions);
                for(var textureIndex = 0; textureIndex < tileTexture.textures.length; ++textureIndex){
                    var textureProperty = 'TEXTURE' + textureIndex;
                    var uniformName = Uniforms.TILE_TEXTURE_PREFIX + textureIndex;
                    gl.activeTexture(gl[textureProperty]);
                    gl.bindTexture(gl.TEXTURE_2D, tileTexture.textures[textureIndex]);
                    gl.uniform1i(this.helper.getUniformLocation(uniformName), textureIndex);
                }
                var alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;
                if (alpha < 1) frameState.animate = true;
                this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, alpha);
                this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);
                this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileSize[0]);
                this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileSize[1]);
                this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);
                this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);
                this.helper.drawElements(0, this.indices_.getSize());
            }
        }
        this.helper.finalizeDraw(frameState);
        var canvas = this.helper.getCanvas();
        var opacity = layerState.opacity;
        if (this.renderedOpacity_ !== opacity) {
            canvas.style.opacity = String(opacity);
            this.renderedOpacity_ = opacity;
        }
        var tileTextureCache = this.tileTextureCache_;
        while(tileTextureCache.canExpireCache()){
            var tileTexture = tileTextureCache.pop();
            tileTexture.dispose();
        }
        // TODO: let the renderers manage their own cache instead of managing the source cache
        /**
         * Here we unconditionally expire the source cache since the renderer maintains
         * its own cache.
         * @param {import("../../PluggableMap.js").default} map Map.
         * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
         */ var postRenderFunction = function(map, frameState1) {
            tileSource.expireCache(tileSource.getProjection(), empty);
        };
        frameState.postRenderFunctions.push(postRenderFunction);
        this.postRender(frameState);
        return canvas;
    };
    /**
     * Look for tiles covering the provided tile coordinate at an alternate
     * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
     * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
     * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
     * @param {number} altZ The alternate zoom level.
     * @param {Object<string, Array<import("../../webgl/TileTexture.js").default>>} tileTexturesByZ Lookup of
     * tile textures by zoom level.
     * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
     * @private
     */ WebGLTileLayerRenderer2.prototype.findAltTiles_ = function(tileGrid, tileCoord, altZ, tileTexturesByZ) {
        var tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);
        if (!tileRange) return false;
        var covered = true;
        var tileTextureCache = this.tileTextureCache_;
        for(var x = tileRange.minX; x <= tileRange.maxX; ++x)for(var y = tileRange.minY; y <= tileRange.maxY; ++y){
            var cacheKey = _tilecoordJs.getKeyZXY(altZ, x, y);
            var loaded = false;
            if (tileTextureCache.containsKey(cacheKey)) {
                var tileTexture = tileTextureCache.get(cacheKey);
                if (tileTexture.loaded) {
                    addTileTextureToLookup(tileTexturesByZ, tileTexture, altZ);
                    loaded = true;
                }
            }
            if (!loaded) covered = false;
        }
        return covered;
    };
    /**
     * Clean up.
     */ WebGLTileLayerRenderer2.prototype.disposeInternal = function() {
        var helper = this.helper;
        var gl = helper.getGL();
        helper.deleteBuffer(this.indices_);
        delete this.indices_;
        gl.deleteProgram(this.program_);
        delete this.program_;
        var tileTextureCache = this.tileTextureCache_;
        tileTextureCache.forEach(function(tileTexture) {
            tileTexture.dispose();
        });
        tileTextureCache.clear();
        delete this.tileTextureCache_;
        _super.prototype.disposeInternal.call(this);
    };
    return WebGLTileLayerRenderer2;
}(_layerJsDefault.default);
/**
 * @function
 * @return {import("../../layer/WebGLTile.js").default}
 */ WebGLTileLayerRenderer1.prototype.getLayer;
exports.default = WebGLTileLayerRenderer1;

},{"../../structs/LRUCache.js":"cn9iq","../../source/State.js":"hpoq1","../../TileRange.js":"lfGfv","../../TileState.js":"eIJIE","../../webgl/TileTexture.js":"cF2I9","../../webgl/Buffer.js":"f61Bw","./Layer.js":"klHTl","../../webgl/Helper.js":"WWhT6","../../webgl.js":"lVL8j","../../transform.js":"C21tg","../../vec/mat4.js":"3asgG","../../tilecoord.js":"gDmuU","../../proj.js":"hmdWM","../../extent.js":"jgUz2","../../util.js":"9zOhk","../../array.js":"jKNP0","../../size.js":"5PZ8p","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"cF2I9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _targetJs = require("../events/Target.js");
var _targetJsDefault = parcelHelpers.interopDefault(_targetJs);
var _eventTypeJs = require("../events/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _imageTileJs = require("../ImageTile.js");
var _imageTileJsDefault = parcelHelpers.interopDefault(_imageTileJs);
var _tileStateJs = require("../TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _bufferJs = require("./Buffer.js");
var _bufferJsDefault = parcelHelpers.interopDefault(_bufferJs);
var _webglJs = require("../webgl.js");
var _sizeJs = require("../size.js");
/**
 * @module ol/webgl/TileTexture
 */ var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
function bindAndConfigure(gl, texture) {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
}
/**
 * @param {WebGLRenderingContext} gl The WebGL context.
 * @param {WebGLTexture} texture The texture.
 * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image The image.
 */ function uploadImageTexture(gl, texture, image) {
    bindAndConfigure(gl, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
}
/**
 * @param {import("./Helper.js").default} helper The WebGL helper.
 * @param {WebGLTexture} texture The texture.
 * @param {import("../DataTile.js").Data} data The pixel data.
 * @param {import("../size.js").Size} size The pixel size.
 * @param {number} bandCount The band count.
 */ function uploadDataTexture(helper, texture, data, size, bandCount) {
    var gl = helper.getGL();
    bindAndConfigure(gl, texture);
    var format;
    switch(bandCount){
        case 1:
            format = gl.LUMINANCE;
            break;
        case 2:
            format = gl.LUMINANCE_ALPHA;
            break;
        case 3:
            format = gl.RGB;
            break;
        case 4:
            format = gl.RGBA;
            break;
        default:
            throw new Error("Unsupported number of bands: " + bandCount);
    }
    var textureType;
    if (data instanceof Float32Array) {
        textureType = gl.FLOAT;
        helper.getExtension('OES_texture_float');
        helper.getExtension('OES_texture_float_linear');
    } else textureType = gl.UNSIGNED_BYTE;
    gl.texImage2D(gl.TEXTURE_2D, 0, format, size[0], size[1], 0, format, textureType, data);
}
var TileTexture1 = function(_super) {
    __extends(TileTexture2, _super);
    /**
     * @param {import("../DataTile.js").default|import("../ImageTile.js").default} tile The tile.
     * @param {import("../tilegrid/TileGrid.js").default} grid Tile grid.
     * @param {import("../webgl/Helper.js").default} helper WebGL helper.
     */ function TileTexture2(tile, grid, helper) {
        var _this = _super.call(this) || this;
        /**
         * @type {import("../DataTile.js").default|import("../ImageTile.js").default}
         */ _this.tile;
        /**
         * @type {Array<WebGLTexture>}
         */ _this.textures = [];
        _this.handleTileChange_ = _this.handleTileChange_.bind(_this);
        _this.size = _sizeJs.toSize(grid.getTileSize(tile.tileCoord[0]));
        _this.bandCount = NaN;
        _this.helper_ = helper;
        var coords = new _bufferJsDefault.default(_webglJs.ARRAY_BUFFER, _webglJs.STATIC_DRAW);
        coords.fromArray([
            0,
            1,
            1,
            1,
            1,
            0,
            0,
            0, 
        ]);
        helper.flushBufferData(coords);
        _this.coords = coords;
        _this.setTile(tile);
        return _this;
    }
    /**
     * @param {import("../DataTile.js").default|import("../ImageTile.js").default} tile Tile.
     */ TileTexture2.prototype.setTile = function(tile) {
        if (tile !== this.tile) {
            if (this.tile) this.tile.removeEventListener(_eventTypeJsDefault.default.CHANGE, this.handleTileChange_);
            this.tile = tile;
            this.textures.length = 0;
            this.loaded = tile.getState() === _tileStateJsDefault.default.LOADED;
            if (this.loaded) this.uploadTile_();
            else tile.addEventListener(_eventTypeJsDefault.default.CHANGE, this.handleTileChange_);
        }
    };
    TileTexture2.prototype.uploadTile_ = function() {
        var helper = this.helper_;
        var gl = helper.getGL();
        var tile = this.tile;
        if (tile instanceof _imageTileJsDefault.default) {
            var texture = gl.createTexture();
            this.textures.push(texture);
            this.bandCount = 4;
            uploadImageTexture(gl, texture, tile.getImage());
            return;
        }
        var data = tile.getData();
        var isFloat = data instanceof Float32Array;
        var pixelCount = this.size[0] * this.size[1];
        // Float arrays feature four bytes per element,
        //  BYTES_PER_ELEMENT throws a TypeScript exception but would handle
        //  this better for more varied typed arrays.
        this.bandCount = data.byteLength / (isFloat ? 4 : 1) / pixelCount;
        var textureCount = Math.ceil(this.bandCount / 4);
        if (textureCount === 1) {
            var texture = gl.createTexture();
            this.textures.push(texture);
            uploadDataTexture(helper, texture, data, this.size, this.bandCount);
            return;
        }
        var DataType = isFloat ? Float32Array : Uint8Array;
        var textureDataArrays = new Array(textureCount);
        for(var textureIndex = 0; textureIndex < textureCount; ++textureIndex){
            var texture = gl.createTexture();
            this.textures.push(texture);
            var bandCount = textureIndex < textureCount - 1 ? 4 : this.bandCount % 4;
            textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);
        }
        var valueCount = pixelCount * this.bandCount;
        for(var dataIndex = 0; dataIndex < valueCount; ++dataIndex){
            var bandIndex = dataIndex % this.bandCount;
            var textureBandIndex = bandIndex % 4;
            var textureIndex = Math.floor(bandIndex / 4);
            var bandCount = textureIndex < textureCount - 1 ? 4 : this.bandCount % 4;
            var pixelIndex = Math.floor(dataIndex / this.bandCount);
            textureDataArrays[textureIndex][pixelIndex * bandCount + textureBandIndex] = data[dataIndex];
        }
        for(var textureIndex = 0; textureIndex < textureCount; ++textureIndex){
            var bandCount = textureIndex < textureCount - 1 ? 4 : this.bandCount % 4;
            var texture = this.textures[textureIndex];
            var data_1 = textureDataArrays[textureIndex];
            uploadDataTexture(helper, texture, data_1, this.size, bandCount);
        }
    };
    TileTexture2.prototype.handleTileChange_ = function() {
        if (this.tile.getState() === _tileStateJsDefault.default.LOADED) {
            this.loaded = true;
            this.uploadTile_();
            this.dispatchEvent(_eventTypeJsDefault.default.CHANGE);
        }
    };
    TileTexture2.prototype.disposeInternal = function() {
        var gl = this.helper_.getGL();
        this.helper_.deleteBuffer(this.coords);
        for(var i = 0; i < this.textures.length; ++i)gl.deleteTexture(this.textures[i]);
        this.tile.removeEventListener(_eventTypeJsDefault.default.CHANGE, this.handleTileChange_);
    };
    return TileTexture2;
}(_targetJsDefault.default);
exports.default = TileTexture1;

},{"../events/Target.js":"dj5zz","../events/EventType.js":"83vee","../ImageTile.js":"wuhP7","../TileState.js":"eIJIE","./Buffer.js":"f61Bw","../webgl.js":"lVL8j","../size.js":"5PZ8p","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"wuhP7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/ImageTile
 */ var _tileJs = require("./Tile.js");
var _tileJsDefault = parcelHelpers.interopDefault(_tileJs);
var _tileStateJs = require("./TileState.js");
var _tileStateJsDefault = parcelHelpers.interopDefault(_tileStateJs);
var _domJs = require("./dom.js");
var _imageJs = require("./Image.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var ImageTile1 = function(_super) {
    __extends(ImageTile2, _super);
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {string} src Image source URI.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @param {import("./Tile.js").Options} [opt_options] Tile options.
     */ function ImageTile2(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
        var _this = _super.call(this, tileCoord, state, opt_options) || this;
        /**
         * @private
         * @type {?string}
         */ _this.crossOrigin_ = crossOrigin;
        /**
         * Image URI
         *
         * @private
         * @type {string}
         */ _this.src_ = src;
        _this.key = src;
        /**
         * @private
         * @type {HTMLImageElement|HTMLCanvasElement}
         */ _this.image_ = new Image();
        if (crossOrigin !== null) _this.image_.crossOrigin = crossOrigin;
        /**
         * @private
         * @type {?function():void}
         */ _this.unlisten_ = null;
        /**
         * @private
         * @type {import("./Tile.js").LoadFunction}
         */ _this.tileLoadFunction_ = tileLoadFunction;
        return _this;
    }
    /**
     * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @api
     */ ImageTile2.prototype.getImage = function() {
        return this.image_;
    };
    /**
     * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
     * @param {HTMLCanvasElement|HTMLImageElement} element Element.
     */ ImageTile2.prototype.setImage = function(element) {
        this.image_ = element;
        this.state = _tileStateJsDefault.default.LOADED;
        this.unlistenImage_();
        this.changed();
    };
    /**
     * Tracks loading or read errors.
     *
     * @private
     */ ImageTile2.prototype.handleImageError_ = function() {
        this.state = _tileStateJsDefault.default.ERROR;
        this.unlistenImage_();
        this.image_ = getBlankImage();
        this.changed();
    };
    /**
     * Tracks successful image load.
     *
     * @private
     */ ImageTile2.prototype.handleImageLoad_ = function() {
        var image = this.image_;
        if (image.naturalWidth && image.naturalHeight) this.state = _tileStateJsDefault.default.LOADED;
        else this.state = _tileStateJsDefault.default.EMPTY;
        this.unlistenImage_();
        this.changed();
    };
    /**
     * Load not yet loaded URI.
     * @api
     */ ImageTile2.prototype.load = function() {
        if (this.state == _tileStateJsDefault.default.ERROR) {
            this.state = _tileStateJsDefault.default.IDLE;
            this.image_ = new Image();
            if (this.crossOrigin_ !== null) this.image_.crossOrigin = this.crossOrigin_;
        }
        if (this.state == _tileStateJsDefault.default.IDLE) {
            this.state = _tileStateJsDefault.default.LOADING;
            this.changed();
            this.tileLoadFunction_(this, this.src_);
            this.unlisten_ = _imageJs.listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
        }
    };
    /**
     * Discards event handlers which listen for load completion or errors.
     *
     * @private
     */ ImageTile2.prototype.unlistenImage_ = function() {
        if (this.unlisten_) {
            this.unlisten_();
            this.unlisten_ = null;
        }
    };
    return ImageTile2;
}(_tileJsDefault.default);
/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */ function getBlankImage() {
    var ctx = _domJs.createCanvasContext2D(1, 1);
    ctx.fillStyle = 'rgba(0,0,0,0)';
    ctx.fillRect(0, 0, 1, 1);
    return ctx.canvas;
}
exports.default = ImageTile1;

},{"./Tile.js":"5dc8H","./TileState.js":"eIJIE","./dom.js":"akJqt","./Image.js":"dcFLD","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"f61Bw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BufferUsage", ()=>BufferUsage
);
/**
 * Returns a typed array constructor based on the given buffer type
 * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
 * @return {Float32ArrayConstructor|Uint32ArrayConstructor} The typed array class to use for this buffer.
 */ parcelHelpers.export(exports, "getArrayClassForType", ()=>getArrayClassForType
);
/**
 * @module ol/webgl/Buffer
 */ var _webglJs = require("../webgl.js");
var _assertsJs = require("../asserts.js");
var BufferUsage = {
    STATIC_DRAW: _webglJs.STATIC_DRAW,
    STREAM_DRAW: _webglJs.STREAM_DRAW,
    DYNAMIC_DRAW: _webglJs.DYNAMIC_DRAW
};
/**
 * @classdesc
 * Object used to store an array of data as well as usage information for that data.
 * Stores typed arrays internally, either Float32Array or Uint16/32Array depending on
 * the buffer type (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER) and available extensions.
 *
 * To populate the array, you can either use:
 * * A size using `#ofSize(buffer)`
 * * An `ArrayBuffer` object using `#fromArrayBuffer(buffer)`
 * * A plain array using `#fromArray(array)`
 *
 * Note:
 * See the documentation of [WebGLRenderingContext.bufferData](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)
 * for more info on buffer usage.
 * @api
 */ var WebGLArrayBuffer = function() {
    /**
     * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
     * @param {number} [opt_usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.
     * Default is `DYNAMIC_DRAW`.
     */ function WebGLArrayBuffer1(type, opt_usage) {
        /**
         * @private
         * @type {Float32Array|Uint32Array}
         */ this.array = null;
        /**
         * @private
         * @type {number}
         */ this.type = type;
        _assertsJs.assert(type === _webglJs.ARRAY_BUFFER || type === _webglJs.ELEMENT_ARRAY_BUFFER, 62);
        /**
         * @private
         * @type {number}
         */ this.usage = opt_usage !== undefined ? opt_usage : BufferUsage.STATIC_DRAW;
    }
    /**
     * Populates the buffer with an array of the given size (all values will be zeroes).
     * @param {number} size Array size
     */ WebGLArrayBuffer1.prototype.ofSize = function(size) {
        this.array = new (getArrayClassForType(this.type))(size);
    };
    /**
     * Populates the buffer with an array of the given size (all values will be zeroes).
     * @param {Array<number>} array Numerical array
     */ WebGLArrayBuffer1.prototype.fromArray = function(array) {
        var arrayClass = getArrayClassForType(this.type);
        this.array = arrayClass.from ? arrayClass.from(array) : new arrayClass(array);
    };
    /**
     * Populates the buffer with a raw binary array buffer.
     * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been
     * initialized for the same typed array class.
     */ WebGLArrayBuffer1.prototype.fromArrayBuffer = function(buffer) {
        this.array = new (getArrayClassForType(this.type))(buffer);
    };
    /**
     * @return {number} Buffer type.
     */ WebGLArrayBuffer1.prototype.getType = function() {
        return this.type;
    };
    /**
     * Will return null if the buffer was not initialized
     * @return {Float32Array|Uint32Array} Array.
     */ WebGLArrayBuffer1.prototype.getArray = function() {
        return this.array;
    };
    /**
     * @return {number} Usage.
     */ WebGLArrayBuffer1.prototype.getUsage = function() {
        return this.usage;
    };
    /**
     * Will return 0 if the buffer is not initialized
     * @return {number} Array size
     */ WebGLArrayBuffer1.prototype.getSize = function() {
        return this.array ? this.array.length : 0;
    };
    return WebGLArrayBuffer1;
}();
function getArrayClassForType(type) {
    switch(type){
        case _webglJs.ARRAY_BUFFER:
            return Float32Array;
        case _webglJs.ELEMENT_ARRAY_BUFFER:
            return Uint32Array;
        default:
            return Float32Array;
    }
}
exports.default = WebGLArrayBuffer;

},{"../webgl.js":"lVL8j","../asserts.js":"cnrP4","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lVL8j":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ARRAY_BUFFER", ()=>ARRAY_BUFFER
);
parcelHelpers.export(exports, "ELEMENT_ARRAY_BUFFER", ()=>ELEMENT_ARRAY_BUFFER
);
parcelHelpers.export(exports, "STREAM_DRAW", ()=>STREAM_DRAW
);
parcelHelpers.export(exports, "STATIC_DRAW", ()=>STATIC_DRAW
);
parcelHelpers.export(exports, "DYNAMIC_DRAW", ()=>DYNAMIC_DRAW
);
parcelHelpers.export(exports, "UNSIGNED_BYTE", ()=>UNSIGNED_BYTE
);
parcelHelpers.export(exports, "UNSIGNED_SHORT", ()=>UNSIGNED_SHORT
);
parcelHelpers.export(exports, "UNSIGNED_INT", ()=>UNSIGNED_INT
);
parcelHelpers.export(exports, "FLOAT", ()=>FLOAT
);
/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object} [opt_attributes] Attributes.
 * @return {WebGLRenderingContext} WebGL rendering context.
 */ parcelHelpers.export(exports, "getContext", ()=>getContext
);
/**
 * @return {Array<string>} List of supported WebGL extensions.
 */ parcelHelpers.export(exports, "getSupportedExtensions", ()=>getSupportedExtensions
);
var ARRAY_BUFFER = 34962;
var ELEMENT_ARRAY_BUFFER = 34963;
var STREAM_DRAW = 35040;
var STATIC_DRAW = 35044;
var DYNAMIC_DRAW = 35048;
var UNSIGNED_BYTE = 5121;
var UNSIGNED_SHORT = 5123;
var UNSIGNED_INT = 5125;
var FLOAT = 5126;
/** end of goog.webgl constants
 */ /**
 * @const
 * @type {Array<string>}
 */ var CONTEXT_IDS = [
    'experimental-webgl',
    'webgl',
    'webkit-3d',
    'moz-webgl'
];
function getContext(canvas, opt_attributes) {
    var ii = CONTEXT_IDS.length;
    for(var i = 0; i < ii; ++i)try {
        var context = canvas.getContext(CONTEXT_IDS[i], opt_attributes);
        if (context) return context;
    } catch (e) {
    // pass
    }
    return null;
}
/**
 * @type {Array<string>}
 */ var supportedExtensions;
function getSupportedExtensions() {
    if (!supportedExtensions) {
        var canvas = document.createElement('canvas');
        var gl = getContext(canvas);
        if (gl) supportedExtensions = gl.getSupportedExtensions();
    }
    return supportedExtensions;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"klHTl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WebGLWorkerMessageType", ()=>WebGLWorkerMessageType
);
/**
 * An object holding positions both in an index and a vertex buffer.
 * @typedef {Object} BufferPositions
 * @property {number} vertexPosition Position in the vertex buffer
 * @property {number} indexPosition Position in the index buffer
 */ /**
 * Pushes a quad (two triangles) based on a point geometry
 * @param {Float32Array} instructions Array of render instructions for points.
 * @param {number} elementIndex Index from which render instructions will be read.
 * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.
 * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.
 * @param {number} customAttributesCount Amount of custom attributes for each element.
 * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.
 * @return {BufferPositions} New buffer positions where to write next
 * @property {number} vertexPosition New position in the vertex buffer where future writes should start.
 * @property {number} indexPosition New position in the index buffer where future writes should start.
 * @private
 */ parcelHelpers.export(exports, "writePointFeatureToBuffers", ()=>writePointFeatureToBuffers
);
/**
 * Returns a texture of 1x1 pixel, white
 * @private
 * @return {ImageData} Image data.
 */ parcelHelpers.export(exports, "getBlankImageData", ()=>getBlankImageData
);
/**
 * Generates a color array based on a numerical id
 * Note: the range for each component is 0 to 1 with 256 steps
 * @param {number} id Id
 * @param {Array<number>} [opt_array] Reusable array
 * @return {Array<number>} Color array containing the encoded id
 */ parcelHelpers.export(exports, "colorEncodeId", ()=>colorEncodeId
);
/**
 * Reads an id from a color-encoded array
 * Note: the expected range for each component is 0 to 1 with 256 steps.
 * @param {Array<number>} color Color array containing the encoded id
 * @return {number} Decoded id
 */ parcelHelpers.export(exports, "colorDecodeId", ()=>colorDecodeId
);
/**
 * @module ol/renderer/webgl/Layer
 */ var _layerJs = require("../Layer.js");
var _layerJsDefault = parcelHelpers.interopDefault(_layerJs);
var _eventJs = require("../../render/Event.js");
var _eventJsDefault = parcelHelpers.interopDefault(_eventJs);
var _eventTypeJs = require("../../render/EventType.js");
var _eventTypeJsDefault = parcelHelpers.interopDefault(_eventTypeJs);
var _helperJs = require("../../webgl/Helper.js");
var _helperJsDefault = parcelHelpers.interopDefault(_helperJs);
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var WebGLWorkerMessageType = {
    GENERATE_BUFFERS: 'GENERATE_BUFFERS'
};
/**
 * @typedef {Object} WebGLWorkerGenerateBuffersMessage
 * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.
 * When the buffers are generated, the worked will send a message of the same type to the main thread, with
 * the generated buffers in it.
 * Note that any addition properties present in the message *will* be sent back to the main thread.
 * @property {WebGLWorkerMessageType} type Message type
 * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.
 * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).
 * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).
 * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.
 */ /**
 * @typedef {Object} PostProcessesOptions
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas that will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
 */ /**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.
 * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process steps
 * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions
 */ /**
 * @classdesc
 * Base WebGL renderer class.
 * Holds all logic related to data manipulation & some common rendering logic
 * @template {import("../../layer/Layer.js").default} LayerType
 */ var WebGLLayerRenderer1 = function(_super) {
    __extends(WebGLLayerRenderer2, _super);
    /**
     * @param {LayerType} layer Layer.
     * @param {Options} [opt_options] Options.
     */ function WebGLLayerRenderer2(layer, opt_options) {
        var _this = _super.call(this, layer) || this;
        var options = opt_options || {
        };
        /**
         * @type {WebGLHelper}
         * @protected
         */ _this.helper = new _helperJsDefault.default({
            postProcesses: options.postProcesses,
            uniforms: options.uniforms
        });
        if (options.className !== undefined) _this.helper.getCanvas().className = options.className;
        return _this;
    }
    /**
     * Clean up.
     */ WebGLLayerRenderer2.prototype.disposeInternal = function() {
        this.helper.dispose();
        delete this.helper;
        _super.prototype.disposeInternal.call(this);
    };
    /**
     * @param {import("../../render/EventType.js").default} type Event type.
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @private
     */ WebGLLayerRenderer2.prototype.dispatchRenderEvent_ = function(type, frameState) {
        var layer = this.getLayer();
        if (layer.hasListener(type)) {
            // RenderEvent does not get a context or an inversePixelTransform, because WebGL allows much less direct editing than Canvas2d does.
            var event_1 = new _eventJsDefault.default(type, null, frameState, null);
            layer.dispatchEvent(event_1);
        }
    };
    /**
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @protected
     */ WebGLLayerRenderer2.prototype.preRender = function(frameState) {
        this.dispatchRenderEvent_(_eventTypeJsDefault.default.PRERENDER, frameState);
    };
    /**
     * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
     * @protected
     */ WebGLLayerRenderer2.prototype.postRender = function(frameState) {
        this.dispatchRenderEvent_(_eventTypeJsDefault.default.POSTRENDER, frameState);
    };
    return WebGLLayerRenderer2;
}(_layerJsDefault.default);
var tmpArray_ = [];
var bufferPositions_ = {
    vertexPosition: 0,
    indexPosition: 0
};
function writePointVertex(buffer, pos, x, y, index) {
    buffer[pos + 0] = x;
    buffer[pos + 1] = y;
    buffer[pos + 2] = index;
}
function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {
    // This is for x, y and index
    var baseVertexAttrsCount = 3;
    var baseInstructionsCount = 2;
    var stride = baseVertexAttrsCount + customAttributesCount;
    var x = instructions[elementIndex + 0];
    var y = instructions[elementIndex + 1];
    // read custom numerical attributes on the feature
    var customAttrs = tmpArray_;
    customAttrs.length = customAttributesCount;
    for(var i = 0; i < customAttrs.length; i++)customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];
    var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;
    var iPos = bufferPositions ? bufferPositions.indexPosition : 0;
    var baseIndex = vPos / stride;
    // push vertices for each of the four quad corners (first standard then custom attributes)
    writePointVertex(vertexBuffer, vPos, x, y, 0);
    customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
    vPos += stride;
    writePointVertex(vertexBuffer, vPos, x, y, 1);
    customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
    vPos += stride;
    writePointVertex(vertexBuffer, vPos, x, y, 2);
    customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
    vPos += stride;
    writePointVertex(vertexBuffer, vPos, x, y, 3);
    customAttrs.length && vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);
    vPos += stride;
    indexBuffer[iPos++] = baseIndex;
    indexBuffer[iPos++] = baseIndex + 1;
    indexBuffer[iPos++] = baseIndex + 3;
    indexBuffer[iPos++] = baseIndex + 1;
    indexBuffer[iPos++] = baseIndex + 2;
    indexBuffer[iPos++] = baseIndex + 3;
    bufferPositions_.vertexPosition = vPos;
    bufferPositions_.indexPosition = iPos;
    return bufferPositions_;
}
function getBlankImageData() {
    var canvas = document.createElement('canvas');
    var image = canvas.getContext('2d').createImageData(1, 1);
    image.data[0] = 255;
    image.data[1] = 255;
    image.data[2] = 255;
    image.data[3] = 255;
    return image;
}
function colorEncodeId(id, opt_array) {
    var array = opt_array || [];
    var radix = 256;
    var divide = radix - 1;
    array[0] = Math.floor(id / radix / radix / radix) / divide;
    array[1] = Math.floor(id / radix / radix) % radix / divide;
    array[2] = Math.floor(id / radix) % radix / divide;
    array[3] = id % radix / divide;
    return array;
}
function colorDecodeId(color) {
    var id = 0;
    var radix = 256;
    var mult = radix - 1;
    id += Math.round(color[0] * radix * radix * radix * mult);
    id += Math.round(color[1] * radix * radix * mult);
    id += Math.round(color[2] * radix * mult);
    id += Math.round(color[3] * mult);
    return id;
}
exports.default = WebGLLayerRenderer1;

},{"../Layer.js":"159ZD","../../render/Event.js":"1IrqP","../../render/EventType.js":"6WjvK","../../webgl/Helper.js":"WWhT6","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"WWhT6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ShaderType", ()=>ShaderType
);
parcelHelpers.export(exports, "DefaultUniform", ()=>DefaultUniform
);
parcelHelpers.export(exports, "AttributeType", ()=>AttributeType
);
/**
 * Compute a stride in bytes based on a list of attributes
 * @param {Array<AttributeDescription>} attributes Ordered list of attributes
 * @return {number} Stride, ie amount of values for each vertex in the vertex buffer
 * @api
 */ parcelHelpers.export(exports, "computeAttributesStride", ()=>computeAttributesStride
);
/**
 * @module ol/webgl/Helper
 */ var _contextEventTypeJs = require("../webgl/ContextEventType.js");
var _contextEventTypeJsDefault = parcelHelpers.interopDefault(_contextEventTypeJs);
var _disposableJs = require("../Disposable.js");
var _disposableJsDefault = parcelHelpers.interopDefault(_disposableJs);
var _postProcessingPassJs = require("./PostProcessingPass.js");
var _postProcessingPassJsDefault = parcelHelpers.interopDefault(_postProcessingPassJs);
var _webglJs = require("../webgl.js");
var _objJs = require("../obj.js");
var _transformJs = require("../transform.js");
var _mat4Js = require("../vec/mat4.js");
var _utilJs = require("../util.js");
var __extends = undefined && undefined.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d1, b1) {
            d1.__proto__ = b1;
        } || function(d1, b1) {
            for(var p in b1)if (Object.prototype.hasOwnProperty.call(b1, p)) d1[p] = b1[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var ShaderType = {
    FRAGMENT_SHADER: 35632,
    VERTEX_SHADER: 35633
};
var DefaultUniform = {
    PROJECTION_MATRIX: 'u_projectionMatrix',
    OFFSET_SCALE_MATRIX: 'u_offsetScaleMatrix',
    OFFSET_ROTATION_MATRIX: 'u_offsetRotateMatrix',
    TIME: 'u_time',
    ZOOM: 'u_zoom',
    RESOLUTION: 'u_resolution'
};
var AttributeType = {
    UNSIGNED_BYTE: _webglJs.UNSIGNED_BYTE,
    UNSIGNED_SHORT: _webglJs.UNSIGNED_SHORT,
    UNSIGNED_INT: _webglJs.UNSIGNED_INT,
    FLOAT: _webglJs.FLOAT
};
/**
 * Description of an attribute in a buffer
 * @typedef {Object} AttributeDescription
 * @property {string} name Attribute name to use in shaders
 * @property {number} size Number of components per attributes
 * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is
 * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).
 * Default is `FLOAT`.
 */ /**
 * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import("../transform").Transform} UniformLiteralValue
 */ /**
 * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning
 * one of the previous types.
 * @typedef {UniformLiteralValue|function(import("../PluggableMap.js").FrameState):UniformLiteralValue} UniformValue
 */ /**
 * @typedef {Object} PostProcessesOptions
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas which will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step
 */ /**
 * @typedef {Object} Options
 * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform
 * names in the provided or default shaders.
 * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions
 */ /**
 * @typedef {Object} UniformInternalDescription
 * @property {string} name Name
 * @property {UniformValue} [value] Value
 * @property {WebGLTexture} [texture] Texture
 * @private
 */ /**
 * @classdesc
 * This class is intended to provide low-level functions related to WebGL rendering, so that accessing
 * directly the WebGL API should not be required anymore.
 *
 * Several operations are handled by the `WebGLHelper` class:
 *
 * ### Define custom shaders and uniforms
 *
 *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:
 *
 *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).
 *   Outputs are:
 *
 *   * `gl_Position`: position of the vertex in screen space
 *
 *   * Varyings usually prefixed with `v_` are passed on to the fragment shader
 *
 *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.
 *
 *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that
 *   can be changed at every frame and can be of type float, arrays of float or images.
 *
 *   Shaders must be compiled and assembled into a program like so:
 *   ```js
 *   // here we simply create two shaders and assemble them in a program which is then used
 *   // for subsequent rendering calls
 *   const vertexShader = new WebGLVertex(VERTEX_SHADER);
 *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);
 *   const program = this.context.getProgram(fragmentShader, vertexShader);
 *   helper.useProgram(this.program);
 *   ```
 *
 *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.
 *   You can also change their value along the way like so:
 *   ```js
 *   helper.setUniformFloatValue('u_value', valueAsNumber);
 *   ```
 *
 * ### Defining post processing passes
 *
 *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas
 *   while applying special effects in screen space.
 *   Typical uses are: blurring, color manipulation, depth of field, filtering...
 *
 *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.
 *   A post process step accepts the following options:
 *
 *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.
 *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.
 *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.
 *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.
 *
 *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.
 *
 * ### Binding WebGL buffers and flushing data into them
 *
 *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.
 *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.
 *   This is done using {@link bindBuffer}.
 *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using
 *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.
 *
 *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}
 *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).
 *
 *   Examples below:
 *   ```js
 *   // at initialization phase
 *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
 *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
 *
 *   // when array values have changed
 *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);
 *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
 *
 *   // at rendering phase
 *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);
 *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
 *   ```
 *
 * ### Specifying attributes
 *
 *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).
 *   Attributes are used to specify these uses. Use {@link enableAttributeArray_} and either
 *   the default attribute names in {@link module:ol/webgl/Helper.DefaultAttrib} or custom ones.
 *
 *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.
 *   ```js
 *   // here we indicate that the data array has the following structure:
 *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]
 *   helper.enableAttributes([
 *     {
 *        name: 'a_position',
 *        size: 2
 *     },
 *     {
 *       name: 'a_offset',
 *       size: 2
 *     },
 *     {
 *       name: 'a_texCoord',
 *       size: 2
 *     }
 *   ])
 *   ```
 *
 * ### Rendering primitives
 *
 *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.
 *   ```js
 *   // frame preparation step
 *   helper.prepareDraw(frameState);
 *
 *   // call this for every data array that has to be rendered on screen
 *   helper.drawElements(0, this.indicesBuffer.getArray().length);
 *
 *   // finalize the rendering by applying post processes
 *   helper.finalizeDraw(frameState);
 *   ```
 *
 * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.
 *
 *
 * @api
 */ var WebGLHelper1 = function(_super) {
    __extends(WebGLHelper2, _super);
    /**
     * @param {Options} [opt_options] Options.
     */ function WebGLHelper2(opt_options) {
        var _this = _super.call(this) || this;
        var options = opt_options || {
        };
        /** @private */ _this.boundHandleWebGLContextLost_ = _this.handleWebGLContextLost.bind(_this);
        /** @private */ _this.boundHandleWebGLContextRestored_ = _this.handleWebGLContextRestored.bind(_this);
        /**
         * @private
         * @type {HTMLCanvasElement}
         */ _this.canvas_ = document.createElement('canvas');
        _this.canvas_.style.position = 'absolute';
        _this.canvas_.style.left = '0';
        /**
         * @private
         * @type {WebGLRenderingContext}
         */ _this.gl_ = _webglJs.getContext(_this.canvas_);
        var gl = _this.getGL();
        /**
         * @private
         * @type {!Object<string, BufferCacheEntry>}
         */ _this.bufferCache_ = {
        };
        /**
         * @private
         * @type {Object<string, Object>}
         */ _this.extensionCache_ = {
        };
        /**
         * @private
         * @type {WebGLProgram}
         */ _this.currentProgram_ = null;
        _this.canvas_.addEventListener(_contextEventTypeJsDefault.default.LOST, _this.boundHandleWebGLContextLost_);
        _this.canvas_.addEventListener(_contextEventTypeJsDefault.default.RESTORED, _this.boundHandleWebGLContextRestored_);
        /**
         * @private
         * @type {import("../transform.js").Transform}
         */ _this.offsetRotateMatrix_ = _transformJs.create();
        /**
         * @private
         * @type {import("../transform.js").Transform}
         */ _this.offsetScaleMatrix_ = _transformJs.create();
        /**
         * @private
         * @type {Array<number>}
         */ _this.tmpMat4_ = _mat4Js.create();
        /**
         * @private
         * @type {Object<string, WebGLUniformLocation>}
         */ _this.uniformLocations_ = {
        };
        /**
         * @private
         * @type {Object<string, number>}
         */ _this.attribLocations_ = {
        };
        /**
         * Holds info about custom uniforms used in the post processing pass.
         * If the uniform is a texture, the WebGL Texture object will be stored here.
         * @type {Array<UniformInternalDescription>}
         * @private
         */ _this.uniforms_ = [];
        if (options.uniforms) for(var name_1 in options.uniforms)_this.uniforms_.push({
            name: name_1,
            value: options.uniforms[name_1]
        });
        /**
         * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the
         * options. If no post process was given, a default one is used (so as not to have to make an exception to
         * the frame buffer logic).
         * @type {Array<WebGLPostProcessingPass>}
         * @private
         */ _this.postProcessPasses_ = options.postProcesses ? options.postProcesses.map(function(options1) {
            return new _postProcessingPassJsDefault.default({
                webGlContext: gl,
                scaleRatio: options1.scaleRatio,
                vertexShader: options1.vertexShader,
                fragmentShader: options1.fragmentShader,
                uniforms: options1.uniforms
            });
        }) : [
            new _postProcessingPassJsDefault.default({
                webGlContext: gl
            })
        ];
        /**
         * @type {string|null}
         * @private
         */ _this.shaderCompileErrors_ = null;
        /**
         * @type {number}
         * @private
         */ _this.startTime_ = Date.now();
        return _this;
    }
    /**
     * Get a WebGL extension.  If the extension is not supported, null is returned.
     * Extensions are cached after they are enabled for the first time.
     * @param {string} name The extension name.
     * @return {Object} The extension or null if not supported.
     */ WebGLHelper2.prototype.getExtension = function(name) {
        if (name in this.extensionCache_) return this.extensionCache_[name];
        var extension = this.gl_.getExtension(name);
        this.extensionCache_[name] = extension;
        return extension;
    };
    /**
     * Just bind the buffer if it's in the cache. Otherwise create
     * the WebGL buffer, bind it, populate it, and add an entry to
     * the cache.
     * @param {import("./Buffer").default} buffer Buffer.
     * @api
     */ WebGLHelper2.prototype.bindBuffer = function(buffer) {
        var gl = this.getGL();
        var bufferKey = _utilJs.getUid(buffer);
        var bufferCache = this.bufferCache_[bufferKey];
        if (!bufferCache) {
            var webGlBuffer = gl.createBuffer();
            bufferCache = {
                buffer: buffer,
                webGlBuffer: webGlBuffer
            };
            this.bufferCache_[bufferKey] = bufferCache;
        }
        gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);
    };
    /**
     * Update the data contained in the buffer array; this is required for the
     * new data to be rendered
     * @param {import("./Buffer").default} buffer Buffer.
     * @api
     */ WebGLHelper2.prototype.flushBufferData = function(buffer) {
        var gl = this.getGL();
        this.bindBuffer(buffer);
        gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());
    };
    /**
     * @param {import("./Buffer.js").default} buf Buffer.
     */ WebGLHelper2.prototype.deleteBuffer = function(buf) {
        var gl = this.getGL();
        var bufferKey = _utilJs.getUid(buf);
        var bufferCacheEntry = this.bufferCache_[bufferKey];
        if (bufferCacheEntry && !gl.isContextLost()) gl.deleteBuffer(bufferCacheEntry.webGlBuffer);
        delete this.bufferCache_[bufferKey];
    };
    /**
     * Clean up.
     */ WebGLHelper2.prototype.disposeInternal = function() {
        this.canvas_.removeEventListener(_contextEventTypeJsDefault.default.LOST, this.boundHandleWebGLContextLost_);
        this.canvas_.removeEventListener(_contextEventTypeJsDefault.default.RESTORED, this.boundHandleWebGLContextRestored_);
        var extension = this.gl_.getExtension('WEBGL_lose_context');
        if (extension) extension.loseContext();
        delete this.gl_;
        delete this.canvas_;
    };
    /**
     * Clear the buffer & set the viewport to draw.
     * Post process passes will be initialized here, the first one being bound as a render target for
     * subsequent draw calls.
     * @param {import("../PluggableMap.js").FrameState} frameState current frame state
     * @param {boolean} [opt_disableAlphaBlend] If true, no alpha blending will happen.
     * @api
     */ WebGLHelper2.prototype.prepareDraw = function(frameState, opt_disableAlphaBlend) {
        var gl = this.getGL();
        var canvas = this.getCanvas();
        var size = frameState.size;
        var pixelRatio = frameState.pixelRatio;
        canvas.width = size[0] * pixelRatio;
        canvas.height = size[1] * pixelRatio;
        canvas.style.width = size[0] + 'px';
        canvas.style.height = size[1] + 'px';
        gl.useProgram(this.currentProgram_);
        // loop backwards in post processes list
        for(var i = this.postProcessPasses_.length - 1; i >= 0; i--)this.postProcessPasses_[i].init(frameState);
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
        gl.useProgram(this.currentProgram_);
        this.applyFrameState(frameState);
        this.applyUniforms(frameState);
    };
    /**
     * Clear the render target & bind it for future draw operations.
     * This is similar to `prepareDraw`, only post processes will not be applied.
     * Note: the whole viewport will be drawn to the render target, regardless of its size.
     * @param {import("../PluggableMap.js").FrameState} frameState current frame state
     * @param {import("./RenderTarget.js").default} renderTarget Render target to draw to
     * @param {boolean} [opt_disableAlphaBlend] If true, no alpha blending will happen.
     */ WebGLHelper2.prototype.prepareDrawToRenderTarget = function(frameState, renderTarget, opt_disableAlphaBlend) {
        var gl = this.getGL();
        var size = renderTarget.getSize();
        gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());
        gl.viewport(0, 0, size[0], size[1]);
        gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
        gl.useProgram(this.currentProgram_);
        this.applyFrameState(frameState);
        this.applyUniforms(frameState);
    };
    /**
     * Execute a draw call based on the currently bound program, texture, buffers, attributes.
     * @param {number} start Start index.
     * @param {number} end End index.
     * @api
     */ WebGLHelper2.prototype.drawElements = function(start, end) {
        var gl = this.getGL();
        this.getExtension('OES_element_index_uint');
        var elementType = gl.UNSIGNED_INT;
        var elementSize = 4;
        var numItems = end - start;
        var offsetInBytes = start * elementSize;
        gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);
    };
    /**
     * Apply the successive post process passes which will eventually render to the actual canvas.
     * @param {import("../PluggableMap.js").FrameState} frameState current frame state
     * @api
     */ WebGLHelper2.prototype.finalizeDraw = function(frameState) {
        // apply post processes using the next one as target
        for(var i = 0; i < this.postProcessPasses_.length; i++)this.postProcessPasses_[i].apply(frameState, this.postProcessPasses_[i + 1] || null);
    };
    /**
     * @return {HTMLCanvasElement} Canvas.
     * @api
     */ WebGLHelper2.prototype.getCanvas = function() {
        return this.canvas_;
    };
    /**
     * Get the WebGL rendering context
     * @return {WebGLRenderingContext} The rendering context.
     * @api
     */ WebGLHelper2.prototype.getGL = function() {
        return this.gl_;
    };
    /**
     * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     * @private
     */ WebGLHelper2.prototype.applyFrameState = function(frameState) {
        var size = frameState.size;
        var rotation = frameState.viewState.rotation;
        var offsetScaleMatrix = _transformJs.reset(this.offsetScaleMatrix_);
        _transformJs.scale(offsetScaleMatrix, 2 / size[0], 2 / size[1]);
        var offsetRotateMatrix = _transformJs.reset(this.offsetRotateMatrix_);
        if (rotation !== 0) _transformJs.rotate(offsetRotateMatrix, -rotation);
        this.setUniformMatrixValue(DefaultUniform.OFFSET_SCALE_MATRIX, _mat4Js.fromTransform(this.tmpMat4_, offsetScaleMatrix));
        this.setUniformMatrixValue(DefaultUniform.OFFSET_ROTATION_MATRIX, _mat4Js.fromTransform(this.tmpMat4_, offsetRotateMatrix));
        this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 0.001);
        this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);
        this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);
    };
    /**
     * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     * @private
     */ WebGLHelper2.prototype.applyUniforms = function(frameState) {
        var gl = this.getGL();
        var value;
        var textureSlot = 0;
        this.uniforms_.forEach((function(uniform) {
            value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value;
            // apply value based on type
            if (value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof ImageData) {
                // create a texture & put data
                if (!uniform.texture) {
                    uniform.prevValue = undefined;
                    uniform.texture = gl.createTexture();
                }
                gl.activeTexture(gl["TEXTURE" + textureSlot]);
                gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                var imageReady = !(value instanceof HTMLImageElement) || /** @type {HTMLImageElement} */ value.complete;
                if (imageReady && uniform.prevValue !== value) {
                    uniform.prevValue = value;
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
                }
                // fill texture slots by increasing index
                gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);
            } else if (Array.isArray(value) && value.length === 6) this.setUniformMatrixValue(uniform.name, _mat4Js.fromTransform(this.tmpMat4_, value));
            else if (Array.isArray(value) && value.length <= 4) switch(value.length){
                case 2:
                    gl.uniform2f(this.getUniformLocation(uniform.name), value[0], value[1]);
                    return;
                case 3:
                    gl.uniform3f(this.getUniformLocation(uniform.name), value[0], value[1], value[2]);
                    return;
                case 4:
                    gl.uniform4f(this.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);
                    return;
                default:
                    return;
            }
            else if (typeof value === 'number') gl.uniform1f(this.getUniformLocation(uniform.name), value);
        }).bind(this));
    };
    /**
     * Use a program.  If the program is already in use, this will return `false`.
     * @param {WebGLProgram} program Program.
     * @return {boolean} Changed.
     * @api
     */ WebGLHelper2.prototype.useProgram = function(program) {
        if (program == this.currentProgram_) return false;
        else {
            var gl = this.getGL();
            gl.useProgram(program);
            this.currentProgram_ = program;
            this.uniformLocations_ = {
            };
            this.attribLocations_ = {
            };
            return true;
        }
    };
    /**
     * Will attempt to compile a vertex or fragment shader based on source
     * On error, the shader will be returned but
     * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`
     * Use `gl.getShaderInfoLog(shader)` to have details
     * @param {string} source Shader source
     * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER
     * @return {WebGLShader} Shader object
     */ WebGLHelper2.prototype.compileShader = function(source, type) {
        var gl = this.getGL();
        var shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
    };
    /**
     * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.
     * @param {string} fragmentShaderSource Fragment shader source.
     * @param {string} vertexShaderSource Vertex shader source.
     * @return {WebGLProgram} Program
     * @api
     */ WebGLHelper2.prototype.getProgram = function(fragmentShaderSource, vertexShaderSource) {
        var gl = this.getGL();
        var fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        var vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        var program = gl.createProgram();
        gl.attachShader(program, fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.linkProgram(program);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            var message = "Fragment shader compliation failed: " + gl.getShaderInfoLog(fragmentShader);
            throw new Error(message);
        }
        gl.deleteShader(fragmentShader);
        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            var message = "Vertex shader compilation failed: " + gl.getShaderInfoLog(vertexShader);
            throw new Error(message);
        }
        gl.deleteShader(vertexShader);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            var message = "GL program linking failed: " + gl.getShaderInfoLog(vertexShader);
            throw new Error(message);
        }
        return program;
    };
    /**
     * Will get the location from the shader or the cache
     * @param {string} name Uniform name
     * @return {WebGLUniformLocation} uniformLocation
     * @api
     */ WebGLHelper2.prototype.getUniformLocation = function(name) {
        if (this.uniformLocations_[name] === undefined) this.uniformLocations_[name] = this.getGL().getUniformLocation(this.currentProgram_, name);
        return this.uniformLocations_[name];
    };
    /**
     * Will get the location from the shader or the cache
     * @param {string} name Attribute name
     * @return {number} attribLocation
     * @api
     */ WebGLHelper2.prototype.getAttributeLocation = function(name) {
        if (this.attribLocations_[name] === undefined) this.attribLocations_[name] = this.getGL().getAttribLocation(this.currentProgram_, name);
        return this.attribLocations_[name];
    };
    /**
     * Modifies the given transform to apply the rotation/translation/scaling of the given frame state.
     * The resulting transform can be used to convert world space coordinates to view coordinates.
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     * @param {import("../transform").Transform} transform Transform to update.
     * @return {import("../transform").Transform} The updated transform object.
     * @api
     */ WebGLHelper2.prototype.makeProjectionTransform = function(frameState, transform) {
        var size = frameState.size;
        var rotation = frameState.viewState.rotation;
        var resolution = frameState.viewState.resolution;
        var center = frameState.viewState.center;
        _transformJs.reset(transform);
        _transformJs.compose(transform, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);
        return transform;
    };
    /**
     * Give a value for a standard float uniform
     * @param {string} uniform Uniform name
     * @param {number} value Value
     * @api
     */ WebGLHelper2.prototype.setUniformFloatValue = function(uniform, value) {
        this.getGL().uniform1f(this.getUniformLocation(uniform), value);
    };
    /**
     * Give a value for a standard matrix4 uniform
     * @param {string} uniform Uniform name
     * @param {Array<number>} value Matrix value
     * @api
     */ WebGLHelper2.prototype.setUniformMatrixValue = function(uniform, value) {
        this.getGL().uniformMatrix4fv(this.getUniformLocation(uniform), false, value);
    };
    /**
     * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`
     * internally.
     * @param {string} attribName Attribute name
     * @param {number} size Number of components per attributes
     * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT
     * @param {number} stride Stride in bytes (0 means attribs are packed)
     * @param {number} offset Offset in bytes
     * @private
     */ WebGLHelper2.prototype.enableAttributeArray_ = function(attribName, size, type, stride, offset) {
        var location = this.getAttributeLocation(attribName);
        // the attribute has not been found in the shaders; do not enable it
        if (location < 0) return;
        this.getGL().enableVertexAttribArray(location);
        this.getGL().vertexAttribPointer(location, size, type, false, stride, offset);
    };
    /**
     * Will enable the following attributes to be read from the currently bound buffer,
     * i.e. tell the GPU where to read the different attributes in the buffer. An error in the
     * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.
     * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
     * @api
     */ WebGLHelper2.prototype.enableAttributes = function(attributes) {
        var stride = computeAttributesStride(attributes);
        var offset = 0;
        for(var i = 0; i < attributes.length; i++){
            var attr = attributes[i];
            this.enableAttributeArray_(attr.name, attr.size, attr.type || _webglJs.FLOAT, stride, offset);
            offset += attr.size * getByteSizeFromType(attr.type);
        }
    };
    /**
     * WebGL context was lost
     * @private
     */ WebGLHelper2.prototype.handleWebGLContextLost = function() {
        _objJs.clear(this.bufferCache_);
        this.currentProgram_ = null;
    };
    /**
     * WebGL context was restored
     * @private
     */ WebGLHelper2.prototype.handleWebGLContextRestored = function() {
    };
    /**
     * Will create or reuse a given webgl texture and apply the given size. If no image data
     * specified, the texture will be empty, otherwise image data will be used and the `size`
     * parameter will be ignored.
     * Note: wrap parameters are set to clamp to edge, min filter is set to linear.
     * @param {Array<number>} size Expected size of the texture
     * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [opt_data] Image data/object to bind to the texture
     * @param {WebGLTexture} [opt_texture] Existing texture to reuse
     * @return {WebGLTexture} The generated texture
     * @api
     */ WebGLHelper2.prototype.createTexture = function(size, opt_data, opt_texture) {
        var gl = this.getGL();
        var texture = opt_texture || gl.createTexture();
        // set params & size
        var level = 0;
        var internalFormat = gl.RGBA;
        var border = 0;
        var format = gl.RGBA;
        var type = gl.UNSIGNED_BYTE;
        gl.bindTexture(gl.TEXTURE_2D, texture);
        if (opt_data) gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, opt_data);
        else gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format, type, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        return texture;
    };
    return WebGLHelper2;
}(_disposableJsDefault.default);
function computeAttributesStride(attributes) {
    var stride = 0;
    for(var i = 0; i < attributes.length; i++){
        var attr = attributes[i];
        stride += attr.size * getByteSizeFromType(attr.type);
    }
    return stride;
}
/**
 * Computes the size in byte of an attribute type.
 * @param {AttributeType} type Attribute type
 * @return {number} The size in bytes
 */ function getByteSizeFromType(type) {
    switch(type){
        case AttributeType.UNSIGNED_BYTE:
            return Uint8Array.BYTES_PER_ELEMENT;
        case AttributeType.UNSIGNED_SHORT:
            return Uint16Array.BYTES_PER_ELEMENT;
        case AttributeType.UNSIGNED_INT:
            return Uint32Array.BYTES_PER_ELEMENT;
        case AttributeType.FLOAT:
        default:
            return Float32Array.BYTES_PER_ELEMENT;
    }
}
exports.default = WebGLHelper1;

},{"../webgl/ContextEventType.js":"4etp6","../Disposable.js":"b72Yc","./PostProcessingPass.js":"lojQ1","../webgl.js":"lVL8j","../obj.js":"g3fPg","../transform.js":"C21tg","../vec/mat4.js":"3asgG","../util.js":"9zOhk","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"4etp6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    LOST: 'webglcontextlost',
    RESTORED: 'webglcontextrestored'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"lojQ1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/webgl/PostProcessingPass
 */ var DEFAULT_VERTEX_SHADER = "\n  precision mediump float;\n  \n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n  \n  uniform vec2 u_screenSize;\n   \n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n";
var DEFAULT_FRAGMENT_SHADER = "\n  precision mediump float;\n   \n  uniform sampler2D u_image;\n   \n  varying vec2 v_texCoord;\n   \n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord);\n  }\n";
/**
 * @typedef {Object} Options
 * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.
 * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
 * the main canvas that will then be sampled up (useful for saving resource on blur steps).
 * @property {string} [vertexShader] Vertex shader source
 * @property {string} [fragmentShader] Fragment shader source
 * @property {Object<string,import("./Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
 */ /**
 * @typedef {Object} UniformInternalDescription
 * @property {import("./Helper").UniformValue} value Value
 * @property {number} location Location
 * @property {WebGLTexture} [texture] Texture
 * @private
 */ /**
 * @classdesc
 * This class is used to define Post Processing passes with custom shaders and uniforms.
 * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.
 *
 * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that
 * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).
 * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.
 *
 * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be
 * premultiplied.
 *
 * Default shaders are shown hereafter:
 *
 * * Vertex shader:
 *
 *   ```
 *   precision mediump float;
 *
 *   attribute vec2 a_position;
 *   varying vec2 v_texCoord;
 *   varying vec2 v_screenCoord;
 *
 *   uniform vec2 u_screenSize;
 *
 *   void main() {
 *     v_texCoord = a_position * 0.5 + 0.5;
 *     v_screenCoord = v_texCoord * u_screenSize;
 *     gl_Position = vec4(a_position, 0.0, 1.0);
 *   }
 *   ```
 *
 * * Fragment shader:
 *
 *   ```
 *   precision mediump float;
 *
 *   uniform sampler2D u_image;
 *
 *   varying vec2 v_texCoord;
 *
 *   void main() {
 *     gl_FragColor = texture2D(u_image, v_texCoord);
 *   }
 *   ```
 *
 * @api
 */ var WebGLPostProcessingPass = function() {
    /**
     * @param {Options} options Options.
     */ function WebGLPostProcessingPass1(options) {
        this.gl_ = options.webGlContext;
        var gl = this.gl_;
        this.scaleRatio_ = options.scaleRatio || 1;
        this.renderTargetTexture_ = gl.createTexture();
        this.renderTargetTextureSize_ = null;
        this.frameBuffer_ = gl.createFramebuffer();
        // compile the program for the frame buffer
        // TODO: make compilation errors show up
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);
        gl.compileShader(vertexShader);
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);
        gl.compileShader(fragmentShader);
        this.renderTargetProgram_ = gl.createProgram();
        gl.attachShader(this.renderTargetProgram_, vertexShader);
        gl.attachShader(this.renderTargetProgram_, fragmentShader);
        gl.linkProgram(this.renderTargetProgram_);
        // bind the vertices buffer for the frame buffer
        this.renderTargetVerticesBuffer_ = gl.createBuffer();
        var verticesArray = [
            -1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            1
        ];
        gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);
        this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, 'a_position');
        this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_screenSize');
        this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_image');
        /**
         * Holds info about custom uniforms used in the post processing pass
         * @type {Array<UniformInternalDescription>}
         * @private
         */ this.uniforms_ = [];
        options.uniforms && Object.keys(options.uniforms).forEach((function(name) {
            this.uniforms_.push({
                value: options.uniforms[name],
                location: gl.getUniformLocation(this.renderTargetProgram_, name)
            });
        }).bind(this));
    }
    /**
     * Get the WebGL rendering context
     * @return {WebGLRenderingContext} The rendering context.
     * @api
     */ WebGLPostProcessingPass1.prototype.getGL = function() {
        return this.gl_;
    };
    /**
     * Initialize the render target texture of the post process, make sure it is at the
     * right size and bind it as a render target for the next draw calls.
     * The last step to be initialized will be the one where the primitives are rendered.
     * @param {import("../PluggableMap.js").FrameState} frameState current frame state
     * @api
     */ WebGLPostProcessingPass1.prototype.init = function(frameState) {
        var gl = this.getGL();
        var textureSize = [
            gl.drawingBufferWidth * this.scaleRatio_,
            gl.drawingBufferHeight * this.scaleRatio_, 
        ];
        // rendering goes to my buffer
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());
        gl.viewport(0, 0, textureSize[0], textureSize[1]);
        // if size has changed: adjust canvas & render target texture
        if (!this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {
            this.renderTargetTextureSize_ = textureSize;
            // create a new texture
            var level = 0;
            var internalFormat = gl.RGBA;
            var border = 0;
            var format = gl.RGBA;
            var type = gl.UNSIGNED_BYTE;
            var data = null;
            gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            // bind the texture to the framebuffer
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);
        }
    };
    /**
     * Render to the next postprocessing pass (or to the canvas if final pass).
     * @param {import("../PluggableMap.js").FrameState} frameState current frame state
     * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional
     * @api
     */ WebGLPostProcessingPass1.prototype.apply = function(frameState, nextPass) {
        var gl = this.getGL();
        var size = frameState.size;
        gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
        // render the frame buffer to the canvas
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
        gl.useProgram(this.renderTargetProgram_);
        gl.enableVertexAttribArray(this.renderTargetAttribLocation_);
        gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);
        gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);
        gl.uniform1i(this.renderTargetTextureLocation_, 0);
        this.applyUniforms(frameState);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    };
    /**
     * @return {WebGLFramebuffer} Frame buffer
     * @api
     */ WebGLPostProcessingPass1.prototype.getFrameBuffer = function() {
        return this.frameBuffer_;
    };
    /**
     * Sets the custom uniforms based on what was given in the constructor.
     * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
     * @private
     */ WebGLPostProcessingPass1.prototype.applyUniforms = function(frameState) {
        var gl = this.getGL();
        var value;
        var textureSlot = 1;
        this.uniforms_.forEach(function(uniform) {
            value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value;
            // apply value based on type
            if (value instanceof HTMLCanvasElement || value instanceof ImageData) {
                // create a texture & put data
                if (!uniform.texture) uniform.texture = gl.createTexture();
                gl.activeTexture(gl["TEXTURE" + textureSlot]);
                gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                if (value instanceof ImageData) gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));
                else gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
                // fill texture slots
                gl.uniform1i(uniform.location, textureSlot++);
            } else if (Array.isArray(value)) switch(value.length){
                case 2:
                    gl.uniform2f(uniform.location, value[0], value[1]);
                    return;
                case 3:
                    gl.uniform3f(uniform.location, value[0], value[1], value[2]);
                    return;
                case 4:
                    gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);
                    return;
                default:
                    return;
            }
            else if (typeof value === 'number') gl.uniform1f(uniform.location, value);
        });
    };
    return WebGLPostProcessingPass1;
}();
exports.default = WebGLPostProcessingPass;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"3asgG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @module ol/vec/mat4
 */ /**
 * @return {Array<number>} "4x4 matrix representing a 3D identity transform."
 */ parcelHelpers.export(exports, "create", ()=>create
);
/**
 * @param {Array<number>} mat4 Flattened 4x4 matrix receiving the result.
 * @param {import("../transform.js").Transform} transform Transformation matrix.
 * @return {Array<number>} "2D transformation matrix as flattened 4x4 matrix."
 */ parcelHelpers.export(exports, "fromTransform", ()=>fromTransform
);
function create() {
    return [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
}
function fromTransform(mat4, transform) {
    mat4[0] = transform[0];
    mat4[1] = transform[1];
    mat4[4] = transform[2];
    mat4[5] = transform[3];
    mat4[12] = transform[4];
    mat4[13] = transform[5];
    return mat4;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"hep5n":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ValueTypes", ()=>ValueTypes
);
parcelHelpers.export(exports, "Operators", ()=>Operators
);
/**
 * Returns the possible types for a given value (each type being a binary flag)
 * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`
 * @param {ExpressionValue} value Value
 * @return {ValueTypes|number} Type or types inferred from the value
 */ parcelHelpers.export(exports, "getValueType", ()=>getValueType
);
/**
 * Checks if only one value type is enabled in the input number.
 * @param {ValueTypes|number} valueType Number containing value type binary flags
 * @return {boolean} True if only one type flag is enabled, false if zero or multiple
 */ parcelHelpers.export(exports, "isTypeUnique", ()=>isTypeUnique
);
/**
 * Context available during the parsing of an expression.
 * @typedef {Object} ParsingContext
 * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader
 * @property {Array<string>} variables List of variables used in the expression; contains **unprefixed names**
 * @property {Array<string>} attributes List of attributes used in the expression; contains **unprefixed names**
 * @property {Object<string, number>} stringLiteralsMap This object maps all encountered string values to a number
 * @property {number} [bandCount] Number of bands per pixel.
 */ /**
 * Will return the number as a float with a dot separator, which is required by GLSL.
 * @param {number} v Numerical value.
 * @return {string} The value as string.
 */ parcelHelpers.export(exports, "numberToGlsl", ()=>numberToGlsl
);
/**
 * Will return the number array as a float with a dot separator, concatenated with ', '.
 * @param {Array<number>} array Numerical values array.
 * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.
 */ parcelHelpers.export(exports, "arrayToGlsl", ()=>arrayToGlsl
);
/**
 * Will normalize and converts to string a `vec4` color array compatible with GLSL.
 * @param {string|import("../color.js").Color} color Color either in string format or [r, g, b, a] array format,
 * with RGB components in the 0..255 range and the alpha component in the 0..1 range.
 * Note that the final array will always have 4 components.
 * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.
 */ parcelHelpers.export(exports, "colorToGlsl", ()=>colorToGlsl
);
/**
 * Returns a stable equivalent number for the string literal.
 * @param {ParsingContext} context Parsing context
 * @param {string} string String literal value
 * @return {number} Number equivalent
 */ parcelHelpers.export(exports, "getStringNumberEquivalent", ()=>getStringNumberEquivalent
);
/**
 * Returns a stable equivalent number for the string literal, for use in shaders. This number is then
 * converted to be a GLSL-compatible string.
 * @param {ParsingContext} context Parsing context
 * @param {string} string String literal value
 * @return {string} GLSL-compatible string containing a number
 */ parcelHelpers.export(exports, "stringToGlsl", ()=>stringToGlsl
);
/**
 * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that
 * will be read and modified during the parsing operation.
 * @param {ParsingContext} context Parsing context
 * @param {ExpressionValue} value Value
 * @param {ValueTypes|number} [typeHint] Hint for the expected final type (can be several types combined)
 * @return {string} GLSL-compatible output
 */ parcelHelpers.export(exports, "expressionToGlsl", ()=>expressionToGlsl
);
/**
 * Get the uniform name given a variable name.
 * @param {string} variableName The variable name.
 * @return {string} The uniform name.
 */ parcelHelpers.export(exports, "uniformNameForVariable", ()=>uniformNameForVariable
);
/**
 * Operators and utilities used for style expressions
 * @module ol/style/expressions
 */ var _tileLayerJs = require("../renderer/webgl/TileLayer.js");
var _colorJs = require("../color.js");
var _mathJs = require("../math.js");
var ValueTypes = {
    NUMBER: 1,
    STRING: 2,
    COLOR: 4,
    BOOLEAN: 8,
    NUMBER_ARRAY: 16,
    ANY: 31,
    NONE: 0
};
var Operators = {
};
function getValueType(value) {
    if (typeof value === 'number') return ValueTypes.NUMBER;
    if (typeof value === 'boolean') return ValueTypes.BOOLEAN;
    if (typeof value === 'string') {
        if (_colorJs.isStringColor(value)) return ValueTypes.COLOR | ValueTypes.STRING;
        return ValueTypes.STRING;
    }
    if (!Array.isArray(value)) throw new Error("Unhandled value type: " + JSON.stringify(value));
    var valueArr = value;
    var onlyNumbers = valueArr.every(function(v) {
        return typeof v === 'number';
    });
    if (onlyNumbers) {
        if (valueArr.length === 3 || valueArr.length === 4) return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;
        return ValueTypes.NUMBER_ARRAY;
    }
    if (typeof valueArr[0] !== 'string') throw new Error("Expected an expression operator but received: " + JSON.stringify(valueArr));
    var operator = Operators[valueArr[0]];
    if (operator === undefined) throw new Error("Unrecognized expression operator: " + JSON.stringify(valueArr));
    return operator.getReturnType(valueArr.slice(1));
}
function isTypeUnique(valueType) {
    return _mathJs.log2(valueType) % 1 === 0;
}
function numberToGlsl(v) {
    var s = v.toString();
    return s.indexOf('.') === -1 ? s + '.0' : s;
}
function arrayToGlsl(array) {
    if (array.length < 2 || array.length > 4) throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');
    return "vec" + array.length + "(" + array.map(numberToGlsl).join(', ') + ")";
}
function colorToGlsl(color) {
    var array = _colorJs.asArray(color).slice();
    if (array.length < 4) array.push(1);
    return arrayToGlsl(array.map(function(c, i) {
        return i < 3 ? c / 255 : c;
    }));
}
function getStringNumberEquivalent(context, string) {
    if (context.stringLiteralsMap[string] === undefined) context.stringLiteralsMap[string] = Object.keys(context.stringLiteralsMap).length;
    return context.stringLiteralsMap[string];
}
function stringToGlsl(context, string) {
    return numberToGlsl(getStringNumberEquivalent(context, string));
}
function expressionToGlsl(context, value, typeHint) {
    // operator
    if (Array.isArray(value) && typeof value[0] === 'string') {
        var operator = Operators[value[0]];
        if (operator === undefined) throw new Error("Unrecognized expression operator: " + JSON.stringify(value));
        return operator.toGlsl(context, value.slice(1), typeHint);
    }
    var valueType = getValueType(value);
    if ((valueType & ValueTypes.NUMBER) > 0) return numberToGlsl(value);
    if ((valueType & ValueTypes.BOOLEAN) > 0) return value.toString();
    if ((valueType & ValueTypes.STRING) > 0 && (typeHint === undefined || typeHint == ValueTypes.STRING)) return stringToGlsl(context, value.toString());
    if ((valueType & ValueTypes.COLOR) > 0 && (typeHint === undefined || typeHint == ValueTypes.COLOR)) return colorToGlsl(value);
    if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) return arrayToGlsl(value);
    throw new Error("Unexpected expression " + value + " (expected type " + typeHint + ")");
}
function assertNumber(value) {
    if (!(getValueType(value) & ValueTypes.NUMBER)) throw new Error("A numeric value was expected, got " + JSON.stringify(value) + " instead");
}
function assertNumbers(values) {
    for(var i = 0; i < values.length; i++)assertNumber(values[i]);
}
function assertString(value) {
    if (!(getValueType(value) & ValueTypes.STRING)) throw new Error("A string value was expected, got " + JSON.stringify(value) + " instead");
}
function assertBoolean(value) {
    if (!(getValueType(value) & ValueTypes.BOOLEAN)) throw new Error("A boolean value was expected, got " + JSON.stringify(value) + " instead");
}
function assertArgsCount(args, count) {
    if (args.length !== count) throw new Error("Exactly " + count + " arguments were expected, got " + args.length + " instead");
}
function assertArgsMinCount(args, count) {
    if (args.length < count) throw new Error("At least " + count + " arguments were expected, got " + args.length + " instead");
}
function assertArgsMaxCount(args, count) {
    if (args.length > count) throw new Error("At most " + count + " arguments were expected, got " + args.length + " instead");
}
function assertArgsEven(args) {
    if (args.length % 2 !== 0) throw new Error("An even amount of arguments was expected, got " + args + " instead");
}
function assertArgsOdd(args) {
    if (args.length % 2 === 0) throw new Error("An odd amount of arguments was expected, got " + args + " instead");
}
function assertUniqueInferredType(args, types) {
    if (!isTypeUnique(types)) throw new Error("Could not infer only one type from the following expression: " + JSON.stringify(args));
}
Operators['get'] = {
    getReturnType: function(args) {
        return ValueTypes.ANY;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 1);
        assertString(args[0]);
        var value = args[0].toString();
        if (context.attributes.indexOf(value) === -1) context.attributes.push(value);
        var prefix = context.inFragmentShader ? 'v_' : 'a_';
        return prefix + value;
    }
};
function uniformNameForVariable(variableName) {
    return 'u_var_' + variableName;
}
Operators['var'] = {
    getReturnType: function(args) {
        return ValueTypes.ANY;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 1);
        assertString(args[0]);
        var value = args[0].toString();
        if (context.variables.indexOf(value) === -1) context.variables.push(value);
        return uniformNameForVariable(value);
    }
};
Operators['band'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER;
    },
    toGlsl: function(context, args) {
        assertArgsMinCount(args, 1);
        assertArgsMaxCount(args, 3);
        var band = args[0];
        if (typeof band !== 'number') throw new Error('Band index must be a number');
        var zeroBasedBand = band - 1;
        var colorIndex = Math.floor(zeroBasedBand / 4);
        var bandIndex = zeroBasedBand % 4;
        if (band === context.bandCount && bandIndex === 1) // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha
        bandIndex = 3;
        if (args.length === 1) return "color" + colorIndex + "[" + bandIndex + "]";
        else {
            var xOffset = args[1];
            var yOffset = args[2] || 0;
            assertNumber(xOffset);
            assertNumber(yOffset);
            var uniformName = _tileLayerJs.Uniforms.TILE_TEXTURE_PREFIX + colorIndex;
            return "texture2D(" + uniformName + ", v_textureCoord + vec2(" + expressionToGlsl(context, xOffset) + " / " + _tileLayerJs.Uniforms.TEXTURE_PIXEL_WIDTH + ", " + expressionToGlsl(context, yOffset) + " / " + _tileLayerJs.Uniforms.TEXTURE_PIXEL_HEIGHT + "))[" + bandIndex + "]";
        }
    }
};
Operators['time'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 0);
        return 'u_time';
    }
};
Operators['zoom'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 0);
        return 'u_zoom';
    }
};
Operators['resolution'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 0);
        return 'u_resolution';
    }
};
Operators['*'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 2);
        assertNumbers(args);
        return "(" + expressionToGlsl(context, args[0]) + " * " + expressionToGlsl(context, args[1]) + ")";
    }
};
Operators['/'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 2);
        assertNumbers(args);
        return "(" + expressionToGlsl(context, args[0]) + " / " + expressionToGlsl(context, args[1]) + ")";
    }
};
Operators['+'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 2);
        assertNumbers(args);
        return "(" + expressionToGlsl(context, args[0]) + " + " + expressionToGlsl(context, args[1]) + ")";
    }
};
Operators['-'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 2);
        assertNumbers(args);
        return "(" + expressionToGlsl(context, args[0]) + " - " + expressionToGlsl(context, args[1]) + ")";
    }
};
Operators['clamp'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 3);
        assertNumbers(args);
        var min = expressionToGlsl(context, args[1]);
        var max = expressionToGlsl(context, args[2]);
        return "clamp(" + expressionToGlsl(context, args[0]) + ", " + min + ", " + max + ")";
    }
};
Operators['%'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 2);
        assertNumbers(args);
        return "mod(" + expressionToGlsl(context, args[0]) + ", " + expressionToGlsl(context, args[1]) + ")";
    }
};
Operators['^'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 2);
        assertNumbers(args);
        return "pow(" + expressionToGlsl(context, args[0]) + ", " + expressionToGlsl(context, args[1]) + ")";
    }
};
Operators['abs'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 1);
        assertNumbers(args);
        return "abs(" + expressionToGlsl(context, args[0]) + ")";
    }
};
Operators['sin'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 1);
        assertNumbers(args);
        return "sin(" + expressionToGlsl(context, args[0]) + ")";
    }
};
Operators['cos'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 1);
        assertNumbers(args);
        return "cos(" + expressionToGlsl(context, args[0]) + ")";
    }
};
Operators['atan'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER;
    },
    toGlsl: function(context, args) {
        assertArgsMinCount(args, 1);
        assertArgsMaxCount(args, 2);
        assertNumbers(args);
        return args.length === 2 ? "atan(" + expressionToGlsl(context, args[0]) + ", " + expressionToGlsl(context, args[1]) + ")" : "atan(" + expressionToGlsl(context, args[0]) + ")";
    }
};
Operators['>'] = {
    getReturnType: function(args) {
        return ValueTypes.BOOLEAN;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 2);
        assertNumbers(args);
        return "(" + expressionToGlsl(context, args[0]) + " > " + expressionToGlsl(context, args[1]) + ")";
    }
};
Operators['>='] = {
    getReturnType: function(args) {
        return ValueTypes.BOOLEAN;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 2);
        assertNumbers(args);
        return "(" + expressionToGlsl(context, args[0]) + " >= " + expressionToGlsl(context, args[1]) + ")";
    }
};
Operators['<'] = {
    getReturnType: function(args) {
        return ValueTypes.BOOLEAN;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 2);
        assertNumbers(args);
        return "(" + expressionToGlsl(context, args[0]) + " < " + expressionToGlsl(context, args[1]) + ")";
    }
};
Operators['<='] = {
    getReturnType: function(args) {
        return ValueTypes.BOOLEAN;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 2);
        assertNumbers(args);
        return "(" + expressionToGlsl(context, args[0]) + " <= " + expressionToGlsl(context, args[1]) + ")";
    }
};
function getEqualOperator(operator) {
    return {
        getReturnType: function(args) {
            return ValueTypes.BOOLEAN;
        },
        toGlsl: function(context, args) {
            assertArgsCount(args, 2);
            // find common type
            var type = ValueTypes.ANY;
            for(var i = 0; i < args.length; i++)type &= getValueType(args[i]);
            if (type === ValueTypes.NONE) throw new Error("All arguments should be of compatible type, got " + JSON.stringify(args) + " instead");
            // Since it's not possible to have color types here, we can leave it out
            // This fixes issues in case the value type is ambiguously detected as a color (e.g. the string 'red')
            type &= ~ValueTypes.COLOR;
            return "(" + expressionToGlsl(context, args[0], type) + " " + operator + " " + expressionToGlsl(context, args[1], type) + ")";
        }
    };
}
Operators['=='] = getEqualOperator('==');
Operators['!='] = getEqualOperator('!=');
Operators['!'] = {
    getReturnType: function(args) {
        return ValueTypes.BOOLEAN;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 1);
        assertBoolean(args[0]);
        return "(!" + expressionToGlsl(context, args[0]) + ")";
    }
};
function getDecisionOperator(operator) {
    return {
        getReturnType: function(args) {
            return ValueTypes.BOOLEAN;
        },
        toGlsl: function(context, args) {
            assertArgsMinCount(args, 2);
            for(var i = 0; i < args.length; i++)assertBoolean(args[i]);
            var result = '';
            result = args.map(function(arg) {
                return expressionToGlsl(context, arg);
            }).join(" " + operator + " ");
            result = "(" + result + ")";
            return result;
        }
    };
}
Operators['all'] = getDecisionOperator('&&');
Operators['any'] = getDecisionOperator('||');
Operators['between'] = {
    getReturnType: function(args) {
        return ValueTypes.BOOLEAN;
    },
    toGlsl: function(context, args) {
        assertArgsCount(args, 3);
        assertNumbers(args);
        var min = expressionToGlsl(context, args[1]);
        var max = expressionToGlsl(context, args[2]);
        var value = expressionToGlsl(context, args[0]);
        return "(" + value + " >= " + min + " && " + value + " <= " + max + ")";
    }
};
Operators['array'] = {
    getReturnType: function(args) {
        return ValueTypes.NUMBER_ARRAY;
    },
    toGlsl: function(context, args) {
        assertArgsMinCount(args, 2);
        assertArgsMaxCount(args, 4);
        assertNumbers(args);
        var parsedArgs = args.map(function(val) {
            return expressionToGlsl(context, val, ValueTypes.NUMBER);
        });
        return "vec" + args.length + "(" + parsedArgs.join(', ') + ")";
    }
};
Operators['color'] = {
    getReturnType: function(args) {
        return ValueTypes.COLOR;
    },
    toGlsl: function(context, args) {
        assertArgsMinCount(args, 3);
        assertArgsMaxCount(args, 4);
        assertNumbers(args);
        var array = args;
        if (args.length === 3) array.push(1);
        var parsedArgs = args.map(function(val, i) {
            return expressionToGlsl(context, val, ValueTypes.NUMBER) + (i < 3 ? ' / 255.0' : '');
        });
        return "vec" + args.length + "(" + parsedArgs.join(', ') + ")";
    }
};
Operators['interpolate'] = {
    getReturnType: function(args) {
        var type = ValueTypes.COLOR | ValueTypes.NUMBER;
        for(var i = 3; i < args.length; i += 2)type = type & getValueType(args[i]);
        return type;
    },
    toGlsl: function(context, args, opt_typeHint) {
        assertArgsEven(args);
        assertArgsMinCount(args, 6);
        // validate interpolation type
        var type = args[0];
        var interpolation;
        switch(type[0]){
            case 'linear':
                interpolation = 1;
                break;
            case 'exponential':
                interpolation = type[1];
                break;
            default:
                interpolation = null;
        }
        if (!interpolation) throw new Error("Invalid interpolation type for \"interpolate\" operator, received: " + JSON.stringify(type));
        // compute input/output types
        var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;
        var outputType = Operators['interpolate'].getReturnType(args) & typeHint;
        assertUniqueInferredType(args, outputType);
        var input = expressionToGlsl(context, args[1]);
        var exponent = numberToGlsl(interpolation);
        var result = '';
        for(var i = 2; i < args.length - 2; i += 2){
            var stop1 = expressionToGlsl(context, args[i]);
            var output1 = result || expressionToGlsl(context, args[i + 1], outputType);
            var stop2 = expressionToGlsl(context, args[i + 2]);
            var output2 = expressionToGlsl(context, args[i + 3], outputType);
            result = "mix(" + output1 + ", " + output2 + ", pow(clamp((" + input + " - " + stop1 + ") / (" + stop2 + " - " + stop1 + "), 0.0, 1.0), " + exponent + "))";
        }
        return result;
    }
};
Operators['match'] = {
    getReturnType: function(args) {
        var type = ValueTypes.ANY;
        for(var i = 2; i < args.length; i += 2)type = type & getValueType(args[i]);
        type = type & getValueType(args[args.length - 1]);
        return type;
    },
    toGlsl: function(context, args, opt_typeHint) {
        assertArgsEven(args);
        assertArgsMinCount(args, 4);
        var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;
        var outputType = Operators['match'].getReturnType(args) & typeHint;
        assertUniqueInferredType(args, outputType);
        var input = expressionToGlsl(context, args[0]);
        var fallback = expressionToGlsl(context, args[args.length - 1], outputType);
        var result = null;
        for(var i = args.length - 3; i >= 1; i -= 2){
            var match = expressionToGlsl(context, args[i]);
            var output = expressionToGlsl(context, args[i + 1], outputType);
            result = "(" + input + " == " + match + " ? " + output + " : " + (result || fallback) + ")";
        }
        return result;
    }
};
Operators['case'] = {
    getReturnType: function(args) {
        var type = ValueTypes.ANY;
        for(var i = 1; i < args.length; i += 2)type = type & getValueType(args[i]);
        type = type & getValueType(args[args.length - 1]);
        return type;
    },
    toGlsl: function(context, args, opt_typeHint) {
        assertArgsOdd(args);
        assertArgsMinCount(args, 3);
        var typeHint = opt_typeHint !== undefined ? opt_typeHint : ValueTypes.ANY;
        var outputType = Operators['case'].getReturnType(args) & typeHint;
        assertUniqueInferredType(args, outputType);
        for(var i = 0; i < args.length - 1; i += 2)assertBoolean(args[i]);
        var fallback = expressionToGlsl(context, args[args.length - 1], outputType);
        var result = null;
        for(var i = args.length - 3; i >= 0; i -= 2){
            var condition = expressionToGlsl(context, args[i]);
            var output = expressionToGlsl(context, args[i + 1], outputType);
            result = "(" + condition + " ? " + output + " : " + (result || fallback) + ")";
        }
        return result;
    }
};

},{"../renderer/webgl/TileLayer.js":"IIUIV","../color.js":"liKgX","../math.js":"kI4rE","@parcel/transformer-js/src/esmodule-helpers.js":"JacNc"}],"8Epul":[function(require,module,exports) {
/*
 * Ben Postlethwaite
 * January 2013
 * License MIT
 */ 'use strict';
var colorScale = require('./colorScale');
var lerp = require('lerp');
module.exports = createColormap;
function createColormap(spec) {
    /*
     * Default Options
     */ var indicies, fromrgba, torgba, nsteps, cmap, colormap, format, nshades, colors, alpha, i;
    if (!spec) spec = {
    };
    nshades = (spec.nshades || 72) - 1;
    format = spec.format || 'hex';
    colormap = spec.colormap;
    if (!colormap) colormap = 'jet';
    if (typeof colormap === 'string') {
        colormap = colormap.toLowerCase();
        if (!colorScale[colormap]) throw Error(colormap + ' not a supported colorscale');
        cmap = colorScale[colormap];
    } else if (Array.isArray(colormap)) cmap = colormap.slice();
    else throw Error('unsupported colormap option', colormap);
    if (cmap.length > nshades + 1) throw new Error(colormap + ' map requires nshades to be at least size ' + cmap.length);
    if (!Array.isArray(spec.alpha)) {
        if (typeof spec.alpha === 'number') alpha = [
            spec.alpha,
            spec.alpha
        ];
        else alpha = [
            1,
            1
        ];
    } else if (spec.alpha.length !== 2) alpha = [
        1,
        1
    ];
    else alpha = spec.alpha.slice();
    // map index points from 0..1 to 0..n-1
    indicies = cmap.map(function(c) {
        return Math.round(c.index * nshades);
    });
    // Add alpha channel to the map
    alpha[0] = Math.min(Math.max(alpha[0], 0), 1);
    alpha[1] = Math.min(Math.max(alpha[1], 0), 1);
    var steps = cmap.map(function(c, i1) {
        var index = cmap[i1].index;
        var rgba = cmap[i1].rgb.slice();
        // if user supplies their own map use it
        if (rgba.length === 4 && rgba[3] >= 0 && rgba[3] <= 1) return rgba;
        rgba[3] = alpha[0] + (alpha[1] - alpha[0]) * index;
        return rgba;
    });
    /*
     * map increasing linear values between indicies to
     * linear steps in colorvalues
     */ var colors = [];
    for(i = 0; i < indicies.length - 1; ++i){
        nsteps = indicies[i + 1] - indicies[i];
        fromrgba = steps[i];
        torgba = steps[i + 1];
        for(var j = 0; j < nsteps; j++){
            var amt = j / nsteps;
            colors.push([
                Math.round(lerp(fromrgba[0], torgba[0], amt)),
                Math.round(lerp(fromrgba[1], torgba[1], amt)),
                Math.round(lerp(fromrgba[2], torgba[2], amt)),
                lerp(fromrgba[3], torgba[3], amt)
            ]);
        }
    }
    //add 1 step as last value
    colors.push(cmap[cmap.length - 1].rgb.concat(alpha[1]));
    if (format === 'hex') colors = colors.map(rgb2hex);
    else if (format === 'rgbaString') colors = colors.map(rgbaStr);
    else if (format === 'float') colors = colors.map(rgb2float);
    return colors;
}
function rgb2float(rgba) {
    return [
        rgba[0] / 255,
        rgba[1] / 255,
        rgba[2] / 255,
        rgba[3]
    ];
}
function rgb2hex(rgba) {
    var dig, hex = '#';
    for(var i = 0; i < 3; ++i){
        dig = rgba[i];
        dig = dig.toString(16);
        hex += ('00' + dig).substr(dig.length);
    }
    return hex;
}
function rgbaStr(rgba) {
    return 'rgba(' + rgba.join(',') + ')';
}

},{"./colorScale":"49NDq","lerp":"2NUzA"}],"49NDq":[function(require,module,exports) {
module.exports = {
    "jet": [
        {
            "index": 0,
            "rgb": [
                0,
                0,
                131
            ]
        },
        {
            "index": 0.125,
            "rgb": [
                0,
                60,
                170
            ]
        },
        {
            "index": 0.375,
            "rgb": [
                5,
                255,
                255
            ]
        },
        {
            "index": 0.625,
            "rgb": [
                255,
                255,
                0
            ]
        },
        {
            "index": 0.875,
            "rgb": [
                250,
                0,
                0
            ]
        },
        {
            "index": 1,
            "rgb": [
                128,
                0,
                0
            ]
        }
    ],
    "hsv": [
        {
            "index": 0,
            "rgb": [
                255,
                0,
                0
            ]
        },
        {
            "index": 0.169,
            "rgb": [
                253,
                255,
                2
            ]
        },
        {
            "index": 0.173,
            "rgb": [
                247,
                255,
                2
            ]
        },
        {
            "index": 0.337,
            "rgb": [
                0,
                252,
                4
            ]
        },
        {
            "index": 0.341,
            "rgb": [
                0,
                252,
                10
            ]
        },
        {
            "index": 0.506,
            "rgb": [
                1,
                249,
                255
            ]
        },
        {
            "index": 0.671,
            "rgb": [
                2,
                0,
                253
            ]
        },
        {
            "index": 0.675,
            "rgb": [
                8,
                0,
                253
            ]
        },
        {
            "index": 0.839,
            "rgb": [
                255,
                0,
                251
            ]
        },
        {
            "index": 0.843,
            "rgb": [
                255,
                0,
                245
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                0,
                6
            ]
        }
    ],
    "hot": [
        {
            "index": 0,
            "rgb": [
                0,
                0,
                0
            ]
        },
        {
            "index": 0.3,
            "rgb": [
                230,
                0,
                0
            ]
        },
        {
            "index": 0.6,
            "rgb": [
                255,
                210,
                0
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                255,
                255
            ]
        }
    ],
    "spring": [
        {
            "index": 0,
            "rgb": [
                255,
                0,
                255
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                255,
                0
            ]
        }
    ],
    "summer": [
        {
            "index": 0,
            "rgb": [
                0,
                128,
                102
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                255,
                102
            ]
        }
    ],
    "autumn": [
        {
            "index": 0,
            "rgb": [
                255,
                0,
                0
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                255,
                0
            ]
        }
    ],
    "winter": [
        {
            "index": 0,
            "rgb": [
                0,
                0,
                255
            ]
        },
        {
            "index": 1,
            "rgb": [
                0,
                255,
                128
            ]
        }
    ],
    "bone": [
        {
            "index": 0,
            "rgb": [
                0,
                0,
                0
            ]
        },
        {
            "index": 0.376,
            "rgb": [
                84,
                84,
                116
            ]
        },
        {
            "index": 0.753,
            "rgb": [
                169,
                200,
                200
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                255,
                255
            ]
        }
    ],
    "copper": [
        {
            "index": 0,
            "rgb": [
                0,
                0,
                0
            ]
        },
        {
            "index": 0.804,
            "rgb": [
                255,
                160,
                102
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                199,
                127
            ]
        }
    ],
    "greys": [
        {
            "index": 0,
            "rgb": [
                0,
                0,
                0
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                255,
                255
            ]
        }
    ],
    "yignbu": [
        {
            "index": 0,
            "rgb": [
                8,
                29,
                88
            ]
        },
        {
            "index": 0.125,
            "rgb": [
                37,
                52,
                148
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                34,
                94,
                168
            ]
        },
        {
            "index": 0.375,
            "rgb": [
                29,
                145,
                192
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                65,
                182,
                196
            ]
        },
        {
            "index": 0.625,
            "rgb": [
                127,
                205,
                187
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                199,
                233,
                180
            ]
        },
        {
            "index": 0.875,
            "rgb": [
                237,
                248,
                217
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                255,
                217
            ]
        }
    ],
    "greens": [
        {
            "index": 0,
            "rgb": [
                0,
                68,
                27
            ]
        },
        {
            "index": 0.125,
            "rgb": [
                0,
                109,
                44
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                35,
                139,
                69
            ]
        },
        {
            "index": 0.375,
            "rgb": [
                65,
                171,
                93
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                116,
                196,
                118
            ]
        },
        {
            "index": 0.625,
            "rgb": [
                161,
                217,
                155
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                199,
                233,
                192
            ]
        },
        {
            "index": 0.875,
            "rgb": [
                229,
                245,
                224
            ]
        },
        {
            "index": 1,
            "rgb": [
                247,
                252,
                245
            ]
        }
    ],
    "yiorrd": [
        {
            "index": 0,
            "rgb": [
                128,
                0,
                38
            ]
        },
        {
            "index": 0.125,
            "rgb": [
                189,
                0,
                38
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                227,
                26,
                28
            ]
        },
        {
            "index": 0.375,
            "rgb": [
                252,
                78,
                42
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                253,
                141,
                60
            ]
        },
        {
            "index": 0.625,
            "rgb": [
                254,
                178,
                76
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                254,
                217,
                118
            ]
        },
        {
            "index": 0.875,
            "rgb": [
                255,
                237,
                160
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                255,
                204
            ]
        }
    ],
    "bluered": [
        {
            "index": 0,
            "rgb": [
                0,
                0,
                255
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                0,
                0
            ]
        }
    ],
    "rdbu": [
        {
            "index": 0,
            "rgb": [
                5,
                10,
                172
            ]
        },
        {
            "index": 0.35,
            "rgb": [
                106,
                137,
                247
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                190,
                190,
                190
            ]
        },
        {
            "index": 0.6,
            "rgb": [
                220,
                170,
                132
            ]
        },
        {
            "index": 0.7,
            "rgb": [
                230,
                145,
                90
            ]
        },
        {
            "index": 1,
            "rgb": [
                178,
                10,
                28
            ]
        }
    ],
    "picnic": [
        {
            "index": 0,
            "rgb": [
                0,
                0,
                255
            ]
        },
        {
            "index": 0.1,
            "rgb": [
                51,
                153,
                255
            ]
        },
        {
            "index": 0.2,
            "rgb": [
                102,
                204,
                255
            ]
        },
        {
            "index": 0.3,
            "rgb": [
                153,
                204,
                255
            ]
        },
        {
            "index": 0.4,
            "rgb": [
                204,
                204,
                255
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                255,
                255,
                255
            ]
        },
        {
            "index": 0.6,
            "rgb": [
                255,
                204,
                255
            ]
        },
        {
            "index": 0.7,
            "rgb": [
                255,
                153,
                255
            ]
        },
        {
            "index": 0.8,
            "rgb": [
                255,
                102,
                204
            ]
        },
        {
            "index": 0.9,
            "rgb": [
                255,
                102,
                102
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                0,
                0
            ]
        }
    ],
    "rainbow": [
        {
            "index": 0,
            "rgb": [
                150,
                0,
                90
            ]
        },
        {
            "index": 0.125,
            "rgb": [
                0,
                0,
                200
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                0,
                25,
                255
            ]
        },
        {
            "index": 0.375,
            "rgb": [
                0,
                152,
                255
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                44,
                255,
                150
            ]
        },
        {
            "index": 0.625,
            "rgb": [
                151,
                255,
                0
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                255,
                234,
                0
            ]
        },
        {
            "index": 0.875,
            "rgb": [
                255,
                111,
                0
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                0,
                0
            ]
        }
    ],
    "portland": [
        {
            "index": 0,
            "rgb": [
                12,
                51,
                131
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                10,
                136,
                186
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                242,
                211,
                56
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                242,
                143,
                56
            ]
        },
        {
            "index": 1,
            "rgb": [
                217,
                30,
                30
            ]
        }
    ],
    "blackbody": [
        {
            "index": 0,
            "rgb": [
                0,
                0,
                0
            ]
        },
        {
            "index": 0.2,
            "rgb": [
                230,
                0,
                0
            ]
        },
        {
            "index": 0.4,
            "rgb": [
                230,
                210,
                0
            ]
        },
        {
            "index": 0.7,
            "rgb": [
                255,
                255,
                255
            ]
        },
        {
            "index": 1,
            "rgb": [
                160,
                200,
                255
            ]
        }
    ],
    "earth": [
        {
            "index": 0,
            "rgb": [
                0,
                0,
                130
            ]
        },
        {
            "index": 0.1,
            "rgb": [
                0,
                180,
                180
            ]
        },
        {
            "index": 0.2,
            "rgb": [
                40,
                210,
                40
            ]
        },
        {
            "index": 0.4,
            "rgb": [
                230,
                230,
                50
            ]
        },
        {
            "index": 0.6,
            "rgb": [
                120,
                70,
                20
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                255,
                255
            ]
        }
    ],
    "electric": [
        {
            "index": 0,
            "rgb": [
                0,
                0,
                0
            ]
        },
        {
            "index": 0.15,
            "rgb": [
                30,
                0,
                100
            ]
        },
        {
            "index": 0.4,
            "rgb": [
                120,
                0,
                100
            ]
        },
        {
            "index": 0.6,
            "rgb": [
                160,
                90,
                0
            ]
        },
        {
            "index": 0.8,
            "rgb": [
                230,
                200,
                0
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                250,
                220
            ]
        }
    ],
    "alpha": [
        {
            "index": 0,
            "rgb": [
                255,
                255,
                255,
                0
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                255,
                255,
                1
            ]
        }
    ],
    "viridis": [
        {
            "index": 0,
            "rgb": [
                68,
                1,
                84
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                71,
                44,
                122
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                59,
                81,
                139
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                44,
                113,
                142
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                33,
                144,
                141
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                39,
                173,
                129
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                92,
                200,
                99
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                170,
                220,
                50
            ]
        },
        {
            "index": 1,
            "rgb": [
                253,
                231,
                37
            ]
        }
    ],
    "inferno": [
        {
            "index": 0,
            "rgb": [
                0,
                0,
                4
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                31,
                12,
                72
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                85,
                15,
                109
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                136,
                34,
                106
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                186,
                54,
                85
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                227,
                89,
                51
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                249,
                140,
                10
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                249,
                201,
                50
            ]
        },
        {
            "index": 1,
            "rgb": [
                252,
                255,
                164
            ]
        }
    ],
    "magma": [
        {
            "index": 0,
            "rgb": [
                0,
                0,
                4
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                28,
                16,
                68
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                79,
                18,
                123
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                129,
                37,
                129
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                181,
                54,
                122
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                229,
                80,
                100
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                251,
                135,
                97
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                254,
                194,
                135
            ]
        },
        {
            "index": 1,
            "rgb": [
                252,
                253,
                191
            ]
        }
    ],
    "plasma": [
        {
            "index": 0,
            "rgb": [
                13,
                8,
                135
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                75,
                3,
                161
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                125,
                3,
                168
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                168,
                34,
                150
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                203,
                70,
                121
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                229,
                107,
                93
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                248,
                148,
                65
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                253,
                195,
                40
            ]
        },
        {
            "index": 1,
            "rgb": [
                240,
                249,
                33
            ]
        }
    ],
    "warm": [
        {
            "index": 0,
            "rgb": [
                125,
                0,
                179
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                172,
                0,
                187
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                219,
                0,
                170
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                255,
                0,
                130
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                255,
                63,
                74
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                255,
                123,
                0
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                234,
                176,
                0
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                190,
                228,
                0
            ]
        },
        {
            "index": 1,
            "rgb": [
                147,
                255,
                0
            ]
        }
    ],
    "cool": [
        {
            "index": 0,
            "rgb": [
                125,
                0,
                179
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                116,
                0,
                218
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                98,
                74,
                237
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                68,
                146,
                231
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                0,
                204,
                197
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                0,
                247,
                146
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                0,
                255,
                88
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                40,
                255,
                8
            ]
        },
        {
            "index": 1,
            "rgb": [
                147,
                255,
                0
            ]
        }
    ],
    "rainbow-soft": [
        {
            "index": 0,
            "rgb": [
                125,
                0,
                179
            ]
        },
        {
            "index": 0.1,
            "rgb": [
                199,
                0,
                180
            ]
        },
        {
            "index": 0.2,
            "rgb": [
                255,
                0,
                121
            ]
        },
        {
            "index": 0.3,
            "rgb": [
                255,
                108,
                0
            ]
        },
        {
            "index": 0.4,
            "rgb": [
                222,
                194,
                0
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                150,
                255,
                0
            ]
        },
        {
            "index": 0.6,
            "rgb": [
                0,
                255,
                55
            ]
        },
        {
            "index": 0.7,
            "rgb": [
                0,
                246,
                150
            ]
        },
        {
            "index": 0.8,
            "rgb": [
                50,
                167,
                222
            ]
        },
        {
            "index": 0.9,
            "rgb": [
                103,
                51,
                235
            ]
        },
        {
            "index": 1,
            "rgb": [
                124,
                0,
                186
            ]
        }
    ],
    "bathymetry": [
        {
            "index": 0,
            "rgb": [
                40,
                26,
                44
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                59,
                49,
                90
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                64,
                76,
                139
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                63,
                110,
                151
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                72,
                142,
                158
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                85,
                174,
                163
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                120,
                206,
                163
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                187,
                230,
                172
            ]
        },
        {
            "index": 1,
            "rgb": [
                253,
                254,
                204
            ]
        }
    ],
    "cdom": [
        {
            "index": 0,
            "rgb": [
                47,
                15,
                62
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                87,
                23,
                86
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                130,
                28,
                99
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                171,
                41,
                96
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                206,
                67,
                86
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                230,
                106,
                84
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                242,
                149,
                103
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                249,
                193,
                135
            ]
        },
        {
            "index": 1,
            "rgb": [
                254,
                237,
                176
            ]
        }
    ],
    "chlorophyll": [
        {
            "index": 0,
            "rgb": [
                18,
                36,
                20
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                25,
                63,
                41
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                24,
                91,
                59
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                13,
                119,
                72
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                18,
                148,
                80
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                80,
                173,
                89
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                132,
                196,
                122
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                175,
                221,
                162
            ]
        },
        {
            "index": 1,
            "rgb": [
                215,
                249,
                208
            ]
        }
    ],
    "density": [
        {
            "index": 0,
            "rgb": [
                54,
                14,
                36
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                89,
                23,
                80
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                110,
                45,
                132
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                120,
                77,
                178
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                120,
                113,
                213
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                115,
                151,
                228
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                134,
                185,
                227
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                177,
                214,
                227
            ]
        },
        {
            "index": 1,
            "rgb": [
                230,
                241,
                241
            ]
        }
    ],
    "freesurface-blue": [
        {
            "index": 0,
            "rgb": [
                30,
                4,
                110
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                47,
                14,
                176
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                41,
                45,
                236
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                25,
                99,
                212
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                68,
                131,
                200
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                114,
                156,
                197
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                157,
                181,
                203
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                200,
                208,
                216
            ]
        },
        {
            "index": 1,
            "rgb": [
                241,
                237,
                236
            ]
        }
    ],
    "freesurface-red": [
        {
            "index": 0,
            "rgb": [
                60,
                9,
                18
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                100,
                17,
                27
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                142,
                20,
                29
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                177,
                43,
                27
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                192,
                87,
                63
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                205,
                125,
                105
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                216,
                162,
                148
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                227,
                199,
                193
            ]
        },
        {
            "index": 1,
            "rgb": [
                241,
                237,
                236
            ]
        }
    ],
    "oxygen": [
        {
            "index": 0,
            "rgb": [
                64,
                5,
                5
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                106,
                6,
                15
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                144,
                26,
                7
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                168,
                64,
                3
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                188,
                100,
                4
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                206,
                136,
                11
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                220,
                174,
                25
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                231,
                215,
                44
            ]
        },
        {
            "index": 1,
            "rgb": [
                248,
                254,
                105
            ]
        }
    ],
    "par": [
        {
            "index": 0,
            "rgb": [
                51,
                20,
                24
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                90,
                32,
                35
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                129,
                44,
                34
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                159,
                68,
                25
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                182,
                99,
                19
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                199,
                134,
                22
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                212,
                171,
                35
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                221,
                210,
                54
            ]
        },
        {
            "index": 1,
            "rgb": [
                225,
                253,
                75
            ]
        }
    ],
    "phase": [
        {
            "index": 0,
            "rgb": [
                145,
                105,
                18
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                184,
                71,
                38
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                186,
                58,
                115
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                160,
                71,
                185
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                110,
                97,
                218
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                50,
                123,
                164
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                31,
                131,
                110
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                77,
                129,
                34
            ]
        },
        {
            "index": 1,
            "rgb": [
                145,
                105,
                18
            ]
        }
    ],
    "salinity": [
        {
            "index": 0,
            "rgb": [
                42,
                24,
                108
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                33,
                50,
                162
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                15,
                90,
                145
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                40,
                118,
                137
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                59,
                146,
                135
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                79,
                175,
                126
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                120,
                203,
                104
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                193,
                221,
                100
            ]
        },
        {
            "index": 1,
            "rgb": [
                253,
                239,
                154
            ]
        }
    ],
    "temperature": [
        {
            "index": 0,
            "rgb": [
                4,
                35,
                51
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                23,
                51,
                122
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                85,
                59,
                157
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                129,
                79,
                143
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                175,
                95,
                130
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                222,
                112,
                101
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                249,
                146,
                66
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                249,
                196,
                65
            ]
        },
        {
            "index": 1,
            "rgb": [
                232,
                250,
                91
            ]
        }
    ],
    "turbidity": [
        {
            "index": 0,
            "rgb": [
                34,
                31,
                27
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                65,
                50,
                41
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                98,
                69,
                52
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                131,
                89,
                57
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                161,
                112,
                59
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                185,
                140,
                66
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                202,
                174,
                88
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                216,
                209,
                126
            ]
        },
        {
            "index": 1,
            "rgb": [
                233,
                246,
                171
            ]
        }
    ],
    "velocity-blue": [
        {
            "index": 0,
            "rgb": [
                17,
                32,
                64
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                35,
                52,
                116
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                29,
                81,
                156
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                31,
                113,
                162
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                50,
                144,
                169
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                87,
                173,
                176
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                149,
                196,
                189
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                203,
                221,
                211
            ]
        },
        {
            "index": 1,
            "rgb": [
                254,
                251,
                230
            ]
        }
    ],
    "velocity-green": [
        {
            "index": 0,
            "rgb": [
                23,
                35,
                19
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                24,
                64,
                38
            ]
        },
        {
            "index": 0.25,
            "rgb": [
                11,
                95,
                45
            ]
        },
        {
            "index": 0.38,
            "rgb": [
                39,
                123,
                35
            ]
        },
        {
            "index": 0.5,
            "rgb": [
                95,
                146,
                12
            ]
        },
        {
            "index": 0.63,
            "rgb": [
                152,
                165,
                18
            ]
        },
        {
            "index": 0.75,
            "rgb": [
                201,
                186,
                69
            ]
        },
        {
            "index": 0.88,
            "rgb": [
                233,
                216,
                137
            ]
        },
        {
            "index": 1,
            "rgb": [
                255,
                253,
                205
            ]
        }
    ],
    "cubehelix": [
        {
            "index": 0,
            "rgb": [
                0,
                0,
                0
            ]
        },
        {
            "index": 0.07,
            "rgb": [
                22,
                5,
                59
            ]
        },
        {
            "index": 0.13,
            "rgb": [
                60,
                4,
                105
            ]
        },
        {
            "index": 0.2,
            "rgb": [
                109,
                1,
                135
            ]
        },
        {
            "index": 0.27,
            "rgb": [
                161,
                0,
                147
            ]
        },
        {
            "index": 0.33,
            "rgb": [
                210,
                2,
                142
            ]
        },
        {
            "index": 0.4,
            "rgb": [
                251,
                11,
                123
            ]
        },
        {
            "index": 0.47,
            "rgb": [
                255,
                29,
                97
            ]
        },
        {
            "index": 0.53,
            "rgb": [
                255,
                54,
                69
            ]
        },
        {
            "index": 0.6,
            "rgb": [
                255,
                85,
                46
            ]
        },
        {
            "index": 0.67,
            "rgb": [
                255,
                120,
                34
            ]
        },
        {
            "index": 0.73,
            "rgb": [
                255,
                157,
                37
            ]
        },
        {
            "index": 0.8,
            "rgb": [
                241,
                191,
                57
            ]
        },
        {
            "index": 0.87,
            "rgb": [
                224,
                220,
                93
            ]
        },
        {
            "index": 0.93,
            "rgb": [
                218,
                241,
                142
            ]
        },
        {
            "index": 1,
            "rgb": [
                227,
                253,
                198
            ]
        }
    ]
};

},{}],"2NUzA":[function(require,module,exports) {
function lerp(v0, v1, t) {
    return v0 * (1 - t) + v1 * t;
}
module.exports = lerp;

},{}]},["5J2cI","hTXjU"], "hTXjU", "parcelRequire3b24")

//# sourceMappingURL=index.6b9ca3e8.js.map
